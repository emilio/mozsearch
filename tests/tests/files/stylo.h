#pragma clang diagnostic push

#pragma clang diagnostic ignored "-Wreserved-id-macro"
#pragma clang diagnostic pop
typedef const char16_t* char16ptr_t;
namespace mozilla {



template<typename> struct RemoveCV;
template<typename> struct AddRvalueReference;
template<typename T>
typename AddRvalueReference<T>::Type DeclVal();







template<typename T, T Value>
struct IntegralConstant
{
  static constexpr T value = Value;
  typedef T ValueType;
  typedef IntegralConstant<T, Value> Type;
};


typedef IntegralConstant<bool, true> TrueType;
typedef IntegralConstant<bool, false> FalseType;





namespace detail {

template<typename T>
struct IsVoidHelper : FalseType {};

template<>
struct IsVoidHelper<void> : TrueType {};

}
template<typename T>
struct IsVoid : detail::IsVoidHelper<typename RemoveCV<T>::Type> {};

namespace detail {

template <typename T>
struct IsIntegralHelper : FalseType {};

template<> struct IsIntegralHelper<char> : TrueType {};
template<> struct IsIntegralHelper<signed char> : TrueType {};
template<> struct IsIntegralHelper<unsigned char> : TrueType {};
template<> struct IsIntegralHelper<short> : TrueType {};
template<> struct IsIntegralHelper<unsigned short> : TrueType {};
template<> struct IsIntegralHelper<int> : TrueType {};
template<> struct IsIntegralHelper<unsigned int> : TrueType {};
template<> struct IsIntegralHelper<long> : TrueType {};
template<> struct IsIntegralHelper<unsigned long> : TrueType {};
template<> struct IsIntegralHelper<long long> : TrueType {};
template<> struct IsIntegralHelper<unsigned long long> : TrueType {};
template<> struct IsIntegralHelper<bool> : TrueType {};
template<> struct IsIntegralHelper<wchar_t> : TrueType {};
template<> struct IsIntegralHelper<char16_t> : TrueType {};

}
template<typename T>
struct IsIntegral : detail::IsIntegralHelper<typename RemoveCV<T>::Type>
{};

template<typename T, typename U>
struct IsSame;

namespace detail {

template<typename T>
struct IsFloatingPointHelper
  : IntegralConstant<bool,
                     IsSame<T, float>::value ||
                     IsSame<T, double>::value ||
                     IsSame<T, long double>::value>
{};

}
template<typename T>
struct IsFloatingPoint
  : detail::IsFloatingPointHelper<typename RemoveCV<T>::Type>
{};

namespace detail {

template<typename T>
struct IsArrayHelper : FalseType {};

template<typename T, decltype(sizeof(1)) N>
struct IsArrayHelper<T[N]> : TrueType {};

template<typename T>
struct IsArrayHelper<T[]> : TrueType {};

}
template<typename T>
struct IsArray : detail::IsArrayHelper<typename RemoveCV<T>::Type>
{};

namespace detail {

template<typename T>
struct IsFunPtr;

template<typename>
struct IsFunPtr
  : public FalseType
{};

template<typename Result, typename... ArgTypes>
struct IsFunPtr<Result(*)(ArgTypes...)>
  : public TrueType
{};

};
template<typename T>
struct IsFunction
  : public detail::IsFunPtr<typename RemoveCV<T>::Type *>
{};

namespace detail {

template<typename T>
struct IsPointerHelper : FalseType {};

template<typename T>
struct IsPointerHelper<T*> : TrueType {};

}
template<typename T>
struct IsPointer : detail::IsPointerHelper<typename RemoveCV<T>::Type>
{};
template<typename T>
struct IsLvalueReference : FalseType {};

template<typename T>
struct IsLvalueReference<T&> : TrueType {};
template<typename T>
struct IsRvalueReference : FalseType {};

template<typename T>
struct IsRvalueReference<T&&> : TrueType {};

namespace detail {


template<typename T>
struct IsEnumHelper
  : IntegralConstant<bool, __is_enum(T)>
{};

}
template<typename T>
struct IsEnum
  : detail::IsEnumHelper<typename RemoveCV<T>::Type>
{};

namespace detail {





template<typename T>
struct IsClassHelper
  : IntegralConstant<bool, __is_class(T)>
{};

}
template<typename T>
struct IsClass
  : detail::IsClassHelper<typename RemoveCV<T>::Type>
{};
template<typename T>
struct IsReference
  : IntegralConstant<bool,
                     IsLvalueReference<T>::value || IsRvalueReference<T>::value>
{};
template<typename T>
struct IsArithmetic
  : IntegralConstant<bool, IsIntegral<T>::value || IsFloatingPoint<T>::value>
{};

namespace detail {

template<typename T>
struct IsMemberPointerHelper : FalseType {};

template<typename T, typename U>
struct IsMemberPointerHelper<T U::*> : TrueType {};

}
template<typename T>
struct IsMemberPointer
  : detail::IsMemberPointerHelper<typename RemoveCV<T>::Type>
{};
template<typename T>
struct IsScalar
  : IntegralConstant<bool, IsArithmetic<T>::value || IsEnum<T>::value ||
                     IsPointer<T>::value || IsMemberPointer<T>::value>
{};
template<typename T>
struct IsConst : FalseType {};

template<typename T>
struct IsConst<const T> : TrueType {};
template<typename T>
struct IsVolatile : FalseType {};

template<typename T>
struct IsVolatile<volatile T> : TrueType {};
template<typename T>
struct IsPod : public FalseType {};

template<> struct IsPod<char> : TrueType {};
template<> struct IsPod<signed char> : TrueType {};
template<> struct IsPod<unsigned char> : TrueType {};
template<> struct IsPod<short> : TrueType {};
template<> struct IsPod<unsigned short> : TrueType {};
template<> struct IsPod<int> : TrueType {};
template<> struct IsPod<unsigned int> : TrueType {};
template<> struct IsPod<long> : TrueType {};
template<> struct IsPod<unsigned long> : TrueType {};
template<> struct IsPod<long long> : TrueType {};
template<> struct IsPod<unsigned long long> : TrueType {};
template<> struct IsPod<bool> : TrueType {};
template<> struct IsPod<float> : TrueType {};
template<> struct IsPod<double> : TrueType {};
template<> struct IsPod<wchar_t> : TrueType {};
template<> struct IsPod<char16_t> : TrueType {};
template<typename T> struct IsPod<T*> : TrueType {};

namespace detail {





template<typename T>
struct IsEmptyHelper
  : IntegralConstant<bool, IsClass<T>::value && __is_empty(T)>
{};

}
template<typename T>
struct IsEmpty : detail::IsEmptyHelper<typename RemoveCV<T>::Type>
{};


namespace detail {

template<typename T,
         bool = IsFloatingPoint<T>::value,
         bool = IsIntegral<T>::value,
         typename NoCV = typename RemoveCV<T>::Type>
struct IsSignedHelper;


template<typename T, typename NoCV>
struct IsSignedHelper<T, true, false, NoCV> : TrueType {};


template<typename T, typename NoCV>
struct IsSignedHelper<T, false, true, NoCV>
  : IntegralConstant<bool, bool(NoCV(-1) < NoCV(1))>
{};


template<typename T, typename NoCV>
struct IsSignedHelper<T, false, false, NoCV> : FalseType {};

}
template<typename T>
struct IsSigned : detail::IsSignedHelper<T> {};

namespace detail {

template<typename T,
         bool = IsFloatingPoint<T>::value,
         bool = IsIntegral<T>::value,
         typename NoCV = typename RemoveCV<T>::Type>
struct IsUnsignedHelper;


template<typename T, typename NoCV>
struct IsUnsignedHelper<T, true, false, NoCV> : FalseType {};


template<typename T, typename NoCV>
struct IsUnsignedHelper<T, false, true, NoCV>
  : IntegralConstant<bool,
                     (IsSame<NoCV, bool>::value || bool(NoCV(1) < NoCV(-1)))>
{};


template<typename T, typename NoCV>
struct IsUnsignedHelper<T, false, false, NoCV> : FalseType {};

}
template<typename T>
struct IsUnsigned : detail::IsUnsignedHelper<T> {};

namespace detail {

struct DoIsDefaultConstructibleImpl
{
  template<typename T, typename = decltype(T())>
  static TrueType test(int);
  template<typename T>
  static FalseType test(...);
};

template<typename T>
struct IsDefaultConstructibleImpl : public DoIsDefaultConstructibleImpl
{
  typedef decltype(test<T>(0)) Type;
};

}
template<typename T>
struct IsDefaultConstructible
  : public detail::IsDefaultConstructibleImpl<T>::Type
{};

namespace detail {

struct DoIsDestructibleImpl
{
  template<typename T, typename = decltype(DeclVal<T&>().~T())>
  static TrueType test(int);
  template<typename T>
  static FalseType test(...);
};

template<typename T>
struct IsDestructibleImpl : public DoIsDestructibleImpl
{
  typedef decltype(test<T>(0)) Type;
};

}
template<typename T>
struct IsDestructible : public detail::IsDestructibleImpl<T>::Type {};
template<typename T, typename U>
struct IsSame : FalseType {};

template<typename T>
struct IsSame<T, T> : TrueType {};

namespace detail {



template<class Base, class Derived>
struct BaseOfTester : IntegralConstant<bool, __is_base_of(Base, Derived)> {};
}
template<class Base, class Derived>
struct IsBaseOf
  : IntegralConstant<bool, detail::BaseOfTester<Base, Derived>::value>
{};

namespace detail {

template<typename From, typename To>
struct ConvertibleTester
{
private:
  template<typename To1>
  static char test_helper(To1);

  template<typename From1, typename To1>
  static decltype(test_helper<To1>(DeclVal<From1>())) test(int);

  template<typename From1, typename To1>
  static int test(...);

public:
  static const bool value =
    sizeof(test<From, To>(0)) == sizeof(char);
};

}
template<typename From, typename To>
struct IsConvertible
  : IntegralConstant<bool, detail::ConvertibleTester<From, To>::value>
{};

template<typename B>
struct IsConvertible<void, B>
  : IntegralConstant<bool, IsVoid<B>::value>
{};

template<typename A>
struct IsConvertible<A, void>
  : IntegralConstant<bool, IsVoid<A>::value>
{};

template<>
struct IsConvertible<void, void>
  : TrueType
{};
template<typename T>
struct RemoveConst
{
  typedef T Type;
};

template<typename T>
struct RemoveConst<const T>
{
  typedef T Type;
};
template<typename T>
struct RemoveVolatile
{
  typedef T Type;
};

template<typename T>
struct RemoveVolatile<volatile T>
{
  typedef T Type;
};
template<typename T>
struct RemoveCV
{
  typedef typename RemoveConst<typename RemoveVolatile<T>::Type>::Type Type;
};
template<typename T>
struct RemoveReference
{
  typedef T Type;
};

template<typename T>
struct RemoveReference<T&>
{
  typedef T Type;
};

template<typename T>
struct RemoveReference<T&&>
{
  typedef T Type;
};

template<bool Condition, typename A, typename B>
struct Conditional;

namespace detail {

enum Voidness { TIsVoid, TIsNotVoid };

template<typename T, Voidness V = IsVoid<T>::value ? TIsVoid : TIsNotVoid>
struct AddLvalueReferenceHelper;

template<typename T>
struct AddLvalueReferenceHelper<T, TIsVoid>
{
  typedef void Type;
};

template<typename T>
struct AddLvalueReferenceHelper<T, TIsNotVoid>
{
  typedef T& Type;
};

}
template<typename T>
struct AddLvalueReference
  : detail::AddLvalueReferenceHelper<T>
{};

namespace detail {

template<typename T, Voidness V = IsVoid<T>::value ? TIsVoid : TIsNotVoid>
struct AddRvalueReferenceHelper;

template<typename T>
struct AddRvalueReferenceHelper<T, TIsVoid>
{
  typedef void Type;
};

template<typename T>
struct AddRvalueReferenceHelper<T, TIsNotVoid>
{
  typedef T&& Type;
};

}
template<typename T>
struct AddRvalueReference
  : detail::AddRvalueReferenceHelper<T>
{};



template<bool B, typename T = void>
struct EnableIf;

namespace detail {

template<bool MakeConst, typename T>
struct WithC : Conditional<MakeConst, const T, T>
{};

template<bool MakeVolatile, typename T>
struct WithV : Conditional<MakeVolatile, volatile T, T>
{};


template<bool MakeConst, bool MakeVolatile, typename T>
struct WithCV : WithC<MakeConst, typename WithV<MakeVolatile, T>::Type>
{};

template<typename T>
struct CorrespondingSigned;

template<>
struct CorrespondingSigned<char> { typedef signed char Type; };
template<>
struct CorrespondingSigned<unsigned char> { typedef signed char Type; };
template<>
struct CorrespondingSigned<unsigned short> { typedef short Type; };
template<>
struct CorrespondingSigned<unsigned int> { typedef int Type; };
template<>
struct CorrespondingSigned<unsigned long> { typedef long Type; };
template<>
struct CorrespondingSigned<unsigned long long> { typedef long long Type; };

template<typename T,
         typename CVRemoved = typename RemoveCV<T>::Type,
         bool IsSignedIntegerType = IsSigned<CVRemoved>::value &&
                                    !IsSame<char, CVRemoved>::value>
struct MakeSigned;

template<typename T, typename CVRemoved>
struct MakeSigned<T, CVRemoved, true>
{
  typedef T Type;
};

template<typename T, typename CVRemoved>
struct MakeSigned<T, CVRemoved, false>
  : WithCV<IsConst<T>::value, IsVolatile<T>::value,
           typename CorrespondingSigned<CVRemoved>::Type>
{};

}
template<typename T>
struct MakeSigned
  : EnableIf<IsIntegral<T>::value &&
             !IsSame<bool, typename RemoveCV<T>::Type>::value,
             typename detail::MakeSigned<T>
            >::Type
{};

namespace detail {

template<typename T>
struct CorrespondingUnsigned;

template<>
struct CorrespondingUnsigned<char> { typedef unsigned char Type; };
template<>
struct CorrespondingUnsigned<signed char> { typedef unsigned char Type; };
template<>
struct CorrespondingUnsigned<short> { typedef unsigned short Type; };
template<>
struct CorrespondingUnsigned<int> { typedef unsigned int Type; };
template<>
struct CorrespondingUnsigned<long> { typedef unsigned long Type; };
template<>
struct CorrespondingUnsigned<long long> { typedef unsigned long long Type; };


template<typename T,
         typename CVRemoved = typename RemoveCV<T>::Type,
         bool IsUnsignedIntegerType = IsUnsigned<CVRemoved>::value &&
                                      !IsSame<char, CVRemoved>::value>
struct MakeUnsigned;

template<typename T, typename CVRemoved>
struct MakeUnsigned<T, CVRemoved, true>
{
  typedef T Type;
};

template<typename T, typename CVRemoved>
struct MakeUnsigned<T, CVRemoved, false>
  : WithCV<IsConst<T>::value, IsVolatile<T>::value,
           typename CorrespondingUnsigned<CVRemoved>::Type>
{};

}
template<typename T>
struct MakeUnsigned
  : EnableIf<IsIntegral<T>::value &&
             !IsSame<bool, typename RemoveCV<T>::Type>::value,
             typename detail::MakeUnsigned<T>
            >::Type
{};
template<typename T>
struct RemoveExtent
{
  typedef T Type;
};

template<typename T>
struct RemoveExtent<T[]>
{
  typedef T Type;
};

template<typename T, decltype(sizeof(1)) N>
struct RemoveExtent<T[N]>
{
  typedef T Type;
};



namespace detail {

template<typename T, typename CVRemoved>
struct RemovePointerHelper
{
  typedef T Type;
};

template<typename T, typename Pointee>
struct RemovePointerHelper<T, Pointee*>
{
  typedef Pointee Type;
};

}
template<typename T>
struct RemovePointer
  : detail::RemovePointerHelper<T, typename RemoveCV<T>::Type>
{};
template<typename T>
struct AddPointer
{
  typedef typename RemoveReference<T>::Type* Type;
};
template<bool B, typename T>
struct EnableIf
{};

template<typename T>
struct EnableIf<true, T>
{
  typedef T Type;
};







template<bool Condition, typename A, typename B>
struct Conditional
{
  typedef A Type;
};

template<class A, class B>
struct Conditional<false, A, B>
{
  typedef B Type;
};

namespace detail {

template<typename U,
         bool IsArray = IsArray<U>::value,
         bool IsFunction = IsFunction<U>::value>
struct DecaySelector;

template<typename U>
struct DecaySelector<U, false, false>
{
  typedef typename RemoveCV<U>::Type Type;
};

template<typename U>
struct DecaySelector<U, true, false>
{
  typedef typename RemoveExtent<U>::Type* Type;
};

template<typename U>
struct DecaySelector<U, false, true>
{
  typedef typename AddPointer<U>::Type Type;
};

};
template<typename T>
class Decay
  : public detail::DecaySelector<typename RemoveReference<T>::Type>
{
};

}


namespace mozilla {

namespace detail {






template<size_t Size, bool Signedness>
struct StdintTypeForSizeAndSignedness;

template<>
struct StdintTypeForSizeAndSignedness<1, true>
{
  typedef int8_t Type;
};

template<>
struct StdintTypeForSizeAndSignedness<1, false>
{
  typedef uint8_t Type;
};

template<>
struct StdintTypeForSizeAndSignedness<2, true>
{
  typedef int16_t Type;
};

template<>
struct StdintTypeForSizeAndSignedness<2, false>
{
  typedef uint16_t Type;
};

template<>
struct StdintTypeForSizeAndSignedness<4, true>
{
  typedef int32_t Type;
};

template<>
struct StdintTypeForSizeAndSignedness<4, false>
{
  typedef uint32_t Type;
};

template<>
struct StdintTypeForSizeAndSignedness<8, true>
{
  typedef int64_t Type;
};

template<>
struct StdintTypeForSizeAndSignedness<8, false>
{
  typedef uint64_t Type;
};

}

template<size_t Size>
struct UnsignedStdintTypeForSize
  : detail::StdintTypeForSizeAndSignedness<Size, false>
{};

template<size_t Size>
struct SignedStdintTypeForSize
  : detail::StdintTypeForSizeAndSignedness<Size, true>
{};

template<typename IntegerType>
struct PositionOfSignBit
{
  static_assert(IsIntegral<IntegerType>::value,
                "PositionOfSignBit is only for integral types");

  static const size_t value = 8 * sizeof(IntegerType) - 1;
};






template<typename IntegerType>
struct MinValue
{
private:
  static_assert(IsIntegral<IntegerType>::value,
                "MinValue is only for integral types");

  typedef typename MakeUnsigned<IntegerType>::Type UnsignedIntegerType;
  static const size_t PosOfSignBit = PositionOfSignBit<IntegerType>::value;

public:






  static const IntegerType value =
      IsSigned<IntegerType>::value
      ? IntegerType(UnsignedIntegerType(1) << PosOfSignBit)
      : IntegerType(0);
};






template<typename IntegerType>
struct MaxValue
{
  static_assert(IsIntegral<IntegerType>::value,
                "MaxValue is only for integral types");




  static const IntegerType value = ~MinValue<IntegerType>::value;
};

}

namespace mozilla {
template<typename E>
class CastableTypedEnumResult
{
private:
  const E mValue;

public:
  explicit constexpr CastableTypedEnumResult(E aValue)
    : mValue(aValue)
  {}

  constexpr operator E() const { return mValue; }

  template<typename DestinationType>
  explicit constexpr
  operator DestinationType() const { return DestinationType(mValue); }

  constexpr bool operator !() const { return !bool(mValue); }
};
template<typename E> constexpr CastableTypedEnumResult<E> operator |(const E& aE, const CastableTypedEnumResult<E>& aR) { return CastableTypedEnumResult<E>(aE | E(aR)); } template<typename E> constexpr CastableTypedEnumResult<E> operator |(const CastableTypedEnumResult<E>& aR, const E& aE) { return CastableTypedEnumResult<E>(E(aR) | aE); } template<typename E> constexpr CastableTypedEnumResult<E> operator |(const CastableTypedEnumResult<E>& aR1, const CastableTypedEnumResult<E>& aR2) { return CastableTypedEnumResult<E>(E(aR1) | E(aR2)); }
template<typename E> constexpr CastableTypedEnumResult<E> operator &(const E& aE, const CastableTypedEnumResult<E>& aR) { return CastableTypedEnumResult<E>(aE & E(aR)); } template<typename E> constexpr CastableTypedEnumResult<E> operator &(const CastableTypedEnumResult<E>& aR, const E& aE) { return CastableTypedEnumResult<E>(E(aR) & aE); } template<typename E> constexpr CastableTypedEnumResult<E> operator &(const CastableTypedEnumResult<E>& aR1, const CastableTypedEnumResult<E>& aR2) { return CastableTypedEnumResult<E>(E(aR1) & E(aR2)); }
template<typename E> constexpr CastableTypedEnumResult<E> operator ^(const E& aE, const CastableTypedEnumResult<E>& aR) { return CastableTypedEnumResult<E>(aE ^ E(aR)); } template<typename E> constexpr CastableTypedEnumResult<E> operator ^(const CastableTypedEnumResult<E>& aR, const E& aE) { return CastableTypedEnumResult<E>(E(aR) ^ aE); } template<typename E> constexpr CastableTypedEnumResult<E> operator ^(const CastableTypedEnumResult<E>& aR1, const CastableTypedEnumResult<E>& aR2) { return CastableTypedEnumResult<E>(E(aR1) ^ E(aR2)); }
template<typename E> constexpr bool operator ==(const E& aE, const CastableTypedEnumResult<E>& aR) { return bool(aE == E(aR)); } template<typename E> constexpr bool operator ==(const CastableTypedEnumResult<E>& aR, const E& aE) { return bool(E(aR) == aE); } template<typename E> constexpr bool operator ==(const CastableTypedEnumResult<E>& aR1, const CastableTypedEnumResult<E>& aR2) { return bool(E(aR1) == E(aR2)); }
template<typename E> constexpr bool operator !=(const E& aE, const CastableTypedEnumResult<E>& aR) { return bool(aE != E(aR)); } template<typename E> constexpr bool operator !=(const CastableTypedEnumResult<E>& aR, const E& aE) { return bool(E(aR) != aE); } template<typename E> constexpr bool operator !=(const CastableTypedEnumResult<E>& aR1, const CastableTypedEnumResult<E>& aR2) { return bool(E(aR1) != E(aR2)); }

template <typename E>
constexpr CastableTypedEnumResult<E>
operator ~(const CastableTypedEnumResult<E>& aR)
{
  return CastableTypedEnumResult<E>(~(E(aR)));
}
template<typename E> E& operator &=(E& aR1, const CastableTypedEnumResult<E>& aR2) { return aR1 &= E(aR2); }
template<typename E> E& operator |=(E& aR1, const CastableTypedEnumResult<E>& aR2) { return aR1 |= E(aR2); }
template<typename E> E& operator ^=(E& aR1, const CastableTypedEnumResult<E>& aR2) { return aR1 ^= E(aR2); }





namespace detail {
template<typename E>
struct UnsignedIntegerTypeForEnum
  : UnsignedStdintTypeForSize<sizeof(E)>
{};
}

}






struct ServoNodeData;
namespace mozilla {





template<typename T>
struct ServoUnsafeCell {
  T value;


  ServoUnsafeCell() : value() {};
};

template<typename T>
struct ServoCell {
  ServoUnsafeCell<T> value;
  T Get() const { return value.value; }
  void Set(T arg) { value.value = arg; }
  ServoCell() : value() {};
};




enum class LazyComputeBehavior {
  Allow,
  Assert,
};




enum class TraversalRootBehavior {
  Normal,
  UnstyledChildrenOnly,
};


enum class UpdateAnimationsTasks : uint8_t {
  CSSAnimations = 1 << 0,
  CSSTransitions = 1 << 1,
  EffectProperties = 1 << 2,
  CascadeResults = 1 << 3,
};

inline constexpr mozilla::CastableTypedEnumResult<UpdateAnimationsTasks> operator |(UpdateAnimationsTasks a, UpdateAnimationsTasks b) { typedef mozilla::CastableTypedEnumResult<UpdateAnimationsTasks> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<UpdateAnimationsTasks>::Type U; return Result(UpdateAnimationsTasks(U(a) | U(b))); } inline UpdateAnimationsTasks& operator |=(UpdateAnimationsTasks& a, UpdateAnimationsTasks b) { return a = a | b; } inline constexpr mozilla::CastableTypedEnumResult<UpdateAnimationsTasks> operator &(UpdateAnimationsTasks a, UpdateAnimationsTasks b) { typedef mozilla::CastableTypedEnumResult<UpdateAnimationsTasks> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<UpdateAnimationsTasks>::Type U; return Result(UpdateAnimationsTasks(U(a) & U(b))); } inline UpdateAnimationsTasks& operator &=(UpdateAnimationsTasks& a, UpdateAnimationsTasks b) { return a = a & b; } inline constexpr mozilla::CastableTypedEnumResult<UpdateAnimationsTasks> operator ^(UpdateAnimationsTasks a, UpdateAnimationsTasks b) { typedef mozilla::CastableTypedEnumResult<UpdateAnimationsTasks> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<UpdateAnimationsTasks>::Type U; return Result(UpdateAnimationsTasks(U(a) ^ U(b))); } inline UpdateAnimationsTasks& operator ^=(UpdateAnimationsTasks& a, UpdateAnimationsTasks b) { return a = a ^ b; } inline constexpr mozilla::CastableTypedEnumResult<UpdateAnimationsTasks> operator~(UpdateAnimationsTasks a) { typedef mozilla::CastableTypedEnumResult<UpdateAnimationsTasks> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<UpdateAnimationsTasks>::Type U; return Result(UpdateAnimationsTasks(~(U(a)))); }

}





namespace mozilla {

struct fallible_t { };
extern const fallible_t fallible;

}
__attribute__((weak)) __attribute__((visibility("default")))

  __attribute__((noreturn))

  void mozalloc_abort(const char* const msg);









namespace mozilla {

namespace tl {


template<size_t Size, size_t... Rest>
struct Min
{
  static constexpr size_t value =
    Size < Min<Rest...>::value
    ? Size
    : Min<Rest...>::value;
};

template<size_t Size>
struct Min<Size>
{
  static constexpr size_t value = Size;
};

template<size_t Size, size_t... Rest>
struct Max
{
  static constexpr size_t value =
    Size > Max<Rest...>::value
    ? Size
    : Max<Rest...>::value;
};

template<size_t Size>
struct Max<Size>
{
  static constexpr size_t value = Size;
};


template<size_t I>
struct FloorLog2
{
  static const size_t value = 1 + FloorLog2<I / 2>::value;
};
template<> struct FloorLog2<0> { };
template<> struct FloorLog2<1> { static const size_t value = 0; };


template<size_t I>
struct CeilingLog2
{
  static const size_t value = FloorLog2<2 * I - 1>::value;
};


template<size_t I>
struct RoundUpPow2
{
  static const size_t value = size_t(1) << CeilingLog2<I>::value;
};
template<>
struct RoundUpPow2<0>
{
  static const size_t value = 1;
};


template<typename T>
struct BitSize
{
  static const size_t value = sizeof(T) * 8;
};





template<size_t N>
struct NBitMask
{




  static const size_t checkPrecondition =
    0 / size_t(N < BitSize<size_t>::value);
  static const size_t value = (size_t(1) << N) - 1 + checkPrecondition;
};
template<>
struct NBitMask<BitSize<size_t>::value>
{
  static const size_t value = size_t(-1);
};





template<size_t N>
struct MulOverflowMask
{
  static const size_t value =
    ~NBitMask<BitSize<size_t>::value - CeilingLog2<N>::value>::value;
};
template<> struct MulOverflowMask<0> { };
template<> struct MulOverflowMask<1> { static const size_t value = 0; };
template<bool...>
struct And;

template<>
struct And<> : public TrueType { };

template<bool C1, bool... Cn>
struct And<C1, Cn...>
  : public Conditional<C1, And<Cn...>, FalseType>::Type { };

}

}
extern "C" {
__attribute__((weak)) __attribute__((visibility("default"))) void* moz_xmalloc(size_t size)
    __attribute__ ((malloc, warn_unused_result));

__attribute__((weak)) __attribute__((visibility("default"))) void* moz_xcalloc(size_t nmemb, size_t size)
    __attribute__ ((malloc, warn_unused_result));

__attribute__((weak)) __attribute__((visibility("default"))) void* moz_xrealloc(void* ptr, size_t size)
    __attribute__ ((malloc, warn_unused_result));

__attribute__((weak)) __attribute__((visibility("default"))) char* moz_xstrdup(const char* str)
    __attribute__ ((malloc, warn_unused_result));

__attribute__((weak)) __attribute__((visibility("default"))) size_t moz_malloc_usable_size(void *ptr);

__attribute__((weak)) __attribute__((visibility("default"))) size_t moz_malloc_size_of(const void *ptr);


__attribute__((weak)) __attribute__((visibility("default"))) char* moz_xstrndup(const char* str, size_t strsize)
    __attribute__ ((malloc, warn_unused_result));




__attribute__((weak)) __attribute__((visibility("default"))) __attribute__ ((warn_unused_result))
int moz_xposix_memalign(void **ptr, size_t alignment, size_t size);

__attribute__((weak)) __attribute__((visibility("default"))) __attribute__ ((warn_unused_result))
int moz_posix_memalign(void **ptr, size_t alignment, size_t size);




__attribute__((weak)) __attribute__((visibility("default"))) void* moz_xmemalign(size_t boundary, size_t size)
    __attribute__ ((malloc, warn_unused_result));




__attribute__((weak)) __attribute__((visibility("default"))) void* moz_xvalloc(size_t size)
    __attribute__ ((malloc, warn_unused_result));




}
__attribute__((always_inline)) inline

void* operator new(size_t size) throw(std::bad_alloc)
{
    return moz_xmalloc(size);
}

                    __attribute__((always_inline)) inline
void* operator new(size_t size, const std::nothrow_t&) throw()
{
    return malloc(size);
}

                    __attribute__((always_inline)) inline
void* operator new[](size_t size) throw(std::bad_alloc)
{
    return moz_xmalloc(size);
}

                    __attribute__((always_inline)) inline
void* operator new[](size_t size, const std::nothrow_t&) throw()
{
    return malloc(size);
}

                    __attribute__((always_inline)) inline
void operator delete(void* ptr) throw()
{
    return free(ptr);
}

                    __attribute__((always_inline)) inline
void operator delete(void* ptr, const std::nothrow_t&) throw()
{
    return free(ptr);
}

                    __attribute__((always_inline)) inline
void operator delete[](void* ptr) throw()
{
    return free(ptr);
}

                    __attribute__((always_inline)) inline
void operator delete[](void* ptr, const std::nothrow_t&) throw()
{
    return free(ptr);
}
__attribute__((always_inline)) inline
void* operator new(size_t size, const mozilla::fallible_t&) throw()
{
    return malloc(size);
}

__attribute__((always_inline)) inline
void* operator new[](size_t size, const mozilla::fallible_t&) throw()
{
    return malloc(size);
}

__attribute__((always_inline)) inline
void operator delete(void* ptr, const mozilla::fallible_t&) throw()
{
    free(ptr);
}

__attribute__((always_inline)) inline
void operator delete[](void* ptr, const mozilla::fallible_t&) throw()
{
    free(ptr);
}







class InfallibleAllocPolicy
{
public:
    template <typename T>
    T* maybe_pod_malloc(size_t aNumElems)
    {
        return pod_malloc<T>(aNumElems);
    }

    template <typename T>
    T* maybe_pod_calloc(size_t aNumElems)
    {
        return pod_calloc<T>(aNumElems);
    }

    template <typename T>
    T* maybe_pod_realloc(T* aPtr, size_t aOldSize, size_t aNewSize)
    {
        return pod_realloc<T>(aPtr, aOldSize, aNewSize);
    }

    template <typename T>
    T* pod_malloc(size_t aNumElems)
    {
        if (aNumElems & mozilla::tl::MulOverflowMask<sizeof(T)>::value) {
            reportAllocOverflow();
        }
        return static_cast<T*>(moz_xmalloc(aNumElems * sizeof(T)));
    }

    template <typename T>
    T* pod_calloc(size_t aNumElems)
    {
        return static_cast<T*>(moz_xcalloc(aNumElems, sizeof(T)));
    }

    template <typename T>
    T* pod_realloc(T* aPtr, size_t aOldSize, size_t aNewSize)
    {
        if (aNewSize & mozilla::tl::MulOverflowMask<sizeof(T)>::value) {
            reportAllocOverflow();
        }
        return static_cast<T*>(moz_xrealloc(aPtr, aNewSize * sizeof(T)));
    }

    void free_(void* aPtr)
    {
        free(aPtr);
    }

    void reportAllocOverflow() const
    {
        mozalloc_abort("alloc overflow");
    }

    bool checkSimulatedOOM() const
    {
        return true;
    }
};







typedef uintptr_t MozRefCountType;
typedef uint32_t MozExternalRefCountType;
enum class nsresult : uint32_t
{






  NS_OK = 0,




  NS_ERROR_BASE = 0xC1F30000,

  NS_ERROR_NOT_INITIALIZED = NS_ERROR_BASE + 1,

  NS_ERROR_ALREADY_INITIALIZED = NS_ERROR_BASE + 2,

  NS_ERROR_NOT_IMPLEMENTED = 0x80004001,

  NS_NOINTERFACE = 0x80004002,
  NS_ERROR_NO_INTERFACE = NS_NOINTERFACE,

  NS_ERROR_ABORT = 0x80004004,

  NS_ERROR_FAILURE = 0x80004005,

  NS_ERROR_UNEXPECTED = 0x8000ffff,

  NS_ERROR_OUT_OF_MEMORY = 0x8007000e,

  NS_ERROR_ILLEGAL_VALUE = 0x80070057,
  NS_ERROR_INVALID_ARG = NS_ERROR_ILLEGAL_VALUE,
  NS_ERROR_INVALID_POINTER = NS_ERROR_INVALID_ARG,
  NS_ERROR_NULL_POINTER = NS_ERROR_INVALID_ARG,

  NS_ERROR_NO_AGGREGATION = 0x80040110,

  NS_ERROR_NOT_AVAILABLE = 0x80040111,

  NS_ERROR_FACTORY_NOT_REGISTERED = 0x80040154,

  NS_ERROR_FACTORY_REGISTER_AGAIN = 0x80040155,

  NS_ERROR_FACTORY_NOT_LOADED = 0x800401f8,

  NS_ERROR_FACTORY_NO_SIGNATURE_SUPPORT = NS_ERROR_BASE + 0x101,

  NS_ERROR_FACTORY_EXISTS = NS_ERROR_BASE + 0x100,







  NS_ERROR_CANNOT_CONVERT_DATA = ((uint32_t)(1) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_OBJECT_IS_IMMUTABLE = ((uint32_t)(1) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_LOSS_OF_SIGNIFICANT_DATA = ((uint32_t)(1) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(3),

  NS_ERROR_NOT_SAME_THREAD = ((uint32_t)(1) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(4),


  NS_ERROR_ILLEGAL_DURING_SHUTDOWN = ((uint32_t)(1) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(30),
  NS_ERROR_SERVICE_NOT_AVAILABLE = ((uint32_t)(1) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(22),

  NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA = ((uint32_t)(0) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(1),

  NS_SUCCESS_INTERRUPTED_TRAVERSE = ((uint32_t)(0) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(2),

  NS_ERROR_SERVICE_NOT_FOUND = ((uint32_t)(0) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(22),

  NS_ERROR_SERVICE_IN_USE = ((uint32_t)(0) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(23),
  NS_BASE_STREAM_CLOSED = ((uint32_t)(1) << 31) | ((uint32_t)(2 + 0x45) << 16) | (uint32_t)(2),

  NS_BASE_STREAM_OSERROR = ((uint32_t)(1) << 31) | ((uint32_t)(2 + 0x45) << 16) | (uint32_t)(3),

  NS_BASE_STREAM_ILLEGAL_ARGS = ((uint32_t)(1) << 31) | ((uint32_t)(2 + 0x45) << 16) | (uint32_t)(4),

  NS_BASE_STREAM_NO_CONVERTER = ((uint32_t)(1) << 31) | ((uint32_t)(2 + 0x45) << 16) | (uint32_t)(5),

  NS_BASE_STREAM_BAD_CONVERSION = ((uint32_t)(1) << 31) | ((uint32_t)(2 + 0x45) << 16) | (uint32_t)(6),
  NS_BASE_STREAM_WOULD_BLOCK = ((uint32_t)(1) << 31) | ((uint32_t)(2 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_GFX_PRINTER_NO_PRINTER_AVAILABLE = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(1),

  NS_ERROR_GFX_PRINTER_NAME_NOT_FOUND = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(2),

  NS_ERROR_GFX_PRINTER_COULD_NOT_OPEN_FILE = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(3),

  NS_ERROR_GFX_PRINTER_STARTDOC = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(4),

  NS_ERROR_GFX_PRINTER_ENDDOC = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(5),

  NS_ERROR_GFX_PRINTER_STARTPAGE = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(6),

  NS_ERROR_GFX_PRINTER_DOC_IS_BUSY = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(7),


  NS_ERROR_GFX_CMAP_MALFORMED = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(51),
  NS_SUCCESS_EVENT_CONSUMED = ((uint32_t)(0) << 31) | ((uint32_t)(4 + 0x45) << 16) | (uint32_t)(1),




  NS_SUCCESS_EVENT_HANDLED_ASYNCHRONOUSLY = ((uint32_t)(0) << 31) | ((uint32_t)(4 + 0x45) << 16) | (uint32_t)(2),
  NS_BINDING_SUCCEEDED = NS_OK,


  NS_BINDING_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(1),

  NS_BINDING_ABORTED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(2),





  NS_BINDING_REDIRECTED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(3),





  NS_BINDING_RETARGETED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(4),





  NS_ERROR_MALFORMED_URI = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(10),



  NS_ERROR_IN_PROGRESS = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(15),




  NS_ERROR_NO_CONTENT = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(17),

  NS_ERROR_UNKNOWN_PROTOCOL = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(18),


  NS_ERROR_INVALID_CONTENT_ENCODING = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(27),



  NS_ERROR_CORRUPTED_CONTENT = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(29),



  NS_ERROR_INVALID_SIGNATURE = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(58),



  NS_ERROR_FIRST_HEADER_FIELD_COMPONENT_EMPTY = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(34),


  NS_ERROR_ALREADY_OPENED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(73),




  NS_ERROR_ALREADY_CONNECTED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(11),

  NS_ERROR_NOT_CONNECTED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(12),


  NS_ERROR_CONNECTION_REFUSED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(13),

  NS_ERROR_NET_TIMEOUT = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(14),


  NS_ERROR_OFFLINE = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(16),



  NS_ERROR_PORT_ACCESS_NOT_ALLOWED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(19),

  NS_ERROR_NET_RESET = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(20),

  NS_ERROR_NET_INTERRUPT = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(71),

  NS_ERROR_PROXY_CONNECTION_REFUSED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(72),

  NS_ERROR_NET_PARTIAL_TRANSFER = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(76),

  NS_ERROR_NET_INADEQUATE_SECURITY = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(82),





  NS_ERROR_NOT_RESUMABLE = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(25),

  NS_ERROR_REDIRECT_LOOP = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(31),


  NS_ERROR_ENTITY_CHANGED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(32),



  NS_ERROR_UNSAFE_CONTENT_TYPE = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(74),


  NS_ERROR_REMOTE_XUL = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(75),

  NS_ERROR_LOAD_SHOWED_ERRORPAGE = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(77),


  NS_ERROR_DOCSHELL_DYING = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(78),




  NS_ERROR_FTP_LOGIN = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(21),
  NS_ERROR_FTP_CWD = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(22),
  NS_ERROR_FTP_PASV = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(23),
  NS_ERROR_FTP_PWD = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(24),
  NS_ERROR_FTP_LIST = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(28),





  NS_ERROR_UNKNOWN_HOST = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(30),


  NS_ERROR_DNS_LOOKUP_QUEUE_FULL = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(33),



  NS_ERROR_UNKNOWN_PROXY_HOST = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(42),





  NS_ERROR_UNKNOWN_SOCKET_TYPE = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(51),

  NS_ERROR_SOCKET_CREATE_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(52),

  NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(53),

  NS_ERROR_SOCKET_ADDRESS_IN_USE = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(54),


  NS_ERROR_CACHE_KEY_NOT_FOUND = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(61),
  NS_ERROR_CACHE_DATA_IS_STREAM = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(62),
  NS_ERROR_CACHE_DATA_IS_NOT_STREAM = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(63),
  NS_ERROR_CACHE_WAIT_FOR_VALIDATION = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(64),
  NS_ERROR_CACHE_ENTRY_DOOMED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(65),
  NS_ERROR_CACHE_READ_ACCESS_DENIED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(66),
  NS_ERROR_CACHE_WRITE_ACCESS_DENIED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(67),
  NS_ERROR_CACHE_IN_USE = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(68),


  NS_ERROR_DOCUMENT_NOT_CACHED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(70),





  NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(80),

  NS_ERROR_HOST_IS_IP_ADDRESS = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(81),







  NS_SUCCESS_ADOPTED_DATA = ((uint32_t)(0) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(90),


  NS_NET_STATUS_BEGIN_FTP_TRANSACTION = ((uint32_t)(0) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(27),
  NS_NET_STATUS_END_FTP_TRANSACTION = ((uint32_t)(0) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(28),




  NS_SUCCESS_AUTH_FINISHED = ((uint32_t)(0) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(40),




  NS_NET_STATUS_READING = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(8),
  NS_NET_STATUS_WRITING = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(9),


  NS_NET_STATUS_RESOLVING_HOST = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(3),
  NS_NET_STATUS_RESOLVED_HOST = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(11),
  NS_NET_STATUS_CONNECTING_TO = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(7),
  NS_NET_STATUS_CONNECTED_TO = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(4),
  NS_NET_STATUS_TLS_HANDSHAKE_STARTING = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(12),
  NS_NET_STATUS_TLS_HANDSHAKE_ENDED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(13),
  NS_NET_STATUS_SENDING_TO = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(5),
  NS_NET_STATUS_WAITING_FOR = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(10),
  NS_NET_STATUS_RECEIVING_FROM = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(6),



  NS_ERROR_INTERCEPTION_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(100),



  NS_ERROR_HSTS_PRIMING_TIMEOUT = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(110),







  NS_ERROR_PLUGINS_PLUGINSNOTCHANGED = ((uint32_t)(1) << 31) | ((uint32_t)(7 + 0x45) << 16) | (uint32_t)(1000),
  NS_ERROR_PLUGIN_DISABLED = ((uint32_t)(1) << 31) | ((uint32_t)(7 + 0x45) << 16) | (uint32_t)(1001),
  NS_ERROR_PLUGIN_BLOCKLISTED = ((uint32_t)(1) << 31) | ((uint32_t)(7 + 0x45) << 16) | (uint32_t)(1002),
  NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED = ((uint32_t)(1) << 31) | ((uint32_t)(7 + 0x45) << 16) | (uint32_t)(1003),
  NS_ERROR_PLUGIN_CLICKTOPLAY = ((uint32_t)(1) << 31) | ((uint32_t)(7 + 0x45) << 16) | (uint32_t)(1004),
  NS_PLUGIN_INIT_PENDING = ((uint32_t)(0) << 31) | ((uint32_t)(7 + 0x45) << 16) | (uint32_t)(1005),
  NS_TABLELAYOUT_CELL_NOT_FOUND = ((uint32_t)(0) << 31) | ((uint32_t)(8 + 0x45) << 16) | (uint32_t)(0),

  NS_POSITION_BEFORE_TABLE = ((uint32_t)(0) << 31) | ((uint32_t)(8 + 0x45) << 16) | (uint32_t)(3),


  NS_STATE_PROPERTY_EXISTS = NS_OK,

  NS_STATE_PROPERTY_NOT_THERE = ((uint32_t)(0) << 31) | ((uint32_t)(8 + 0x45) << 16) | (uint32_t)(5),







  NS_ERROR_HTMLPARSER_CONTINUE = NS_OK,

  NS_ERROR_HTMLPARSER_EOF = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1000),
  NS_ERROR_HTMLPARSER_UNKNOWN = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1001),
  NS_ERROR_HTMLPARSER_CANTPROPAGATE = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1002),
  NS_ERROR_HTMLPARSER_CONTEXTMISMATCH = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1003),
  NS_ERROR_HTMLPARSER_BADFILENAME = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1004),
  NS_ERROR_HTMLPARSER_BADURL = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1005),
  NS_ERROR_HTMLPARSER_INVALIDPARSERCONTEXT = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1006),
  NS_ERROR_HTMLPARSER_INTERRUPTED = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1007),
  NS_ERROR_HTMLPARSER_BLOCK = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1008),
  NS_ERROR_HTMLPARSER_BADTOKENIZER = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1009),
  NS_ERROR_HTMLPARSER_BADATTRIBUTE = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1010),
  NS_ERROR_HTMLPARSER_UNRESOLVEDDTD = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1011),
  NS_ERROR_HTMLPARSER_MISPLACEDTABLECONTENT = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1012),
  NS_ERROR_HTMLPARSER_BADDTD = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1013),
  NS_ERROR_HTMLPARSER_BADCONTEXT = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1014),
  NS_ERROR_HTMLPARSER_STOPPARSING = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1015),
  NS_ERROR_HTMLPARSER_UNTERMINATEDSTRINGLITERAL = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1016),
  NS_ERROR_HTMLPARSER_HIERARCHYTOODEEP = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1017),
  NS_ERROR_HTMLPARSER_FAKE_ENDTAG = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1018),
  NS_ERROR_HTMLPARSER_INVALID_COMMENT = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1019),

  NS_HTMLTOKENS_NOT_AN_ENTITY = ((uint32_t)(0) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(2000),
  NS_HTMLPARSER_VALID_META_CHARSET = ((uint32_t)(0) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(3000),
  NS_RDF_ASSERTION_ACCEPTED = NS_OK,


  NS_RDF_CURSOR_EMPTY = ((uint32_t)(0) << 31) | ((uint32_t)(10 + 0x45) << 16) | (uint32_t)(1),


  NS_RDF_NO_VALUE = ((uint32_t)(0) << 31) | ((uint32_t)(10 + 0x45) << 16) | (uint32_t)(2),



  NS_RDF_ASSERTION_REJECTED = ((uint32_t)(0) << 31) | ((uint32_t)(10 + 0x45) << 16) | (uint32_t)(3),

  NS_RDF_STOP_VISIT = ((uint32_t)(0) << 31) | ((uint32_t)(10 + 0x45) << 16) | (uint32_t)(4),







  NS_ERROR_UCONV_NOCONV = ((uint32_t)(1) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_UDEC_ILLEGALINPUT = ((uint32_t)(1) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(14),

  NS_SUCCESS_USING_FALLBACK_LOCALE = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(2),
  NS_OK_UDEC_EXACTLENGTH = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(11),
  NS_OK_UDEC_MOREINPUT = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(12),
  NS_OK_UDEC_MOREOUTPUT = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(13),
  NS_OK_UDEC_NOBOMFOUND = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(14),
  NS_OK_UENC_EXACTLENGTH = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(33),
  NS_OK_UENC_MOREOUTPUT = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(34),
  NS_ERROR_UENC_NOMAPPING = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(35),
  NS_OK_UENC_MOREINPUT = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(36),


  NS_EXACT_LENGTH = NS_OK_UDEC_EXACTLENGTH,
  NS_PARTIAL_MORE_INPUT = NS_OK_UDEC_MOREINPUT,
  NS_PARTIAL_MORE_OUTPUT = NS_OK_UDEC_MOREOUTPUT,
  NS_ERROR_ILLEGAL_INPUT = NS_ERROR_UDEC_ILLEGALINPUT,
  NS_ERROR_FILE_UNRECOGNIZED_PATH = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_FILE_UNRESOLVABLE_SYMLINK = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_FILE_EXECUTION_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_FILE_UNKNOWN_TYPE = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_FILE_DESTINATION_NOT_DIR = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_FILE_TARGET_DOES_NOT_EXIST = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(6),
  NS_ERROR_FILE_COPY_OR_MOVE_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_FILE_ALREADY_EXISTS = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(8),
  NS_ERROR_FILE_INVALID_PATH = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(9),
  NS_ERROR_FILE_DISK_FULL = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(10),
  NS_ERROR_FILE_CORRUPTED = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(11),
  NS_ERROR_FILE_NOT_DIRECTORY = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(12),
  NS_ERROR_FILE_IS_DIRECTORY = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(13),
  NS_ERROR_FILE_IS_LOCKED = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(14),
  NS_ERROR_FILE_TOO_BIG = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(15),
  NS_ERROR_FILE_NO_DEVICE_SPACE = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(16),
  NS_ERROR_FILE_NAME_TOO_LONG = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(17),
  NS_ERROR_FILE_NOT_FOUND = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(18),
  NS_ERROR_FILE_READ_ONLY = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(19),
  NS_ERROR_FILE_DIR_NOT_EMPTY = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(20),
  NS_ERROR_FILE_ACCESS_DENIED = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(21),

  NS_SUCCESS_FILE_DIRECTORY_EMPTY = ((uint32_t)(0) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(1),

  NS_SUCCESS_AGGREGATE_RESULT = ((uint32_t)(0) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_DOM_INDEX_SIZE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_DOM_HIERARCHY_REQUEST_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_DOM_WRONG_DOCUMENT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_DOM_INVALID_CHARACTER_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_DOM_NOT_FOUND_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(8),
  NS_ERROR_DOM_NOT_SUPPORTED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(9),
  NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(10),
  NS_ERROR_DOM_INVALID_STATE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(11),
  NS_ERROR_DOM_SYNTAX_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(12),
  NS_ERROR_DOM_INVALID_MODIFICATION_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(13),
  NS_ERROR_DOM_NAMESPACE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(14),
  NS_ERROR_DOM_INVALID_ACCESS_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(15),
  NS_ERROR_DOM_TYPE_MISMATCH_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(17),
  NS_ERROR_DOM_SECURITY_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(18),
  NS_ERROR_DOM_NETWORK_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(19),
  NS_ERROR_DOM_ABORT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(20),
  NS_ERROR_DOM_URL_MISMATCH_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(21),
  NS_ERROR_DOM_QUOTA_EXCEEDED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(22),
  NS_ERROR_DOM_TIMEOUT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(23),
  NS_ERROR_DOM_INVALID_NODE_TYPE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(24),
  NS_ERROR_DOM_DATA_CLONE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(25),

  NS_ERROR_TYPE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(26),
  NS_ERROR_RANGE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(27),

  NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(28),
  NS_ERROR_DOM_INVALID_POINTER_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(29),

  NS_ERROR_DOM_UNKNOWN_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(30),
  NS_ERROR_DOM_DATA_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(31),
  NS_ERROR_DOM_OPERATION_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(32),

  NS_ERROR_DOM_NOT_ALLOWED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(33),

  NS_ERROR_DOM_SECMAN_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1001),
  NS_ERROR_DOM_WRONG_TYPE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1002),
  NS_ERROR_DOM_NOT_OBJECT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1003),
  NS_ERROR_DOM_NOT_XPC_OBJECT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1004),
  NS_ERROR_DOM_NOT_NUMBER_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1005),
  NS_ERROR_DOM_NOT_BOOLEAN_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1006),
  NS_ERROR_DOM_NOT_FUNCTION_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1007),
  NS_ERROR_DOM_TOO_FEW_PARAMETERS_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1008),
  NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1009),
  NS_ERROR_DOM_PROP_ACCESS_DENIED = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1010),
  NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1011),
  NS_ERROR_DOM_BAD_URI = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1012),
  NS_ERROR_DOM_RETVAL_UNDEFINED = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1013),
  NS_ERROR_DOM_QUOTA_REACHED = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1014),


  NS_ERROR_UNCATCHABLE_EXCEPTION = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1015),

  NS_ERROR_DOM_MALFORMED_URI = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1016),
  NS_ERROR_DOM_INVALID_HEADER_NAME = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1017),

  NS_ERROR_DOM_INVALID_STATE_XHR_HAS_INVALID_CONTEXT = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1018),
  NS_ERROR_DOM_INVALID_STATE_XHR_MUST_BE_OPENED = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1019),
  NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_SENDING = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1020),
  NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_LOADING_OR_DONE = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1021),
  NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSEXML = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1022),
  NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSETEXT = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1023),
  NS_ERROR_DOM_INVALID_STATE_XHR_CHUNKED_RESPONSETYPES_UNSUPPORTED_FOR_SYNC = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1024),
  NS_ERROR_DOM_INVALID_ACCESS_XHR_TIMEOUT_AND_RESPONSETYPE_UNSUPPORTED_FOR_SYNC = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1025),





  NS_SUCCESS_DOM_NO_OPERATION = ((uint32_t)(0) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1),






  NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW = ((uint32_t)(0) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(2),






  NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW_UNCATCHABLE = ((uint32_t)(0) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(3),







  NS_IMAGELIB_SUCCESS_LOAD_FINISHED = ((uint32_t)(0) << 31) | ((uint32_t)(15 + 0x45) << 16) | (uint32_t)(0),
  NS_IMAGELIB_CHANGING_OWNER = ((uint32_t)(0) << 31) | ((uint32_t)(15 + 0x45) << 16) | (uint32_t)(1),

  NS_IMAGELIB_ERROR_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(15 + 0x45) << 16) | (uint32_t)(5),
  NS_IMAGELIB_ERROR_NO_DECODER = ((uint32_t)(1) << 31) | ((uint32_t)(15 + 0x45) << 16) | (uint32_t)(6),
  NS_IMAGELIB_ERROR_NOT_FINISHED = ((uint32_t)(1) << 31) | ((uint32_t)(15 + 0x45) << 16) | (uint32_t)(7),
  NS_IMAGELIB_ERROR_NO_ENCODER = ((uint32_t)(1) << 31) | ((uint32_t)(15 + 0x45) << 16) | (uint32_t)(9),







  NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND = ((uint32_t)(0) << 31) | ((uint32_t)(17 + 0x45) << 16) | (uint32_t)(1),
  NS_SUCCESS_EDITOR_FOUND_TARGET = ((uint32_t)(0) << 31) | ((uint32_t)(17 + 0x45) << 16) | (uint32_t)(2),







  NS_ERROR_XPC_NOT_ENOUGH_ARGS = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_XPC_NEED_OUT_OBJECT = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_XPC_CANT_SET_OUT_VAL = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_XPC_NATIVE_RETURNED_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_XPC_CANT_GET_INTERFACE_INFO = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(6),
  NS_ERROR_XPC_CANT_GET_METHOD_INFO = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_XPC_UNEXPECTED = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(8),
  NS_ERROR_XPC_BAD_CONVERT_JS = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(9),
  NS_ERROR_XPC_BAD_CONVERT_NATIVE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(10),
  NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(11),
  NS_ERROR_XPC_BAD_OP_ON_WN_PROTO = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(12),
  NS_ERROR_XPC_CANT_CONVERT_WN_TO_FUN = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(13),
  NS_ERROR_XPC_CANT_DEFINE_PROP_ON_WN = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(14),
  NS_ERROR_XPC_CANT_WATCH_WN_STATIC = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(15),
  NS_ERROR_XPC_CANT_EXPORT_WN_STATIC = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(16),
  NS_ERROR_XPC_SCRIPTABLE_CALL_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(17),
  NS_ERROR_XPC_SCRIPTABLE_CTOR_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(18),
  NS_ERROR_XPC_CANT_CALL_WO_SCRIPTABLE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(19),
  NS_ERROR_XPC_CANT_CTOR_WO_SCRIPTABLE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(20),
  NS_ERROR_XPC_CI_RETURNED_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(21),
  NS_ERROR_XPC_GS_RETURNED_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(22),
  NS_ERROR_XPC_BAD_CID = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(23),
  NS_ERROR_XPC_BAD_IID = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(24),
  NS_ERROR_XPC_CANT_CREATE_WN = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(25),
  NS_ERROR_XPC_JS_THREW_EXCEPTION = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(26),
  NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(27),
  NS_ERROR_XPC_JS_THREW_JS_OBJECT = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(28),
  NS_ERROR_XPC_JS_THREW_NULL = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(29),
  NS_ERROR_XPC_JS_THREW_STRING = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(30),
  NS_ERROR_XPC_JS_THREW_NUMBER = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(31),
  NS_ERROR_XPC_JAVASCRIPT_ERROR = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(32),
  NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(33),
  NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(34),
  NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(35),
  NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(36),
  NS_ERROR_XPC_CANT_GET_ARRAY_INFO = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(37),
  NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(38),
  NS_ERROR_XPC_SECURITY_MANAGER_VETO = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(39),
  NS_ERROR_XPC_INTERFACE_NOT_SCRIPTABLE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(40),
  NS_ERROR_XPC_INTERFACE_NOT_FROM_NSISUPPORTS = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(41),
  NS_ERROR_XPC_CANT_GET_JSOBJECT_OF_DOM_OBJECT = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(42),
  NS_ERROR_XPC_CANT_SET_READ_ONLY_CONSTANT = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(43),
  NS_ERROR_XPC_CANT_SET_READ_ONLY_ATTRIBUTE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(44),
  NS_ERROR_XPC_CANT_SET_READ_ONLY_METHOD = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(45),
  NS_ERROR_XPC_CANT_ADD_PROP_TO_WRAPPED_NATIVE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(46),
  NS_ERROR_XPC_CALL_TO_SCRIPTABLE_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(47),
  NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(48),
  NS_ERROR_XPC_BAD_ID_STRING = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(49),
  NS_ERROR_XPC_BAD_INITIALIZER_NAME = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(50),
  NS_ERROR_XPC_HAS_BEEN_SHUTDOWN = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(51),
  NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(52),
  NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(53),
  NS_ERROR_XPC_CANT_PASS_CPOW_TO_NATIVE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(54),
  NS_ERROR_LAUNCHED_CHILD_PROCESS = ((uint32_t)(1) << 31) | ((uint32_t)(19 + 0x45) << 16) | (uint32_t)(200),
  NS_ERROR_CSP_FORM_ACTION_VIOLATION = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(98),
  NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(99),


  NS_ERROR_SRI_CORRUPT = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(200),
  NS_ERROR_SRI_DISABLED = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(201),
  NS_ERROR_SRI_NOT_ELIGIBLE = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(202),
  NS_ERROR_SRI_UNEXPECTED_HASH_TYPE = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(203),
  NS_ERROR_SRI_IMPORT = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(204),



  NS_ERROR_CMS_VERIFY_NOT_SIGNED = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1024),
  NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1025),
  NS_ERROR_CMS_VERIFY_BAD_DIGEST = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1026),
  NS_ERROR_CMS_VERIFY_NOCERT = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1028),
  NS_ERROR_CMS_VERIFY_UNTRUSTED = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1029),
  NS_ERROR_CMS_VERIFY_ERROR_UNVERIFIED = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1031),
  NS_ERROR_CMS_VERIFY_ERROR_PROCESSING = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1032),
  NS_ERROR_CMS_VERIFY_BAD_SIGNATURE = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1033),
  NS_ERROR_CMS_VERIFY_DIGEST_MISMATCH = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1034),
  NS_ERROR_CMS_VERIFY_UNKNOWN_ALGO = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1035),
  NS_ERROR_CMS_VERIFY_UNSUPPORTED_ALGO = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1036),
  NS_ERROR_CMS_VERIFY_MALFORMED_SIGNATURE = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1037),
  NS_ERROR_CMS_VERIFY_HEADER_MISMATCH = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1038),
  NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1039),
  NS_ERROR_CMS_VERIFY_CERT_WITHOUT_ADDRESS = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1040),
  NS_ERROR_CMS_ENCRYPT_NO_BULK_ALG = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1056),
  NS_ERROR_CMS_ENCRYPT_INCOMPLETE = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1057),
  NS_ERROR_DOM_INVALID_EXPRESSION_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(22 + 0x45) << 16) | (uint32_t)(51),
  NS_ERROR_DOM_TYPE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(22 + 0x45) << 16) | (uint32_t)(52),







  NS_ERROR_WONT_HANDLE_CONTENT = ((uint32_t)(1) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(1),


  NS_ERROR_MALWARE_URI = ((uint32_t)(1) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(30),
  NS_ERROR_PHISHING_URI = ((uint32_t)(1) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(31),
  NS_ERROR_TRACKING_URI = ((uint32_t)(1) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(34),
  NS_ERROR_UNWANTED_URI = ((uint32_t)(1) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(35),
  NS_ERROR_BLOCKED_URI = ((uint32_t)(1) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(37),


  NS_ERROR_SAVE_LINK_AS_TIMEOUT = ((uint32_t)(1) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(32),


  NS_ERROR_PARSED_DATA_CACHED = ((uint32_t)(1) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(33),



  NS_REFRESHURI_HEADER_FOUND = ((uint32_t)(0) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_IMAGE_SRC_CHANGED = ((uint32_t)(1) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_IMAGE_BLOCKED = ((uint32_t)(1) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(5),

  NS_ERROR_CONTENT_BLOCKED = ((uint32_t)(1) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(6),
  NS_ERROR_CONTENT_BLOCKED_SHOW_ALT = ((uint32_t)(1) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(7),

  NS_PROPTABLE_PROP_NOT_THERE = ((uint32_t)(1) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(10),

  NS_ERROR_XBL_BLOCKED = ((uint32_t)(1) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(15),

  NS_ERROR_CONTENT_CRASHED = ((uint32_t)(1) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(16),


  NS_HTML_STYLE_PROPERTY_NOT_THERE = ((uint32_t)(0) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(2),
  NS_CONTENT_BLOCKED = ((uint32_t)(0) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(8),
  NS_CONTENT_BLOCKED_SHOW_ALT = ((uint32_t)(0) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(9),
  NS_PROPTABLE_PROP_OVERWRITTEN = ((uint32_t)(0) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(11),

  NS_FINDBROADCASTER_NOT_FOUND = ((uint32_t)(0) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(12),
  NS_FINDBROADCASTER_FOUND = ((uint32_t)(0) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(13),
  NS_FINDBROADCASTER_AWAIT_OVERLAYS = ((uint32_t)(0) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(14),







  NS_ERROR_XPATH_INVALID_ARG = NS_ERROR_INVALID_ARG,

  NS_ERROR_XSLT_PARSE_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_XPATH_PARSE_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_XSLT_ALREADY_SET = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_XSLT_EXECUTION_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_XPATH_UNKNOWN_FUNCTION = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_XSLT_BAD_RECURSION = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(6),
  NS_ERROR_XSLT_BAD_VALUE = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_XSLT_NODESET_EXPECTED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(8),
  NS_ERROR_XSLT_ABORTED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(9),
  NS_ERROR_XSLT_NETWORK_ERROR = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(10),
  NS_ERROR_XSLT_WRONG_MIME_TYPE = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(11),
  NS_ERROR_XSLT_LOAD_RECURSION = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(12),
  NS_ERROR_XPATH_BAD_ARGUMENT_COUNT = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(13),
  NS_ERROR_XPATH_BAD_EXTENSION_FUNCTION = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(14),
  NS_ERROR_XPATH_PAREN_EXPECTED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(15),
  NS_ERROR_XPATH_INVALID_AXIS = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(16),
  NS_ERROR_XPATH_NO_NODE_TYPE_TEST = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(17),
  NS_ERROR_XPATH_BRACKET_EXPECTED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(18),
  NS_ERROR_XPATH_INVALID_VAR_NAME = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(19),
  NS_ERROR_XPATH_UNEXPECTED_END = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(20),
  NS_ERROR_XPATH_OPERATOR_EXPECTED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(21),
  NS_ERROR_XPATH_UNCLOSED_LITERAL = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(22),
  NS_ERROR_XPATH_BAD_COLON = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(23),
  NS_ERROR_XPATH_BAD_BANG = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(24),
  NS_ERROR_XPATH_ILLEGAL_CHAR = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(25),
  NS_ERROR_XPATH_BINARY_EXPECTED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(26),
  NS_ERROR_XSLT_LOAD_BLOCKED_ERROR = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(27),
  NS_ERROR_XPATH_INVALID_EXPRESSION_EVALUATED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(28),
  NS_ERROR_XPATH_UNBALANCED_CURLY_BRACE = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(29),
  NS_ERROR_XSLT_BAD_NODE_NAME = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(30),
  NS_ERROR_XSLT_VAR_ALREADY_SET = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(31),
  NS_ERROR_XSLT_CALL_TO_KEY_NOT_ALLOWED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(32),

  NS_XSLT_GET_NEW_HANDLER = ((uint32_t)(0) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_TRANSPORT_INIT = ((uint32_t)(1) << 31) | ((uint32_t)(28 + 0x45) << 16) | (uint32_t)(1),

  NS_ERROR_DUPLICATE_HANDLE = ((uint32_t)(1) << 31) | ((uint32_t)(28 + 0x45) << 16) | (uint32_t)(2),

  NS_ERROR_BRIDGE_OPEN_PARENT = ((uint32_t)(1) << 31) | ((uint32_t)(28 + 0x45) << 16) | (uint32_t)(3),

  NS_ERROR_BRIDGE_OPEN_CHILD = ((uint32_t)(1) << 31) | ((uint32_t)(28 + 0x45) << 16) | (uint32_t)(4),







  NS_ERROR_DOM_SVG_WRONG_TYPE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(29 + 0x45) << 16) | (uint32_t)(0),

  NS_ERROR_DOM_SVG_MATRIX_NOT_INVERTABLE = ((uint32_t)(1) << 31) | ((uint32_t)(29 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_STORAGE_BUSY = ((uint32_t)(1) << 31) | ((uint32_t)(30 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_STORAGE_IOERR = ((uint32_t)(1) << 31) | ((uint32_t)(30 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_STORAGE_CONSTRAINT = ((uint32_t)(1) << 31) | ((uint32_t)(30 + 0x45) << 16) | (uint32_t)(3),







  NS_ERROR_DOM_FILE_NOT_FOUND_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(32 + 0x45) << 16) | (uint32_t)(0),
  NS_ERROR_DOM_FILE_NOT_READABLE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(32 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_DOM_FILE_ABORT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(32 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_DOM_INDEXEDDB_NOT_FOUND_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_DOM_INDEXEDDB_CONSTRAINT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_DOM_INDEXEDDB_DATA_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_DOM_INDEXEDDB_NOT_ALLOWED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(6),
  NS_ERROR_DOM_INDEXEDDB_TRANSACTION_INACTIVE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_DOM_INDEXEDDB_ABORT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(8),
  NS_ERROR_DOM_INDEXEDDB_READ_ONLY_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(9),
  NS_ERROR_DOM_INDEXEDDB_TIMEOUT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(10),
  NS_ERROR_DOM_INDEXEDDB_QUOTA_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(11),
  NS_ERROR_DOM_INDEXEDDB_VERSION_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(12),
  NS_ERROR_DOM_INDEXEDDB_RECOVERABLE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(1001),







  NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(34 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(34 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_DOM_FILEHANDLE_INACTIVE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(34 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_DOM_FILEHANDLE_ABORT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(34 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_DOM_FILEHANDLE_READ_ONLY_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(34 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_DOM_FILEHANDLE_QUOTA_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(34 + 0x45) << 16) | (uint32_t)(6),






  NS_ERROR_SIGNED_JAR_NOT_SIGNED = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_SIGNED_JAR_ENTRY_MISSING = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_SIGNED_JAR_WRONG_SIGNATURE = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(6),
  NS_ERROR_SIGNED_JAR_ENTRY_INVALID = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_SIGNED_JAR_MANIFEST_INVALID = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(8),






  NS_ERROR_DOM_FILESYSTEM_INVALID_PATH_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(36 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_DOM_FILESYSTEM_INVALID_MODIFICATION_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(36 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_DOM_FILESYSTEM_NO_MODIFICATION_ALLOWED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(36 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_DOM_FILESYSTEM_PATH_EXISTS_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(36 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_DOM_FILESYSTEM_TYPE_MISMATCH_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(36 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_DOM_FILESYSTEM_UNKNOWN_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(36 + 0x45) << 16) | (uint32_t)(6),






  NS_ERROR_SIGNED_APP_MANIFEST_INVALID = ((uint32_t)(1) << 31) | ((uint32_t)(38 + 0x45) << 16) | (uint32_t)(1),






  NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(39 + 0x45) << 16) | (uint32_t)(1),






  NS_ERROR_DOM_PUSH_INVALID_REGISTRATION_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(40 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_DOM_PUSH_DENIED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(40 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_DOM_PUSH_ABORT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(40 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_DOM_PUSH_SERVICE_UNREACHABLE = ((uint32_t)(1) << 31) | ((uint32_t)(40 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_DOM_PUSH_INVALID_KEY_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(40 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_DOM_PUSH_MISMATCHED_KEY_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(40 + 0x45) << 16) | (uint32_t)(6),







  NS_ERROR_DOM_MEDIA_ABORT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(3),


  NS_ERROR_DOM_MEDIA_DECODE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_DOM_MEDIA_FATAL_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_DOM_MEDIA_METADATA_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(6),
  NS_ERROR_DOM_MEDIA_OVERFLOW_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_DOM_MEDIA_END_OF_STREAM = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(8),
  NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(9),
  NS_ERROR_DOM_MEDIA_CANCELED = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(10),
  NS_ERROR_DOM_MEDIA_MEDIASINK_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(11),
  NS_ERROR_DOM_MEDIA_DEMUXER_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(12),
  NS_ERROR_DOM_MEDIA_CDM_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(13),
  NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(14),
  NS_ERROR_DOM_MEDIA_INITIALIZING_DECODER = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(15),


  NS_ERROR_DOM_MEDIA_CUBEB_INITIALIZATION_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(41 + 0x45) << 16) | (uint32_t)(101),






  NS_ERROR_UC_UPDATE_UNKNOWN = ((uint32_t)(1) << 31) | ((uint32_t)(42 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_UC_UPDATE_DUPLICATE_PREFIX = ((uint32_t)(1) << 31) | ((uint32_t)(42 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_UC_UPDATE_INFINITE_LOOP = ((uint32_t)(1) << 31) | ((uint32_t)(42 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_UC_UPDATE_WRONG_REMOVAL_INDICES = ((uint32_t)(1) << 31) | ((uint32_t)(42 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_UC_UPDATE_CHECKSUM_MISMATCH = ((uint32_t)(1) << 31) | ((uint32_t)(42 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_UC_UPDATE_MISSING_CHECKSUM = ((uint32_t)(1) << 31) | ((uint32_t)(42 + 0x45) << 16) | (uint32_t)(6),
  NS_ERROR_UC_UPDATE_SHUTDOWNING = ((uint32_t)(1) << 31) | ((uint32_t)(42 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_UC_UPDATE_TABLE_NOT_FOUND = ((uint32_t)(1) << 31) | ((uint32_t)(42 + 0x45) << 16) | (uint32_t)(8),
  NS_ERROR_UC_UPDATE_BUILD_PREFIX_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(42 + 0x45) << 16) | (uint32_t)(9),
  NS_ERROR_UC_UPDATE_FAIL_TO_WRITE_DISK = ((uint32_t)(1) << 31) | ((uint32_t)(42 + 0x45) << 16) | (uint32_t)(10),
  NS_ERROR_UC_UPDATE_PROTOCOL_PARSER_ERROR = ((uint32_t)(1) << 31) | ((uint32_t)(42 + 0x45) << 16) | (uint32_t)(11),







  NS_ERROR_INTERNAL_ERRORRESULT_JS_EXCEPTION = ((uint32_t)(1) << 31) | ((uint32_t)(43 + 0x45) << 16) | (uint32_t)(1),

  NS_ERROR_INTERNAL_ERRORRESULT_DOMEXCEPTION = ((uint32_t)(1) << 31) | ((uint32_t)(43 + 0x45) << 16) | (uint32_t)(2),

  NS_ERROR_INTERNAL_ERRORRESULT_EXCEPTION_ON_JSCONTEXT = ((uint32_t)(1) << 31) | ((uint32_t)(43 + 0x45) << 16) | (uint32_t)(3),

  NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR = ((uint32_t)(1) << 31) | ((uint32_t)(43 + 0x45) << 16) | (uint32_t)(4),

  NS_ERROR_INTERNAL_ERRORRESULT_RANGEERROR = ((uint32_t)(1) << 31) | ((uint32_t)(43 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_DOWNLOAD_COMPLETE = ((uint32_t)(1) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(1),



  NS_ERROR_DOWNLOAD_NOT_PARTIAL = ((uint32_t)(1) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_UNORM_MOREOUTPUT = ((uint32_t)(1) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(33),

  NS_ERROR_DOCSHELL_REQUEST_REJECTED = ((uint32_t)(1) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(1001),




  NS_ERROR_DOCUMENT_IS_PRINTMODE = ((uint32_t)(1) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(2001),

  NS_SUCCESS_DONT_FIXUP = ((uint32_t)(0) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(1),



  NS_SUCCESS_RESTART_APP = ((uint32_t)(0) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(1),
  NS_SUCCESS_RESTART_APP_NOT_SAME_PROFILE = ((uint32_t)(0) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(3),
  NS_SUCCESS_UNORM_NOTFOUND = ((uint32_t)(0) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(17),




  NS_ERROR_NOT_IN_TREE = ((uint32_t)(1) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(38),


  NS_OK_NO_NAME_CLAUSE_HANDLED = ((uint32_t)(0) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(34)

};





const nsresult





  NS_OK = nsresult::NS_OK,




  NS_ERROR_BASE = nsresult::NS_ERROR_BASE,

  NS_ERROR_NOT_INITIALIZED = nsresult::NS_ERROR_NOT_INITIALIZED,

  NS_ERROR_ALREADY_INITIALIZED = nsresult::NS_ERROR_ALREADY_INITIALIZED,

  NS_ERROR_NOT_IMPLEMENTED = nsresult::NS_ERROR_NOT_IMPLEMENTED,

  NS_NOINTERFACE = nsresult::NS_NOINTERFACE,
  NS_ERROR_NO_INTERFACE = nsresult::NS_ERROR_NO_INTERFACE,

  NS_ERROR_ABORT = nsresult::NS_ERROR_ABORT,

  NS_ERROR_FAILURE = nsresult::NS_ERROR_FAILURE,

  NS_ERROR_UNEXPECTED = nsresult::NS_ERROR_UNEXPECTED,

  NS_ERROR_OUT_OF_MEMORY = nsresult::NS_ERROR_OUT_OF_MEMORY,

  NS_ERROR_ILLEGAL_VALUE = nsresult::NS_ERROR_ILLEGAL_VALUE,
  NS_ERROR_INVALID_ARG = nsresult::NS_ERROR_INVALID_ARG,
  NS_ERROR_INVALID_POINTER = nsresult::NS_ERROR_INVALID_POINTER,
  NS_ERROR_NULL_POINTER = nsresult::NS_ERROR_NULL_POINTER,

  NS_ERROR_NO_AGGREGATION = nsresult::NS_ERROR_NO_AGGREGATION,

  NS_ERROR_NOT_AVAILABLE = nsresult::NS_ERROR_NOT_AVAILABLE,

  NS_ERROR_FACTORY_NOT_REGISTERED = nsresult::NS_ERROR_FACTORY_NOT_REGISTERED,

  NS_ERROR_FACTORY_REGISTER_AGAIN = nsresult::NS_ERROR_FACTORY_REGISTER_AGAIN,

  NS_ERROR_FACTORY_NOT_LOADED = nsresult::NS_ERROR_FACTORY_NOT_LOADED,

  NS_ERROR_FACTORY_NO_SIGNATURE_SUPPORT = nsresult::NS_ERROR_FACTORY_NO_SIGNATURE_SUPPORT,

  NS_ERROR_FACTORY_EXISTS = nsresult::NS_ERROR_FACTORY_EXISTS,







  NS_ERROR_CANNOT_CONVERT_DATA = nsresult::NS_ERROR_CANNOT_CONVERT_DATA,
  NS_ERROR_OBJECT_IS_IMMUTABLE = nsresult::NS_ERROR_OBJECT_IS_IMMUTABLE,
  NS_ERROR_LOSS_OF_SIGNIFICANT_DATA = nsresult::NS_ERROR_LOSS_OF_SIGNIFICANT_DATA,

  NS_ERROR_NOT_SAME_THREAD = nsresult::NS_ERROR_NOT_SAME_THREAD,


  NS_ERROR_ILLEGAL_DURING_SHUTDOWN = nsresult::NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
  NS_ERROR_SERVICE_NOT_AVAILABLE = nsresult::NS_ERROR_SERVICE_NOT_AVAILABLE,

  NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA = nsresult::NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA,

  NS_SUCCESS_INTERRUPTED_TRAVERSE = nsresult::NS_SUCCESS_INTERRUPTED_TRAVERSE,

  NS_ERROR_SERVICE_NOT_FOUND = nsresult::NS_ERROR_SERVICE_NOT_FOUND,

  NS_ERROR_SERVICE_IN_USE = nsresult::NS_ERROR_SERVICE_IN_USE,
  NS_BASE_STREAM_CLOSED = nsresult::NS_BASE_STREAM_CLOSED,

  NS_BASE_STREAM_OSERROR = nsresult::NS_BASE_STREAM_OSERROR,

  NS_BASE_STREAM_ILLEGAL_ARGS = nsresult::NS_BASE_STREAM_ILLEGAL_ARGS,

  NS_BASE_STREAM_NO_CONVERTER = nsresult::NS_BASE_STREAM_NO_CONVERTER,

  NS_BASE_STREAM_BAD_CONVERSION = nsresult::NS_BASE_STREAM_BAD_CONVERSION,
  NS_BASE_STREAM_WOULD_BLOCK = nsresult::NS_BASE_STREAM_WOULD_BLOCK,
  NS_ERROR_GFX_PRINTER_NO_PRINTER_AVAILABLE = nsresult::NS_ERROR_GFX_PRINTER_NO_PRINTER_AVAILABLE,

  NS_ERROR_GFX_PRINTER_NAME_NOT_FOUND = nsresult::NS_ERROR_GFX_PRINTER_NAME_NOT_FOUND,

  NS_ERROR_GFX_PRINTER_COULD_NOT_OPEN_FILE = nsresult::NS_ERROR_GFX_PRINTER_COULD_NOT_OPEN_FILE,

  NS_ERROR_GFX_PRINTER_STARTDOC = nsresult::NS_ERROR_GFX_PRINTER_STARTDOC,

  NS_ERROR_GFX_PRINTER_ENDDOC = nsresult::NS_ERROR_GFX_PRINTER_ENDDOC,

  NS_ERROR_GFX_PRINTER_STARTPAGE = nsresult::NS_ERROR_GFX_PRINTER_STARTPAGE,

  NS_ERROR_GFX_PRINTER_DOC_IS_BUSY = nsresult::NS_ERROR_GFX_PRINTER_DOC_IS_BUSY,


  NS_ERROR_GFX_CMAP_MALFORMED = nsresult::NS_ERROR_GFX_CMAP_MALFORMED,
  NS_SUCCESS_EVENT_CONSUMED = nsresult::NS_SUCCESS_EVENT_CONSUMED,




  NS_SUCCESS_EVENT_HANDLED_ASYNCHRONOUSLY = nsresult::NS_SUCCESS_EVENT_HANDLED_ASYNCHRONOUSLY,
  NS_BINDING_SUCCEEDED = nsresult::NS_BINDING_SUCCEEDED,


  NS_BINDING_FAILED = nsresult::NS_BINDING_FAILED,

  NS_BINDING_ABORTED = nsresult::NS_BINDING_ABORTED,





  NS_BINDING_REDIRECTED = nsresult::NS_BINDING_REDIRECTED,





  NS_BINDING_RETARGETED = nsresult::NS_BINDING_RETARGETED,





  NS_ERROR_MALFORMED_URI = nsresult::NS_ERROR_MALFORMED_URI,



  NS_ERROR_IN_PROGRESS = nsresult::NS_ERROR_IN_PROGRESS,




  NS_ERROR_NO_CONTENT = nsresult::NS_ERROR_NO_CONTENT,

  NS_ERROR_UNKNOWN_PROTOCOL = nsresult::NS_ERROR_UNKNOWN_PROTOCOL,


  NS_ERROR_INVALID_CONTENT_ENCODING = nsresult::NS_ERROR_INVALID_CONTENT_ENCODING,



  NS_ERROR_CORRUPTED_CONTENT = nsresult::NS_ERROR_CORRUPTED_CONTENT,



  NS_ERROR_INVALID_SIGNATURE = nsresult::NS_ERROR_INVALID_SIGNATURE,



  NS_ERROR_FIRST_HEADER_FIELD_COMPONENT_EMPTY = nsresult::NS_ERROR_FIRST_HEADER_FIELD_COMPONENT_EMPTY,


  NS_ERROR_ALREADY_OPENED = nsresult::NS_ERROR_ALREADY_OPENED,




  NS_ERROR_ALREADY_CONNECTED = nsresult::NS_ERROR_ALREADY_CONNECTED,

  NS_ERROR_NOT_CONNECTED = nsresult::NS_ERROR_NOT_CONNECTED,


  NS_ERROR_CONNECTION_REFUSED = nsresult::NS_ERROR_CONNECTION_REFUSED,

  NS_ERROR_NET_TIMEOUT = nsresult::NS_ERROR_NET_TIMEOUT,


  NS_ERROR_OFFLINE = nsresult::NS_ERROR_OFFLINE,



  NS_ERROR_PORT_ACCESS_NOT_ALLOWED = nsresult::NS_ERROR_PORT_ACCESS_NOT_ALLOWED,

  NS_ERROR_NET_RESET = nsresult::NS_ERROR_NET_RESET,

  NS_ERROR_NET_INTERRUPT = nsresult::NS_ERROR_NET_INTERRUPT,

  NS_ERROR_PROXY_CONNECTION_REFUSED = nsresult::NS_ERROR_PROXY_CONNECTION_REFUSED,

  NS_ERROR_NET_PARTIAL_TRANSFER = nsresult::NS_ERROR_NET_PARTIAL_TRANSFER,

  NS_ERROR_NET_INADEQUATE_SECURITY = nsresult::NS_ERROR_NET_INADEQUATE_SECURITY,





  NS_ERROR_NOT_RESUMABLE = nsresult::NS_ERROR_NOT_RESUMABLE,

  NS_ERROR_REDIRECT_LOOP = nsresult::NS_ERROR_REDIRECT_LOOP,


  NS_ERROR_ENTITY_CHANGED = nsresult::NS_ERROR_ENTITY_CHANGED,



  NS_ERROR_UNSAFE_CONTENT_TYPE = nsresult::NS_ERROR_UNSAFE_CONTENT_TYPE,


  NS_ERROR_REMOTE_XUL = nsresult::NS_ERROR_REMOTE_XUL,

  NS_ERROR_LOAD_SHOWED_ERRORPAGE = nsresult::NS_ERROR_LOAD_SHOWED_ERRORPAGE,


  NS_ERROR_DOCSHELL_DYING = nsresult::NS_ERROR_DOCSHELL_DYING,




  NS_ERROR_FTP_LOGIN = nsresult::NS_ERROR_FTP_LOGIN,
  NS_ERROR_FTP_CWD = nsresult::NS_ERROR_FTP_CWD,
  NS_ERROR_FTP_PASV = nsresult::NS_ERROR_FTP_PASV,
  NS_ERROR_FTP_PWD = nsresult::NS_ERROR_FTP_PWD,
  NS_ERROR_FTP_LIST = nsresult::NS_ERROR_FTP_LIST,





  NS_ERROR_UNKNOWN_HOST = nsresult::NS_ERROR_UNKNOWN_HOST,


  NS_ERROR_DNS_LOOKUP_QUEUE_FULL = nsresult::NS_ERROR_DNS_LOOKUP_QUEUE_FULL,



  NS_ERROR_UNKNOWN_PROXY_HOST = nsresult::NS_ERROR_UNKNOWN_PROXY_HOST,





  NS_ERROR_UNKNOWN_SOCKET_TYPE = nsresult::NS_ERROR_UNKNOWN_SOCKET_TYPE,

  NS_ERROR_SOCKET_CREATE_FAILED = nsresult::NS_ERROR_SOCKET_CREATE_FAILED,

  NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED = nsresult::NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED,

  NS_ERROR_SOCKET_ADDRESS_IN_USE = nsresult::NS_ERROR_SOCKET_ADDRESS_IN_USE,


  NS_ERROR_CACHE_KEY_NOT_FOUND = nsresult::NS_ERROR_CACHE_KEY_NOT_FOUND,
  NS_ERROR_CACHE_DATA_IS_STREAM = nsresult::NS_ERROR_CACHE_DATA_IS_STREAM,
  NS_ERROR_CACHE_DATA_IS_NOT_STREAM = nsresult::NS_ERROR_CACHE_DATA_IS_NOT_STREAM,
  NS_ERROR_CACHE_WAIT_FOR_VALIDATION = nsresult::NS_ERROR_CACHE_WAIT_FOR_VALIDATION,
  NS_ERROR_CACHE_ENTRY_DOOMED = nsresult::NS_ERROR_CACHE_ENTRY_DOOMED,
  NS_ERROR_CACHE_READ_ACCESS_DENIED = nsresult::NS_ERROR_CACHE_READ_ACCESS_DENIED,
  NS_ERROR_CACHE_WRITE_ACCESS_DENIED = nsresult::NS_ERROR_CACHE_WRITE_ACCESS_DENIED,
  NS_ERROR_CACHE_IN_USE = nsresult::NS_ERROR_CACHE_IN_USE,


  NS_ERROR_DOCUMENT_NOT_CACHED = nsresult::NS_ERROR_DOCUMENT_NOT_CACHED,





  NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS = nsresult::NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS,

  NS_ERROR_HOST_IS_IP_ADDRESS = nsresult::NS_ERROR_HOST_IS_IP_ADDRESS,







  NS_SUCCESS_ADOPTED_DATA = nsresult::NS_SUCCESS_ADOPTED_DATA,


  NS_NET_STATUS_BEGIN_FTP_TRANSACTION = nsresult::NS_NET_STATUS_BEGIN_FTP_TRANSACTION,
  NS_NET_STATUS_END_FTP_TRANSACTION = nsresult::NS_NET_STATUS_END_FTP_TRANSACTION,




  NS_SUCCESS_AUTH_FINISHED = nsresult::NS_SUCCESS_AUTH_FINISHED,




  NS_NET_STATUS_READING = nsresult::NS_NET_STATUS_READING,
  NS_NET_STATUS_WRITING = nsresult::NS_NET_STATUS_WRITING,


  NS_NET_STATUS_RESOLVING_HOST = nsresult::NS_NET_STATUS_RESOLVING_HOST,
  NS_NET_STATUS_RESOLVED_HOST = nsresult::NS_NET_STATUS_RESOLVED_HOST,
  NS_NET_STATUS_CONNECTING_TO = nsresult::NS_NET_STATUS_CONNECTING_TO,
  NS_NET_STATUS_CONNECTED_TO = nsresult::NS_NET_STATUS_CONNECTED_TO,
  NS_NET_STATUS_TLS_HANDSHAKE_STARTING = nsresult::NS_NET_STATUS_TLS_HANDSHAKE_STARTING,
  NS_NET_STATUS_TLS_HANDSHAKE_ENDED = nsresult::NS_NET_STATUS_TLS_HANDSHAKE_ENDED,
  NS_NET_STATUS_SENDING_TO = nsresult::NS_NET_STATUS_SENDING_TO,
  NS_NET_STATUS_WAITING_FOR = nsresult::NS_NET_STATUS_WAITING_FOR,
  NS_NET_STATUS_RECEIVING_FROM = nsresult::NS_NET_STATUS_RECEIVING_FROM,



  NS_ERROR_INTERCEPTION_FAILED = nsresult::NS_ERROR_INTERCEPTION_FAILED,



  NS_ERROR_HSTS_PRIMING_TIMEOUT = nsresult::NS_ERROR_HSTS_PRIMING_TIMEOUT,







  NS_ERROR_PLUGINS_PLUGINSNOTCHANGED = nsresult::NS_ERROR_PLUGINS_PLUGINSNOTCHANGED,
  NS_ERROR_PLUGIN_DISABLED = nsresult::NS_ERROR_PLUGIN_DISABLED,
  NS_ERROR_PLUGIN_BLOCKLISTED = nsresult::NS_ERROR_PLUGIN_BLOCKLISTED,
  NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED = nsresult::NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED,
  NS_ERROR_PLUGIN_CLICKTOPLAY = nsresult::NS_ERROR_PLUGIN_CLICKTOPLAY,
  NS_PLUGIN_INIT_PENDING = nsresult::NS_PLUGIN_INIT_PENDING,
  NS_TABLELAYOUT_CELL_NOT_FOUND = nsresult::NS_TABLELAYOUT_CELL_NOT_FOUND,

  NS_POSITION_BEFORE_TABLE = nsresult::NS_POSITION_BEFORE_TABLE,


  NS_STATE_PROPERTY_EXISTS = nsresult::NS_STATE_PROPERTY_EXISTS,

  NS_STATE_PROPERTY_NOT_THERE = nsresult::NS_STATE_PROPERTY_NOT_THERE,







  NS_ERROR_HTMLPARSER_CONTINUE = nsresult::NS_ERROR_HTMLPARSER_CONTINUE,

  NS_ERROR_HTMLPARSER_EOF = nsresult::NS_ERROR_HTMLPARSER_EOF,
  NS_ERROR_HTMLPARSER_UNKNOWN = nsresult::NS_ERROR_HTMLPARSER_UNKNOWN,
  NS_ERROR_HTMLPARSER_CANTPROPAGATE = nsresult::NS_ERROR_HTMLPARSER_CANTPROPAGATE,
  NS_ERROR_HTMLPARSER_CONTEXTMISMATCH = nsresult::NS_ERROR_HTMLPARSER_CONTEXTMISMATCH,
  NS_ERROR_HTMLPARSER_BADFILENAME = nsresult::NS_ERROR_HTMLPARSER_BADFILENAME,
  NS_ERROR_HTMLPARSER_BADURL = nsresult::NS_ERROR_HTMLPARSER_BADURL,
  NS_ERROR_HTMLPARSER_INVALIDPARSERCONTEXT = nsresult::NS_ERROR_HTMLPARSER_INVALIDPARSERCONTEXT,
  NS_ERROR_HTMLPARSER_INTERRUPTED = nsresult::NS_ERROR_HTMLPARSER_INTERRUPTED,
  NS_ERROR_HTMLPARSER_BLOCK = nsresult::NS_ERROR_HTMLPARSER_BLOCK,
  NS_ERROR_HTMLPARSER_BADTOKENIZER = nsresult::NS_ERROR_HTMLPARSER_BADTOKENIZER,
  NS_ERROR_HTMLPARSER_BADATTRIBUTE = nsresult::NS_ERROR_HTMLPARSER_BADATTRIBUTE,
  NS_ERROR_HTMLPARSER_UNRESOLVEDDTD = nsresult::NS_ERROR_HTMLPARSER_UNRESOLVEDDTD,
  NS_ERROR_HTMLPARSER_MISPLACEDTABLECONTENT = nsresult::NS_ERROR_HTMLPARSER_MISPLACEDTABLECONTENT,
  NS_ERROR_HTMLPARSER_BADDTD = nsresult::NS_ERROR_HTMLPARSER_BADDTD,
  NS_ERROR_HTMLPARSER_BADCONTEXT = nsresult::NS_ERROR_HTMLPARSER_BADCONTEXT,
  NS_ERROR_HTMLPARSER_STOPPARSING = nsresult::NS_ERROR_HTMLPARSER_STOPPARSING,
  NS_ERROR_HTMLPARSER_UNTERMINATEDSTRINGLITERAL = nsresult::NS_ERROR_HTMLPARSER_UNTERMINATEDSTRINGLITERAL,
  NS_ERROR_HTMLPARSER_HIERARCHYTOODEEP = nsresult::NS_ERROR_HTMLPARSER_HIERARCHYTOODEEP,
  NS_ERROR_HTMLPARSER_FAKE_ENDTAG = nsresult::NS_ERROR_HTMLPARSER_FAKE_ENDTAG,
  NS_ERROR_HTMLPARSER_INVALID_COMMENT = nsresult::NS_ERROR_HTMLPARSER_INVALID_COMMENT,

  NS_HTMLTOKENS_NOT_AN_ENTITY = nsresult::NS_HTMLTOKENS_NOT_AN_ENTITY,
  NS_HTMLPARSER_VALID_META_CHARSET = nsresult::NS_HTMLPARSER_VALID_META_CHARSET,
  NS_RDF_ASSERTION_ACCEPTED = nsresult::NS_RDF_ASSERTION_ACCEPTED,


  NS_RDF_CURSOR_EMPTY = nsresult::NS_RDF_CURSOR_EMPTY,


  NS_RDF_NO_VALUE = nsresult::NS_RDF_NO_VALUE,



  NS_RDF_ASSERTION_REJECTED = nsresult::NS_RDF_ASSERTION_REJECTED,

  NS_RDF_STOP_VISIT = nsresult::NS_RDF_STOP_VISIT,







  NS_ERROR_UCONV_NOCONV = nsresult::NS_ERROR_UCONV_NOCONV,
  NS_ERROR_UDEC_ILLEGALINPUT = nsresult::NS_ERROR_UDEC_ILLEGALINPUT,

  NS_SUCCESS_USING_FALLBACK_LOCALE = nsresult::NS_SUCCESS_USING_FALLBACK_LOCALE,
  NS_OK_UDEC_EXACTLENGTH = nsresult::NS_OK_UDEC_EXACTLENGTH,
  NS_OK_UDEC_MOREINPUT = nsresult::NS_OK_UDEC_MOREINPUT,
  NS_OK_UDEC_MOREOUTPUT = nsresult::NS_OK_UDEC_MOREOUTPUT,
  NS_OK_UDEC_NOBOMFOUND = nsresult::NS_OK_UDEC_NOBOMFOUND,
  NS_OK_UENC_EXACTLENGTH = nsresult::NS_OK_UENC_EXACTLENGTH,
  NS_OK_UENC_MOREOUTPUT = nsresult::NS_OK_UENC_MOREOUTPUT,
  NS_ERROR_UENC_NOMAPPING = nsresult::NS_ERROR_UENC_NOMAPPING,
  NS_OK_UENC_MOREINPUT = nsresult::NS_OK_UENC_MOREINPUT,


  NS_EXACT_LENGTH = nsresult::NS_EXACT_LENGTH,
  NS_PARTIAL_MORE_INPUT = nsresult::NS_PARTIAL_MORE_INPUT,
  NS_PARTIAL_MORE_OUTPUT = nsresult::NS_PARTIAL_MORE_OUTPUT,
  NS_ERROR_ILLEGAL_INPUT = nsresult::NS_ERROR_ILLEGAL_INPUT,
  NS_ERROR_FILE_UNRECOGNIZED_PATH = nsresult::NS_ERROR_FILE_UNRECOGNIZED_PATH,
  NS_ERROR_FILE_UNRESOLVABLE_SYMLINK = nsresult::NS_ERROR_FILE_UNRESOLVABLE_SYMLINK,
  NS_ERROR_FILE_EXECUTION_FAILED = nsresult::NS_ERROR_FILE_EXECUTION_FAILED,
  NS_ERROR_FILE_UNKNOWN_TYPE = nsresult::NS_ERROR_FILE_UNKNOWN_TYPE,
  NS_ERROR_FILE_DESTINATION_NOT_DIR = nsresult::NS_ERROR_FILE_DESTINATION_NOT_DIR,
  NS_ERROR_FILE_TARGET_DOES_NOT_EXIST = nsresult::NS_ERROR_FILE_TARGET_DOES_NOT_EXIST,
  NS_ERROR_FILE_COPY_OR_MOVE_FAILED = nsresult::NS_ERROR_FILE_COPY_OR_MOVE_FAILED,
  NS_ERROR_FILE_ALREADY_EXISTS = nsresult::NS_ERROR_FILE_ALREADY_EXISTS,
  NS_ERROR_FILE_INVALID_PATH = nsresult::NS_ERROR_FILE_INVALID_PATH,
  NS_ERROR_FILE_DISK_FULL = nsresult::NS_ERROR_FILE_DISK_FULL,
  NS_ERROR_FILE_CORRUPTED = nsresult::NS_ERROR_FILE_CORRUPTED,
  NS_ERROR_FILE_NOT_DIRECTORY = nsresult::NS_ERROR_FILE_NOT_DIRECTORY,
  NS_ERROR_FILE_IS_DIRECTORY = nsresult::NS_ERROR_FILE_IS_DIRECTORY,
  NS_ERROR_FILE_IS_LOCKED = nsresult::NS_ERROR_FILE_IS_LOCKED,
  NS_ERROR_FILE_TOO_BIG = nsresult::NS_ERROR_FILE_TOO_BIG,
  NS_ERROR_FILE_NO_DEVICE_SPACE = nsresult::NS_ERROR_FILE_NO_DEVICE_SPACE,
  NS_ERROR_FILE_NAME_TOO_LONG = nsresult::NS_ERROR_FILE_NAME_TOO_LONG,
  NS_ERROR_FILE_NOT_FOUND = nsresult::NS_ERROR_FILE_NOT_FOUND,
  NS_ERROR_FILE_READ_ONLY = nsresult::NS_ERROR_FILE_READ_ONLY,
  NS_ERROR_FILE_DIR_NOT_EMPTY = nsresult::NS_ERROR_FILE_DIR_NOT_EMPTY,
  NS_ERROR_FILE_ACCESS_DENIED = nsresult::NS_ERROR_FILE_ACCESS_DENIED,

  NS_SUCCESS_FILE_DIRECTORY_EMPTY = nsresult::NS_SUCCESS_FILE_DIRECTORY_EMPTY,

  NS_SUCCESS_AGGREGATE_RESULT = nsresult::NS_SUCCESS_AGGREGATE_RESULT,
  NS_ERROR_DOM_INDEX_SIZE_ERR = nsresult::NS_ERROR_DOM_INDEX_SIZE_ERR,
  NS_ERROR_DOM_HIERARCHY_REQUEST_ERR = nsresult::NS_ERROR_DOM_HIERARCHY_REQUEST_ERR,
  NS_ERROR_DOM_WRONG_DOCUMENT_ERR = nsresult::NS_ERROR_DOM_WRONG_DOCUMENT_ERR,
  NS_ERROR_DOM_INVALID_CHARACTER_ERR = nsresult::NS_ERROR_DOM_INVALID_CHARACTER_ERR,
  NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR = nsresult::NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR,
  NS_ERROR_DOM_NOT_FOUND_ERR = nsresult::NS_ERROR_DOM_NOT_FOUND_ERR,
  NS_ERROR_DOM_NOT_SUPPORTED_ERR = nsresult::NS_ERROR_DOM_NOT_SUPPORTED_ERR,
  NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR = nsresult::NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR,
  NS_ERROR_DOM_INVALID_STATE_ERR = nsresult::NS_ERROR_DOM_INVALID_STATE_ERR,
  NS_ERROR_DOM_SYNTAX_ERR = nsresult::NS_ERROR_DOM_SYNTAX_ERR,
  NS_ERROR_DOM_INVALID_MODIFICATION_ERR = nsresult::NS_ERROR_DOM_INVALID_MODIFICATION_ERR,
  NS_ERROR_DOM_NAMESPACE_ERR = nsresult::NS_ERROR_DOM_NAMESPACE_ERR,
  NS_ERROR_DOM_INVALID_ACCESS_ERR = nsresult::NS_ERROR_DOM_INVALID_ACCESS_ERR,
  NS_ERROR_DOM_TYPE_MISMATCH_ERR = nsresult::NS_ERROR_DOM_TYPE_MISMATCH_ERR,
  NS_ERROR_DOM_SECURITY_ERR = nsresult::NS_ERROR_DOM_SECURITY_ERR,
  NS_ERROR_DOM_NETWORK_ERR = nsresult::NS_ERROR_DOM_NETWORK_ERR,
  NS_ERROR_DOM_ABORT_ERR = nsresult::NS_ERROR_DOM_ABORT_ERR,
  NS_ERROR_DOM_URL_MISMATCH_ERR = nsresult::NS_ERROR_DOM_URL_MISMATCH_ERR,
  NS_ERROR_DOM_QUOTA_EXCEEDED_ERR = nsresult::NS_ERROR_DOM_QUOTA_EXCEEDED_ERR,
  NS_ERROR_DOM_TIMEOUT_ERR = nsresult::NS_ERROR_DOM_TIMEOUT_ERR,
  NS_ERROR_DOM_INVALID_NODE_TYPE_ERR = nsresult::NS_ERROR_DOM_INVALID_NODE_TYPE_ERR,
  NS_ERROR_DOM_DATA_CLONE_ERR = nsresult::NS_ERROR_DOM_DATA_CLONE_ERR,

  NS_ERROR_TYPE_ERR = nsresult::NS_ERROR_TYPE_ERR,
  NS_ERROR_RANGE_ERR = nsresult::NS_ERROR_RANGE_ERR,

  NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR = nsresult::NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR,
  NS_ERROR_DOM_INVALID_POINTER_ERR = nsresult::NS_ERROR_DOM_INVALID_POINTER_ERR,

  NS_ERROR_DOM_UNKNOWN_ERR = nsresult::NS_ERROR_DOM_UNKNOWN_ERR,
  NS_ERROR_DOM_DATA_ERR = nsresult::NS_ERROR_DOM_DATA_ERR,
  NS_ERROR_DOM_OPERATION_ERR = nsresult::NS_ERROR_DOM_OPERATION_ERR,

  NS_ERROR_DOM_NOT_ALLOWED_ERR = nsresult::NS_ERROR_DOM_NOT_ALLOWED_ERR,

  NS_ERROR_DOM_SECMAN_ERR = nsresult::NS_ERROR_DOM_SECMAN_ERR,
  NS_ERROR_DOM_WRONG_TYPE_ERR = nsresult::NS_ERROR_DOM_WRONG_TYPE_ERR,
  NS_ERROR_DOM_NOT_OBJECT_ERR = nsresult::NS_ERROR_DOM_NOT_OBJECT_ERR,
  NS_ERROR_DOM_NOT_XPC_OBJECT_ERR = nsresult::NS_ERROR_DOM_NOT_XPC_OBJECT_ERR,
  NS_ERROR_DOM_NOT_NUMBER_ERR = nsresult::NS_ERROR_DOM_NOT_NUMBER_ERR,
  NS_ERROR_DOM_NOT_BOOLEAN_ERR = nsresult::NS_ERROR_DOM_NOT_BOOLEAN_ERR,
  NS_ERROR_DOM_NOT_FUNCTION_ERR = nsresult::NS_ERROR_DOM_NOT_FUNCTION_ERR,
  NS_ERROR_DOM_TOO_FEW_PARAMETERS_ERR = nsresult::NS_ERROR_DOM_TOO_FEW_PARAMETERS_ERR,
  NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN = nsresult::NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN,
  NS_ERROR_DOM_PROP_ACCESS_DENIED = nsresult::NS_ERROR_DOM_PROP_ACCESS_DENIED,
  NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED = nsresult::NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED,
  NS_ERROR_DOM_BAD_URI = nsresult::NS_ERROR_DOM_BAD_URI,
  NS_ERROR_DOM_RETVAL_UNDEFINED = nsresult::NS_ERROR_DOM_RETVAL_UNDEFINED,
  NS_ERROR_DOM_QUOTA_REACHED = nsresult::NS_ERROR_DOM_QUOTA_REACHED,


  NS_ERROR_UNCATCHABLE_EXCEPTION = nsresult::NS_ERROR_UNCATCHABLE_EXCEPTION,

  NS_ERROR_DOM_MALFORMED_URI = nsresult::NS_ERROR_DOM_MALFORMED_URI,
  NS_ERROR_DOM_INVALID_HEADER_NAME = nsresult::NS_ERROR_DOM_INVALID_HEADER_NAME,

  NS_ERROR_DOM_INVALID_STATE_XHR_HAS_INVALID_CONTEXT = nsresult::NS_ERROR_DOM_INVALID_STATE_XHR_HAS_INVALID_CONTEXT,
  NS_ERROR_DOM_INVALID_STATE_XHR_MUST_BE_OPENED = nsresult::NS_ERROR_DOM_INVALID_STATE_XHR_MUST_BE_OPENED,
  NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_SENDING = nsresult::NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_SENDING,
  NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_LOADING_OR_DONE = nsresult::NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_LOADING_OR_DONE,
  NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSEXML = nsresult::NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSEXML,
  NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSETEXT = nsresult::NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSETEXT,
  NS_ERROR_DOM_INVALID_STATE_XHR_CHUNKED_RESPONSETYPES_UNSUPPORTED_FOR_SYNC = nsresult::NS_ERROR_DOM_INVALID_STATE_XHR_CHUNKED_RESPONSETYPES_UNSUPPORTED_FOR_SYNC,
  NS_ERROR_DOM_INVALID_ACCESS_XHR_TIMEOUT_AND_RESPONSETYPE_UNSUPPORTED_FOR_SYNC = nsresult::NS_ERROR_DOM_INVALID_ACCESS_XHR_TIMEOUT_AND_RESPONSETYPE_UNSUPPORTED_FOR_SYNC,





  NS_SUCCESS_DOM_NO_OPERATION = nsresult::NS_SUCCESS_DOM_NO_OPERATION,






  NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW = nsresult::NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW,






  NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW_UNCATCHABLE = nsresult::NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW_UNCATCHABLE,







  NS_IMAGELIB_SUCCESS_LOAD_FINISHED = nsresult::NS_IMAGELIB_SUCCESS_LOAD_FINISHED,
  NS_IMAGELIB_CHANGING_OWNER = nsresult::NS_IMAGELIB_CHANGING_OWNER,

  NS_IMAGELIB_ERROR_FAILURE = nsresult::NS_IMAGELIB_ERROR_FAILURE,
  NS_IMAGELIB_ERROR_NO_DECODER = nsresult::NS_IMAGELIB_ERROR_NO_DECODER,
  NS_IMAGELIB_ERROR_NOT_FINISHED = nsresult::NS_IMAGELIB_ERROR_NOT_FINISHED,
  NS_IMAGELIB_ERROR_NO_ENCODER = nsresult::NS_IMAGELIB_ERROR_NO_ENCODER,







  NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND = nsresult::NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND,
  NS_SUCCESS_EDITOR_FOUND_TARGET = nsresult::NS_SUCCESS_EDITOR_FOUND_TARGET,







  NS_ERROR_XPC_NOT_ENOUGH_ARGS = nsresult::NS_ERROR_XPC_NOT_ENOUGH_ARGS,
  NS_ERROR_XPC_NEED_OUT_OBJECT = nsresult::NS_ERROR_XPC_NEED_OUT_OBJECT,
  NS_ERROR_XPC_CANT_SET_OUT_VAL = nsresult::NS_ERROR_XPC_CANT_SET_OUT_VAL,
  NS_ERROR_XPC_NATIVE_RETURNED_FAILURE = nsresult::NS_ERROR_XPC_NATIVE_RETURNED_FAILURE,
  NS_ERROR_XPC_CANT_GET_INTERFACE_INFO = nsresult::NS_ERROR_XPC_CANT_GET_INTERFACE_INFO,
  NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO = nsresult::NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO,
  NS_ERROR_XPC_CANT_GET_METHOD_INFO = nsresult::NS_ERROR_XPC_CANT_GET_METHOD_INFO,
  NS_ERROR_XPC_UNEXPECTED = nsresult::NS_ERROR_XPC_UNEXPECTED,
  NS_ERROR_XPC_BAD_CONVERT_JS = nsresult::NS_ERROR_XPC_BAD_CONVERT_JS,
  NS_ERROR_XPC_BAD_CONVERT_NATIVE = nsresult::NS_ERROR_XPC_BAD_CONVERT_NATIVE,
  NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF = nsresult::NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF,
  NS_ERROR_XPC_BAD_OP_ON_WN_PROTO = nsresult::NS_ERROR_XPC_BAD_OP_ON_WN_PROTO,
  NS_ERROR_XPC_CANT_CONVERT_WN_TO_FUN = nsresult::NS_ERROR_XPC_CANT_CONVERT_WN_TO_FUN,
  NS_ERROR_XPC_CANT_DEFINE_PROP_ON_WN = nsresult::NS_ERROR_XPC_CANT_DEFINE_PROP_ON_WN,
  NS_ERROR_XPC_CANT_WATCH_WN_STATIC = nsresult::NS_ERROR_XPC_CANT_WATCH_WN_STATIC,
  NS_ERROR_XPC_CANT_EXPORT_WN_STATIC = nsresult::NS_ERROR_XPC_CANT_EXPORT_WN_STATIC,
  NS_ERROR_XPC_SCRIPTABLE_CALL_FAILED = nsresult::NS_ERROR_XPC_SCRIPTABLE_CALL_FAILED,
  NS_ERROR_XPC_SCRIPTABLE_CTOR_FAILED = nsresult::NS_ERROR_XPC_SCRIPTABLE_CTOR_FAILED,
  NS_ERROR_XPC_CANT_CALL_WO_SCRIPTABLE = nsresult::NS_ERROR_XPC_CANT_CALL_WO_SCRIPTABLE,
  NS_ERROR_XPC_CANT_CTOR_WO_SCRIPTABLE = nsresult::NS_ERROR_XPC_CANT_CTOR_WO_SCRIPTABLE,
  NS_ERROR_XPC_CI_RETURNED_FAILURE = nsresult::NS_ERROR_XPC_CI_RETURNED_FAILURE,
  NS_ERROR_XPC_GS_RETURNED_FAILURE = nsresult::NS_ERROR_XPC_GS_RETURNED_FAILURE,
  NS_ERROR_XPC_BAD_CID = nsresult::NS_ERROR_XPC_BAD_CID,
  NS_ERROR_XPC_BAD_IID = nsresult::NS_ERROR_XPC_BAD_IID,
  NS_ERROR_XPC_CANT_CREATE_WN = nsresult::NS_ERROR_XPC_CANT_CREATE_WN,
  NS_ERROR_XPC_JS_THREW_EXCEPTION = nsresult::NS_ERROR_XPC_JS_THREW_EXCEPTION,
  NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT = nsresult::NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT,
  NS_ERROR_XPC_JS_THREW_JS_OBJECT = nsresult::NS_ERROR_XPC_JS_THREW_JS_OBJECT,
  NS_ERROR_XPC_JS_THREW_NULL = nsresult::NS_ERROR_XPC_JS_THREW_NULL,
  NS_ERROR_XPC_JS_THREW_STRING = nsresult::NS_ERROR_XPC_JS_THREW_STRING,
  NS_ERROR_XPC_JS_THREW_NUMBER = nsresult::NS_ERROR_XPC_JS_THREW_NUMBER,
  NS_ERROR_XPC_JAVASCRIPT_ERROR = nsresult::NS_ERROR_XPC_JAVASCRIPT_ERROR,
  NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS = nsresult::NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS,
  NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY = nsresult::NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY,
  NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY = nsresult::NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY,
  NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY = nsresult::NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY,
  NS_ERROR_XPC_CANT_GET_ARRAY_INFO = nsresult::NS_ERROR_XPC_CANT_GET_ARRAY_INFO,
  NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING = nsresult::NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING,
  NS_ERROR_XPC_SECURITY_MANAGER_VETO = nsresult::NS_ERROR_XPC_SECURITY_MANAGER_VETO,
  NS_ERROR_XPC_INTERFACE_NOT_SCRIPTABLE = nsresult::NS_ERROR_XPC_INTERFACE_NOT_SCRIPTABLE,
  NS_ERROR_XPC_INTERFACE_NOT_FROM_NSISUPPORTS = nsresult::NS_ERROR_XPC_INTERFACE_NOT_FROM_NSISUPPORTS,
  NS_ERROR_XPC_CANT_GET_JSOBJECT_OF_DOM_OBJECT = nsresult::NS_ERROR_XPC_CANT_GET_JSOBJECT_OF_DOM_OBJECT,
  NS_ERROR_XPC_CANT_SET_READ_ONLY_CONSTANT = nsresult::NS_ERROR_XPC_CANT_SET_READ_ONLY_CONSTANT,
  NS_ERROR_XPC_CANT_SET_READ_ONLY_ATTRIBUTE = nsresult::NS_ERROR_XPC_CANT_SET_READ_ONLY_ATTRIBUTE,
  NS_ERROR_XPC_CANT_SET_READ_ONLY_METHOD = nsresult::NS_ERROR_XPC_CANT_SET_READ_ONLY_METHOD,
  NS_ERROR_XPC_CANT_ADD_PROP_TO_WRAPPED_NATIVE = nsresult::NS_ERROR_XPC_CANT_ADD_PROP_TO_WRAPPED_NATIVE,
  NS_ERROR_XPC_CALL_TO_SCRIPTABLE_FAILED = nsresult::NS_ERROR_XPC_CALL_TO_SCRIPTABLE_FAILED,
  NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED = nsresult::NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED,
  NS_ERROR_XPC_BAD_ID_STRING = nsresult::NS_ERROR_XPC_BAD_ID_STRING,
  NS_ERROR_XPC_BAD_INITIALIZER_NAME = nsresult::NS_ERROR_XPC_BAD_INITIALIZER_NAME,
  NS_ERROR_XPC_HAS_BEEN_SHUTDOWN = nsresult::NS_ERROR_XPC_HAS_BEEN_SHUTDOWN,
  NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN = nsresult::NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN,
  NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL = nsresult::NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL,
  NS_ERROR_XPC_CANT_PASS_CPOW_TO_NATIVE = nsresult::NS_ERROR_XPC_CANT_PASS_CPOW_TO_NATIVE,
  NS_ERROR_LAUNCHED_CHILD_PROCESS = nsresult::NS_ERROR_LAUNCHED_CHILD_PROCESS,
  NS_ERROR_CSP_FORM_ACTION_VIOLATION = nsresult::NS_ERROR_CSP_FORM_ACTION_VIOLATION,
  NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION = nsresult::NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION,


  NS_ERROR_SRI_CORRUPT = nsresult::NS_ERROR_SRI_CORRUPT,
  NS_ERROR_SRI_DISABLED = nsresult::NS_ERROR_SRI_DISABLED,
  NS_ERROR_SRI_NOT_ELIGIBLE = nsresult::NS_ERROR_SRI_NOT_ELIGIBLE,
  NS_ERROR_SRI_UNEXPECTED_HASH_TYPE = nsresult::NS_ERROR_SRI_UNEXPECTED_HASH_TYPE,
  NS_ERROR_SRI_IMPORT = nsresult::NS_ERROR_SRI_IMPORT,



  NS_ERROR_CMS_VERIFY_NOT_SIGNED = nsresult::NS_ERROR_CMS_VERIFY_NOT_SIGNED,
  NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO = nsresult::NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO,
  NS_ERROR_CMS_VERIFY_BAD_DIGEST = nsresult::NS_ERROR_CMS_VERIFY_BAD_DIGEST,
  NS_ERROR_CMS_VERIFY_NOCERT = nsresult::NS_ERROR_CMS_VERIFY_NOCERT,
  NS_ERROR_CMS_VERIFY_UNTRUSTED = nsresult::NS_ERROR_CMS_VERIFY_UNTRUSTED,
  NS_ERROR_CMS_VERIFY_ERROR_UNVERIFIED = nsresult::NS_ERROR_CMS_VERIFY_ERROR_UNVERIFIED,
  NS_ERROR_CMS_VERIFY_ERROR_PROCESSING = nsresult::NS_ERROR_CMS_VERIFY_ERROR_PROCESSING,
  NS_ERROR_CMS_VERIFY_BAD_SIGNATURE = nsresult::NS_ERROR_CMS_VERIFY_BAD_SIGNATURE,
  NS_ERROR_CMS_VERIFY_DIGEST_MISMATCH = nsresult::NS_ERROR_CMS_VERIFY_DIGEST_MISMATCH,
  NS_ERROR_CMS_VERIFY_UNKNOWN_ALGO = nsresult::NS_ERROR_CMS_VERIFY_UNKNOWN_ALGO,
  NS_ERROR_CMS_VERIFY_UNSUPPORTED_ALGO = nsresult::NS_ERROR_CMS_VERIFY_UNSUPPORTED_ALGO,
  NS_ERROR_CMS_VERIFY_MALFORMED_SIGNATURE = nsresult::NS_ERROR_CMS_VERIFY_MALFORMED_SIGNATURE,
  NS_ERROR_CMS_VERIFY_HEADER_MISMATCH = nsresult::NS_ERROR_CMS_VERIFY_HEADER_MISMATCH,
  NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED = nsresult::NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED,
  NS_ERROR_CMS_VERIFY_CERT_WITHOUT_ADDRESS = nsresult::NS_ERROR_CMS_VERIFY_CERT_WITHOUT_ADDRESS,
  NS_ERROR_CMS_ENCRYPT_NO_BULK_ALG = nsresult::NS_ERROR_CMS_ENCRYPT_NO_BULK_ALG,
  NS_ERROR_CMS_ENCRYPT_INCOMPLETE = nsresult::NS_ERROR_CMS_ENCRYPT_INCOMPLETE,
  NS_ERROR_DOM_INVALID_EXPRESSION_ERR = nsresult::NS_ERROR_DOM_INVALID_EXPRESSION_ERR,
  NS_ERROR_DOM_TYPE_ERR = nsresult::NS_ERROR_DOM_TYPE_ERR,







  NS_ERROR_WONT_HANDLE_CONTENT = nsresult::NS_ERROR_WONT_HANDLE_CONTENT,


  NS_ERROR_MALWARE_URI = nsresult::NS_ERROR_MALWARE_URI,
  NS_ERROR_PHISHING_URI = nsresult::NS_ERROR_PHISHING_URI,
  NS_ERROR_TRACKING_URI = nsresult::NS_ERROR_TRACKING_URI,
  NS_ERROR_UNWANTED_URI = nsresult::NS_ERROR_UNWANTED_URI,
  NS_ERROR_BLOCKED_URI = nsresult::NS_ERROR_BLOCKED_URI,


  NS_ERROR_SAVE_LINK_AS_TIMEOUT = nsresult::NS_ERROR_SAVE_LINK_AS_TIMEOUT,


  NS_ERROR_PARSED_DATA_CACHED = nsresult::NS_ERROR_PARSED_DATA_CACHED,



  NS_REFRESHURI_HEADER_FOUND = nsresult::NS_REFRESHURI_HEADER_FOUND,
  NS_ERROR_IMAGE_SRC_CHANGED = nsresult::NS_ERROR_IMAGE_SRC_CHANGED,
  NS_ERROR_IMAGE_BLOCKED = nsresult::NS_ERROR_IMAGE_BLOCKED,

  NS_ERROR_CONTENT_BLOCKED = nsresult::NS_ERROR_CONTENT_BLOCKED,
  NS_ERROR_CONTENT_BLOCKED_SHOW_ALT = nsresult::NS_ERROR_CONTENT_BLOCKED_SHOW_ALT,

  NS_PROPTABLE_PROP_NOT_THERE = nsresult::NS_PROPTABLE_PROP_NOT_THERE,

  NS_ERROR_XBL_BLOCKED = nsresult::NS_ERROR_XBL_BLOCKED,

  NS_ERROR_CONTENT_CRASHED = nsresult::NS_ERROR_CONTENT_CRASHED,


  NS_HTML_STYLE_PROPERTY_NOT_THERE = nsresult::NS_HTML_STYLE_PROPERTY_NOT_THERE,
  NS_CONTENT_BLOCKED = nsresult::NS_CONTENT_BLOCKED,
  NS_CONTENT_BLOCKED_SHOW_ALT = nsresult::NS_CONTENT_BLOCKED_SHOW_ALT,
  NS_PROPTABLE_PROP_OVERWRITTEN = nsresult::NS_PROPTABLE_PROP_OVERWRITTEN,

  NS_FINDBROADCASTER_NOT_FOUND = nsresult::NS_FINDBROADCASTER_NOT_FOUND,
  NS_FINDBROADCASTER_FOUND = nsresult::NS_FINDBROADCASTER_FOUND,
  NS_FINDBROADCASTER_AWAIT_OVERLAYS = nsresult::NS_FINDBROADCASTER_AWAIT_OVERLAYS,







  NS_ERROR_XPATH_INVALID_ARG = nsresult::NS_ERROR_XPATH_INVALID_ARG,

  NS_ERROR_XSLT_PARSE_FAILURE = nsresult::NS_ERROR_XSLT_PARSE_FAILURE,
  NS_ERROR_XPATH_PARSE_FAILURE = nsresult::NS_ERROR_XPATH_PARSE_FAILURE,
  NS_ERROR_XSLT_ALREADY_SET = nsresult::NS_ERROR_XSLT_ALREADY_SET,
  NS_ERROR_XSLT_EXECUTION_FAILURE = nsresult::NS_ERROR_XSLT_EXECUTION_FAILURE,
  NS_ERROR_XPATH_UNKNOWN_FUNCTION = nsresult::NS_ERROR_XPATH_UNKNOWN_FUNCTION,
  NS_ERROR_XSLT_BAD_RECURSION = nsresult::NS_ERROR_XSLT_BAD_RECURSION,
  NS_ERROR_XSLT_BAD_VALUE = nsresult::NS_ERROR_XSLT_BAD_VALUE,
  NS_ERROR_XSLT_NODESET_EXPECTED = nsresult::NS_ERROR_XSLT_NODESET_EXPECTED,
  NS_ERROR_XSLT_ABORTED = nsresult::NS_ERROR_XSLT_ABORTED,
  NS_ERROR_XSLT_NETWORK_ERROR = nsresult::NS_ERROR_XSLT_NETWORK_ERROR,
  NS_ERROR_XSLT_WRONG_MIME_TYPE = nsresult::NS_ERROR_XSLT_WRONG_MIME_TYPE,
  NS_ERROR_XSLT_LOAD_RECURSION = nsresult::NS_ERROR_XSLT_LOAD_RECURSION,
  NS_ERROR_XPATH_BAD_ARGUMENT_COUNT = nsresult::NS_ERROR_XPATH_BAD_ARGUMENT_COUNT,
  NS_ERROR_XPATH_BAD_EXTENSION_FUNCTION = nsresult::NS_ERROR_XPATH_BAD_EXTENSION_FUNCTION,
  NS_ERROR_XPATH_PAREN_EXPECTED = nsresult::NS_ERROR_XPATH_PAREN_EXPECTED,
  NS_ERROR_XPATH_INVALID_AXIS = nsresult::NS_ERROR_XPATH_INVALID_AXIS,
  NS_ERROR_XPATH_NO_NODE_TYPE_TEST = nsresult::NS_ERROR_XPATH_NO_NODE_TYPE_TEST,
  NS_ERROR_XPATH_BRACKET_EXPECTED = nsresult::NS_ERROR_XPATH_BRACKET_EXPECTED,
  NS_ERROR_XPATH_INVALID_VAR_NAME = nsresult::NS_ERROR_XPATH_INVALID_VAR_NAME,
  NS_ERROR_XPATH_UNEXPECTED_END = nsresult::NS_ERROR_XPATH_UNEXPECTED_END,
  NS_ERROR_XPATH_OPERATOR_EXPECTED = nsresult::NS_ERROR_XPATH_OPERATOR_EXPECTED,
  NS_ERROR_XPATH_UNCLOSED_LITERAL = nsresult::NS_ERROR_XPATH_UNCLOSED_LITERAL,
  NS_ERROR_XPATH_BAD_COLON = nsresult::NS_ERROR_XPATH_BAD_COLON,
  NS_ERROR_XPATH_BAD_BANG = nsresult::NS_ERROR_XPATH_BAD_BANG,
  NS_ERROR_XPATH_ILLEGAL_CHAR = nsresult::NS_ERROR_XPATH_ILLEGAL_CHAR,
  NS_ERROR_XPATH_BINARY_EXPECTED = nsresult::NS_ERROR_XPATH_BINARY_EXPECTED,
  NS_ERROR_XSLT_LOAD_BLOCKED_ERROR = nsresult::NS_ERROR_XSLT_LOAD_BLOCKED_ERROR,
  NS_ERROR_XPATH_INVALID_EXPRESSION_EVALUATED = nsresult::NS_ERROR_XPATH_INVALID_EXPRESSION_EVALUATED,
  NS_ERROR_XPATH_UNBALANCED_CURLY_BRACE = nsresult::NS_ERROR_XPATH_UNBALANCED_CURLY_BRACE,
  NS_ERROR_XSLT_BAD_NODE_NAME = nsresult::NS_ERROR_XSLT_BAD_NODE_NAME,
  NS_ERROR_XSLT_VAR_ALREADY_SET = nsresult::NS_ERROR_XSLT_VAR_ALREADY_SET,
  NS_ERROR_XSLT_CALL_TO_KEY_NOT_ALLOWED = nsresult::NS_ERROR_XSLT_CALL_TO_KEY_NOT_ALLOWED,

  NS_XSLT_GET_NEW_HANDLER = nsresult::NS_XSLT_GET_NEW_HANDLER,
  NS_ERROR_TRANSPORT_INIT = nsresult::NS_ERROR_TRANSPORT_INIT,

  NS_ERROR_DUPLICATE_HANDLE = nsresult::NS_ERROR_DUPLICATE_HANDLE,

  NS_ERROR_BRIDGE_OPEN_PARENT = nsresult::NS_ERROR_BRIDGE_OPEN_PARENT,

  NS_ERROR_BRIDGE_OPEN_CHILD = nsresult::NS_ERROR_BRIDGE_OPEN_CHILD,







  NS_ERROR_DOM_SVG_WRONG_TYPE_ERR = nsresult::NS_ERROR_DOM_SVG_WRONG_TYPE_ERR,

  NS_ERROR_DOM_SVG_MATRIX_NOT_INVERTABLE = nsresult::NS_ERROR_DOM_SVG_MATRIX_NOT_INVERTABLE,
  NS_ERROR_STORAGE_BUSY = nsresult::NS_ERROR_STORAGE_BUSY,
  NS_ERROR_STORAGE_IOERR = nsresult::NS_ERROR_STORAGE_IOERR,
  NS_ERROR_STORAGE_CONSTRAINT = nsresult::NS_ERROR_STORAGE_CONSTRAINT,







  NS_ERROR_DOM_FILE_NOT_FOUND_ERR = nsresult::NS_ERROR_DOM_FILE_NOT_FOUND_ERR,
  NS_ERROR_DOM_FILE_NOT_READABLE_ERR = nsresult::NS_ERROR_DOM_FILE_NOT_READABLE_ERR,
  NS_ERROR_DOM_FILE_ABORT_ERR = nsresult::NS_ERROR_DOM_FILE_ABORT_ERR,
  NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR = nsresult::NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR,
  NS_ERROR_DOM_INDEXEDDB_NOT_FOUND_ERR = nsresult::NS_ERROR_DOM_INDEXEDDB_NOT_FOUND_ERR,
  NS_ERROR_DOM_INDEXEDDB_CONSTRAINT_ERR = nsresult::NS_ERROR_DOM_INDEXEDDB_CONSTRAINT_ERR,
  NS_ERROR_DOM_INDEXEDDB_DATA_ERR = nsresult::NS_ERROR_DOM_INDEXEDDB_DATA_ERR,
  NS_ERROR_DOM_INDEXEDDB_NOT_ALLOWED_ERR = nsresult::NS_ERROR_DOM_INDEXEDDB_NOT_ALLOWED_ERR,
  NS_ERROR_DOM_INDEXEDDB_TRANSACTION_INACTIVE_ERR = nsresult::NS_ERROR_DOM_INDEXEDDB_TRANSACTION_INACTIVE_ERR,
  NS_ERROR_DOM_INDEXEDDB_ABORT_ERR = nsresult::NS_ERROR_DOM_INDEXEDDB_ABORT_ERR,
  NS_ERROR_DOM_INDEXEDDB_READ_ONLY_ERR = nsresult::NS_ERROR_DOM_INDEXEDDB_READ_ONLY_ERR,
  NS_ERROR_DOM_INDEXEDDB_TIMEOUT_ERR = nsresult::NS_ERROR_DOM_INDEXEDDB_TIMEOUT_ERR,
  NS_ERROR_DOM_INDEXEDDB_QUOTA_ERR = nsresult::NS_ERROR_DOM_INDEXEDDB_QUOTA_ERR,
  NS_ERROR_DOM_INDEXEDDB_VERSION_ERR = nsresult::NS_ERROR_DOM_INDEXEDDB_VERSION_ERR,
  NS_ERROR_DOM_INDEXEDDB_RECOVERABLE_ERR = nsresult::NS_ERROR_DOM_INDEXEDDB_RECOVERABLE_ERR,







  NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR = nsresult::NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR,
  NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR = nsresult::NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR,
  NS_ERROR_DOM_FILEHANDLE_INACTIVE_ERR = nsresult::NS_ERROR_DOM_FILEHANDLE_INACTIVE_ERR,
  NS_ERROR_DOM_FILEHANDLE_ABORT_ERR = nsresult::NS_ERROR_DOM_FILEHANDLE_ABORT_ERR,
  NS_ERROR_DOM_FILEHANDLE_READ_ONLY_ERR = nsresult::NS_ERROR_DOM_FILEHANDLE_READ_ONLY_ERR,
  NS_ERROR_DOM_FILEHANDLE_QUOTA_ERR = nsresult::NS_ERROR_DOM_FILEHANDLE_QUOTA_ERR,






  NS_ERROR_SIGNED_JAR_NOT_SIGNED = nsresult::NS_ERROR_SIGNED_JAR_NOT_SIGNED,
  NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY = nsresult::NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY,
  NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY = nsresult::NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY,
  NS_ERROR_SIGNED_JAR_ENTRY_MISSING = nsresult::NS_ERROR_SIGNED_JAR_ENTRY_MISSING,
  NS_ERROR_SIGNED_JAR_WRONG_SIGNATURE = nsresult::NS_ERROR_SIGNED_JAR_WRONG_SIGNATURE,
  NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE = nsresult::NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE,
  NS_ERROR_SIGNED_JAR_ENTRY_INVALID = nsresult::NS_ERROR_SIGNED_JAR_ENTRY_INVALID,
  NS_ERROR_SIGNED_JAR_MANIFEST_INVALID = nsresult::NS_ERROR_SIGNED_JAR_MANIFEST_INVALID,






  NS_ERROR_DOM_FILESYSTEM_INVALID_PATH_ERR = nsresult::NS_ERROR_DOM_FILESYSTEM_INVALID_PATH_ERR,
  NS_ERROR_DOM_FILESYSTEM_INVALID_MODIFICATION_ERR = nsresult::NS_ERROR_DOM_FILESYSTEM_INVALID_MODIFICATION_ERR,
  NS_ERROR_DOM_FILESYSTEM_NO_MODIFICATION_ALLOWED_ERR = nsresult::NS_ERROR_DOM_FILESYSTEM_NO_MODIFICATION_ALLOWED_ERR,
  NS_ERROR_DOM_FILESYSTEM_PATH_EXISTS_ERR = nsresult::NS_ERROR_DOM_FILESYSTEM_PATH_EXISTS_ERR,
  NS_ERROR_DOM_FILESYSTEM_TYPE_MISMATCH_ERR = nsresult::NS_ERROR_DOM_FILESYSTEM_TYPE_MISMATCH_ERR,
  NS_ERROR_DOM_FILESYSTEM_UNKNOWN_ERR = nsresult::NS_ERROR_DOM_FILESYSTEM_UNKNOWN_ERR,






  NS_ERROR_SIGNED_APP_MANIFEST_INVALID = nsresult::NS_ERROR_SIGNED_APP_MANIFEST_INVALID,






  NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR = nsresult::NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR,






  NS_ERROR_DOM_PUSH_INVALID_REGISTRATION_ERR = nsresult::NS_ERROR_DOM_PUSH_INVALID_REGISTRATION_ERR,
  NS_ERROR_DOM_PUSH_DENIED_ERR = nsresult::NS_ERROR_DOM_PUSH_DENIED_ERR,
  NS_ERROR_DOM_PUSH_ABORT_ERR = nsresult::NS_ERROR_DOM_PUSH_ABORT_ERR,
  NS_ERROR_DOM_PUSH_SERVICE_UNREACHABLE = nsresult::NS_ERROR_DOM_PUSH_SERVICE_UNREACHABLE,
  NS_ERROR_DOM_PUSH_INVALID_KEY_ERR = nsresult::NS_ERROR_DOM_PUSH_INVALID_KEY_ERR,
  NS_ERROR_DOM_PUSH_MISMATCHED_KEY_ERR = nsresult::NS_ERROR_DOM_PUSH_MISMATCHED_KEY_ERR,







  NS_ERROR_DOM_MEDIA_ABORT_ERR = nsresult::NS_ERROR_DOM_MEDIA_ABORT_ERR,
  NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR = nsresult::NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR,
  NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR = nsresult::NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR,


  NS_ERROR_DOM_MEDIA_DECODE_ERR = nsresult::NS_ERROR_DOM_MEDIA_DECODE_ERR,
  NS_ERROR_DOM_MEDIA_FATAL_ERR = nsresult::NS_ERROR_DOM_MEDIA_FATAL_ERR,
  NS_ERROR_DOM_MEDIA_METADATA_ERR = nsresult::NS_ERROR_DOM_MEDIA_METADATA_ERR,
  NS_ERROR_DOM_MEDIA_OVERFLOW_ERR = nsresult::NS_ERROR_DOM_MEDIA_OVERFLOW_ERR,
  NS_ERROR_DOM_MEDIA_END_OF_STREAM = nsresult::NS_ERROR_DOM_MEDIA_END_OF_STREAM,
  NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA = nsresult::NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA,
  NS_ERROR_DOM_MEDIA_CANCELED = nsresult::NS_ERROR_DOM_MEDIA_CANCELED,
  NS_ERROR_DOM_MEDIA_MEDIASINK_ERR = nsresult::NS_ERROR_DOM_MEDIA_MEDIASINK_ERR,
  NS_ERROR_DOM_MEDIA_DEMUXER_ERR = nsresult::NS_ERROR_DOM_MEDIA_DEMUXER_ERR,
  NS_ERROR_DOM_MEDIA_CDM_ERR = nsresult::NS_ERROR_DOM_MEDIA_CDM_ERR,
  NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER = nsresult::NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER,
  NS_ERROR_DOM_MEDIA_INITIALIZING_DECODER = nsresult::NS_ERROR_DOM_MEDIA_INITIALIZING_DECODER,


  NS_ERROR_DOM_MEDIA_CUBEB_INITIALIZATION_ERR = nsresult::NS_ERROR_DOM_MEDIA_CUBEB_INITIALIZATION_ERR,






  NS_ERROR_UC_UPDATE_UNKNOWN = nsresult::NS_ERROR_UC_UPDATE_UNKNOWN,
  NS_ERROR_UC_UPDATE_DUPLICATE_PREFIX = nsresult::NS_ERROR_UC_UPDATE_DUPLICATE_PREFIX,
  NS_ERROR_UC_UPDATE_INFINITE_LOOP = nsresult::NS_ERROR_UC_UPDATE_INFINITE_LOOP,
  NS_ERROR_UC_UPDATE_WRONG_REMOVAL_INDICES = nsresult::NS_ERROR_UC_UPDATE_WRONG_REMOVAL_INDICES,
  NS_ERROR_UC_UPDATE_CHECKSUM_MISMATCH = nsresult::NS_ERROR_UC_UPDATE_CHECKSUM_MISMATCH,
  NS_ERROR_UC_UPDATE_MISSING_CHECKSUM = nsresult::NS_ERROR_UC_UPDATE_MISSING_CHECKSUM,
  NS_ERROR_UC_UPDATE_SHUTDOWNING = nsresult::NS_ERROR_UC_UPDATE_SHUTDOWNING,
  NS_ERROR_UC_UPDATE_TABLE_NOT_FOUND = nsresult::NS_ERROR_UC_UPDATE_TABLE_NOT_FOUND,
  NS_ERROR_UC_UPDATE_BUILD_PREFIX_FAILURE = nsresult::NS_ERROR_UC_UPDATE_BUILD_PREFIX_FAILURE,
  NS_ERROR_UC_UPDATE_FAIL_TO_WRITE_DISK = nsresult::NS_ERROR_UC_UPDATE_FAIL_TO_WRITE_DISK,
  NS_ERROR_UC_UPDATE_PROTOCOL_PARSER_ERROR = nsresult::NS_ERROR_UC_UPDATE_PROTOCOL_PARSER_ERROR,







  NS_ERROR_INTERNAL_ERRORRESULT_JS_EXCEPTION = nsresult::NS_ERROR_INTERNAL_ERRORRESULT_JS_EXCEPTION,

  NS_ERROR_INTERNAL_ERRORRESULT_DOMEXCEPTION = nsresult::NS_ERROR_INTERNAL_ERRORRESULT_DOMEXCEPTION,

  NS_ERROR_INTERNAL_ERRORRESULT_EXCEPTION_ON_JSCONTEXT = nsresult::NS_ERROR_INTERNAL_ERRORRESULT_EXCEPTION_ON_JSCONTEXT,

  NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR = nsresult::NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR,

  NS_ERROR_INTERNAL_ERRORRESULT_RANGEERROR = nsresult::NS_ERROR_INTERNAL_ERRORRESULT_RANGEERROR,
  NS_ERROR_DOWNLOAD_COMPLETE = nsresult::NS_ERROR_DOWNLOAD_COMPLETE,



  NS_ERROR_DOWNLOAD_NOT_PARTIAL = nsresult::NS_ERROR_DOWNLOAD_NOT_PARTIAL,
  NS_ERROR_UNORM_MOREOUTPUT = nsresult::NS_ERROR_UNORM_MOREOUTPUT,

  NS_ERROR_DOCSHELL_REQUEST_REJECTED = nsresult::NS_ERROR_DOCSHELL_REQUEST_REJECTED,




  NS_ERROR_DOCUMENT_IS_PRINTMODE = nsresult::NS_ERROR_DOCUMENT_IS_PRINTMODE,

  NS_SUCCESS_DONT_FIXUP = nsresult::NS_SUCCESS_DONT_FIXUP,



  NS_SUCCESS_RESTART_APP = nsresult::NS_SUCCESS_RESTART_APP,
  NS_SUCCESS_RESTART_APP_NOT_SAME_PROFILE = nsresult::NS_SUCCESS_RESTART_APP_NOT_SAME_PROFILE,
  NS_SUCCESS_UNORM_NOTFOUND = nsresult::NS_SUCCESS_UNORM_NOTFOUND,




  NS_ERROR_NOT_IN_TREE = nsresult::NS_ERROR_NOT_IN_TREE,


  NS_OK_NO_NAME_CLAUSE_HANDLED = nsresult::NS_OK_NO_NAME_CLAUSE_HANDLED

;
inline uint32_t
NS_FAILED_impl(nsresult aErr)
{
  return static_cast<uint32_t>(aErr) & 0x80000000;
}




static_assert(((nsresult)0) < ((nsresult)-1),
              "nsresult must be an unsigned type");
static_assert(sizeof(nsresult) == sizeof(uint32_t),
              "nsresult must be 32 bits");
extern nsresult
NS_ErrorAccordingToNSPR();






inline constexpr uint16_t
NS_ERROR_GET_CODE(nsresult aErr)
{
  return uint32_t(aErr) & 0xffff;
}
inline constexpr uint16_t
NS_ERROR_GET_MODULE(nsresult aErr)
{
  return ((uint32_t(aErr) >> 16) - 0x45) & 0x1fff;
}
inline bool
NS_ERROR_GET_SEVERITY(nsresult aErr)
{
  return uint32_t(aErr) >> 31;
}

typedef MozRefCountType nsrefcnt;

class nsTraceRefcnt
{
public:
  static void Shutdown();

  static nsresult DumpStatistics();

  static void ResetStatistics();

  static void WalkTheStack(FILE* aStream);






  static void SetActivityIsLegal(bool aLegal);
};




extern "C" void
NS_MeanAndStdDev(double aNumberOfValues,
                 double aSumOfValues, double aSumOfSquaredValues,
                 double* aMeanResult, double* aStdDevResult);








extern "C" {
extern __attribute__((weak)) __attribute__((visibility("default"))) const char* gMozCrashReason;
}


static inline void
AnnotateMozCrashReason(const char* reason)
{
  gMozCrashReason = reason;
}








using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
extern "C" {


extern int __sigismember (const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);







typedef __sig_atomic_t sig_atomic_t;











typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
typedef __clock_t __sigchld_clock_t;



typedef struct
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __sigchld_clock_t si_utime;
     __sigchld_clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
     short int si_addr_lsb;
     struct
       {
  void *_lower;
  void *_upper;
       } si_addr_bnd;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;


 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;
      } _sifields;
  } siginfo_t ;
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};




enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};




enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};




enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     throw ();

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     throw ();







extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     throw ();
extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler)
     throw ();






extern int kill (__pid_t __pid, int __sig) throw ();






extern int killpg (__pid_t __pgrp, int __sig) throw ();




extern int raise (int __sig) throw ();




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     throw ();
extern int gsignal (int __sig) throw ();




extern void psignal (int __sig, const char *__s);


extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
extern int sigblock (int __mask) throw () __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) throw () __attribute__ ((__deprecated__));


extern int siggetmask (void) throw () __attribute__ ((__deprecated__));
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     throw () __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (const sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));





struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) throw ();






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) throw ();


extern int sigpending (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));






extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     throw ();
extern const char *const _sys_siglist[65];
extern const char *const sys_siglist[65];




struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t padding[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short padding[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t padding[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t reserved1[2];
  __uint64_t reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};


extern int sigreturn (struct sigcontext *__scp) throw ();











extern int siginterrupt (int __sig, int __interrupt) throw ();


struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;










__extension__ typedef long long int greg_t;





typedef greg_t gregset_t[23];



enum
{
  REG_R8 = 0,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

  REG_RDI,

  REG_RSI,

  REG_RBP,

  REG_RBX,

  REG_RDX,

  REG_RAX,

  REG_RCX,

  REG_RSP,

  REG_RIP,

  REG_EFL,

  REG_CSGSFS,

  REG_ERR,

  REG_TRAPNO,

  REG_OLDMASK,

  REG_CR2

};


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int padding[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t padding[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     throw () __attribute__ ((__deprecated__));



extern int sigaltstack (const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) throw ();







extern int sighold (int __sig) throw ();


extern int sigrelse (int __sig) throw ();


extern int sigignore (int __sig) throw ();


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) throw ();







extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)throw ();


extern int pthread_kill (pthread_t __threadid, int __signo) throw ();



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) throw ();






extern int __libc_current_sigrtmin (void) throw ();

extern int __libc_current_sigrtmax (void) throw ();



}
extern "C" {
__attribute__ ((__unused__)) static __attribute__ ((cold)) __attribute__((noinline)) void
MOZ_ReportAssertionFailure(const char* aStr, const char* aFilename, int aLine)

{





  fprintf(stderr, "Assertion failure: %s, at %s:%d\n", aStr, aFilename, aLine);

  nsTraceRefcnt::WalkTheStack(stderr);

  fflush(stderr);

}

__attribute__ ((__unused__)) static __attribute__ ((cold)) __attribute__((noinline)) void
MOZ_ReportCrash(const char* aStr, const char* aFilename, int aLine)

{




  fprintf(stderr, "Hit MOZ_CRASH(%s) at %s:%d\n", aStr, aFilename, aLine);

  nsTraceRefcnt::WalkTheStack(stderr);

  fflush(stderr);

}
__attribute__((weak)) __attribute__((visibility("default"))) __attribute__ ((cold)) __attribute__((noreturn)) __attribute__((noinline)) void
MOZ_CrashOOL(int aLine, const char* aReason);







static const size_t sPrintfMaxArgs = 4;
static const size_t sPrintfCrashReasonSize = 1024;


__attribute__((weak)) __attribute__((visibility("default"))) __attribute__ ((cold)) __attribute__((noreturn)) __attribute__((noinline)) __attribute__ ((format (printf, 2, 3))) void
MOZ_CrashPrintf(int aLine, const char* aFormat, ...);
}
namespace mozilla {
namespace detail {

template<typename T>
struct AssertionConditionType
{
  typedef typename RemoveReference<T>::Type ValueT;
  static_assert(!IsArray<ValueT>::value,
                "Expected boolean assertion condition, got an array or a "
                "string!");
  static_assert(!IsFunction<ValueT>::value,
                "Expected boolean assertion condition, got a function! Did "
                "you intend to call that function?");
  static_assert(!IsFloatingPoint<ValueT>::value,
                "It's often a bad idea to assert that a floating-point number "
                "is nonzero, because such assertions tend to intermittently "
                "fail. Shouldn't your code gracefully handle this case instead "
                "of asserting? Anyway, if you really want to do that, write an "
                "explicit boolean condition, like !!x or x!=0.");

  static const bool isValid = true;
};

}
}

namespace mozilla {
template<typename T>
inline typename RemoveReference<T>::Type&&
Move(T&& aX)
{
  return static_cast<typename RemoveReference<T>::Type&&>(aX);
}





template<typename T>
inline T&&
Forward(typename RemoveReference<T>::Type& aX)
{
  return static_cast<T&&>(aX);
}

template<typename T>
inline T&&
Forward(typename RemoveReference<T>::Type&& aX)
{
  static_assert(!IsLvalueReference<T>::value,
                "misuse of Forward detected!  try the other overload");
  return static_cast<T&&>(aX);
}


template<typename T>
inline void
Swap(T& aX, T& aY)
{
  T tmp(Move(aX));
  aX = Move(aY);
  aY = Move(tmp);
}

}

namespace mozilla {

struct unused_t;

}
template<class T>
struct already_AddRefed
{
  already_AddRefed() : mRawPtr(nullptr) {}



  typedef void (already_AddRefed::* MatchNullptr)(double, float);
               already_AddRefed(MatchNullptr aRawPtr) : mRawPtr(nullptr) {}

  explicit already_AddRefed(T* aRawPtr) : mRawPtr(aRawPtr) {}


  already_AddRefed(const already_AddRefed<T>& aOther) = delete;
  already_AddRefed<T>& operator=(const already_AddRefed<T>& aOther) = delete;

  already_AddRefed(already_AddRefed<T>&& aOther) : mRawPtr(aOther.take()) {}

  already_AddRefed<T>& operator=(already_AddRefed<T>&& aOther)
  {
    mRawPtr = aOther.take();
    return *this;
  }
  template <typename U>
               already_AddRefed(already_AddRefed<U>&& aOther) : mRawPtr(aOther.take()) {}

  ~already_AddRefed() { do { } while (0); }





  friend void operator<<(const mozilla::unused_t& aUnused,
                         const already_AddRefed<T>& aRhs)
  {
    auto mutableAlreadyAddRefed = const_cast<already_AddRefed<T>*>(&aRhs);
    aUnused << mutableAlreadyAddRefed->take();
  }

  __attribute__ ((warn_unused_result)) T* take()
  {
    T* rawPtr = mRawPtr;
    mRawPtr = nullptr;
    return rawPtr;
  }
  template<class U>
  already_AddRefed<U> downcast()
  {
    U* tmp = static_cast<U*>(mRawPtr);
    mRawPtr = nullptr;
    return already_AddRefed<U>(tmp);
  }

private:
  T* mRawPtr;
};







class nsCOMPtr_helper;

namespace mozilla {
template<class T> class OwningNonNull;
template<class T> class StaticRefPtr;
template<class U>
struct RefPtrTraits
{
  static void AddRef(U* aPtr) {
    aPtr->AddRef();
  }
  static void Release(U* aPtr) {
    aPtr->Release();
  }
};

}

template <class T>
class RefPtr
{
private:
  void
  assign_with_AddRef(T* aRawPtr)
  {
    if (aRawPtr) {
      ConstRemovingRefPtrTraits<T>::AddRef(aRawPtr);
    }
    assign_assuming_AddRef(aRawPtr);
  }

  void
  assign_assuming_AddRef(T* aNewPtr)
  {
    T* oldPtr = mRawPtr;
    mRawPtr = aNewPtr;
    if (oldPtr) {
      ConstRemovingRefPtrTraits<T>::Release(oldPtr);
    }
  }

private:
  T* mRawPtr;

public:
  typedef T element_type;

  ~RefPtr()
  {
    if (mRawPtr) {
      ConstRemovingRefPtrTraits<T>::Release(mRawPtr);
    }
  }



  RefPtr()
    : mRawPtr(nullptr)

  {
  }

  RefPtr(const RefPtr<T>& aSmartPtr)
    : mRawPtr(aSmartPtr.mRawPtr)

  {
    if (mRawPtr) {
      ConstRemovingRefPtrTraits<T>::AddRef(mRawPtr);
    }
  }

  RefPtr(RefPtr<T>&& aRefPtr)
    : mRawPtr(aRefPtr.mRawPtr)
  {
    aRefPtr.mRawPtr = nullptr;
  }



               RefPtr(T* aRawPtr)
    : mRawPtr(aRawPtr)
  {
    if (mRawPtr) {
      ConstRemovingRefPtrTraits<T>::AddRef(mRawPtr);
    }
  }

               RefPtr(decltype(nullptr))
    : mRawPtr(nullptr)
  {
  }

  template <typename I>
               RefPtr(already_AddRefed<I>& aSmartPtr)
    : mRawPtr(aSmartPtr.take())

  {
  }

  template <typename I>
               RefPtr(already_AddRefed<I>&& aSmartPtr)
    : mRawPtr(aSmartPtr.take())

  {
  }

  template <typename I>
               RefPtr(const RefPtr<I>& aSmartPtr)
    : mRawPtr(aSmartPtr.get())

  {
    if (mRawPtr) {
      ConstRemovingRefPtrTraits<T>::AddRef(mRawPtr);
    }
  }

  template <typename I>
               RefPtr(RefPtr<I>&& aSmartPtr)
    : mRawPtr(aSmartPtr.forget().take())

  {
  }

               RefPtr(const nsCOMPtr_helper& aHelper);


  template<class U>
               RefPtr(const mozilla::OwningNonNull<U>& aOther);


  template<class U>
               RefPtr(const mozilla::StaticRefPtr<U>& aOther);



  RefPtr<T>&
  operator=(decltype(nullptr))
  {
    assign_assuming_AddRef(nullptr);
    return *this;
  }

  RefPtr<T>&
  operator=(const RefPtr<T>& aRhs)

  {
    assign_with_AddRef(aRhs.mRawPtr);
    return *this;
  }

  template <typename I>
  RefPtr<T>&
  operator=(const RefPtr<I>& aRhs)

  {
    assign_with_AddRef(aRhs.get());
    return *this;
  }

  RefPtr<T>&
  operator=(T* aRhs)

  {
    assign_with_AddRef(aRhs);
    return *this;
  }

  template <typename I>
  RefPtr<T>&
  operator=(already_AddRefed<I>& aRhs)

  {
    assign_assuming_AddRef(aRhs.take());
    return *this;
  }

  template <typename I>
  RefPtr<T>&
  operator=(already_AddRefed<I> && aRhs)

  {
    assign_assuming_AddRef(aRhs.take());
    return *this;
  }

  RefPtr<T>& operator=(const nsCOMPtr_helper& aHelper);

  RefPtr<T>&
  operator=(RefPtr<T> && aRefPtr)
  {
    assign_assuming_AddRef(aRefPtr.mRawPtr);
    aRefPtr.mRawPtr = nullptr;
    return *this;
  }


  template<class U>
  RefPtr<T>&
  operator=(const mozilla::OwningNonNull<U>& aOther);


  template<class U>
  RefPtr<T>&
  operator=(const mozilla::StaticRefPtr<U>& aOther);



  void
  swap(RefPtr<T>& aRhs)

  {
    T* temp = aRhs.mRawPtr;
    aRhs.mRawPtr = mRawPtr;
    mRawPtr = temp;
  }

  void
  swap(T*& aRhs)

  {
    T* temp = aRhs;
    aRhs = mRawPtr;
    mRawPtr = temp;
  }

  already_AddRefed<T>

  forget()


  {
    T* temp = nullptr;
    swap(temp);
    return already_AddRefed<T>(temp);
  }

  template <typename I>
  void
  forget(I** aRhs)




  {
    do { } while (0);
    *aRhs = mRawPtr;
    mRawPtr = nullptr;
  }

  T*
  get() const




  {
    return const_cast<T*>(mRawPtr);
  }

  operator T*() const &
  {
    return get();
  }




  operator T*() const && = delete;




  explicit operator bool() const { return !!mRawPtr; }
  bool operator!() const { return !mRawPtr; }

  T*
  operator->() const
  {
    do { } while (0);

    return get();
  }

  template <typename R, typename... Args>
  class Proxy
  {
    typedef R (T::*member_function)(Args...);
    T* mRawPtr;
    member_function mFunction;
  public:
    Proxy(T* aRawPtr, member_function aFunction)
      : mRawPtr(aRawPtr),
        mFunction(aFunction)
    {
    }
    template<typename... ActualArgs>
    R operator()(ActualArgs&&... aArgs)
    {
      return ((*mRawPtr).*mFunction)(mozilla::Forward<ActualArgs>(aArgs)...);
    }
  };

  template <typename R, typename... Args>
  Proxy<R, Args...> operator->*(R (T::*aFptr)(Args...)) const
  {
    do { } while (0);

    return Proxy<R, Args...>(get(), aFptr);
  }

  RefPtr<T>*
  get_address()


  {
    return this;
  }

  const RefPtr<T>*
  get_address() const


  {
    return this;
  }

public:
  T&
  operator*() const
  {
    do { } while (0);

    return *get();
  }

  T**
  StartAssignment()
  {
    assign_assuming_AddRef(nullptr);
    return reinterpret_cast<T**>(&mRawPtr);
  }
private:
  template<class U>
  struct ConstRemovingRefPtrTraits
  {
    static void AddRef(U* aPtr) {
      mozilla::RefPtrTraits<U>::AddRef(aPtr);
    }
    static void Release(U* aPtr) {
      mozilla::RefPtrTraits<U>::Release(aPtr);
    }
  };
  template<class U>
  struct ConstRemovingRefPtrTraits<const U>
  {
    static void AddRef(const U* aPtr) {
      mozilla::RefPtrTraits<U>::AddRef(const_cast<U*>(aPtr));
    }
    static void Release(const U* aPtr) {
      mozilla::RefPtrTraits<U>::Release(const_cast<U*>(aPtr));
    }
  };
};

class nsCycleCollectionTraversalCallback;
template <typename T>
void
CycleCollectionNoteChild(nsCycleCollectionTraversalCallback& aCallback,
                         T* aChild, const char* aName, uint32_t aFlags);

template <typename T>
inline void
ImplCycleCollectionUnlink(RefPtr<T>& aField)
{
  aField = nullptr;
}

template <typename T>
inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            RefPtr<T>& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  CycleCollectionNoteChild(aCallback, aField.get(), aName, aFlags);
}

template <class T>
inline RefPtr<T>*
address_of(RefPtr<T>& aPtr)
{
  return aPtr.get_address();
}

template <class T>
inline const RefPtr<T>*
address_of(const RefPtr<T>& aPtr)
{
  return aPtr.get_address();
}

template <class T>
class RefPtrGetterAddRefs
{
public:
  explicit
  RefPtrGetterAddRefs(RefPtr<T>& aSmartPtr)
    : mTargetSmartPtr(aSmartPtr)
  {

  }

  operator void**()
  {
    return reinterpret_cast<void**>(mTargetSmartPtr.StartAssignment());
  }

  operator T**()
  {
    return mTargetSmartPtr.StartAssignment();
  }

  T*&
  operator*()
  {
    return *(mTargetSmartPtr.StartAssignment());
  }

private:
  RefPtr<T>& mTargetSmartPtr;
};

template <class T>
inline RefPtrGetterAddRefs<T>
getter_AddRefs(RefPtr<T>& aSmartPtr)




{
  return RefPtrGetterAddRefs<T>(aSmartPtr);
}




template <class T, class U>
inline bool
operator==(const RefPtr<T>& aLhs, const RefPtr<U>& aRhs)
{
  return static_cast<const T*>(aLhs.get()) == static_cast<const U*>(aRhs.get());
}


template <class T, class U>
inline bool
operator!=(const RefPtr<T>& aLhs, const RefPtr<U>& aRhs)
{
  return static_cast<const T*>(aLhs.get()) != static_cast<const U*>(aRhs.get());
}




template <class T, class U>
inline bool
operator==(const RefPtr<T>& aLhs, const U* aRhs)
{
  return static_cast<const T*>(aLhs.get()) == static_cast<const U*>(aRhs);
}

template <class T, class U>
inline bool
operator==(const U* aLhs, const RefPtr<T>& aRhs)
{
  return static_cast<const U*>(aLhs) == static_cast<const T*>(aRhs.get());
}

template <class T, class U>
inline bool
operator!=(const RefPtr<T>& aLhs, const U* aRhs)
{
  return static_cast<const T*>(aLhs.get()) != static_cast<const U*>(aRhs);
}

template <class T, class U>
inline bool
operator!=(const U* aLhs, const RefPtr<T>& aRhs)
{
  return static_cast<const U*>(aLhs) != static_cast<const T*>(aRhs.get());
}

template <class T, class U>
inline bool
operator==(const RefPtr<T>& aLhs, U* aRhs)
{
  return static_cast<const T*>(aLhs.get()) == const_cast<const U*>(aRhs);
}

template <class T, class U>
inline bool
operator==(U* aLhs, const RefPtr<T>& aRhs)
{
  return const_cast<const U*>(aLhs) == static_cast<const T*>(aRhs.get());
}

template <class T, class U>
inline bool
operator!=(const RefPtr<T>& aLhs, U* aRhs)
{
  return static_cast<const T*>(aLhs.get()) != const_cast<const U*>(aRhs);
}

template <class T, class U>
inline bool
operator!=(U* aLhs, const RefPtr<T>& aRhs)
{
  return const_cast<const U*>(aLhs) != static_cast<const T*>(aRhs.get());
}



template <class T>
inline bool
operator==(const RefPtr<T>& aLhs, decltype(nullptr))
{
  return aLhs.get() == nullptr;
}

template <class T>
inline bool
operator==(decltype(nullptr), const RefPtr<T>& aRhs)
{
  return nullptr == aRhs.get();
}

template <class T>
inline bool
operator!=(const RefPtr<T>& aLhs, decltype(nullptr))
{
  return aLhs.get() != nullptr;
}

template <class T>
inline bool
operator!=(decltype(nullptr), const RefPtr<T>& aRhs)
{
  return nullptr != aRhs.get();
}



template <class T>
inline already_AddRefed<T>
do_AddRef(T* aObj)
{
  RefPtr<T> ref(aObj);
  return ref.forget();
}

template <class T>
inline already_AddRefed<T>
do_AddRef(const RefPtr<T>& aObj)
{
  RefPtr<T> ref(aObj);
  return ref.forget();
}

namespace mozilla {
template<typename T, typename... Args>
already_AddRefed<T>
MakeAndAddRef(Args&&... aArgs)
{
  RefPtr<T> p(new T(Forward<Args>(aArgs)...));
  return p.forget();
}

}

namespace mozilla {

namespace detail {

enum StorageType { AsBase, AsMember };
template<typename A, typename B,
         detail::StorageType =
           IsEmpty<A>::value ? detail::AsBase : detail::AsMember,
         detail::StorageType =
           IsEmpty<B>::value && !IsBaseOf<A, B>::value && !IsBaseOf<B, A>::value
           ? detail::AsBase
           : detail::AsMember>
struct PairHelper;

template<typename A, typename B>
struct PairHelper<A, B, AsMember, AsMember>
{
protected:
  template<typename AArg, typename BArg>
  PairHelper(AArg&& aA, BArg&& aB)
    : mFirstA(Forward<AArg>(aA)),
      mSecondB(Forward<BArg>(aB))
  {}

  A& first() { return mFirstA; }
  const A& first() const { return mFirstA; }
  B& second() { return mSecondB; }
  const B& second() const { return mSecondB; }

  void swap(PairHelper& aOther)
  {
    Swap(mFirstA, aOther.mFirstA);
    Swap(mSecondB, aOther.mSecondB);
  }

private:
  A mFirstA;
  B mSecondB;
};

template<typename A, typename B>
struct PairHelper<A, B, AsMember, AsBase> : private B
{
protected:
  template<typename AArg, typename BArg>
  PairHelper(AArg&& aA, BArg&& aB)
    : B(Forward<BArg>(aB)),
      mFirstA(Forward<AArg>(aA))
  {}

  A& first() { return mFirstA; }
  const A& first() const { return mFirstA; }
  B& second() { return *this; }
  const B& second() const { return *this; }

  void swap(PairHelper& aOther)
  {
    Swap(mFirstA, aOther.mFirstA);
    Swap(static_cast<B&>(*this), static_cast<B&>(aOther));
  }

private:
  A mFirstA;
};

template<typename A, typename B>
struct PairHelper<A, B, AsBase, AsMember> : private A
{
protected:
  template<typename AArg, typename BArg>
  PairHelper(AArg&& aA, BArg&& aB)
    : A(Forward<AArg>(aA)),
      mSecondB(Forward<BArg>(aB))
  {}

  A& first() { return *this; }
  const A& first() const { return *this; }
  B& second() { return mSecondB; }
  const B& second() const { return mSecondB; }

  void swap(PairHelper& aOther)
  {
    Swap(static_cast<A&>(*this), static_cast<A&>(aOther));
    Swap(mSecondB, aOther.mSecondB);
  }

private:
  B mSecondB;
};

template<typename A, typename B>
struct PairHelper<A, B, AsBase, AsBase> : private A, private B
{
protected:
  template<typename AArg, typename BArg>
  PairHelper(AArg&& aA, BArg&& aB)
    : A(Forward<AArg>(aA)),
      B(Forward<BArg>(aB))
  {}

  A& first() { return static_cast<A&>(*this); }
  const A& first() const { return static_cast<A&>(*this); }
  B& second() { return static_cast<B&>(*this); }
  const B& second() const { return static_cast<B&>(*this); }

  void swap(PairHelper& aOther)
  {
    Swap(static_cast<A&>(*this), static_cast<A&>(aOther));
    Swap(static_cast<B&>(*this), static_cast<B&>(aOther));
  }
};

}
template<typename A, typename B>
struct Pair
  : private detail::PairHelper<A, B>
{
  typedef typename detail::PairHelper<A, B> Base;

public:
  template<typename AArg, typename BArg>
  Pair(AArg&& aA, BArg&& aB)
    : Base(Forward<AArg>(aA), Forward<BArg>(aB))
  {}

  Pair(Pair&& aOther)
    : Base(Move(aOther.first()), Move(aOther.second()))
  { }

  Pair(const Pair& aOther) = default;

  Pair& operator=(Pair&& aOther)
  {
    do { } while (0);

    first() = Move(aOther.first());
    second() = Move(aOther.second());

    return *this;
  }

  Pair& operator=(const Pair& aOther) = default;


  using Base::first;

  using Base::second;


  void swap(Pair& aOther) { Base::swap(aOther); }
};

template<typename A, class B>
void
Swap(Pair<A, B>& aX, Pair<A, B>& aY)
{
  aX.swap(aY);
}
template<typename A, typename B>
Pair<typename RemoveCV<typename RemoveReference<A>::Type>::Type,
     typename RemoveCV<typename RemoveReference<B>::Type>::Type>
MakePair(A&& aA, B&& aB)
{
  return
    Pair<typename RemoveCV<typename RemoveReference<A>::Type>::Type,
         typename RemoveCV<typename RemoveReference<B>::Type>::Type>(
             Forward<A>(aA),
             Forward<B>(aB));
}

}


namespace mozilla {

template<typename T> class DefaultDelete;
template<typename T, class D = DefaultDelete<T>> class UniquePtr;

}

namespace mozilla {

namespace detail {

struct HasPointerTypeHelper
{
  template <class U> static double Test(...);
  template <class U> static char Test(typename U::pointer* = 0);
};

template <class T>
class HasPointerType : public IntegralConstant<bool, sizeof(HasPointerTypeHelper::Test<T>(0)) == 1>
{
};

template <class T, class D, bool = HasPointerType<D>::value>
struct PointerTypeImpl
{
  typedef typename D::pointer Type;
};

template <class T, class D>
struct PointerTypeImpl<T, D, false>
{
  typedef T* Type;
};

template <class T, class D>
struct PointerType
{
  typedef typename PointerTypeImpl<T, typename RemoveReference<D>::Type>::Type Type;
};

}
template<typename T, class D>
class UniquePtr
{
public:
  typedef T ElementType;
  typedef D DeleterType;
  typedef typename detail::PointerType<T, DeleterType>::Type Pointer;

private:
  Pair<Pointer, DeleterType> mTuple;

  Pointer& ptr() { return mTuple.first(); }
  const Pointer& ptr() const { return mTuple.first(); }

  DeleterType& del() { return mTuple.second(); }
  const DeleterType& del() const { return mTuple.second(); }

public:



  constexpr UniquePtr()
    : mTuple(static_cast<Pointer>(nullptr), DeleterType())
  {
    static_assert(!IsPointer<D>::value, "must provide a deleter instance");
    static_assert(!IsReference<D>::value, "must provide a deleter instance");
  }




  explicit UniquePtr(Pointer aPtr)
    : mTuple(aPtr, DeleterType())
  {
    static_assert(!IsPointer<D>::value, "must provide a deleter instance");
    static_assert(!IsReference<D>::value, "must provide a deleter instance");
  }

  UniquePtr(Pointer aPtr,
            typename Conditional<IsReference<D>::value,
                                 D,
                                 const D&>::Type aD1)
    : mTuple(aPtr, aD1)
  {}
  UniquePtr(Pointer aPtr,
            typename RemoveReference<D>::Type&& aD2)
    : mTuple(aPtr, Move(aD2))
  {
    static_assert(!IsReference<D>::value,
                  "rvalue deleter can't be stored by reference");
  }

  UniquePtr(UniquePtr&& aOther)
    : mTuple(aOther.release(), Forward<DeleterType>(aOther.get_deleter()))
  {}


  UniquePtr(decltype(nullptr))
    : mTuple(nullptr, DeleterType())
  {
    static_assert(!IsPointer<D>::value, "must provide a deleter instance");
    static_assert(!IsReference<D>::value, "must provide a deleter instance");
  }

  template<typename U, class E>

  UniquePtr(UniquePtr<U, E>&& aOther,
            typename EnableIf<IsConvertible<typename UniquePtr<U, E>::Pointer,
                                            Pointer>::value &&
                              !IsArray<U>::value &&
                              (IsReference<D>::value
                               ? IsSame<D, E>::value
                               : IsConvertible<E, D>::value),
                              int>::Type aDummy = 0)
    : mTuple(aOther.release(), Forward<E>(aOther.get_deleter()))
  {
  }

  ~UniquePtr() { reset(nullptr); }

  UniquePtr& operator=(UniquePtr&& aOther)
  {
    reset(aOther.release());
    get_deleter() = Forward<DeleterType>(aOther.get_deleter());
    return *this;
  }

  template<typename U, typename E>
  UniquePtr& operator=(UniquePtr<U, E>&& aOther)
  {
    static_assert(IsConvertible<typename UniquePtr<U, E>::Pointer,
                                Pointer>::value,
                  "incompatible UniquePtr pointees");
    static_assert(!IsArray<U>::value,
                  "can't assign from UniquePtr holding an array");

    reset(aOther.release());
    get_deleter() = Forward<E>(aOther.get_deleter());
    return *this;
  }

  UniquePtr& operator=(decltype(nullptr))
  {
    reset(nullptr);
    return *this;
  }

  T& operator*() const { return *get(); }
  Pointer operator->() const
  {
    do { } while (0);
    return get();
  }

  explicit operator bool() const { return get() != nullptr; }

  Pointer get() const { return ptr(); }

  DeleterType& get_deleter() { return del(); }
  const DeleterType& get_deleter() const { return del(); }

  __attribute__ ((warn_unused_result)) Pointer release()
  {
    Pointer p = ptr();
    ptr() = nullptr;
    return p;
  }

  void reset(Pointer aPtr = Pointer())
  {
    Pointer old = ptr();
    ptr() = aPtr;
    if (old != nullptr) {
      get_deleter()(old);
    }
  }

  void swap(UniquePtr& aOther)
  {
    mTuple.swap(aOther.mTuple);
  }

  UniquePtr(const UniquePtr& aOther) = delete;
  void operator=(const UniquePtr& aOther) = delete;
};





template<typename T, class D>
class UniquePtr<T[], D>
{
public:
  typedef T* Pointer;
  typedef T ElementType;
  typedef D DeleterType;

private:
  Pair<Pointer, DeleterType> mTuple;

public:



  constexpr UniquePtr()
    : mTuple(static_cast<Pointer>(nullptr), DeleterType())
  {
    static_assert(!IsPointer<D>::value, "must provide a deleter instance");
    static_assert(!IsReference<D>::value, "must provide a deleter instance");
  }




  explicit UniquePtr(Pointer aPtr)
    : mTuple(aPtr, DeleterType())
  {
    static_assert(!IsPointer<D>::value, "must provide a deleter instance");
    static_assert(!IsReference<D>::value, "must provide a deleter instance");
  }






  template<typename U>
  UniquePtr(U&& aU,
            typename EnableIf<IsPointer<U>::value &&
                              IsConvertible<U, Pointer>::value,
                              int>::Type aDummy = 0)
  = delete;

  UniquePtr(Pointer aPtr,
            typename Conditional<IsReference<D>::value,
                                 D,
                                 const D&>::Type aD1)
    : mTuple(aPtr, aD1)
  {}





  UniquePtr(Pointer aPtr,
            typename RemoveReference<D>::Type&& aD2)
    : mTuple(aPtr, Move(aD2))
  {
    static_assert(!IsReference<D>::value,
                  "rvalue deleter can't be stored by reference");
  }


  template<typename U, typename V>
  UniquePtr(U&& aU, V&& aV,
            typename EnableIf<IsPointer<U>::value &&
                              IsConvertible<U, Pointer>::value,
                              int>::Type aDummy = 0)
  = delete;

  UniquePtr(UniquePtr&& aOther)
    : mTuple(aOther.release(), Forward<DeleterType>(aOther.get_deleter()))
  {}


  UniquePtr(decltype(nullptr))
    : mTuple(nullptr, DeleterType())
  {
    static_assert(!IsPointer<D>::value, "must provide a deleter instance");
    static_assert(!IsReference<D>::value, "must provide a deleter instance");
  }

  ~UniquePtr() { reset(nullptr); }

  UniquePtr& operator=(UniquePtr&& aOther)
  {
    reset(aOther.release());
    get_deleter() = Forward<DeleterType>(aOther.get_deleter());
    return *this;
  }

  UniquePtr& operator=(decltype(nullptr))
  {
    reset();
    return *this;
  }

  explicit operator bool() const { return get() != nullptr; }

  T& operator[](decltype(sizeof(int)) aIndex) const { return get()[aIndex]; }
  Pointer get() const { return mTuple.first(); }

  DeleterType& get_deleter() { return mTuple.second(); }
  const DeleterType& get_deleter() const { return mTuple.second(); }

  __attribute__ ((warn_unused_result)) Pointer release()
  {
    Pointer p = mTuple.first();
    mTuple.first() = nullptr;
    return p;
  }

  void reset(Pointer aPtr = Pointer())
  {
    Pointer old = mTuple.first();
    mTuple.first() = aPtr;
    if (old != nullptr) {
      mTuple.second()(old);
    }
  }

  void reset(decltype(nullptr))
  {
    Pointer old = mTuple.first();
    mTuple.first() = nullptr;
    if (old != nullptr) {
      mTuple.second()(old);
    }
  }

  template<typename U>
  void reset(U) = delete;

  void swap(UniquePtr& aOther) { mTuple.swap(aOther.mTuple); }

  UniquePtr(const UniquePtr& aOther) = delete;
  void operator=(const UniquePtr& aOther) = delete;
};
template<typename T>
class DefaultDelete
{
public:
  constexpr DefaultDelete() {}

  template<typename U>
               DefaultDelete(const DefaultDelete<U>& aOther,
                             typename EnableIf<mozilla::IsConvertible<U*, T*>::value,
                                               int>::Type aDummy = 0)
  {}

  void operator()(T* aPtr) const
  {
    static_assert(sizeof(T) > 0, "T must be complete");
    delete aPtr;
  }
};


template<typename T>
class DefaultDelete<T[]>
{
public:
  constexpr DefaultDelete() {}

  void operator()(T* aPtr) const
  {
    static_assert(sizeof(T) > 0, "T must be complete");
    delete[] aPtr;
  }

  template<typename U>
  void operator()(U* aPtr) const = delete;
};

template<typename T, class D>
void
Swap(UniquePtr<T, D>& aX, UniquePtr<T, D>& aY)
{
  aX.swap(aY);
}

template<typename T, class D, typename U, class E>
bool
operator==(const UniquePtr<T, D>& aX, const UniquePtr<U, E>& aY)
{
  return aX.get() == aY.get();
}

template<typename T, class D, typename U, class E>
bool
operator!=(const UniquePtr<T, D>& aX, const UniquePtr<U, E>& aY)
{
  return aX.get() != aY.get();
}

template<typename T, class D>
bool
operator==(const UniquePtr<T, D>& aX, decltype(nullptr))
{
  return !aX;
}

template<typename T, class D>
bool
operator==(decltype(nullptr), const UniquePtr<T, D>& aX)
{
  return !aX;
}

template<typename T, class D>
bool
operator!=(const UniquePtr<T, D>& aX, decltype(nullptr))
{
  return bool(aX);
}

template<typename T, class D>
bool
operator!=(decltype(nullptr), const UniquePtr<T, D>& aX)
{
  return bool(aX);
}



namespace detail {

template<typename T>
struct UniqueSelector
{
  typedef UniquePtr<T> SingleObject;
};

template<typename T>
struct UniqueSelector<T[]>
{
  typedef UniquePtr<T[]> UnknownBound;
};

template<typename T, decltype(sizeof(int)) N>
struct UniqueSelector<T[N]>
{
  typedef UniquePtr<T[N]> KnownBound;
};

}
template<typename T, typename... Args>
typename detail::UniqueSelector<T>::SingleObject
MakeUnique(Args&&... aArgs)
{
  return UniquePtr<T>(new T(Forward<Args>(aArgs)...));
}

template<typename T>
typename detail::UniqueSelector<T>::UnknownBound
MakeUnique(decltype(sizeof(int)) aN)
{
  typedef typename RemoveExtent<T>::Type ArrayType;
  return UniquePtr<T>(new ArrayType[aN]());
}

template<typename T, typename... Args>
typename detail::UniqueSelector<T>::KnownBound
MakeUnique(Args&&... aArgs) = delete;

}









template<class E>
class nsTArray;

template<class E>
class FallibleTArray;

template<class E, size_t N>
class AutoTArray;

template<class E>
using InfallibleTArray = nsTArray<E>;


namespace mozilla {





template<typename T>
class AlignmentFinder
{
  struct Aligner
  {
    char mChar;
    T mT;
  };

public:
  static const size_t alignment = sizeof(Aligner) - sizeof(T);
};
template<size_t Align>
struct AlignedElem;






template<>
struct AlignedElem<1>
{
  uint8_t elem __attribute__((aligned(1)));
};

template<>
struct AlignedElem<2>
{
  uint8_t elem __attribute__((aligned(2)));
};

template<>
struct AlignedElem<4>
{
  uint8_t elem __attribute__((aligned(4)));
};

template<>
struct AlignedElem<8>
{
  uint8_t elem __attribute__((aligned(8)));
};

template<>
struct AlignedElem<16>
{
  uint8_t elem __attribute__((aligned(16)));
};

template<typename T>
struct AlignedStorage2
{
  union U
  {
    char mBytes[sizeof(T)];
    uint64_t mDummy;
  } u;

  const T* addr() const { return reinterpret_cast<const T*>(u.mBytes); }
  T* addr() { return static_cast<T*>(static_cast<void*>(u.mBytes)); }

  AlignedStorage2() = default;



  AlignedStorage2(const AlignedStorage2&) = delete;
  void operator=(const AlignedStorage2&) = delete;
};

}


namespace mozilla {
template<class Element, class ArrayType>
class ArrayIterator
{
public:
  typedef ArrayType array_type;
  typedef ArrayIterator<Element, ArrayType> iterator_type;
  typedef typename array_type::index_type index_type;
  typedef typename RemoveReference<Element>::Type value_type;
  typedef ptrdiff_t difference_type;
  typedef value_type* pointer;
  typedef value_type& reference;
  typedef std::random_access_iterator_tag iterator_category;

private:
  const array_type* mArray;
  index_type mIndex;

public:
  ArrayIterator() : mArray(nullptr), mIndex(0) {}
  ArrayIterator(const iterator_type& aOther)
    : mArray(aOther.mArray), mIndex(aOther.mIndex) {}
  ArrayIterator(const array_type& aArray, index_type aIndex)
    : mArray(&aArray), mIndex(aIndex) {}

  iterator_type& operator=(const iterator_type& aOther) {
    mArray = aOther.mArray;
    mIndex = aOther.mIndex;
    return *this;
  }

  bool operator==(const iterator_type& aRhs) const {
    return mIndex == aRhs.mIndex;
  }
  bool operator!=(const iterator_type& aRhs) const {
    return !(*this == aRhs);
  }
  bool operator<(const iterator_type& aRhs) const {
    return mIndex < aRhs.mIndex;
  }
  bool operator>(const iterator_type& aRhs) const {
    return mIndex > aRhs.mIndex;
  }
  bool operator<=(const iterator_type& aRhs) const {
    return mIndex <= aRhs.mIndex;
  }
  bool operator>=(const iterator_type& aRhs) const {
    return mIndex >= aRhs.mIndex;
  }



  value_type* operator->() const {
    return const_cast<value_type*>(&mArray->ElementAt(mIndex));
  }
  Element operator*() const {
    return const_cast<Element>(mArray->ElementAt(mIndex));
  }

  iterator_type& operator++() {
    ++mIndex;
    return *this;
  }
  iterator_type operator++(int) {
    iterator_type it = *this;
    ++*this;
    return it;
  }
  iterator_type& operator--() {
    --mIndex;
    return *this;
  }
  iterator_type operator--(int) {
    iterator_type it = *this;
    --*this;
    return it;
  }

  iterator_type& operator+=(difference_type aDiff) {
    mIndex += aDiff;
    return *this;
  }
  iterator_type& operator-=(difference_type aDiff) {
    mIndex -= aDiff;
    return *this;
  }

  iterator_type operator+(difference_type aDiff) const {
    iterator_type it = *this;
    it += aDiff;
    return it;
  }
  iterator_type operator-(difference_type aDiff) const {
    iterator_type it = *this;
    it -= aDiff;
    return it;
  }

  difference_type operator-(const iterator_type& aOther) const {
    return static_cast<difference_type>(mIndex) -
      static_cast<difference_type>(aOther.mIndex);
  }

  Element operator[](difference_type aIndex) const {
    return *this->operator+(aIndex);
  }
};

}



namespace mozilla {
template<typename Container, typename Comparator>
bool
BinarySearchIf(const Container& aContainer, size_t aBegin, size_t aEnd,
               const Comparator& aCompare, size_t* aMatchOrInsertionPoint)
{
  do { } while (0);

  size_t low = aBegin;
  size_t high = aEnd;
  while (high != low) {
    size_t middle = low + (high - low) / 2;



    const int result = aCompare(aContainer[middle]);

    if (result == 0) {
      *aMatchOrInsertionPoint = middle;
      return true;
    }

    if (result < 0) {
      high = middle;
    } else {
      low = middle + 1;
    }
  }

  *aMatchOrInsertionPoint = low;
  return false;
}

namespace detail {

template<class T>
class BinarySearchDefaultComparator
{
public:
  explicit BinarySearchDefaultComparator(const T& aTarget)
    : mTarget(aTarget)
  {}

  template <class U>
  int operator()(const U& aVal) const {
    if (mTarget == aVal) {
      return 0;
    }

    if (mTarget < aVal) {
      return -1;
    }

    return 1;
  }

private:
  const T& mTarget;
};

}

template <typename Container, typename T>
bool
BinarySearch(const Container& aContainer, size_t aBegin, size_t aEnd,
             T aTarget, size_t* aMatchOrInsertionPoint)
{
  return BinarySearchIf(aContainer, aBegin, aEnd,
                        detail::BinarySearchDefaultComparator<T>(aTarget),
                        aMatchOrInsertionPoint);
}

}


namespace mozilla {


template<typename IntegerType>
__attribute__((always_inline)) inline IntegerType
EuclidGCD(IntegerType aA, IntegerType aB)
{


  do { } while (0);
  do { } while (0);

  while (aA != aB) {
    if (aA > aB) {
      aA = aA - aB;
    } else {
      aB = aB - aA;
    }
  }

  return aA;
}


template<typename IntegerType>
__attribute__((always_inline)) inline IntegerType
EuclidLCM(IntegerType aA, IntegerType aB)
{

  return (aA / EuclidGCD(aA, aB)) * aB;
}

namespace detail {

template<typename T>
struct AllowDeprecatedAbsFixed : FalseType {};

template<> struct AllowDeprecatedAbsFixed<int32_t> : TrueType {};
template<> struct AllowDeprecatedAbsFixed<int64_t> : TrueType {};

template<typename T>
struct AllowDeprecatedAbs : AllowDeprecatedAbsFixed<T> {};

template<> struct AllowDeprecatedAbs<int> : TrueType {};
template<> struct AllowDeprecatedAbs<long> : TrueType {};

}



template<typename T>
inline typename mozilla::EnableIf<detail::AllowDeprecatedAbs<T>::value, T>::Type
DeprecatedAbs(const T aValue)
{
  do { } while (0);


  return aValue >= 0 ? aValue : -aValue;
}

namespace detail {





template<typename T>
struct AbsReturnTypeFixed;

template<> struct AbsReturnTypeFixed<int8_t> { typedef uint8_t Type; };
template<> struct AbsReturnTypeFixed<int16_t> { typedef uint16_t Type; };
template<> struct AbsReturnTypeFixed<int32_t> { typedef uint32_t Type; };
template<> struct AbsReturnTypeFixed<int64_t> { typedef uint64_t Type; };

template<typename T>
struct AbsReturnType : AbsReturnTypeFixed<T> {};

template<> struct AbsReturnType<char> :
  EnableIf<char(-1) < char(0), unsigned char> {};
template<> struct AbsReturnType<signed char> { typedef unsigned char Type; };
template<> struct AbsReturnType<short> { typedef unsigned short Type; };
template<> struct AbsReturnType<int> { typedef unsigned int Type; };
template<> struct AbsReturnType<long> { typedef unsigned long Type; };
template<> struct AbsReturnType<long long> { typedef unsigned long long Type; };
template<> struct AbsReturnType<float> { typedef float Type; };
template<> struct AbsReturnType<double> { typedef double Type; };
template<> struct AbsReturnType<long double> { typedef long double Type; };

}

template<typename T>
inline typename detail::AbsReturnType<T>::Type
Abs(const T aValue)
{
  typedef typename detail::AbsReturnType<T>::Type ReturnType;
  return aValue >= 0 ? ReturnType(aValue) : ~ReturnType(aValue) + 1;
}

template<>
inline float
Abs<float>(const float aFloat)
{
  return std::fabs(aFloat);
}

template<>
inline double
Abs<double>(const double aDouble)
{
  return std::fabs(aDouble);
}

template<>
inline long double
Abs<long double>(const long double aLongDouble)
{
  return std::fabs(aLongDouble);
}

}
namespace mozilla {

namespace detail {
inline uint_fast8_t
CountLeadingZeroes32(uint32_t aValue)
{
  return __builtin_clz(aValue);
}

inline uint_fast8_t
CountTrailingZeroes32(uint32_t aValue)
{
  return __builtin_ctz(aValue);
}

inline uint_fast8_t
CountPopulation32(uint32_t aValue)
{
  return __builtin_popcount(aValue);
}

inline uint_fast8_t
CountPopulation64(uint64_t aValue)
{
  return __builtin_popcountll(aValue);
}

inline uint_fast8_t
CountLeadingZeroes64(uint64_t aValue)
{
  return __builtin_clzll(aValue);
}

inline uint_fast8_t
CountTrailingZeroes64(uint64_t aValue)
{
  return __builtin_ctzll(aValue);
}
}
inline uint_fast8_t
CountLeadingZeroes32(uint32_t aValue)
{
  do { } while (0);
  return detail::CountLeadingZeroes32(aValue);
}
inline uint_fast8_t
CountTrailingZeroes32(uint32_t aValue)
{
  do { } while (0);
  return detail::CountTrailingZeroes32(aValue);
}




inline uint_fast8_t
CountPopulation32(uint32_t aValue)
{
  return detail::CountPopulation32(aValue);
}


inline uint_fast8_t
CountPopulation64(uint64_t aValue)
{
  return detail::CountPopulation64(aValue);
}


inline uint_fast8_t
CountLeadingZeroes64(uint64_t aValue)
{
  do { } while (0);
  return detail::CountLeadingZeroes64(aValue);
}


inline uint_fast8_t
CountTrailingZeroes64(uint64_t aValue)
{
  do { } while (0);
  return detail::CountTrailingZeroes64(aValue);
}

namespace detail {

template<typename T, size_t Size = sizeof(T)>
class CeilingLog2;

template<typename T>
class CeilingLog2<T, 4>
{
public:
  static uint_fast8_t compute(const T aValue)
  {

    return aValue <= 1 ? 0u : 32u - CountLeadingZeroes32(aValue - 1);
  }
};

template<typename T>
class CeilingLog2<T, 8>
{
public:
  static uint_fast8_t compute(const T aValue)
  {

    return aValue <= 1 ? 0u : 64u - CountLeadingZeroes64(aValue - 1);
  }
};

}
template<typename T>
inline uint_fast8_t
CeilingLog2(const T aValue)
{
  return detail::CeilingLog2<T>::compute(aValue);
}


inline uint_fast8_t
CeilingLog2Size(size_t aValue)
{
  return CeilingLog2(aValue);
}

namespace detail {

template<typename T, size_t Size = sizeof(T)>
class FloorLog2;

template<typename T>
class FloorLog2<T, 4>
{
public:
  static uint_fast8_t compute(const T aValue)
  {
    return 31u - CountLeadingZeroes32(aValue | 1);
  }
};

template<typename T>
class FloorLog2<T, 8>
{
public:
  static uint_fast8_t compute(const T aValue)
  {
    return 63u - CountLeadingZeroes64(aValue | 1);
  }
};

}
template<typename T>
inline uint_fast8_t
FloorLog2(const T aValue)
{
  return detail::FloorLog2<T>::compute(aValue);
}


inline uint_fast8_t
FloorLog2Size(size_t aValue)
{
  return FloorLog2(aValue);
}





inline size_t
RoundUpPow2(size_t aValue)
{
  do { } while (0);

  return size_t(1) << CeilingLog2(aValue);
}




template<typename T>
inline T
RotateLeft(const T aValue, uint_fast8_t aShift)
{
  do { } while (0);
  do { } while (0);




  static_assert(IsUnsigned<T>::value, "Rotates require unsigned values");
  return (aValue << aShift) | (aValue >> (sizeof(T) * 8 - aShift));
}




template<typename T>
inline T
RotateRight(const T aValue, uint_fast8_t aShift)
{
  do { } while (0);
  do { } while (0);




  static_assert(IsUnsigned<T>::value, "Rotates require unsigned values");
  return (aValue >> aShift) | (aValue << (sizeof(T) * 8 - aShift));
}





template<typename T>
constexpr bool
IsPowerOfTwo(T x)
{
    static_assert(IsUnsigned<T>::value,
                  "IsPowerOfTwo requires unsigned values");
    return x && (x & (x - 1)) == 0;
}

template<typename T>
inline T
Clamp(const T aValue, const T aMin, const T aMax)
{
    static_assert(IsIntegral<T>::value,
                  "Clamp accepts only integral types, so that it doesn't have"
                  " to distinguish differently-signed zeroes (which users may"
                  " or may not care to distinguish, likely at a perf cost) or"
                  " to decide how to clamp NaN or a range with a NaN"
                  " endpoint.");
    do { } while (0);

    if (aValue <= aMin)
        return aMin;
    if (aValue >= aMax)
        return aMax;
    return aValue;
}

}



namespace mozilla {





typedef size_t (*MallocSizeOf)(const void* p);

}



typedef size_t (*MozMallocSizeOf)(const void* p);

namespace mozilla {

template<typename IteratorT>
class ReverseIterator
{
public:
  template<typename Iterator>
  explicit ReverseIterator(Iterator aIter)
    : mCurrent(aIter) { }

  template<typename Iterator>
               ReverseIterator(const ReverseIterator<Iterator>& aOther)
    : mCurrent(aOther.mCurrent) { }

  decltype(*DeclVal<IteratorT>()) operator*() const
  {
    IteratorT tmp = mCurrent;
    return *--tmp;
  }



  ReverseIterator& operator++() { --mCurrent; return *this; }
  ReverseIterator& operator--() { ++mCurrent; return *this; }
  ReverseIterator operator++(int) { auto ret = *this; mCurrent--; return ret; }
  ReverseIterator operator--(int) { auto ret = *this; mCurrent++; return ret; }



  template<typename Iterator1, typename Iterator2>
  friend bool operator==(const ReverseIterator<Iterator1>& aIter1,
                         const ReverseIterator<Iterator2>& aIter2);
  template<typename Iterator1, typename Iterator2>
  friend bool operator!=(const ReverseIterator<Iterator1>& aIter1,
                         const ReverseIterator<Iterator2>& aIter2);
  template<typename Iterator1, typename Iterator2>
  friend bool operator<(const ReverseIterator<Iterator1>& aIter1,
                        const ReverseIterator<Iterator2>& aIter2);
  template<typename Iterator1, typename Iterator2>
  friend bool operator<=(const ReverseIterator<Iterator1>& aIter1,
                         const ReverseIterator<Iterator2>& aIter2);
  template<typename Iterator1, typename Iterator2>
  friend bool operator>(const ReverseIterator<Iterator1>& aIter1,
                        const ReverseIterator<Iterator2>& aIter2);
  template<typename Iterator1, typename Iterator2>
  friend bool operator>=(const ReverseIterator<Iterator1>& aIter1,
                         const ReverseIterator<Iterator2>& aIter2);

private:
  IteratorT mCurrent;
};

template<typename Iterator1, typename Iterator2>
bool
operator==(const ReverseIterator<Iterator1>& aIter1,
           const ReverseIterator<Iterator2>& aIter2)
{
  return aIter1.mCurrent == aIter2.mCurrent;
}

template<typename Iterator1, typename Iterator2>
bool
operator!=(const ReverseIterator<Iterator1>& aIter1,
           const ReverseIterator<Iterator2>& aIter2)
{
  return aIter1.mCurrent != aIter2.mCurrent;
}

template<typename Iterator1, typename Iterator2>
bool
operator<(const ReverseIterator<Iterator1>& aIter1,
          const ReverseIterator<Iterator2>& aIter2)
{
  return aIter1.mCurrent > aIter2.mCurrent;
}

template<typename Iterator1, typename Iterator2>
bool
operator<=(const ReverseIterator<Iterator1>& aIter1,
           const ReverseIterator<Iterator2>& aIter2)
{
  return aIter1.mCurrent >= aIter2.mCurrent;
}

template<typename Iterator1, typename Iterator2>
bool
operator>(const ReverseIterator<Iterator1>& aIter1,
          const ReverseIterator<Iterator2>& aIter2)
{
  return aIter1.mCurrent < aIter2.mCurrent;
}

template<typename Iterator1, typename Iterator2>
bool
operator>=(const ReverseIterator<Iterator1>& aIter1,
           const ReverseIterator<Iterator2>& aIter2)
{
  return aIter1.mCurrent <= aIter2.mCurrent;
}

namespace detail {

template<typename IteratorT>
class IteratorRange
{
public:
  typedef IteratorT iterator;
  typedef IteratorT const_iterator;
  typedef ReverseIterator<IteratorT> reverse_iterator;
  typedef ReverseIterator<IteratorT> const_reverse_iterator;

  template<typename Iterator1, typename Iterator2>
               IteratorRange(Iterator1 aIterBegin, Iterator2 aIterEnd)
    : mIterBegin(aIterBegin), mIterEnd(aIterEnd) { }

  template<typename Iterator>
               IteratorRange(const IteratorRange<Iterator>& aOther)
    : mIterBegin(aOther.mIterBegin), mIterEnd(aOther.mIterEnd) { }

  iterator begin() const { return mIterBegin; }
  const_iterator cbegin() const { return begin(); }
  iterator end() const { return mIterEnd; }
  const_iterator cend() const { return end(); }
  reverse_iterator rbegin() const { return reverse_iterator(mIterEnd); }
  const_reverse_iterator crbegin() const { return rbegin(); }
  reverse_iterator rend() const { return reverse_iterator(mIterBegin); }
  const_reverse_iterator crend() const { return rend(); }

private:
  IteratorT mIterBegin;
  IteratorT mIterEnd;
};

}

template<typename Range>
detail::IteratorRange<typename Range::reverse_iterator>
Reversed(Range& aRange)
{
  return {aRange.rbegin(), aRange.rend()};
}

template<typename Range>
detail::IteratorRange<typename Range::const_reverse_iterator>
Reversed(const Range& aRange)
{
  return {aRange.rbegin(), aRange.rend()};
}

}


namespace mozilla {

template<typename T, size_t Length>
class Array
{
  T mArr[Length];

public:
  Array() {}

  template <typename... Args>
               Array(Args&&... aArgs)
    : mArr{mozilla::Forward<Args>(aArgs)...}
  {
    static_assert(sizeof...(aArgs) == Length,
                  "The number of arguments should be equal to the template parameter Length");
  }

  T& operator[](size_t aIndex)
  {
    do { } while (0);
    return mArr[aIndex];
  }

  const T& operator[](size_t aIndex) const
  {
    do { } while (0);
    return mArr[aIndex];
  }

  bool operator==(const Array<T, Length>& aOther) const
  {
    for (size_t i = 0; i < Length; i++) {
      if (mArr[i] != aOther[i]) {
        return false;
      }
    }
    return true;
  }

  typedef T* iterator;
  typedef const T* const_iterator;
  typedef ReverseIterator<T*> reverse_iterator;
  typedef ReverseIterator<const T*> const_reverse_iterator;


  iterator begin() { return mArr; }
  const_iterator begin() const { return mArr; }
  const_iterator cbegin() const { return begin(); }
  iterator end() { return mArr + Length; }
  const_iterator end() const { return mArr + Length; }
  const_iterator cend() const { return end(); }


  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
  const_reverse_iterator crbegin() const { return rbegin(); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
  const_reverse_iterator crend() const { return rend(); }
};

template<typename T>
class Array<T, 0>
{
public:
  T& operator[](size_t aIndex)
  {
    do { AnnotateMozCrashReason("MOZ_CRASH(" "indexing into zero-length array" ")"); do { *((volatile int*) __null) = 87; ::abort(); } while (0); } while (0);
  }

  const T& operator[](size_t aIndex) const
  {
    do { AnnotateMozCrashReason("MOZ_CRASH(" "indexing into zero-length array" ")"); do { *((volatile int*) __null) = 92; ::abort(); } while (0); } while (0);
  }
};

}

namespace mozilla {
template<typename To, typename From>
inline void
BitwiseCast(const From aFrom, To* aResult)
{
  static_assert(sizeof(From) == sizeof(To),
                "To and From must have the same size");
  union
  {
    From mFrom;
    To mTo;
  } u;
  u.mFrom = aFrom;
  *aResult = u.mTo;
}

template<typename To, typename From>
inline To
BitwiseCast(const From aFrom)
{
  To temp;
  BitwiseCast<To, From>(aFrom, &temp);
  return temp;
}

namespace detail {

enum ToSignedness { ToIsSigned, ToIsUnsigned };
enum FromSignedness { FromIsSigned, FromIsUnsigned };

template<typename From,
         typename To,
         FromSignedness = IsSigned<From>::value ? FromIsSigned : FromIsUnsigned,
         ToSignedness = IsSigned<To>::value ? ToIsSigned : ToIsUnsigned>
struct BoundsCheckImpl;






enum UUComparison { FromIsBigger, FromIsNotBigger };



template<typename From, typename To,
         UUComparison = (sizeof(From) > sizeof(To))
                        ? FromIsBigger
                        : FromIsNotBigger>
struct UnsignedUnsignedCheck;

template<typename From, typename To>
struct UnsignedUnsignedCheck<From, To, FromIsBigger>
{
public:
  static bool checkBounds(const From aFrom)
  {
    return aFrom <= From(To(-1));
  }
};

template<typename From, typename To>
struct UnsignedUnsignedCheck<From, To, FromIsNotBigger>
{
public:
  static bool checkBounds(const From aFrom)
  {
    return true;
  }
};

template<typename From, typename To>
struct BoundsCheckImpl<From, To, FromIsUnsigned, ToIsUnsigned>
{
public:
  static bool checkBounds(const From aFrom)
  {
    return UnsignedUnsignedCheck<From, To>::checkBounds(aFrom);
  }
};



template<typename From, typename To>
struct BoundsCheckImpl<From, To, FromIsSigned, ToIsUnsigned>
{
public:
  static bool checkBounds(const From aFrom)
  {
    if (aFrom < 0) {
      return false;
    }
    if (sizeof(To) >= sizeof(From)) {
      return true;
    }
    return aFrom <= From(To(-1));
  }
};



enum USComparison { FromIsSmaller, FromIsNotSmaller };

template<typename From, typename To,
         USComparison = (sizeof(From) < sizeof(To))
                        ? FromIsSmaller
                        : FromIsNotSmaller>
struct UnsignedSignedCheck;

template<typename From, typename To>
struct UnsignedSignedCheck<From, To, FromIsSmaller>
{
public:
  static bool checkBounds(const From aFrom)
  {
    return true;
  }
};

template<typename From, typename To>
struct UnsignedSignedCheck<From, To, FromIsNotSmaller>
{
public:
  static bool checkBounds(const From aFrom)
  {
    const To MaxValue = To((1ULL << (8 * sizeof(To) - 1)) - 1);
    return aFrom <= From(MaxValue);
  }
};

template<typename From, typename To>
struct BoundsCheckImpl<From, To, FromIsUnsigned, ToIsSigned>
{
public:
  static bool checkBounds(const From aFrom)
  {
    return UnsignedSignedCheck<From, To>::checkBounds(aFrom);
  }
};



template<typename From, typename To>
struct BoundsCheckImpl<From, To, FromIsSigned, ToIsSigned>
{
public:
  static bool checkBounds(const From aFrom)
  {
    if (sizeof(From) <= sizeof(To)) {
      return true;
    }
    const To MaxValue = To((1ULL << (8 * sizeof(To) - 1)) - 1);
    const To MinValue = -MaxValue - To(1);
    return From(MinValue) <= aFrom &&
           From(aFrom) <= From(MaxValue);
  }
};

template<typename From, typename To,
         bool TypesAreIntegral = IsIntegral<From>::value &&
                                 IsIntegral<To>::value>
class BoundsChecker;

template<typename From>
class BoundsChecker<From, From, true>
{
public:
  static bool checkBounds(const From aFrom) { return true; }
};

template<typename From, typename To>
class BoundsChecker<From, To, true>
{
public:
  static bool checkBounds(const From aFrom)
  {
    return BoundsCheckImpl<From, To>::checkBounds(aFrom);
  }
};

template<typename From, typename To>
inline bool
IsInBounds(const From aFrom)
{
  return BoundsChecker<From, To>::checkBounds(aFrom);
}

}






template<typename To, typename From>
inline To
AssertedCast(const From aFrom)
{
  do { } while (0);
  return static_cast<To>(aFrom);
}






template<typename To, typename From>
inline To
ReleaseAssertedCast(const From aFrom)
{
  do { static_assert(mozilla::detail::AssertionConditionType<decltype((detail::IsInBounds<From, To>(aFrom)))>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!((detail::IsInBounds<From, To>(aFrom))))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "(detail::IsInBounds<From, To>(aFrom))" ")"); do { *((volatile int*) __null) = 250; ::abort(); } while (0); } } while (0);
  return static_cast<To>(aFrom);
}

}

namespace mozilla {




template<class T, class U>
inline constexpr T
narrow_cast(U&& u)
{
  return static_cast<T>(mozilla::Forward<U>(u));
}
constexpr const size_t dynamic_extent = mozilla::MaxValue<size_t>::value;

template<class ElementType, size_t Extent = dynamic_extent>
class Span;


namespace span_details {

inline size_t strlen16(const char16_t* aZeroTerminated) {
  size_t len = 0;
  while (*(aZeroTerminated++)) {
    len++;
  }
  return len;
}


template<class T>
using remove_cv_t = typename mozilla::RemoveCV<T>::Type;
template<class T>
using remove_const_t = typename mozilla::RemoveConst<T>::Type;
template<bool B, class T, class F>
using conditional_t = typename mozilla::Conditional<B, T, F>::Type;
template<class T>
using add_pointer_t = typename mozilla::AddPointer<T>::Type;
template<bool B, class T = void>
using enable_if_t = typename mozilla::EnableIf<B, T>::Type;

template<class T>
struct is_span_oracle : mozilla::FalseType
{
};

template<class ElementType, size_t Extent>
struct is_span_oracle<mozilla::Span<ElementType, Extent>> : mozilla::TrueType
{
};

template<class T>
struct is_span : public is_span_oracle<remove_cv_t<T>>
{
};

template<class T>
struct is_std_array_oracle : mozilla::FalseType
{
};

template<class ElementType, size_t Extent>
struct is_std_array_oracle<std::array<ElementType, Extent>> : mozilla::TrueType
{
};

template<class T>
struct is_std_array : public is_std_array_oracle<remove_cv_t<T>>
{
};

template<size_t From, size_t To>
struct is_allowed_extent_conversion
  : public mozilla::IntegralConstant<bool,
                                  From == To ||
                                    From == mozilla::dynamic_extent ||
                                    To == mozilla::dynamic_extent>
{
};

template<class From, class To>
struct is_allowed_element_type_conversion
  : public mozilla::IntegralConstant<bool, mozilla::IsConvertible<From (*)[], To (*)[]>::value>
{
};

template<class Span, bool IsConst>
class span_iterator
{
  using element_type_ = typename Span::element_type;

public:
  using iterator_category = std::random_access_iterator_tag;
  using value_type = remove_const_t<element_type_>;
  using difference_type = typename Span::index_type;

  using reference = conditional_t<IsConst, const element_type_, element_type_>&;
  using pointer = add_pointer_t<reference>;

  constexpr span_iterator() : span_iterator(nullptr, 0) {}

                               span_iterator(const Span* span,
                                             typename Span::index_type index)
    : span_(span)
    , index_(index)
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(span == nullptr || (index_ >= 0 && index <= span_->Length()))>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(span == nullptr || (index_ >= 0 && index <= span_->Length())))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "span == nullptr || (index_ >= 0 && index <= span_->Length())" ")"); do { *((volatile int*) __null) = 176; ::abort(); } while (0); } } while (0);

  }

  friend class span_iterator<Span, true>;
  constexpr span_iterator(const span_iterator<Span, false>& other)
    : span_iterator(other.span_, other.index_)
  {
  }

                                          span_iterator<Span, IsConst>&
  operator=(const span_iterator<Span, IsConst>&) = default;

                         reference operator*() const
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(span_)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(span_))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "span_" ")"); do { *((volatile int*) __null) = 190; ::abort(); } while (0); } } while (0);
    return (*span_)[index_];
  }

                         pointer operator->() const
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(span_)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(span_))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "span_" ")"); do { *((volatile int*) __null) = 196; ::abort(); } while (0); } } while (0);
    return &((*span_)[index_]);
  }

                               span_iterator& operator++()
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(span_ && index_ >= 0 && index_ < span_->Length())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(span_ && index_ >= 0 && index_ < span_->Length()))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "span_ && index_ >= 0 && index_ < span_->Length()" ")"); do { *((volatile int*) __null) = 202; ::abort(); } while (0); } } while (0);
    ++index_;
    return *this;
  }

                               span_iterator operator++(int)
  {
    auto ret = *this;
    ++(*this);
    return ret;
  }

                               span_iterator& operator--()
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(span_ && index_ > 0 && index_ <= span_->Length())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(span_ && index_ > 0 && index_ <= span_->Length()))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "span_ && index_ > 0 && index_ <= span_->Length()" ")"); do { *((volatile int*) __null) = 216; ::abort(); } while (0); } } while (0);
    --index_;
    return *this;
  }

                               span_iterator operator--(int)
  {
    auto ret = *this;
    --(*this);
    return ret;
  }

                                     span_iterator
  operator+(difference_type n) const
  {
    auto ret = *this;
    return ret += n;
  }

                         span_iterator& operator+=(difference_type n)
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(span_ && (index_ + n) >= 0 && (index_ + n) <= span_->Length())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(span_ && (index_ + n) >= 0 && (index_ + n) <= span_->Length()))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "span_ && (index_ + n) >= 0 && (index_ + n) <= span_->Length()" ")"); do { *((volatile int*) __null) = 238; ::abort(); } while (0); } } while (0);

    index_ += n;
    return *this;
  }

                                     span_iterator
  operator-(difference_type n) const
  {
    auto ret = *this;
    return ret -= n;
  }

                               span_iterator& operator-=(difference_type n)

  {
    return *this += -n;
  }

                         difference_type
  operator-(const span_iterator& rhs) const
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(span_ == rhs.span_)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(span_ == rhs.span_))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "span_ == rhs.span_" ")"); do { *((volatile int*) __null) = 259; ::abort(); } while (0); } } while (0);
    return index_ - rhs.index_;
  }

  constexpr reference operator[](difference_type n) const
  {
    return *(*this + n);
  }

  constexpr friend bool operator==(const span_iterator& lhs,
                                   const span_iterator& rhs)
  {
    return lhs.span_ == rhs.span_ && lhs.index_ == rhs.index_;
  }

  constexpr friend bool operator!=(const span_iterator& lhs,
                                   const span_iterator& rhs)
  {
    return !(lhs == rhs);
  }

                         friend bool operator<(const span_iterator& lhs,
                                               const span_iterator& rhs)
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(lhs.span_ == rhs.span_)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(lhs.span_ == rhs.span_))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "lhs.span_ == rhs.span_" ")"); do { *((volatile int*) __null) = 283; ::abort(); } while (0); } } while (0);
    return lhs.index_ < rhs.index_;
  }

  constexpr friend bool operator<=(const span_iterator& lhs,
                                   const span_iterator& rhs)
  {
    return !(rhs < lhs);
  }

  constexpr friend bool operator>(const span_iterator& lhs,
                                  const span_iterator& rhs)
  {
    return rhs < lhs;
  }

  constexpr friend bool operator>=(const span_iterator& lhs,
                                   const span_iterator& rhs)
  {
    return !(rhs > lhs);
  }

  void swap(span_iterator& rhs)
  {
    std::swap(index_, rhs.index_);
    std::swap(span_, rhs.span_);
  }

protected:
  const Span* span_;
  size_t index_;
};

template<class Span, bool IsConst>
inline constexpr span_iterator<Span, IsConst>
operator+(typename span_iterator<Span, IsConst>::difference_type n,
          const span_iterator<Span, IsConst>& rhs)
{
  return rhs + n;
}

template<size_t Ext>
class extent_type
{
public:
  using index_type = size_t;

  static_assert(Ext >= 0, "A fixed-size Span must be >= 0 in size.");

  constexpr extent_type() {}

  template<index_type Other>
                                            extent_type(extent_type<Other> ext)
  {
    static_assert(
      Other == Ext || Other == dynamic_extent,
      "Mismatch between fixed-size extent and size of initializing data.");
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(ext.size() == Ext)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(ext.size() == Ext))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "ext.size() == Ext" ")"); do { *((volatile int*) __null) = 340; ::abort(); } while (0); } } while (0);
  }

                                            extent_type(index_type length)
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(length == Ext)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(length == Ext))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "length == Ext" ")"); do { *((volatile int*) __null) = 345; ::abort(); } while (0); } } while (0);
  }

  constexpr index_type size() const { return Ext; }
};

template<>
class extent_type<dynamic_extent>
{
public:
  using index_type = size_t;

  template<index_type Other>
  explicit constexpr extent_type(extent_type<Other> ext)
    : size_(ext.size())
  {
  }

  explicit constexpr extent_type(index_type length)
    : size_(length)
  {
  }

  constexpr index_type size() const { return size_; }

private:
  index_type size_;
};
}
template<class ElementType, size_t Extent>
class Span
{
public:

  using element_type = ElementType;
  using index_type = size_t;
  using pointer = element_type*;
  using reference = element_type&;

  using iterator =
    span_details::span_iterator<Span<ElementType, Extent>, false>;
  using const_iterator =
    span_details::span_iterator<Span<ElementType, Extent>, true>;
  using reverse_iterator = std::reverse_iterator<iterator>;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;

  constexpr static const index_type extent = Extent;







  template<
    bool Dependent = false,
    class = span_details::enable_if_t<
      (Dependent || Extent == 0 || Extent == mozilla::MaxValue<size_t>::value)>>
  constexpr Span()
    : storage_(nullptr, span_details::extent_type<0>())
  {
  }




  constexpr Span(std::nullptr_t) : Span() {}




  constexpr Span(pointer aPtr, index_type aLength)
    : storage_(aPtr, aLength)
  {
  }




  constexpr Span(pointer aStartPtr, pointer aEndPtr)
    : storage_(aStartPtr, std::distance(aStartPtr, aEndPtr))
  {
  }




  template<size_t N>
  constexpr Span(element_type (&aArr)[N])
    : storage_(&aArr[0], span_details::extent_type<N>())
  {
  }




  template<size_t N,
           class ArrayElementType = span_details::remove_const_t<element_type>>
  constexpr Span(std::array<ArrayElementType, N>& aArr)
    : storage_(&aArr[0], span_details::extent_type<N>())
  {
  }




  template<size_t N>
  constexpr Span(
    const std::array<span_details::remove_const_t<element_type>, N>& aArr)
    : storage_(&aArr[0], span_details::extent_type<N>())
  {
  }




  template<size_t N,
           class ArrayElementType = span_details::remove_const_t<element_type>>
  constexpr Span(mozilla::Array<ArrayElementType, N>& aArr)
    : storage_(&aArr[0], span_details::extent_type<N>())
  {
  }




  template<size_t N>
  constexpr Span(
    const mozilla::Array<span_details::remove_const_t<element_type>, N>& aArr)
    : storage_(&aArr[0], span_details::extent_type<N>())
  {
  }




  template<class ArrayElementType = std::add_pointer<element_type>>
  constexpr Span(const mozilla::UniquePtr<ArrayElementType>& aPtr,
                 index_type aLength)
    : storage_(aPtr.get(), aLength)
  {
  }






  template<
    class Container,
    class = span_details::enable_if_t<
      !span_details::is_span<Container>::value &&
      !span_details::is_std_array<Container>::value &&
      mozilla::IsConvertible<typename Container::pointer, pointer>::value &&
      mozilla::IsConvertible<typename Container::pointer,
                          decltype(mozilla::DeclVal<Container>().data())>::value>>
  constexpr Span(Container& cont)
    : Span(cont.data(), ReleaseAssertedCast<index_type>(cont.size()))
  {
  }




  template<
    class Container,
    class = span_details::enable_if_t<
      mozilla::IsConst<element_type>::value &&
      !span_details::is_span<Container>::value &&
      mozilla::IsConvertible<typename Container::pointer, pointer>::value &&
      mozilla::IsConvertible<typename Container::pointer,
                          decltype(mozilla::DeclVal<Container>().data())>::value>>
  constexpr Span(const Container& cont)
    : Span(cont.data(), ReleaseAssertedCast<index_type>(cont.size()))
  {
  }




  constexpr Span(const Span& other) = default;




  constexpr Span(Span&& other) = default;




  template<
    class OtherElementType,
    size_t OtherExtent,
    class = span_details::enable_if_t<
      span_details::is_allowed_extent_conversion<OtherExtent, Extent>::value &&
      span_details::is_allowed_element_type_conversion<OtherElementType,
                                                       element_type>::value>>
  constexpr Span(const Span<OtherElementType, OtherExtent>& other)
    : storage_(other.data(),
               span_details::extent_type<OtherExtent>(other.size()))
  {
  }




  template<
    class OtherElementType,
    size_t OtherExtent,
    class = span_details::enable_if_t<
      span_details::is_allowed_extent_conversion<OtherExtent, Extent>::value &&
      span_details::is_allowed_element_type_conversion<OtherElementType,
                                                       element_type>::value>>
  constexpr Span(Span<OtherElementType, OtherExtent>&& other)
    : storage_(other.data(),
               span_details::extent_type<OtherExtent>(other.size()))
  {
  }

  ~Span() = default;
                                          Span& operator=(const Span& other)
    = default;

                                          Span& operator=(Span&& other)
    = default;





  template<size_t Count>
                         Span<element_type, Count> First() const
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(Count <= size())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(Count <= size()))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "Count <= size()" ")"); do { *((volatile int*) __null) = 640; ::abort(); } while (0); } } while (0);
    return { data(), Count };
  }




  template<size_t Count>
                         Span<element_type, Count> Last() const
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(Count <= size())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(Count <= size()))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "Count <= size()" ")"); do { *((volatile int*) __null) = 650; ::abort(); } while (0); } } while (0);
    return { data() + (size() - Count), Count };
  }




  template<size_t Offset, size_t Count = dynamic_extent>
                         Span<element_type, Count> Subspan() const
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(Offset <= size() && (Count == dynamic_extent || (Offset + Count <= size())))>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(Offset <= size() && (Count == dynamic_extent || (Offset + Count <= size()))))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "Offset <= size() && (Count == dynamic_extent || (Offset + Count <= size()))" ")"); do { *((volatile int*) __null) = 661; ::abort(); } while (0); } } while (0);

    return { data() + Offset,
             Count == dynamic_extent ? size() - Offset : Count };
  }




                         Span<element_type, dynamic_extent> First(
    index_type aCount) const
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(aCount <= size())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(aCount <= size()))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "aCount <= size()" ")"); do { *((volatile int*) __null) = 672; ::abort(); } while (0); } } while (0);
    return { data(), aCount };
  }




                         Span<element_type, dynamic_extent> Last(
    index_type aCount) const
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(aCount <= size())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(aCount <= size()))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "aCount <= size()" ")"); do { *((volatile int*) __null) = 682; ::abort(); } while (0); } } while (0);
    return { data() + (size() - aCount), aCount };
  }




                         Span<element_type, dynamic_extent> Subspan(
    index_type aStart,
    index_type aLength = dynamic_extent) const
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(aStart <= size() && (aLength == dynamic_extent || (aStart + aLength <= size())))>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(aStart <= size() && (aLength == dynamic_extent || (aStart + aLength <= size()))))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "aStart <= size() && (aLength == dynamic_extent || (aStart + aLength <= size()))" ")"); do { *((volatile int*) __null) = 695; ::abort(); } while (0); } } while (0);


    return { data() + aStart,
             aLength == dynamic_extent ? size() - aStart : aLength };
  }




                         Span<element_type, dynamic_extent> From(
    index_type aStart) const
  {
    return Subspan(aStart);
  }




                         Span<element_type, dynamic_extent> To(
    index_type aEnd) const
  {
    return Subspan(0, aEnd);
  }





                         Span<element_type, dynamic_extent> FromTo(
    index_type aStart,
    index_type aEnd) const
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(aStart <= aEnd)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(aStart <= aEnd))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "aStart <= aEnd" ")"); do { *((volatile int*) __null) = 726; ::abort(); } while (0); } } while (0);
    return Subspan(aStart, aEnd - aStart);
  }





  constexpr index_type Length() const { return size(); }




  constexpr index_type size() const { return storage_.size(); }




  constexpr index_type LengthBytes() const { return size_bytes(); }




  constexpr index_type size_bytes() const
  {
    return size() * narrow_cast<index_type>(sizeof(element_type));
  }




  constexpr bool IsEmpty() const { return empty(); }





  constexpr bool empty() const { return size() == 0; }


                         reference operator[](index_type idx) const
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(idx < storage_.size())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(idx < storage_.size()))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "idx < storage_.size()" ")"); do { *((volatile int*) __null) = 768; ::abort(); } while (0); } } while (0);
    return data()[idx];
  }




  constexpr reference at(index_type idx) const { return this->operator[](idx); }

  constexpr reference operator()(index_type idx) const
  {
    return this->operator[](idx);
  }




  constexpr pointer Elements() const { return data(); }




  constexpr pointer data() const { return storage_.data(); }


  iterator begin() const { return { this, 0 }; }
  iterator end() const { return { this, Length() }; }

  const_iterator cbegin() const { return { this, 0 }; }
  const_iterator cend() const { return { this, Length() }; }

  reverse_iterator rbegin() const
  {
    return reverse_iterator{ end() };
  }
  reverse_iterator rend() const
  {
    return reverse_iterator{ begin() };
  }

  const_reverse_iterator crbegin() const
  {
    return const_reverse_iterator{ cend() };
  }
  const_reverse_iterator crend() const
  {
    return const_reverse_iterator{ cbegin() };
  }

private:



  template<class ExtentType>
  class storage_type : public ExtentType
  {
  public:
    template<class OtherExtentType>
                                 storage_type(pointer elements,
                                              OtherExtentType ext)
      : ExtentType(ext)
      , data_(elements)
    {
      do { static_assert(mozilla::detail::AssertionConditionType<decltype((!elements && ExtentType::size() == 0) || (elements && ExtentType::size() != mozilla::MaxValue<size_t>::value))>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!((!elements && ExtentType::size() == 0) || (elements && ExtentType::size() != mozilla::MaxValue<size_t>::value)))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "(!elements && ExtentType::size() == 0) || (elements && ExtentType::size() != mozilla::MaxValue<size_t>::value)" ")"); do { *((volatile int*) __null) = 833; ::abort(); } while (0); } } while (0);


    }

    constexpr pointer data() const { return data_; }

  private:
    pointer data_;
  };

  storage_type<span_details::extent_type<Extent>> storage_;
};


template<class ElementType, size_t FirstExtent, size_t SecondExtent>
inline constexpr bool
operator==(const Span<ElementType, FirstExtent>& l,
           const Span<ElementType, SecondExtent>& r)
{
  return (l.size() == r.size()) && std::equal(l.begin(), l.end(), r.begin());
}

template<class ElementType, size_t Extent>
inline constexpr bool
operator!=(const Span<ElementType, Extent>& l,
           const Span<ElementType, Extent>& r)
{
  return !(l == r);
}

template<class ElementType, size_t Extent>
inline constexpr bool
operator<(const Span<ElementType, Extent>& l,
          const Span<ElementType, Extent>& r)
{
  return std::lexicographical_compare(l.begin(), l.end(), r.begin(), r.end());
}

template<class ElementType, size_t Extent>
inline constexpr bool
operator<=(const Span<ElementType, Extent>& l,
           const Span<ElementType, Extent>& r)
{
  return !(l > r);
}

template<class ElementType, size_t Extent>
inline constexpr bool
operator>(const Span<ElementType, Extent>& l,
          const Span<ElementType, Extent>& r)
{
  return r < l;
}

template<class ElementType, size_t Extent>
inline constexpr bool
operator>=(const Span<ElementType, Extent>& l,
           const Span<ElementType, Extent>& r)
{
  return !(l < r);
}

namespace span_details {






template<class ElementType, size_t Extent>
struct calculate_byte_size
  : mozilla::IntegralConstant<size_t,
                           static_cast<size_t>(sizeof(ElementType) *
                                               static_cast<size_t>(Extent))>
{
};

template<class ElementType>
struct calculate_byte_size<ElementType, dynamic_extent>
  : mozilla::IntegralConstant<size_t, dynamic_extent>
{
};
}





template<class ElementType, size_t Extent>
Span<const uint8_t,
     span_details::calculate_byte_size<ElementType, Extent>::value>
AsBytes(Span<ElementType, Extent> s)
{
  return { reinterpret_cast<const uint8_t*>(s.data()), s.size_bytes() };
}




template<class ElementType,
         size_t Extent,
         class = span_details::enable_if_t<!mozilla::IsConst<ElementType>::value>>
Span<uint8_t, span_details::calculate_byte_size<ElementType, Extent>::value>
AsWritableBytes(Span<ElementType, Extent> s)
{
  return { reinterpret_cast<uint8_t*>(s.data()), s.size_bytes() };
}







template<class ElementType>
Span<ElementType>
MakeSpan(ElementType* aPtr, typename Span<ElementType>::index_type aLength)
{
  return Span<ElementType>(aPtr, aLength);
}




template<class ElementType>
Span<ElementType>
MakeSpan(ElementType* aStartPtr, ElementType* aEndPtr)
{
  return Span<ElementType>(aStartPtr, aEndPtr);
}




template<class ElementType, size_t N>
Span<ElementType> MakeSpan(ElementType (&aArr)[N])
{
  return Span<ElementType>(aArr);
}




template<class ElementType, size_t N>
Span<ElementType>
MakeSpan(mozilla::Array<ElementType, N>& aArr)
{
  return aArr;
}




template<class ElementType, size_t N>
Span<const ElementType>
MakeSpan(const mozilla::Array<ElementType, N>& arr)
{
  return arr;
}




template<class Container>
Span<typename Container::value_type>
MakeSpan(Container& cont)
{
  return Span<typename Container::value_type>(cont);
}




template<class Container>
Span<const typename Container::value_type>
MakeSpan(const Container& cont)
{
  return Span<const typename Container::value_type>(cont);
}




template<class Ptr>
Span<typename Ptr::element_type>
MakeSpan(Ptr& aPtr, size_t aLength)
{
  return Span<typename Ptr::element_type>(aPtr, aLength);
}




inline Span<const char>
MakeStringSpan(const char* aZeroTerminated)
{
  return Span<const char>(aZeroTerminated, std::strlen(aZeroTerminated));
}




inline Span<const char16_t>
MakeStringSpan(const char16_t* aZeroTerminated)
{
  return Span<const char16_t>(aZeroTerminated, span_details::strlen16(aZeroTerminated));
}

}



namespace mozilla {
template<typename IndexType,
         IndexType SizeAsEnumValue,
         typename ValueType>
class EnumeratedArray
{
public:
  static const size_t kSize = size_t(SizeAsEnumValue);

private:
  typedef Array<ValueType, kSize> ArrayType;

  ArrayType mArray;

public:
  EnumeratedArray() {}

  template <typename... Args>
               EnumeratedArray(Args&&... aArgs)
    : mArray{mozilla::Forward<Args>(aArgs)...}
  {}

  explicit EnumeratedArray(const EnumeratedArray& aOther)
  {
    for (size_t i = 0; i < kSize; i++) {
      mArray[i] = aOther.mArray[i];
    }
  }

  EnumeratedArray(EnumeratedArray&& aOther)
  {
    for (size_t i = 0; i < kSize; i++) {
      mArray[i] = Move(aOther.mArray[i]);
    }
  }

  ValueType& operator[](IndexType aIndex)
  {
    return mArray[size_t(aIndex)];
  }

  const ValueType& operator[](IndexType aIndex) const
  {
    return mArray[size_t(aIndex)];
  }

  typedef typename ArrayType::iterator iterator;
  typedef typename ArrayType::const_iterator const_iterator;
  typedef typename ArrayType::reverse_iterator reverse_iterator;
  typedef typename ArrayType::const_reverse_iterator const_reverse_iterator;


  iterator begin() { return mArray.begin(); }
  const_iterator begin() const { return mArray.begin(); }
  const_iterator cbegin() const { return mArray.cbegin(); }
  iterator end() { return mArray.end(); }
  const_iterator end() const { return mArray.end(); }
  const_iterator cend() const { return mArray.cend(); }


  reverse_iterator rbegin() { return mArray.rbegin(); }
  const_reverse_iterator rbegin() const { return mArray.rbegin(); }
  const_reverse_iterator crbegin() const { return mArray.crbegin(); }
  reverse_iterator rend() { return mArray.rend(); }
  const_reverse_iterator rend() const { return mArray.rend(); }
  const_reverse_iterator crend() const { return mArray.crend(); }
};

}
namespace mozilla {

template<typename T>
class LinkedListElement;

namespace detail {






template<typename T>
struct LinkedListElementTraits
{
  typedef T* RawType;
  typedef const T* ConstRawType;
  typedef T* ClientType;
  typedef const T* ConstClientType;






  static void enterList(LinkedListElement<T>* elt) {}
  static void exitList(LinkedListElement<T>* elt) {}
};

template<typename T>
struct LinkedListElementTraits<RefPtr<T>>
{
  typedef T* RawType;
  typedef const T* ConstRawType;
  typedef RefPtr<T> ClientType;
  typedef RefPtr<const T> ConstClientType;

  static void enterList(LinkedListElement<RefPtr<T>>* elt) { elt->asT()->AddRef(); }
  static void exitList(LinkedListElement<RefPtr<T>>* elt) { elt->asT()->Release(); }
};

}

template<typename T>
class LinkedList;

template<typename T>
class LinkedListElement
{
  typedef typename detail::LinkedListElementTraits<T> Traits;
  typedef typename Traits::RawType RawType;
  typedef typename Traits::ConstRawType ConstRawType;
  typedef typename Traits::ClientType ClientType;
  typedef typename Traits::ConstClientType ConstClientType;
private:
  LinkedListElement* mNext;
  LinkedListElement* mPrev;
  const bool mIsSentinel;

public:
  LinkedListElement()
    : mNext(this),
      mPrev(this),
      mIsSentinel(false)
  { }





  LinkedListElement(LinkedListElement<T>&& aOther)
    : mIsSentinel(aOther.mIsSentinel)
  {
    adjustLinkForMove(Move(aOther));
  }

  LinkedListElement& operator=(LinkedListElement<T>&& aOther)
  {
    do { } while (0);
    do { } while (0);

    adjustLinkForMove(Move(aOther));
    return *this;
  }

  ~LinkedListElement()
  {
    if (!mIsSentinel && isInList()) {
      remove();
    }
  }





  RawType getNext() { return mNext->asT(); }
  ConstRawType getNext() const { return mNext->asT(); }





  RawType getPrevious() { return mPrev->asT(); }
  ConstRawType getPrevious() const { return mPrev->asT(); }





  void setNext(RawType aElem)
  {
    do { } while (0);
    setNextUnsafe(aElem);
  }






  void setPrevious(RawType aElem)
  {
    do { } while (0);
    setPreviousUnsafe(aElem);
  }





  void remove()
  {
    do { } while (0);

    mPrev->mNext = mNext;
    mNext->mPrev = mPrev;
    mNext = this;
    mPrev = this;

    Traits::exitList(this);
  }






  ClientType removeAndGetNext()
  {
    ClientType r = getNext();
    remove();
    return r;
  }






  ClientType removeAndGetPrevious()
  {
    ClientType r = getPrevious();
    remove();
    return r;
  }





  void removeFrom(const LinkedList<T>& aList)
  {
    aList.assertContains(asT());
    remove();
  }




  bool isInList() const
  {
    do { } while (0);
    return mNext != this;
  }

private:
  friend class LinkedList<T>;
  friend struct detail::LinkedListElementTraits<T>;

  enum class NodeKind {
    Normal,
    Sentinel
  };

  explicit LinkedListElement(NodeKind nodeKind)
    : mNext(this),
      mPrev(this),
      mIsSentinel(nodeKind == NodeKind::Sentinel)
  { }





  RawType asT()
  {
    return mIsSentinel ? nullptr : static_cast<RawType>(this);
  }
  ConstRawType asT() const
  {
    return mIsSentinel ? nullptr : static_cast<ConstRawType>(this);
  }





  void setNextUnsafe(RawType aElem)
  {
    LinkedListElement *listElem = static_cast<LinkedListElement*>(aElem);
    do { } while (0);

    listElem->mNext = this->mNext;
    listElem->mPrev = this;
    this->mNext->mPrev = listElem;
    this->mNext = listElem;

    Traits::enterList(aElem);
  }





  void setPreviousUnsafe(RawType aElem)
  {
    LinkedListElement<T>* listElem = static_cast<LinkedListElement<T>*>(aElem);
    do { } while (0);

    listElem->mNext = this;
    listElem->mPrev = this->mPrev;
    this->mPrev->mNext = listElem;
    this->mPrev = listElem;

    Traits::enterList(aElem);
  }





  void adjustLinkForMove(LinkedListElement<T>&& aOther)
  {
    if (!aOther.isInList()) {
      mNext = this;
      mPrev = this;
      return;
    }

    if (!mIsSentinel) {
      Traits::enterList(this);
    }

    do { } while (0);
    do { } while (0);





    mNext = aOther.mNext;
    mPrev = aOther.mPrev;

    mNext->mPrev = this;
    mPrev->mNext = this;





    aOther.mNext = &aOther;
    aOther.mPrev = &aOther;

    if (!mIsSentinel) {
      Traits::exitList(&aOther);
    }
  }

  LinkedListElement& operator=(const LinkedListElement<T>& aOther) = delete;
  LinkedListElement(const LinkedListElement<T>& aOther) = delete;
};

template<typename T>
class LinkedList
{
private:
  typedef typename detail::LinkedListElementTraits<T> Traits;
  typedef typename Traits::RawType RawType;
  typedef typename Traits::ConstRawType ConstRawType;
  typedef typename Traits::ClientType ClientType;
  typedef typename Traits::ConstClientType ConstClientType;

  LinkedListElement<T> sentinel;

public:
  class Iterator {
    RawType mCurrent;

  public:
    explicit Iterator(RawType aCurrent) : mCurrent(aCurrent) {}

    RawType operator *() const {
      return mCurrent;
    }

    const Iterator& operator++() {
      mCurrent = mCurrent->getNext();
      return *this;
    }

    bool operator!=(Iterator& aOther) const {
      return mCurrent != aOther.mCurrent;
    }
  };

  LinkedList() : sentinel(LinkedListElement<T>::NodeKind::Sentinel) { }

  LinkedList(LinkedList<T>&& aOther)
    : sentinel(mozilla::Move(aOther.sentinel))
  { }

  LinkedList& operator=(LinkedList<T>&& aOther)
  {
    do { } while (0);
    sentinel = mozilla::Move(aOther.sentinel);
    return *this;
  }

  ~LinkedList() {
    do { } while (0);



  }




  void insertFront(RawType aElem)
  {

    sentinel.setNextUnsafe(aElem);
  }




  void insertBack(RawType aElem)
  {
    sentinel.setPreviousUnsafe(aElem);
  }




  RawType getFirst() { return sentinel.getNext(); }
  ConstRawType getFirst() const { return sentinel.getNext(); }




  RawType getLast() { return sentinel.getPrevious(); }
  ConstRawType getLast() const { return sentinel.getPrevious(); }





  ClientType popFirst()
  {
    ClientType ret = sentinel.getNext();
    if (ret) {
      static_cast<LinkedListElement<T>*>(RawType(ret))->remove();
    }
    return ret;
  }





  ClientType popLast()
  {
    ClientType ret = sentinel.getPrevious();
    if (ret) {
      static_cast<LinkedListElement<T>*>(RawType(ret))->remove();
    }
    return ret;
  }




  bool isEmpty() const
  {
    return !sentinel.isInList();
  }







  void clear()
  {
    while (popFirst()) {
      continue;
    }
  }






  Iterator begin() {
    return Iterator(getFirst());
  }
  Iterator end() {
    return Iterator(nullptr);
  }







  size_t sizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const
  {
    size_t n = 0;
    for (const T* t = getFirst(); t; t = t->getNext()) {
      n += aMallocSizeOf(t);
    }
    return n;
  }




  size_t sizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const
  {
    return aMallocSizeOf(this) + sizeOfExcludingThis(aMallocSizeOf);
  }





  void debugAssertIsSane() const
  {
  }

private:
  friend class LinkedListElement<T>;

  void assertContains(const RawType aValue) const
  {
  }

  LinkedList& operator=(const LinkedList<T>& aOther) = delete;
  LinkedList(const LinkedList<T>& aOther) = delete;
};

template <typename T>
class AutoCleanLinkedList : public LinkedList<T>
{
public:
  ~AutoCleanLinkedList()
  {
    while (T* element = this->popFirst()) {
      delete element;
    }
  }
};

}








namespace mozilla {
template<class T>
__attribute__((always_inline)) inline size_t
PointerRangeSize(T* aBegin, T* aEnd)
{
  do { } while (0);
  return (size_t(aEnd) - size_t(aBegin)) / sizeof(T);
}







template<typename T, size_t N>
constexpr size_t
ArrayLength(T (&aArr)[N])
{
  return N;
}

template<typename T, size_t N>
constexpr size_t
ArrayLength(const Array<T, N>& aArr)
{
  return N;
}

template<typename E, E N, typename T>
constexpr size_t
ArrayLength(const EnumeratedArray<E, N, T>& aArr)
{
  return size_t(N);
}






template<typename T, size_t N>
constexpr T*
ArrayEnd(T (&aArr)[N])
{
  return aArr + ArrayLength(aArr);
}

template<typename T, size_t N>
constexpr T*
ArrayEnd(Array<T, N>& aArr)
{
  return &aArr[0] + ArrayLength(aArr);
}

template<typename T, size_t N>
constexpr const T*
ArrayEnd(const Array<T, N>& aArr)
{
  return &aArr[0] + ArrayLength(aArr);
}

namespace detail {

template<typename AlignType, typename Pointee,
         typename = EnableIf<!IsVoid<AlignType>::value>>
struct AlignedChecker
{
  static void
  test(const Pointee* aPtr)
  {
    do { } while (0);

  }
};

template<typename AlignType, typename Pointee>
struct AlignedChecker<AlignType, Pointee>
{
  static void
  test(const Pointee* aPtr)
  {
  }
};

}
template<typename T, typename U>
inline typename EnableIf<IsSame<T, U>::value ||
                         IsBaseOf<T, U>::value ||
                         IsVoid<T>::value,
                         bool>::Type
IsInRange(const T* aPtr, const U* aBegin, const U* aEnd)
{
  do { } while (0);
  detail::AlignedChecker<U, T>::test(aPtr);
  detail::AlignedChecker<U, U>::test(aBegin);
  detail::AlignedChecker<U, U>::test(aEnd);
  return aBegin <= reinterpret_cast<const U*>(aPtr) &&
         reinterpret_cast<const U*>(aPtr) < aEnd;
}






template<typename T>
inline bool
IsInRange(const T* aPtr, uintptr_t aBegin, uintptr_t aEnd)
{
  return IsInRange(aPtr,
                   reinterpret_cast<const T*>(aBegin),
                   reinterpret_cast<const T*>(aEnd));
}

namespace detail {





template <typename T, size_t N>
char (&ArrayLengthHelper(T (&array)[N]))[N];

}

}





namespace mozilla {


template<typename T>
static __attribute__((always_inline)) inline void
PodZero(T* aT)
{
  memset(aT, 0, sizeof(T));
}


template<typename T>
static __attribute__((always_inline)) inline void
PodZero(T* aT, size_t aNElem)
{





  for (T* end = aT + aNElem; aT < end; aT++) {
    memset(aT, 0, sizeof(T));
  }
}
template<typename T, size_t N>
static void PodZero(T (&aT)[N]) = delete;
template<typename T, size_t N>
static void PodZero(T (&aT)[N], size_t aNElem) = delete;


template <class T, size_t N>
static __attribute__((always_inline)) inline void
PodArrayZero(T (&aT)[N])
{
  memset(aT, 0, N * sizeof(T));
}

template <typename T, size_t N>
static __attribute__((always_inline)) inline void
PodArrayZero(Array<T, N>& aArr)
{
  memset(&aArr[0], 0, N * sizeof(T));
}





template<typename T>
static __attribute__((always_inline)) inline void
PodAssign(T* aDst, const T* aSrc)
{
  do { } while (0);

  memcpy(reinterpret_cast<char*>(aDst), reinterpret_cast<const char*>(aSrc),
         sizeof(T));
}





template<typename T>
static __attribute__((always_inline)) inline void
PodCopy(T* aDst, const T* aSrc, size_t aNElem)
{
  do { } while (0);

  if (aNElem < 128) {




    for (const T* srcend = aSrc + aNElem; aSrc < srcend; aSrc++, aDst++) {
      PodAssign(aDst, aSrc);
    }
  } else {
    memcpy(aDst, aSrc, aNElem * sizeof(T));
  }
}

template<typename T>
static __attribute__((always_inline)) inline void
PodCopy(volatile T* aDst, const volatile T* aSrc, size_t aNElem)
{
  do { } while (0);
  for (const volatile T* srcend = aSrc + aNElem;
       aSrc < srcend;
       aSrc++, aDst++) {
    *aDst = *aSrc;
  }
}





template <class T, size_t N>
static __attribute__((always_inline)) inline void
PodArrayCopy(T (&aDst)[N], const T (&aSrc)[N])
{
  PodCopy(aDst, aSrc, N);
}







template<typename T>
static __attribute__((always_inline)) inline void
PodMove(T* aDst, const T* aSrc, size_t aNElem)
{
  do { } while (0);

  memmove(aDst, aSrc, aNElem * sizeof(T));
}





template<typename T>
static __attribute__((always_inline)) inline bool
PodEqual(const T* one, const T* two, size_t len)
{
  if (len < 128) {
    const T* p1end = one + len;
    const T* p1 = one;
    const T* p2 = two;
    for (; p1 < p1end; p1++, p2++) {
      if (*p1 != *p2) {
        return false;
      }
    }
    return true;
  }

  return !memcmp(one, two, len * sizeof(T));
}





template <class T, size_t N>
static __attribute__((always_inline)) inline bool
PodEqual(const T (&one)[N], const T (&two)[N])
{
  return PodEqual(one, two, N);
}

}

namespace mozilla {
template<typename T>
class DebugOnly
{
public:
  DebugOnly() { }
               DebugOnly(const T&) { }
  DebugOnly(const DebugOnly&) { }
  DebugOnly& operator=(const T&) { return *this; }
  void operator++(int) { }
  void operator--(int) { }
  DebugOnly& operator+=(const T&) { return *this; }
  DebugOnly& operator-=(const T&) { return *this; }
  DebugOnly& operator&=(const T&) { return *this; }
  DebugOnly& operator|=(const T&) { return *this; }
  DebugOnly& operator^=(const T&) { return *this; }







  ~DebugOnly() {}
};

}
namespace mozilla {

namespace detail {






template<typename T, size_t Size = sizeof(T)>
struct Swapper;

template<typename T>
struct Swapper<T, 2>
{
  static T swap(T aValue)
  {

    return __builtin_bswap16(aValue);



  }
};

template<typename T>
struct Swapper<T, 4>
{
  static T swap(T aValue)
  {

    return T(__builtin_bswap32(aValue));
  }
};

template<typename T>
struct Swapper<T, 8>
{
  static inline T swap(T aValue)
  {

    return T(__builtin_bswap64(aValue));
  }
};

enum Endianness { Little, Big };







class EndianUtils
{




  static void assertNoOverlap(const void* aDest, const void* aSrc,
                              size_t aCount)
  {
    DebugOnly<const uint8_t*> byteDestPtr = static_cast<const uint8_t*>(aDest);
    DebugOnly<const uint8_t*> byteSrcPtr = static_cast<const uint8_t*>(aSrc);
    do { } while (0);



  }

  template<typename T>
  static void assertAligned(T* aPtr)
  {
    do { } while (0);
  }

protected:




  template<Endianness SourceEndian, Endianness DestEndian, typename T>
  static inline T maybeSwap(T aValue)
  {
    if (SourceEndian == DestEndian) {
      return aValue;
    }
    return Swapper<T>::swap(aValue);
  }





  template<Endianness SourceEndian, Endianness DestEndian, typename T>
  static inline void maybeSwapInPlace(T* aPtr, size_t aCount)
  {
    assertAligned(aPtr);

    if (SourceEndian == DestEndian) {
      return;
    }
    for (size_t i = 0; i < aCount; i++) {
      aPtr[i] = Swapper<T>::swap(aPtr[i]);
    }
  }





  template<Endianness SourceEndian, Endianness DestEndian, typename T>
  static void copyAndSwapTo(void* aDest, const T* aSrc, size_t aCount)
  {
    assertNoOverlap(aDest, aSrc, aCount * sizeof(T));
    assertAligned(aSrc);

    if (SourceEndian == DestEndian) {
      memcpy(aDest, aSrc, aCount * sizeof(T));
      return;
    }

    uint8_t* byteDestPtr = static_cast<uint8_t*>(aDest);
    for (size_t i = 0; i < aCount; ++i) {
      union
      {
        T mVal;
        uint8_t mBuffer[sizeof(T)];
      } u;
      u.mVal = maybeSwap<SourceEndian, DestEndian>(aSrc[i]);
      memcpy(byteDestPtr, u.mBuffer, sizeof(T));
      byteDestPtr += sizeof(T);
    }
  }





  template<Endianness SourceEndian, Endianness DestEndian, typename T>
  static void copyAndSwapFrom(T* aDest, const void* aSrc, size_t aCount)
  {
    assertNoOverlap(aDest, aSrc, aCount * sizeof(T));
    assertAligned(aDest);

    if (SourceEndian == DestEndian) {
      memcpy(aDest, aSrc, aCount * sizeof(T));
      return;
    }

    const uint8_t* byteSrcPtr = static_cast<const uint8_t*>(aSrc);
    for (size_t i = 0; i < aCount; ++i) {
      union
      {
        T mVal;
        uint8_t mBuffer[sizeof(T)];
      } u;
      memcpy(u.mBuffer, byteSrcPtr, sizeof(T));
      aDest[i] = maybeSwap<SourceEndian, DestEndian>(u.mVal);
      byteSrcPtr += sizeof(T);
    }
  }
};

template<Endianness ThisEndian>
class Endian : private EndianUtils
{
protected:

  static __attribute__ ((warn_unused_result)) uint16_t readUint16(const void* aPtr)
  {
    return read<uint16_t>(aPtr);
  }


  static __attribute__ ((warn_unused_result)) uint32_t readUint32(const void* aPtr)
  {
    return read<uint32_t>(aPtr);
  }


  static __attribute__ ((warn_unused_result)) uint64_t readUint64(const void* aPtr)
  {
    return read<uint64_t>(aPtr);
  }


  static __attribute__ ((warn_unused_result)) int16_t readInt16(const void* aPtr)
  {
    return read<int16_t>(aPtr);
  }


  static __attribute__ ((warn_unused_result)) int32_t readInt32(const void* aPtr)
  {
    return read<uint32_t>(aPtr);
  }


  static __attribute__ ((warn_unused_result)) int64_t readInt64(const void* aPtr)
  {
    return read<int64_t>(aPtr);
  }


  static void writeUint16(void* aPtr, uint16_t aValue)
  {
    write(aPtr, aValue);
  }


  static void writeUint32(void* aPtr, uint32_t aValue)
  {
    write(aPtr, aValue);
  }


  static void writeUint64(void* aPtr, uint64_t aValue)
  {
    write(aPtr, aValue);
  }


  static void writeInt16(void* aPtr, int16_t aValue)
  {
    write(aPtr, aValue);
  }


  static void writeInt32(void* aPtr, int32_t aValue)
  {
    write(aPtr, aValue);
  }


  static void writeInt64(void* aPtr, int64_t aValue)
  {
    write(aPtr, aValue);
  }
  template<typename T>
  __attribute__ ((warn_unused_result)) static T swapToLittleEndian(T aValue)
  {
    return maybeSwap<ThisEndian, Little>(aValue);
  }






  template<typename T>
  static void copyAndSwapToLittleEndian(void* aDest, const T* aSrc,
                                        size_t aCount)
  {
    copyAndSwapTo<ThisEndian, Little>(aDest, aSrc, aCount);
  }




  template<typename T>
  static void swapToLittleEndianInPlace(T* aPtr, size_t aCount)
  {
    maybeSwapInPlace<ThisEndian, Little>(aPtr, aCount);
  }




  template<typename T>
  __attribute__ ((warn_unused_result)) static T swapToBigEndian(T aValue)
  {
    return maybeSwap<ThisEndian, Big>(aValue);
  }






  template<typename T>
  static void copyAndSwapToBigEndian(void* aDest, const T* aSrc,
                                     size_t aCount)
  {
    copyAndSwapTo<ThisEndian, Big>(aDest, aSrc, aCount);
  }




  template<typename T>
  static void swapToBigEndianInPlace(T* aPtr, size_t aCount)
  {
    maybeSwapInPlace<ThisEndian, Big>(aPtr, aCount);
  }






  template<typename T>
  __attribute__ ((warn_unused_result)) static T swapToNetworkOrder(T aValue)
  {
    return swapToBigEndian(aValue);
  }

  template<typename T>
  static void
  copyAndSwapToNetworkOrder(void* aDest, const T* aSrc, size_t aCount)
  {
    copyAndSwapToBigEndian(aDest, aSrc, aCount);
  }

  template<typename T>
  static void
  swapToNetworkOrderInPlace(T* aPtr, size_t aCount)
  {
    swapToBigEndianInPlace(aPtr, aCount);
  }




  template<typename T>
  __attribute__ ((warn_unused_result)) static T swapFromLittleEndian(T aValue)
  {
    return maybeSwap<Little, ThisEndian>(aValue);
  }






  template<typename T>
  static void copyAndSwapFromLittleEndian(T* aDest, const void* aSrc,
                                          size_t aCount)
  {
    copyAndSwapFrom<Little, ThisEndian>(aDest, aSrc, aCount);
  }




  template<typename T>
  static void swapFromLittleEndianInPlace(T* aPtr, size_t aCount)
  {
    maybeSwapInPlace<Little, ThisEndian>(aPtr, aCount);
  }




  template<typename T>
  __attribute__ ((warn_unused_result)) static T swapFromBigEndian(T aValue)
  {
    return maybeSwap<Big, ThisEndian>(aValue);
  }






  template<typename T>
  static void copyAndSwapFromBigEndian(T* aDest, const void* aSrc,
                                       size_t aCount)
  {
    copyAndSwapFrom<Big, ThisEndian>(aDest, aSrc, aCount);
  }




  template<typename T>
  static void swapFromBigEndianInPlace(T* aPtr, size_t aCount)
  {
    maybeSwapInPlace<Big, ThisEndian>(aPtr, aCount);
  }





  template<typename T>
  __attribute__ ((warn_unused_result)) static T swapFromNetworkOrder(T aValue)
  {
    return swapFromBigEndian(aValue);
  }

  template<typename T>
  static void copyAndSwapFromNetworkOrder(T* aDest, const void* aSrc,
                                          size_t aCount)
  {
    copyAndSwapFromBigEndian(aDest, aSrc, aCount);
  }

  template<typename T>
  static void swapFromNetworkOrderInPlace(T* aPtr, size_t aCount)
  {
    swapFromBigEndianInPlace(aPtr, aCount);
  }

private:




  template<typename T>
  static T read(const void* aPtr)
  {
    union
    {
      T mVal;
      uint8_t mBuffer[sizeof(T)];
    } u;
    memcpy(u.mBuffer, aPtr, sizeof(T));
    return maybeSwap<ThisEndian, detail::Little>(u.mVal);
  }





  template<typename T>
  static void write(void* aPtr, T aValue)
  {
    T tmp = maybeSwap<detail::Little, ThisEndian>(aValue);
    memcpy(aPtr, &tmp, sizeof(T));
  }

  Endian() = delete;
  Endian(const Endian& aTther) = delete;
  void operator=(const Endian& aOther) = delete;
};

template<Endianness ThisEndian>
class EndianReadWrite : public Endian<ThisEndian>
{
private:
  typedef Endian<ThisEndian> super;

public:
  using super::readUint16;
  using super::readUint32;
  using super::readUint64;
  using super::readInt16;
  using super::readInt32;
  using super::readInt64;
  using super::writeUint16;
  using super::writeUint32;
  using super::writeUint64;
  using super::writeInt16;
  using super::writeInt32;
  using super::writeInt64;
};

}

class LittleEndian final : public detail::EndianReadWrite<detail::Little>
{};

class BigEndian final : public detail::EndianReadWrite<detail::Big>
{};

typedef BigEndian NetworkEndian;

class NativeEndian final : public detail::Endian<detail::Little>
{
private:
  typedef detail::Endian<detail::Little> super;

public:





  using super::swapToLittleEndian;
  using super::copyAndSwapToLittleEndian;
  using super::swapToLittleEndianInPlace;
  using super::swapToBigEndian;
  using super::copyAndSwapToBigEndian;
  using super::swapToBigEndianInPlace;
  using super::swapToNetworkOrder;
  using super::copyAndSwapToNetworkOrder;
  using super::swapToNetworkOrderInPlace;






  using super::swapFromLittleEndian;
  using super::copyAndSwapFromLittleEndian;
  using super::swapFromLittleEndianInPlace;
  using super::swapFromBigEndian;
  using super::copyAndSwapFromBigEndian;
  using super::swapFromBigEndianInPlace;
  using super::swapFromNetworkOrder;
  using super::copyAndSwapFromNetworkOrder;
  using super::swapFromNetworkOrderInPlace;
};



}

namespace mozilla {
enum NotNullTag {
  KnownNotNull,
};
}
inline void*
operator new(size_t, mozilla::NotNullTag, void* p)
{
  do { } while (0);
  return p;
}






namespace mozilla {

template<typename... Ts>
class Variant;

namespace detail {

template <typename...>
struct FirstTypeIsInRest;

template <typename First>
struct FirstTypeIsInRest<First> : FalseType {};

template <typename First, typename Second, typename... Rest>
struct FirstTypeIsInRest<First, Second, Rest...>
{
  static constexpr bool value =
    IsSame<First, Second>::value ||
    FirstTypeIsInRest<First, Rest...>::value;
};

template <typename...>
struct TypesAreDistinct;

template <>
struct TypesAreDistinct<> : TrueType { };

template<typename First, typename... Rest>
struct TypesAreDistinct<First, Rest...>
{
  static constexpr bool value =
    !FirstTypeIsInRest<First, Rest...>::value &&
    TypesAreDistinct<Rest...>::value;
};






template<typename Needle, typename... Haystack>
struct IsVariant;

template<typename Needle>
struct IsVariant<Needle> : FalseType {};

template<typename Needle, typename... Haystack>
struct IsVariant<Needle, Needle, Haystack...> : TrueType {};

template<typename Needle, typename T, typename... Haystack>
struct IsVariant<Needle, T, Haystack...> : public IsVariant<Needle, Haystack...> { };


template<typename T, typename... Variants>
struct SelectVariantTypeHelper;

template<typename T>
struct SelectVariantTypeHelper<T>
{ };

template<typename T, typename... Variants>
struct SelectVariantTypeHelper<T, T, Variants...>
{
  typedef T Type;
};

template<typename T, typename... Variants>
struct SelectVariantTypeHelper<T, const T, Variants...>
{
  typedef const T Type;
};

template<typename T, typename... Variants>
struct SelectVariantTypeHelper<T, const T&, Variants...>
{
  typedef const T& Type;
};

template<typename T, typename... Variants>
struct SelectVariantTypeHelper<T, T&&, Variants...>
{
  typedef T&& Type;
};

template<typename T, typename Head, typename... Variants>
struct SelectVariantTypeHelper<T, Head, Variants...>
  : public SelectVariantTypeHelper<T, Variants...>
{ };






template <typename T, typename... Variants>
struct SelectVariantType
  : public SelectVariantTypeHelper<typename RemoveConst<typename RemoveReference<T>::Type>::Type,
                                   Variants...>
{ };



template<typename... Ts>
struct VariantTag
{
private:
  static const size_t TypeCount = sizeof...(Ts);

public:
  using Type =
    typename Conditional<TypeCount < 3,
                         bool,
                         typename Conditional<TypeCount < (1 << 8),
                                              uint_fast8_t,
                                              size_t
                                              >::Type
                         >::Type;
};





template<typename Tag, size_t N, typename T, typename U, typename Next, bool isMatch>
struct TagHelper;


template<typename Tag, size_t N, typename T, typename U, typename Next>
struct TagHelper<Tag, N, T, U, Next, false>
{
  static Tag tag() { return Next::template tag<U>(); }
};


template<typename Tag, size_t N, typename T, typename U, typename Next>
struct TagHelper<Tag, N, T, U, Next, true>
{
  static Tag tag() { return Tag(N); }
};







template<typename Tag, size_t N, typename... Ts>
struct VariantImplementation;


template<typename Tag, size_t N, typename T>
struct VariantImplementation<Tag, N, T>
{
  template<typename U>
  static Tag tag() {
    static_assert(mozilla::IsSame<T, U>::value,
                  "mozilla::Variant: tag: bad type!");
    return Tag(N);
  }

  template<typename Variant>
  static void copyConstruct(void* aLhs, const Variant& aRhs) {
    ::new (KnownNotNull, aLhs) T(aRhs.template as<T>());
  }

  template<typename Variant>
  static void moveConstruct(void* aLhs, Variant&& aRhs) {
    ::new (KnownNotNull, aLhs) T(aRhs.template extract<T>());
  }

  template<typename Variant>
  static void destroy(Variant& aV) {
    aV.template as<T>().~T();
  }

  template<typename Variant>
  static bool
  equal(const Variant& aLhs, const Variant& aRhs) {
      return aLhs.template as<T>() == aRhs.template as<T>();
  }

  template<typename Matcher, typename ConcreteVariant>
  static auto
  match(Matcher&& aMatcher, ConcreteVariant& aV)
    -> decltype(aMatcher.match(aV.template as<T>()))
  {
    return aMatcher.match(aV.template as<T>());
  }
};


template<typename Tag, size_t N, typename T, typename... Ts>
struct VariantImplementation<Tag, N, T, Ts...>
{

  using Next = VariantImplementation<Tag, N + 1, Ts...>;

  template<typename U>
  static Tag tag() {
    return TagHelper<Tag, N, T, U, Next, IsSame<T, U>::value>::tag();
  }

  template<typename Variant>
  static void copyConstruct(void* aLhs, const Variant& aRhs) {
    if (aRhs.template is<T>()) {
      ::new (KnownNotNull, aLhs) T(aRhs.template as<T>());
    } else {
      Next::copyConstruct(aLhs, aRhs);
    }
  }

  template<typename Variant>
  static void moveConstruct(void* aLhs, Variant&& aRhs) {
    if (aRhs.template is<T>()) {
      ::new (KnownNotNull, aLhs) T(aRhs.template extract<T>());
    } else {
      Next::moveConstruct(aLhs, aRhs);
    }
  }

  template<typename Variant>
  static void destroy(Variant& aV) {
    if (aV.template is<T>()) {
      aV.template as<T>().~T();
    } else {
      Next::destroy(aV);
    }
  }

  template<typename Variant>
  static bool equal(const Variant& aLhs, const Variant& aRhs) {
    if (aLhs.template is<T>()) {
      do { } while (0);
      return aLhs.template as<T>() == aRhs.template as<T>();
    } else {
      return Next::equal(aLhs, aRhs);
    }
  }

  template<typename Matcher, typename ConcreteVariant>
  static auto
  match(Matcher&& aMatcher, ConcreteVariant& aV)
    -> decltype(aMatcher.match(aV.template as<T>()))
  {
    if (aV.template is<T>()) {
      return aMatcher.match(aV.template as<T>());
    } else {
      return Next::match(aMatcher, aV);
    }
  }
};







template <typename T>
struct AsVariantTemporary
{
  explicit AsVariantTemporary(const T& aValue)
    : mValue(aValue)
  {}

  template<typename U>
  explicit AsVariantTemporary(U&& aValue)
    : mValue(Forward<U>(aValue))
  {}

  AsVariantTemporary(const AsVariantTemporary& aOther)
    : mValue(aOther.mValue)
  {}

  AsVariantTemporary(AsVariantTemporary&& aOther)
    : mValue(Move(aOther.mValue))
  {}

  AsVariantTemporary() = delete;
  void operator=(const AsVariantTemporary&) = delete;
  void operator=(AsVariantTemporary&&) = delete;

  typename RemoveConst<typename RemoveReference<T>::Type>::Type mValue;
};

}
template<typename... Ts>
class Variant
{
  static_assert(detail::TypesAreDistinct<Ts...>::value,
                "Variant with duplicate types is not supported");

  using Tag = typename detail::VariantTag<Ts...>::Type;
  using Impl = detail::VariantImplementation<Tag, 0, Ts...>;

  static constexpr size_t RawDataAlignment = tl::Max<alignof(Ts)...>::value;
  static constexpr size_t RawDataSize = tl::Max<sizeof(Ts)...>::value;


  alignas(RawDataAlignment) unsigned char rawData[RawDataSize];



  Tag tag;





  void* ptr() {
    return rawData;
  }

  const void* ptr() const {
    return rawData;
  }

public:

  template<typename RefT,




           typename T = typename detail::SelectVariantType<RefT, Ts...>::Type>
  explicit Variant(RefT&& aT)
    : tag(Impl::template tag<T>())
  {
    ::new (KnownNotNull, ptr()) T(Forward<RefT>(aT));
  }






  template<typename RefT,
           typename T = typename detail::SelectVariantType<RefT, Ts...>::Type>
               Variant(detail::AsVariantTemporary<RefT>&& aValue)
    : tag(Impl::template tag<T>())
  {
    ::new (KnownNotNull, ptr()) T(Move(aValue.mValue));
  }


  Variant(const Variant& aRhs)
    : tag(aRhs.tag)
  {
    Impl::copyConstruct(ptr(), aRhs);
  }


  Variant(Variant&& aRhs)
    : tag(aRhs.tag)
  {
    Impl::moveConstruct(ptr(), Move(aRhs));
  }


  Variant& operator=(const Variant& aRhs) {
    do { } while (0);
    this->~Variant();
    ::new (KnownNotNull, this) Variant(aRhs);
    return *this;
  }


  Variant& operator=(Variant&& aRhs) {
    do { } while (0);
    this->~Variant();
    ::new (KnownNotNull, this) Variant(Move(aRhs));
    return *this;
  }


  template <typename T>
  Variant& operator=(detail::AsVariantTemporary<T>&& aValue)
  {
    this->~Variant();
    ::new (KnownNotNull, this) Variant(Move(aValue));
    return *this;
  }

  ~Variant()
  {
    Impl::destroy(*this);
  }


  template<typename T>
  bool is() const {
    static_assert(detail::IsVariant<T, Ts...>::value,
                  "provided a type not found in this Variant's type list");
    return Impl::template tag<T>() == tag;
  }





  bool operator==(const Variant& aRhs) const {
    return tag == aRhs.tag && Impl::equal(*this, aRhs);
  }






  bool operator!=(const Variant& aRhs) const {
    return !(*this == aRhs);
  }




  template<typename T>
  T& as() {
    static_assert(detail::IsVariant<T, Ts...>::value,
                  "provided a type not found in this Variant's type list");
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(is<T>())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(is<T>()))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "is<T>()" ")"); do { *((volatile int*) __null) = 581; ::abort(); } while (0); } } while (0);
    return *static_cast<T*>(ptr());
  }


  template<typename T>
  const T& as() const {
    static_assert(detail::IsVariant<T, Ts...>::value,
                  "provided a type not found in this Variant's type list");
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(is<T>())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(is<T>()))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "is<T>()" ")"); do { *((volatile int*) __null) = 590; ::abort(); } while (0); } } while (0);
    return *static_cast<const T*>(ptr());
  }







  template<typename T>
  T extract() {
    static_assert(detail::IsVariant<T, Ts...>::value,
                  "provided a type not found in this Variant's type list");
    do { } while (0);
    return T(Move(as<T>()));
  }




  template<typename Matcher>
  auto
  match(Matcher&& aMatcher) const
    -> decltype(Impl::match(aMatcher, *this))
  {
    return Impl::match(aMatcher, *this);
  }


  template<typename Matcher>
  auto
  match(Matcher&& aMatcher)
    -> decltype(Impl::match(aMatcher, *this))
  {
    return Impl::match(aMatcher, *this);
  }
};
template<typename T>
detail::AsVariantTemporary<T>
AsVariant(T&& aValue)
{
  return detail::AsVariantTemporary<T>(Forward<T>(aValue));
}

}

namespace mozilla {






struct Ok {};

template <typename E> class GenericErrorResult;
template <typename V, typename E> class Result;

namespace detail {

enum class PackingStrategy {
  Variant,
  NullIsOk,
  LowBitTagIsError,
  PackedVariant,
};

template <typename V, typename E, PackingStrategy Strategy>
class ResultImplementation;

template <typename V, typename E>
class ResultImplementation<V, E, PackingStrategy::Variant>
{
  mozilla::Variant<V, E> mStorage;

public:
  explicit ResultImplementation(V aValue) : mStorage(aValue) {}
  explicit ResultImplementation(E aErrorValue) : mStorage(aErrorValue) {}

  bool isOk() const { return mStorage.template is<V>(); }




  V unwrap() const { return mStorage.template as<V>(); }
  E unwrapErr() const { return mStorage.template as<E>(); }
};





template <typename V, typename E>
class ResultImplementation<V, E&, PackingStrategy::Variant>
{
  mozilla::Variant<V, E*> mStorage;

public:
  explicit ResultImplementation(V aValue) : mStorage(aValue) {}
  explicit ResultImplementation(E& aErrorValue) : mStorage(&aErrorValue) {}

  bool isOk() const { return mStorage.template is<V>(); }
  V unwrap() const { return mStorage.template as<V>(); }
  E& unwrapErr() const { return *mStorage.template as<E*>(); }
};





template <typename V, typename E>
class ResultImplementation<V, E&, PackingStrategy::NullIsOk>
{
  E* mErrorValue;

public:
  explicit ResultImplementation(V) : mErrorValue(nullptr) {}
  explicit ResultImplementation(E& aErrorValue) : mErrorValue(&aErrorValue) {}

  bool isOk() const { return mErrorValue == nullptr; }

  V unwrap() const { return V(); }
  E& unwrapErr() const { return *mErrorValue; }
};





template <typename V, typename E>
class ResultImplementation<V*, E&, PackingStrategy::LowBitTagIsError>
{
  uintptr_t mBits;

public:
  explicit ResultImplementation(V* aValue)
    : mBits(reinterpret_cast<uintptr_t>(aValue))
  {
    do { } while (0);

  }
  explicit ResultImplementation(E& aErrorValue)
    : mBits(reinterpret_cast<uintptr_t>(&aErrorValue) | 1)
  {
    do { } while (0);

  }

  bool isOk() const { return (mBits & 1) == 0; }

  V* unwrap() const { return reinterpret_cast<V*>(mBits); }
  E& unwrapErr() const { return *reinterpret_cast<E*>(mBits ^ 1); }
};


template<typename V, typename E>
struct IsPackableVariant
{
  struct VEbool {
      V v;
      E e;
      bool ok;
  };
  struct EVbool {
      E e;
      V v;
      bool ok;
  };

  using Impl = typename Conditional<sizeof(VEbool) <= sizeof(EVbool),
                                    VEbool, EVbool>::Type;

  static const bool value = sizeof(Impl) <= sizeof(uintptr_t);
};





template <typename V, typename E>
class ResultImplementation<V, E, PackingStrategy::PackedVariant>
{
  using Impl = typename IsPackableVariant<V, E>::Impl;
  Impl data;

public:
  explicit ResultImplementation(V aValue)
  {
    data.v = aValue;
    data.ok = true;
  }
  explicit ResultImplementation(E aErrorValue)
  {
    data.e = aErrorValue;
    data.ok = false;
  }

  bool isOk() const { return data.ok; }

  V unwrap() const { return data.v; }
  E unwrapErr() const { return data.e; }
};





template<typename T>
struct UnusedZero
{
  static const bool value = false;
};


template<typename T>
struct UnusedZero<T&>
{
  static const bool value = true;
};




template <typename T> struct HasFreeLSB { static const bool value = false; };




template <typename T> struct HasFreeLSB<T*> {
  static const bool value = (mozilla::AlignmentFinder<T>::alignment & 1) == 0;
};



template <typename T> struct HasFreeLSB<T&> {
  static const bool value = HasFreeLSB<T*>::value;
};



template <typename V, typename E>
struct SelectResultImpl
{
  static const PackingStrategy value =
      (IsEmpty<V>::value && UnusedZero<E>::value)
    ? PackingStrategy::NullIsOk
    : (detail::HasFreeLSB<V>::value && detail::HasFreeLSB<E>::value)
    ? PackingStrategy::LowBitTagIsError
    : (IsDefaultConstructible<V>::value && IsDefaultConstructible<E>::value &&
       IsPackableVariant<V, E>::value)
    ? PackingStrategy::PackedVariant
    : PackingStrategy::Variant;

  using Type = detail::ResultImplementation<V, E, value>;
};

template <typename T>
struct IsResult : FalseType { };

template <typename V, typename E>
struct IsResult<Result<V, E>> : TrueType { };

}
template <typename V, typename E>
class Result final
{
  using Impl = typename detail::SelectResultImpl<V, E>::Type;

  Impl mImpl;

public:



               Result(V aValue) : mImpl(aValue) { do { } while (0); }




  explicit Result(E aErrorValue) : mImpl(aErrorValue) { do { } while (0); }





  template <typename E2>
               Result(const GenericErrorResult<E2>& aErrorResult)
    : mImpl(aErrorResult.mErrorValue)
  {
    static_assert(mozilla::IsConvertible<E2, E>::value,
                  "E2 must be convertible to E");
    do { } while (0);
  }

  Result(const Result&) = default;
  Result& operator=(const Result&) = default;


  bool isOk() const { return mImpl.isOk(); }


  bool isErr() const { return !mImpl.isOk(); }


  V unwrap() const {
    do { } while (0);
    return mImpl.unwrap();
  }


  E unwrapErr() const {
    do { } while (0);
    return mImpl.unwrapErr();
  }
  template<typename F>
  auto map(F f) const -> Result<decltype(f(*((V*) nullptr))), E> {
      using RetResult = Result<decltype(f(*((V*) nullptr))), E>;
      return isOk() ? RetResult(f(unwrap())) : RetResult(unwrapErr());
  }
  template<
      typename F,
      typename = typename EnableIf<
          detail::IsResult<decltype((*((F*) nullptr))(*((V*) nullptr)))>::value
      >::Type
  >
  auto andThen(F f) const -> decltype(f(*((V*) nullptr))) {
      return isOk() ? f(unwrap()) : GenericErrorResult<E>(unwrapErr());
  }
};







template <typename E>
class GenericErrorResult
{
  E mErrorValue;

  template<typename V, typename E2> friend class Result;

public:
  explicit GenericErrorResult(E aErrorValue) : mErrorValue(aErrorValue) {}
};

template <typename E>
inline GenericErrorResult<E>
Err(E&& aErrorValue)
{
  return GenericErrorResult<E>(aErrorValue);
}

}

struct JSContext;
namespace JS {

using mozilla::Ok;





struct Error
{


    int dummy;
};

struct OOM : public Error
{
};
template <typename V = Ok, typename E = Error&>
using Result = mozilla::Result<V, E>;

static_assert(sizeof(Result<>) == sizeof(uintptr_t),
              "Result<> should be pointer-sized");

static_assert(sizeof(Result<int*, Error&>) == sizeof(uintptr_t),
              "Result<V*, Error&> should be pointer-sized");

}




struct JSContext;
class JSFunction;
class JSObject;
class JSScript;
class JSString;
class JSAddonId;

struct jsid;

namespace JS {

typedef unsigned char Latin1Char;

class Symbol;
class Value;
template <typename T> class Handle;
template <typename T> class MutableHandle;
template <typename T> class Rooted;
template <typename T> class PersistentRooted;

typedef Handle<JSFunction*> HandleFunction;
typedef Handle<jsid> HandleId;
typedef Handle<JSObject*> HandleObject;
typedef Handle<JSScript*> HandleScript;
typedef Handle<JSString*> HandleString;
typedef Handle<JS::Symbol*> HandleSymbol;
typedef Handle<Value> HandleValue;

typedef MutableHandle<JSFunction*> MutableHandleFunction;
typedef MutableHandle<jsid> MutableHandleId;
typedef MutableHandle<JSObject*> MutableHandleObject;
typedef MutableHandle<JSScript*> MutableHandleScript;
typedef MutableHandle<JSString*> MutableHandleString;
typedef MutableHandle<JS::Symbol*> MutableHandleSymbol;
typedef MutableHandle<Value> MutableHandleValue;

typedef Rooted<JSObject*> RootedObject;
typedef Rooted<JSFunction*> RootedFunction;
typedef Rooted<JSScript*> RootedScript;
typedef Rooted<JSString*> RootedString;
typedef Rooted<JS::Symbol*> RootedSymbol;
typedef Rooted<jsid> RootedId;
typedef Rooted<JS::Value> RootedValue;

typedef PersistentRooted<JSFunction*> PersistentRootedFunction;
typedef PersistentRooted<jsid> PersistentRootedId;
typedef PersistentRooted<JSObject*> PersistentRootedObject;
typedef PersistentRooted<JSScript*> PersistentRootedScript;
typedef PersistentRooted<JSString*> PersistentRootedString;
typedef PersistentRooted<JS::Symbol*> PersistentRootedSymbol;
typedef PersistentRooted<Value> PersistentRootedValue;

}


namespace js {
class BaseShape;
class LazyScript;
class ObjectGroup;
class RegExpShared;
class Shape;
class Scope;
namespace jit {
class JitCode;
}
}

namespace JS {
enum class TraceKind
{



    Object = 0x00,
    String = 0x02,
    Symbol = 0x03,


    Script = 0x01,


    Shape = 0x04,


    ObjectGroup = 0x05,


    Null = 0x06,


    BaseShape = 0x0F,
    JitCode = 0x1F,
    LazyScript = 0x2F,
    Scope = 0x3F,
    RegExpShared = 0x4F
};
const static uintptr_t OutOfLineTraceKindMask = 0x07;
static_assert(uintptr_t(JS::TraceKind::BaseShape) & OutOfLineTraceKindMask, "mask bits are set");
static_assert(uintptr_t(JS::TraceKind::JitCode) & OutOfLineTraceKindMask, "mask bits are set");
static_assert(uintptr_t(JS::TraceKind::LazyScript) & OutOfLineTraceKindMask, "mask bits are set");
static_assert(uintptr_t(JS::TraceKind::Scope) & OutOfLineTraceKindMask, "mask bits are set");
static_assert(uintptr_t(JS::TraceKind::RegExpShared) & OutOfLineTraceKindMask, "mask bits are set");




template <typename T>
struct MapTypeToTraceKind {
    static const JS::TraceKind kind = T::TraceKind;
};
template <> struct MapTypeToTraceKind<js::BaseShape> { static const JS::TraceKind kind = JS::TraceKind::BaseShape; }; template <> struct MapTypeToTraceKind<js::jit::JitCode> { static const JS::TraceKind kind = JS::TraceKind::JitCode; }; template <> struct MapTypeToTraceKind<js::LazyScript> { static const JS::TraceKind kind = JS::TraceKind::LazyScript; }; template <> struct MapTypeToTraceKind<js::Scope> { static const JS::TraceKind kind = JS::TraceKind::Scope; }; template <> struct MapTypeToTraceKind<JSObject> { static const JS::TraceKind kind = JS::TraceKind::Object; }; template <> struct MapTypeToTraceKind<js::ObjectGroup> { static const JS::TraceKind kind = JS::TraceKind::ObjectGroup; }; template <> struct MapTypeToTraceKind<JSScript> { static const JS::TraceKind kind = JS::TraceKind::Script; }; template <> struct MapTypeToTraceKind<js::Shape> { static const JS::TraceKind kind = JS::TraceKind::Shape; }; template <> struct MapTypeToTraceKind<JSString> { static const JS::TraceKind kind = JS::TraceKind::String; }; template <> struct MapTypeToTraceKind<JS::Symbol> { static const JS::TraceKind kind = JS::TraceKind::Symbol; }; template <> struct MapTypeToTraceKind<js::RegExpShared> { static const JS::TraceKind kind = JS::TraceKind::RegExpShared; };;





enum class RootKind : int8_t
{



BaseShape, JitCode, LazyScript, Scope, Object, ObjectGroup, Script, Shape, String, Symbol, RegExpShared,



    Id,
    Value,


    Traceable,

    Limit
};


template <TraceKind traceKind> struct MapTraceKindToRootKind {};




template <> struct MapTraceKindToRootKind<JS::TraceKind::BaseShape> { static const JS::RootKind kind = JS::RootKind::BaseShape; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::JitCode> { static const JS::RootKind kind = JS::RootKind::JitCode; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::LazyScript> { static const JS::RootKind kind = JS::RootKind::LazyScript; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::Scope> { static const JS::RootKind kind = JS::RootKind::Scope; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::Object> { static const JS::RootKind kind = JS::RootKind::Object; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::ObjectGroup> { static const JS::RootKind kind = JS::RootKind::ObjectGroup; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::Script> { static const JS::RootKind kind = JS::RootKind::Script; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::Shape> { static const JS::RootKind kind = JS::RootKind::Shape; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::String> { static const JS::RootKind kind = JS::RootKind::String; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::Symbol> { static const JS::RootKind kind = JS::RootKind::Symbol; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::RegExpShared> { static const JS::RootKind kind = JS::RootKind::RegExpShared; };





template <typename T>
struct MapTypeToRootKind {
    static const JS::RootKind kind = JS::RootKind::Traceable;
};
template <typename T>
struct MapTypeToRootKind<T*> {
    static const JS::RootKind kind =
        JS::MapTraceKindToRootKind<JS::MapTypeToTraceKind<T>::kind>::kind;
};
template <typename T>
struct MapTypeToRootKind<mozilla::UniquePtr<T>> {
    static const JS::RootKind kind = JS::MapTypeToRootKind<T>::kind;
};
template <> struct MapTypeToRootKind<JS::Value> {
    static const JS::RootKind kind = JS::RootKind::Value;
};
template <> struct MapTypeToRootKind<jsid> {
    static const JS::RootKind kind = JS::RootKind::Id;
};
template <> struct MapTypeToRootKind<JSFunction*> : public MapTypeToRootKind<JSObject*> {};
template <typename F, typename... Args>
auto
DispatchTraceKindTyped(F f, JS::TraceKind traceKind, Args&&... args)
  -> decltype(f. template operator()<JSObject>(mozilla::Forward<Args>(args)...))
{
    switch (traceKind) {



      case JS::TraceKind::BaseShape: return f. template operator()<js::BaseShape>(mozilla::Forward<Args>(args)...); case JS::TraceKind::JitCode: return f. template operator()<js::jit::JitCode>(mozilla::Forward<Args>(args)...); case JS::TraceKind::LazyScript: return f. template operator()<js::LazyScript>(mozilla::Forward<Args>(args)...); case JS::TraceKind::Scope: return f. template operator()<js::Scope>(mozilla::Forward<Args>(args)...); case JS::TraceKind::Object: return f. template operator()<JSObject>(mozilla::Forward<Args>(args)...); case JS::TraceKind::ObjectGroup: return f. template operator()<js::ObjectGroup>(mozilla::Forward<Args>(args)...); case JS::TraceKind::Script: return f. template operator()<JSScript>(mozilla::Forward<Args>(args)...); case JS::TraceKind::Shape: return f. template operator()<js::Shape>(mozilla::Forward<Args>(args)...); case JS::TraceKind::String: return f. template operator()<JSString>(mozilla::Forward<Args>(args)...); case JS::TraceKind::Symbol: return f. template operator()<JS::Symbol>(mozilla::Forward<Args>(args)...); case JS::TraceKind::RegExpShared: return f. template operator()<js::RegExpShared>(mozilla::Forward<Args>(args)...);;

      default:
          do { AnnotateMozCrashReason("MOZ_CRASH(" "Invalid trace kind in DispatchTraceKindTyped." ")"); do { *((volatile int*) __null) = 195; ::abort(); } while (0); } while (0);
    }
}


template <typename F, typename... Args>
auto
DispatchTraceKindTyped(F f, void* thing, JS::TraceKind traceKind, Args&&... args)
  -> decltype(f(static_cast<JSObject*>(nullptr), mozilla::Forward<Args>(args)...))
{
    switch (traceKind) {



      case JS::TraceKind::BaseShape: return f(static_cast<js::BaseShape*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::JitCode: return f(static_cast<js::jit::JitCode*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::LazyScript: return f(static_cast<js::LazyScript*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::Scope: return f(static_cast<js::Scope*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::Object: return f(static_cast<JSObject*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::ObjectGroup: return f(static_cast<js::ObjectGroup*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::Script: return f(static_cast<JSScript*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::Shape: return f(static_cast<js::Shape*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::String: return f(static_cast<JSString*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::Symbol: return f(static_cast<JS::Symbol*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::RegExpShared: return f(static_cast<js::RegExpShared*>(thing), mozilla::Forward<Args>(args)...);;

      default:
          do { AnnotateMozCrashReason("MOZ_CRASH(" "Invalid trace kind in DispatchTraceKindTyped." ")"); do { *((volatile int*) __null) = 212; ::abort(); } while (0); } while (0);
    }
}

}






namespace JS {

class AutoIdVector;
class CallArgs;

template <typename T>
class Rooted;

class CompileOptions;
class ReadOnlyCompileOptions;
class OwningCompileOptions;
class TransitiveCompileOptions;
class CompartmentOptions;

class Value;
struct Zone;

}






enum JSVersion {
    JSVERSION_ECMA_3 = 148,
    JSVERSION_1_6 = 160,
    JSVERSION_1_7 = 170,
    JSVERSION_1_8 = 180,
    JSVERSION_ECMA_5 = 185,
    JSVERSION_DEFAULT = 0,
    JSVERSION_UNKNOWN = -1,
    JSVERSION_LATEST = JSVERSION_ECMA_5
};


enum JSType {
    JSTYPE_UNDEFINED,
    JSTYPE_OBJECT,
    JSTYPE_FUNCTION,
    JSTYPE_STRING,
    JSTYPE_NUMBER,
    JSTYPE_BOOLEAN,
    JSTYPE_NULL,
    JSTYPE_SYMBOL,
    JSTYPE_LIMIT
};


enum JSProtoKey {

    JSProto_Null = 0, JSProto_Object = 1, JSProto_Function = 2, JSProto_Array = 3, JSProto_Boolean = 4, JSProto_JSON = 5, JSProto_Date = 6, JSProto_Math = 7, JSProto_Number = 8, JSProto_String = 9, JSProto_RegExp = 10, JSProto_Error = 11, JSProto_InternalError = 12, JSProto_EvalError = 13, JSProto_RangeError = 14, JSProto_ReferenceError = 15, JSProto_SyntaxError = 16, JSProto_TypeError = 17, JSProto_URIError = 18, JSProto_DebuggeeWouldRun = 19, JSProto_CompileError = 20, JSProto_LinkError = 21, JSProto_RuntimeError = 22, JSProto_Iterator = 23, JSProto_StopIteration = 24, JSProto_ArrayBuffer = 25, JSProto_Int8Array = 26, JSProto_Uint8Array = 27, JSProto_Int16Array = 28, JSProto_Uint16Array = 29, JSProto_Int32Array = 30, JSProto_Uint32Array = 31, JSProto_Float32Array = 32, JSProto_Float64Array = 33, JSProto_Uint8ClampedArray = 34, JSProto_Proxy = 35, JSProto_WeakMap = 36, JSProto_Map = 37, JSProto_Set = 38, JSProto_DataView = 39, JSProto_Symbol = 40, JSProto_SharedArrayBuffer = 41, JSProto_Intl = 42, JSProto_TypedObject = 43, JSProto_Reflect = 44, JSProto_SIMD = 45, JSProto_WeakSet = 46, JSProto_TypedArray = 47, JSProto_Atomics = 48, JSProto_SavedFrame = 49, JSProto_WebAssembly = 50, JSProto_WasmModule = 51, JSProto_WasmInstance = 52, JSProto_WasmMemory = 53, JSProto_WasmTable = 54, JSProto_Promise = 55,

    JSProto_LIMIT
};


struct JSClass;
struct JSCompartment;
struct JSCrossCompartmentCall;
class JSErrorReport;
struct JSExceptionState;
struct JSFunctionSpec;
struct JSLocaleCallbacks;
struct JSObjectMap;
struct JSPrincipals;
struct JSPropertyName;
struct JSPropertySpec;
struct JSRuntime;
struct JSSecurityCallbacks;
struct JSStructuredCloneCallbacks;
struct JSStructuredCloneReader;
struct JSStructuredCloneWriter;
class JSTracer;

class JSFlatString;

typedef bool (*JSInitCallback)(void);

template<typename T> struct JSConstScalarSpec;
typedef JSConstScalarSpec<double> JSConstDoubleSpec;
typedef JSConstScalarSpec<int32_t> JSConstIntegerSpec;





typedef void
(* JSTraceDataOp)(JSTracer* trc, void* data);

namespace js {
namespace gc {
class AutoTraceSession;
class StoreBuffer;
}

class CooperatingContext;

inline JSCompartment* GetContextCompartment(const JSContext* cx);
inline JS::Zone* GetContextZone(const JSContext* cx);



bool
CurrentThreadCanAccessRuntime(const JSRuntime* rt);






}

namespace JS {

class AutoEnterCycleCollection;
class AutoAssertOnBarrier;
struct PropertyDescriptor;

typedef void (*OffThreadCompileCallback)(void* token, void* callbackData);

enum class HeapState {
    Idle,
    Tracing,
    MajorCollecting,
    MinorCollecting,
    CycleCollecting
};

HeapState
CurrentThreadHeapState();

static inline bool
CurrentThreadIsHeapBusy()
{
    return CurrentThreadHeapState() != HeapState::Idle;
}

static inline bool
CurrentThreadIsHeapTracing()
{
    return CurrentThreadHeapState() == HeapState::Tracing;
}

static inline bool
CurrentThreadIsHeapMajorCollecting()
{
    return CurrentThreadHeapState() == HeapState::MajorCollecting;
}

static inline bool
CurrentThreadIsHeapMinorCollecting()
{
    return CurrentThreadHeapState() == HeapState::MinorCollecting;
}

static inline bool
CurrentThreadIsHeapCollecting()
{
    HeapState state = CurrentThreadHeapState();
    return state == HeapState::MajorCollecting || state == HeapState::MinorCollecting;
}

static inline bool
CurrentThreadIsHeapCycleCollecting()
{
    return CurrentThreadHeapState() == HeapState::CycleCollecting;
}



class AutoEnterCycleCollection
{







  public:
    explicit AutoEnterCycleCollection(JSContext* cx) {}
    ~AutoEnterCycleCollection() {}

};

class RootingContext;

class AutoGCRooter
{
  public:
    AutoGCRooter(JSContext* cx, ptrdiff_t tag);
    AutoGCRooter(RootingContext* cx, ptrdiff_t tag);

    ~AutoGCRooter() {
        do { } while (0);
        *stackTop = down;
    }


    inline void trace(JSTracer* trc);
    static void traceAll(const js::CooperatingContext& target, JSTracer* trc);
    static void traceAllWrappers(const js::CooperatingContext& target, JSTracer* trc);

  protected:
    AutoGCRooter * const down;
    ptrdiff_t tag_;

    enum {
        VALARRAY = -2,
        PARSER = -3,
        VALVECTOR = -10,
        IDVECTOR = -11,
        OBJVECTOR = -14,
        IONMASM = -19,
        WRAPVECTOR = -20,
        WRAPPER = -21,
        CUSTOM = -26
    };

    static ptrdiff_t GetTag(const Value& value) { return VALVECTOR; }
    static ptrdiff_t GetTag(const jsid& id) { return IDVECTOR; }
    static ptrdiff_t GetTag(JSObject* obj) { return OBJVECTOR; }

  private:
    AutoGCRooter ** const stackTop;


    AutoGCRooter(AutoGCRooter& ida) = delete;
    void operator=(AutoGCRooter& ida) = delete;
};



template <>
struct MapTypeToRootKind<void*> {
    static const RootKind kind = RootKind::Traceable;
};

using RootedListHeads = mozilla::EnumeratedArray<RootKind, RootKind::Limit,
                                                 Rooted<void*>*>;






enum StackKind
{
    StackForSystemCode,
    StackForTrustedScript,
    StackForUntrustedScript,
    StackKindCount
};



class RootingContext
{

    RootedListHeads stackRoots_;
    template <typename T> friend class JS::Rooted;


    JS::AutoGCRooter* autoGCRooters_;
    friend class JS::AutoGCRooter;

  public:
    RootingContext();

    void traceStackRoots(JSTracer* trc);
    void checkNoGCRooters();

  protected:





    JSCompartment* compartment_;


    JS::Zone* zone_;

  public:

    uintptr_t nativeStackLimit[StackKindCount];

    static const RootingContext* get(const JSContext* cx) {
        return reinterpret_cast<const RootingContext*>(cx);
    }

    static RootingContext* get(JSContext* cx) {
        return reinterpret_cast<RootingContext*>(cx);
    }

    friend JSCompartment* js::GetContextCompartment(const JSContext* cx);
    friend JS::Zone* js::GetContextZone(const JSContext* cx);
};

}

namespace js {
inline JSCompartment*
GetContextCompartment(const JSContext* cx)
{
    return JS::RootingContext::get(cx)->compartment_;
}

inline JS::Zone*
GetContextZone(const JSContext* cx)
{
    return JS::RootingContext::get(cx)->zone_;
}

}

extern "C" {


typedef struct PRFileDesc PRFileDesc;

}
namespace mozilla {
enum MemoryOrdering {
  Relaxed,
  ReleaseAcquire,
  SequentiallyConsistent,
};

}










namespace mozilla {
namespace detail {





template<MemoryOrdering Order> struct AtomicOrderConstraints;

template<>
struct AtomicOrderConstraints<Relaxed>
{
  static const std::memory_order AtomicRMWOrder = std::memory_order_relaxed;
  static const std::memory_order LoadOrder = std::memory_order_relaxed;
  static const std::memory_order StoreOrder = std::memory_order_relaxed;
  static const std::memory_order CompareExchangeFailureOrder =
    std::memory_order_relaxed;
};

template<>
struct AtomicOrderConstraints<ReleaseAcquire>
{
  static const std::memory_order AtomicRMWOrder = std::memory_order_acq_rel;
  static const std::memory_order LoadOrder = std::memory_order_acquire;
  static const std::memory_order StoreOrder = std::memory_order_release;
  static const std::memory_order CompareExchangeFailureOrder =
    std::memory_order_acquire;
};

template<>
struct AtomicOrderConstraints<SequentiallyConsistent>
{
  static const std::memory_order AtomicRMWOrder = std::memory_order_seq_cst;
  static const std::memory_order LoadOrder = std::memory_order_seq_cst;
  static const std::memory_order StoreOrder = std::memory_order_seq_cst;
  static const std::memory_order CompareExchangeFailureOrder =
    std::memory_order_seq_cst;
};

template<typename T, MemoryOrdering Order>
struct IntrinsicBase
{
  typedef std::atomic<T> ValueType;
  typedef AtomicOrderConstraints<Order> OrderedOp;
};

template<typename T, MemoryOrdering Order>
struct IntrinsicMemoryOps : public IntrinsicBase<T, Order>
{
  typedef IntrinsicBase<T, Order> Base;

  static T load(const typename Base::ValueType& aPtr)
  {
    return aPtr.load(Base::OrderedOp::LoadOrder);
  }

  static void store(typename Base::ValueType& aPtr, T aVal)
  {
    aPtr.store(aVal, Base::OrderedOp::StoreOrder);
  }

  static T exchange(typename Base::ValueType& aPtr, T aVal)
  {
    return aPtr.exchange(aVal, Base::OrderedOp::AtomicRMWOrder);
  }

  static bool compareExchange(typename Base::ValueType& aPtr,
                              T aOldVal, T aNewVal)
  {
    return aPtr.compare_exchange_strong(aOldVal, aNewVal,
                                        Base::OrderedOp::AtomicRMWOrder,
                                        Base::OrderedOp::CompareExchangeFailureOrder);
  }
};

template<typename T, MemoryOrdering Order>
struct IntrinsicAddSub : public IntrinsicBase<T, Order>
{
  typedef IntrinsicBase<T, Order> Base;

  static T add(typename Base::ValueType& aPtr, T aVal)
  {
    return aPtr.fetch_add(aVal, Base::OrderedOp::AtomicRMWOrder);
  }

  static T sub(typename Base::ValueType& aPtr, T aVal)
  {
    return aPtr.fetch_sub(aVal, Base::OrderedOp::AtomicRMWOrder);
  }
};

template<typename T, MemoryOrdering Order>
struct IntrinsicAddSub<T*, Order> : public IntrinsicBase<T*, Order>
{
  typedef IntrinsicBase<T*, Order> Base;

  static T* add(typename Base::ValueType& aPtr, ptrdiff_t aVal)
  {
    return aPtr.fetch_add(aVal, Base::OrderedOp::AtomicRMWOrder);
  }

  static T* sub(typename Base::ValueType& aPtr, ptrdiff_t aVal)
  {
    return aPtr.fetch_sub(aVal, Base::OrderedOp::AtomicRMWOrder);
  }
};

template<typename T, MemoryOrdering Order>
struct IntrinsicIncDec : public IntrinsicAddSub<T, Order>
{
  typedef IntrinsicBase<T, Order> Base;

  static T inc(typename Base::ValueType& aPtr)
  {
    return IntrinsicAddSub<T, Order>::add(aPtr, 1);
  }

  static T dec(typename Base::ValueType& aPtr)
  {
    return IntrinsicAddSub<T, Order>::sub(aPtr, 1);
  }
};

template<typename T, MemoryOrdering Order>
struct AtomicIntrinsics : public IntrinsicMemoryOps<T, Order>,
                          public IntrinsicIncDec<T, Order>
{
  typedef IntrinsicBase<T, Order> Base;

  static T or_(typename Base::ValueType& aPtr, T aVal)
  {
    return aPtr.fetch_or(aVal, Base::OrderedOp::AtomicRMWOrder);
  }

  static T xor_(typename Base::ValueType& aPtr, T aVal)
  {
    return aPtr.fetch_xor(aVal, Base::OrderedOp::AtomicRMWOrder);
  }

  static T and_(typename Base::ValueType& aPtr, T aVal)
  {
    return aPtr.fetch_and(aVal, Base::OrderedOp::AtomicRMWOrder);
  }
};

template<typename T, MemoryOrdering Order>
struct AtomicIntrinsics<T*, Order>
  : public IntrinsicMemoryOps<T*, Order>, public IntrinsicIncDec<T*, Order>
{
};

template<typename T>
struct ToStorageTypeArgument
{
  static constexpr T convert (T aT) { return aT; }
};

}
}
namespace mozilla {

namespace detail {

template<typename T, MemoryOrdering Order>
class AtomicBase
{
  static_assert(sizeof(T) == 4 || sizeof(T) == 8,
                "mozilla/Atomics.h only supports 32-bit and 64-bit types");

protected:
  typedef typename detail::AtomicIntrinsics<T, Order> Intrinsics;
  typedef typename Intrinsics::ValueType ValueType;
  ValueType mValue;

public:
  constexpr AtomicBase() : mValue() {}
  explicit constexpr AtomicBase(T aInit)
    : mValue(ToStorageTypeArgument<T>::convert(aInit))
  {}






  T operator=(T aVal)
  {
    Intrinsics::store(mValue, aVal);
    return aVal;
  }





  T exchange(T aVal)
  {
    return Intrinsics::exchange(mValue, aVal);
  }
  bool compareExchange(T aOldValue, T aNewValue)
  {
    return Intrinsics::compareExchange(mValue, aOldValue, aNewValue);
  }

private:
  template<MemoryOrdering AnyOrder>
  AtomicBase(const AtomicBase<T, AnyOrder>& aCopy) = delete;
};

template<typename T, MemoryOrdering Order>
class AtomicBaseIncDec : public AtomicBase<T, Order>
{
  typedef typename detail::AtomicBase<T, Order> Base;

public:
  constexpr AtomicBaseIncDec() : Base() {}
  explicit constexpr AtomicBaseIncDec(T aInit) : Base(aInit) {}

  using Base::operator=;

  operator T() const { return Base::Intrinsics::load(Base::mValue); }
  T operator++(int) { return Base::Intrinsics::inc(Base::mValue); }
  T operator--(int) { return Base::Intrinsics::dec(Base::mValue); }
  T operator++() { return Base::Intrinsics::inc(Base::mValue) + 1; }
  T operator--() { return Base::Intrinsics::dec(Base::mValue) - 1; }

private:
  template<MemoryOrdering AnyOrder>
  AtomicBaseIncDec(const AtomicBaseIncDec<T, AnyOrder>& aCopy) = delete;
};

}
template<typename T,
         MemoryOrdering Order = SequentiallyConsistent,
         typename Enable = void>
class Atomic;
template<typename T, MemoryOrdering Order>
class Atomic<T, Order, typename EnableIf<IsIntegral<T>::value &&
                       !IsSame<T, bool>::value>::Type>
  : public detail::AtomicBaseIncDec<T, Order>
{
  typedef typename detail::AtomicBaseIncDec<T, Order> Base;

public:
  constexpr Atomic() : Base() {}
  explicit constexpr Atomic(T aInit) : Base(aInit) {}

  using Base::operator=;

  T operator+=(T aDelta)
  {
    return Base::Intrinsics::add(Base::mValue, aDelta) + aDelta;
  }

  T operator-=(T aDelta)
  {
    return Base::Intrinsics::sub(Base::mValue, aDelta) - aDelta;
  }

  T operator|=(T aVal)
  {
    return Base::Intrinsics::or_(Base::mValue, aVal) | aVal;
  }

  T operator^=(T aVal)
  {
    return Base::Intrinsics::xor_(Base::mValue, aVal) ^ aVal;
  }

  T operator&=(T aVal)
  {
    return Base::Intrinsics::and_(Base::mValue, aVal) & aVal;
  }

private:
  Atomic(Atomic<T, Order>& aOther) = delete;
};
template<typename T, MemoryOrdering Order>
class Atomic<T*, Order> : public detail::AtomicBaseIncDec<T*, Order>
{
  typedef typename detail::AtomicBaseIncDec<T*, Order> Base;

public:
  constexpr Atomic() : Base() {}
  explicit constexpr Atomic(T* aInit) : Base(aInit) {}

  using Base::operator=;

  T* operator+=(ptrdiff_t aDelta)
  {
    return Base::Intrinsics::add(Base::mValue, aDelta) + aDelta;
  }

  T* operator-=(ptrdiff_t aDelta)
  {
    return Base::Intrinsics::sub(Base::mValue, aDelta) - aDelta;
  }

private:
  Atomic(Atomic<T*, Order>& aOther) = delete;
};






template<typename T, MemoryOrdering Order>
class Atomic<T, Order, typename EnableIf<IsEnum<T>::value>::Type>
  : public detail::AtomicBase<T, Order>
{
  typedef typename detail::AtomicBase<T, Order> Base;

public:
  constexpr Atomic() : Base() {}
  explicit constexpr Atomic(T aInit) : Base(aInit) {}

  operator T() const { return T(Base::Intrinsics::load(Base::mValue)); }

  using Base::operator=;

private:
  Atomic(Atomic<T, Order>& aOther) = delete;
};
template<MemoryOrdering Order>
class Atomic<bool, Order>
  : protected detail::AtomicBase<uint32_t, Order>
{
  typedef typename detail::AtomicBase<uint32_t, Order> Base;

public:
  constexpr Atomic() : Base() {}
  explicit constexpr Atomic(bool aInit) : Base(aInit) {}


               operator bool() const
  {
    return Base::Intrinsics::load(Base::mValue);
  }

  bool operator=(bool aVal)
  {
    return Base::operator=(aVal);
  }

  bool exchange(bool aVal)
  {
    return Base::exchange(aVal);
  }

  bool compareExchange(bool aOldValue, bool aNewValue)
  {
    return Base::compareExchange(aOldValue, aNewValue);
  }

private:
  Atomic(Atomic<bool, Order>& aOther) = delete;
};

}





namespace mozilla {
template<typename Traits>
class Scoped
{
public:
  typedef typename Traits::type Resource;

  explicit Scoped()
    : mValue(Traits::empty())
  {
    do { } while (0);
  }

  explicit Scoped(const Resource& aValue
                                                 )
    : mValue(aValue)
  {
    do { } while (0);
  }


  Scoped(Scoped&& aOther
                                        )
    : mValue(Move(aOther.mValue))
  {
    do { } while (0);
    aOther.mValue = Traits::empty();
  }

  ~Scoped() { Traits::release(mValue); }


  operator const Resource&() const { return mValue; }
  const Resource& operator->() const { return mValue; }
  const Resource& get() const { return mValue; }

  Resource& rwget() { return mValue; }
  Resource forget()
  {
    Resource tmp = mValue;
    mValue = Traits::empty();
    return tmp;
  }






  void dispose()
  {
    Traits::release(mValue);
    mValue = Traits::empty();
  }

  bool operator==(const Resource& aOther) const { return mValue == aOther; }
  Scoped& operator=(const Resource& aOther) { return reset(aOther); }

  Scoped& reset(const Resource& aOther)
  {
    Traits::release(mValue);
    mValue = aOther;
    return *this;
  }


  Scoped& operator=(Scoped&& aRhs)
  {
    do { } while (0);
    this->~Scoped();
    new(this) Scoped(Move(aRhs));
    return *this;
  }

private:
  explicit Scoped(const Scoped& aValue) = delete;
  Scoped& operator=(const Scoped& aValue) = delete;

private:
  Resource mValue;

};
template <typename T> void TypeSpecificDelete(T* aValue);

template <typename T>
struct TypeSpecificScopedPointerTraits
{
  typedef T* type;
  static type empty() { return nullptr; }
  static void release(type aValue)
  {
    if (aValue) {
      TypeSpecificDelete(aValue);
    }
  }
};

template<typename Type> struct TypeSpecificScopedPointer : public mozilla::Scoped<TypeSpecificScopedPointerTraits<Type> > { typedef mozilla::Scoped<TypeSpecificScopedPointerTraits<Type> > Super; typedef typename Super::Resource Resource; TypeSpecificScopedPointer& operator=(Resource aRhs) { Super::operator=(aRhs); return *this; } TypeSpecificScopedPointer& operator=(TypeSpecificScopedPointer&& aRhs) { Super::operator=(Move(aRhs)); return *this; } explicit TypeSpecificScopedPointer() : Super() {} explicit TypeSpecificScopedPointer(Resource aRhs ) : Super(aRhs ) {} TypeSpecificScopedPointer(TypeSpecificScopedPointer&& aRhs ) : Super(Move(aRhs) ) {} private: explicit TypeSpecificScopedPointer(TypeSpecificScopedPointer&) = delete; TypeSpecificScopedPointer& operator=(TypeSpecificScopedPointer&) = delete; };

}



namespace JS {}


namespace mozilla {}


namespace js {}




extern __attribute__((noreturn)) __attribute__ ((cold)) void
JS_Assert(const char* s, const char* file, int ln);
namespace js {
namespace oom {







enum ThreadType {
    THREAD_TYPE_NONE = 0,
    THREAD_TYPE_COOPERATING,
    THREAD_TYPE_WASM,
    THREAD_TYPE_ION,
    THREAD_TYPE_PARSE,
    THREAD_TYPE_COMPRESS,
    THREAD_TYPE_GCHELPER,
    THREAD_TYPE_GCPARALLEL,
    THREAD_TYPE_PROMISE_TASK,
    THREAD_TYPE_MAX
};
inline bool InitThreadType(void) { return true; }
inline void SetThreadType(ThreadType t) {};
inline uint32_t GetThreadType(void) { return 0; }


}
}
namespace js {
namespace oom {
static inline bool IsSimulatedOOMAllocation() { return false; }
static inline bool ShouldFailWithOOM() { return false; }
}
}



namespace js {


struct AutoEnterOOMUnsafeRegion
{
    __attribute__((noreturn)) __attribute__ ((cold)) void crash(const char* reason);
    __attribute__((noreturn)) __attribute__ ((cold)) void crash(size_t size, const char* reason);

    using AnnotateOOMAllocationSizeCallback = void(*)(size_t);
    static AnnotateOOMAllocationSizeCallback annotateOOMSizeCallback;
    static void setAnnotateOOMAllocationSizeCallback(AnnotateOOMAllocationSizeCallback callback) {
        annotateOOMSizeCallback = callback;
    }
};

}

static inline void* js_malloc(size_t bytes)
{
    do {} while(0);
    return malloc(bytes);
}

static inline void* js_calloc(size_t bytes)
{
    do {} while(0);
    return calloc(bytes, 1);
}

static inline void* js_calloc(size_t nmemb, size_t size)
{
    do {} while(0);
    return calloc(nmemb, size);
}

static inline void* js_realloc(void* p, size_t bytes)
{



    do { } while (0);

    do {} while(0);
    return realloc(p, bytes);
}

static inline void js_free(void* p)
{
    free(p);
}

static inline char* js_strdup(const char* s)
{
    do {} while(0);
    return strdup(s);
}
template <class T, typename... Args> static __attribute__((always_inline)) inline T * js_new(Args&&... args) { void* memory = js_malloc(sizeof(T)); return (__builtin_expect(!!(memory), 1)) ? new(memory) T(mozilla::Forward<Args>(args)...) : nullptr; }

namespace js {





template <typename T>
__attribute__ ((warn_unused_result)) inline bool
CalculateAllocSize(size_t numElems, size_t* bytesOut)
{
    *bytesOut = numElems * sizeof(T);
    return (numElems & mozilla::tl::MulOverflowMask<sizeof(T)>::value) == 0;
}






template <typename T, typename Extra>
__attribute__ ((warn_unused_result)) inline bool
CalculateAllocSizeWithExtra(size_t numExtra, size_t* bytesOut)
{
    *bytesOut = sizeof(T) + numExtra * sizeof(Extra);
    return (numExtra & mozilla::tl::MulOverflowMask<sizeof(Extra)>::value) == 0 &&
           *bytesOut >= sizeof(T);
}

}

template <class T>
static __attribute__((always_inline)) inline void
js_delete(const T* p)
{
    if (p) {
        p->~T();
        js_free(const_cast<T*>(p));
    }
}

template<class T>
static __attribute__((always_inline)) inline void
js_delete_poison(const T* p)
{
    if (p) {
        p->~T();
        memset(const_cast<T*>(p), 0x3B, sizeof(T));
        js_free(const_cast<T*>(p));
    }
}

template <class T>
static __attribute__((always_inline)) inline T*
js_pod_malloc()
{
    return static_cast<T*>(js_malloc(sizeof(T)));
}

template <class T>
static __attribute__((always_inline)) inline T*
js_pod_calloc()
{
    return static_cast<T*>(js_calloc(sizeof(T)));
}

template <class T>
static __attribute__((always_inline)) inline T*
js_pod_malloc(size_t numElems)
{
    size_t bytes;
    if ((__builtin_expect(!!(!js::CalculateAllocSize<T>(numElems, &bytes)), 0)))
        return nullptr;
    return static_cast<T*>(js_malloc(bytes));
}

template <class T>
static __attribute__((always_inline)) inline T*
js_pod_calloc(size_t numElems)
{
    size_t bytes;
    if ((__builtin_expect(!!(!js::CalculateAllocSize<T>(numElems, &bytes)), 0)))
        return nullptr;
    return static_cast<T*>(js_calloc(bytes));
}

template <class T>
static __attribute__((always_inline)) inline T*
js_pod_realloc(T* prior, size_t oldSize, size_t newSize)
{
    do { } while (0);
    size_t bytes;
    if ((__builtin_expect(!!(!js::CalculateAllocSize<T>(newSize, &bytes)), 0)))
        return nullptr;
    return static_cast<T*>(js_realloc(prior, bytes));
}

namespace js {

template<typename T>
struct ScopedFreePtrTraits
{
    typedef T* type;
    static T* empty() { return nullptr; }
    static void release(T* ptr) { js_free(ptr); }
};
template<typename Type> struct ScopedJSFreePtr : public mozilla::Scoped<ScopedFreePtrTraits<Type> > { typedef mozilla::Scoped<ScopedFreePtrTraits<Type> > Super; typedef typename Super::Resource Resource; ScopedJSFreePtr& operator=(Resource aRhs) { Super::operator=(aRhs); return *this; } ScopedJSFreePtr& operator=(ScopedJSFreePtr&& aRhs) { Super::operator=(Move(aRhs)); return *this; } explicit ScopedJSFreePtr() : Super() {} explicit ScopedJSFreePtr(Resource aRhs ) : Super(aRhs ) {} ScopedJSFreePtr(ScopedJSFreePtr&& aRhs ) : Super(Move(aRhs) ) {} private: explicit ScopedJSFreePtr(ScopedJSFreePtr&) = delete; ScopedJSFreePtr& operator=(ScopedJSFreePtr&) = delete; };

template <typename T>
struct ScopedDeletePtrTraits : public ScopedFreePtrTraits<T>
{
    static void release(T* ptr) { js_delete(ptr); }
};
template<typename Type> struct ScopedJSDeletePtr : public mozilla::Scoped<ScopedDeletePtrTraits<Type> > { typedef mozilla::Scoped<ScopedDeletePtrTraits<Type> > Super; typedef typename Super::Resource Resource; ScopedJSDeletePtr& operator=(Resource aRhs) { Super::operator=(aRhs); return *this; } ScopedJSDeletePtr& operator=(ScopedJSDeletePtr&& aRhs) { Super::operator=(Move(aRhs)); return *this; } explicit ScopedJSDeletePtr() : Super() {} explicit ScopedJSDeletePtr(Resource aRhs ) : Super(aRhs ) {} ScopedJSDeletePtr(ScopedJSDeletePtr&& aRhs ) : Super(Move(aRhs) ) {} private: explicit ScopedJSDeletePtr(ScopedJSDeletePtr&) = delete; ScopedJSDeletePtr& operator=(ScopedJSDeletePtr&) = delete; };

template <typename T>
struct ScopedReleasePtrTraits : public ScopedFreePtrTraits<T>
{
    static void release(T* ptr) { if (ptr) ptr->release(); }
};
template<typename Type> struct ScopedReleasePtr : public mozilla::Scoped<ScopedReleasePtrTraits<Type> > { typedef mozilla::Scoped<ScopedReleasePtrTraits<Type> > Super; typedef typename Super::Resource Resource; ScopedReleasePtr& operator=(Resource aRhs) { Super::operator=(aRhs); return *this; } ScopedReleasePtr& operator=(ScopedReleasePtr&& aRhs) { Super::operator=(Move(aRhs)); return *this; } explicit ScopedReleasePtr() : Super() {} explicit ScopedReleasePtr(Resource aRhs ) : Super(aRhs ) {} ScopedReleasePtr(ScopedReleasePtr&& aRhs ) : Super(Move(aRhs) ) {} private: explicit ScopedReleasePtr(ScopedReleasePtr&) = delete; ScopedReleasePtr& operator=(ScopedReleasePtr&) = delete; };

}

namespace JS {

template<typename T>
struct DeletePolicy
{
    constexpr DeletePolicy() {}

    template<typename U>
                 DeletePolicy(DeletePolicy<U> other,
                              typename mozilla::EnableIf<mozilla::IsConvertible<U*, T*>::value,
                                                         int>::Type dummy = 0)
    {}

    void operator()(const T* ptr) {
        js_delete(const_cast<T*>(ptr));
    }
};

struct FreePolicy
{
    void operator()(const void* ptr) {
        js_free(const_cast<void*>(ptr));
    }
};

typedef mozilla::UniquePtr<char[], JS::FreePolicy> UniqueChars;
typedef mozilla::UniquePtr<char16_t[], JS::FreePolicy> UniqueTwoByteChars;

}

namespace js {


typedef uint32_t HashNumber;
const unsigned HashNumberSizeBits = 32;

namespace detail {
inline HashNumber
ScrambleHashCode(HashNumber h)
{
    static const HashNumber goldenRatio = 0x9E3779B9U;
    return h * goldenRatio;
}

}

}


namespace js {

bool
CurrentThreadCanAccessZone(JS::Zone* zone);

namespace gc {

struct Cell;

const size_t ArenaShift = 12;
const size_t ArenaSize = size_t(1) << ArenaShift;
const size_t ArenaMask = ArenaSize - 1;




const size_t ChunkShift = 20;

const size_t ChunkSize = size_t(1) << ChunkShift;
const size_t ChunkMask = ChunkSize - 1;

const size_t CellShift = 3;
const size_t CellSize = size_t(1) << CellShift;
const size_t CellMask = CellSize - 1;






const size_t ChunkMarkBitmapOffset = 1032352;
const size_t ChunkMarkBitmapBits = 129024;

const size_t ChunkRuntimeOffset = ChunkSize - sizeof(void*);
const size_t ChunkTrailerSize = 2 * sizeof(uintptr_t) + sizeof(uint64_t);
const size_t ChunkLocationOffset = ChunkSize - ChunkTrailerSize;
const size_t ArenaZoneOffset = sizeof(size_t);
const size_t ArenaHeaderSize = sizeof(size_t) + 2 * sizeof(uintptr_t) +
                               sizeof(size_t) + sizeof(uintptr_t);






static const uint32_t BLACK = 0;
static const uint32_t GRAY = 1;





enum class ChunkLocation : uint32_t
{
    Invalid = 0,
    Nursery = 1,
    TenuredHeap = 2
};



extern void
AssertGCThingHasType(js::gc::Cell* cell, JS::TraceKind kind);





__attribute__((always_inline)) inline bool IsInsideNursery(const js::gc::Cell* cell);

}
}

namespace JS {
struct Zone;


const uint32_t DefaultNurseryBytes = 16 * js::gc::ChunkSize;


const uint32_t DefaultHeapMaxBytes = 32 * 1024 * 1024;

namespace shadow {

struct Zone
{
  protected:
    JSRuntime* const runtime_;
    JSTracer* const barrierTracer_;

  public:
    bool needsIncrementalBarrier_;

    Zone(JSRuntime* runtime, JSTracer* barrierTracerArg)
      : runtime_(runtime),
        barrierTracer_(barrierTracerArg),
        needsIncrementalBarrier_(false)
    {}

    bool needsIncrementalBarrier() const {
        return needsIncrementalBarrier_;
    }

    JSTracer* barrierTracer() {
        do { } while (0);
        do { } while (0);
        return barrierTracer_;
    }

    JSRuntime* runtimeFromActiveCooperatingThread() const {
        do { } while (0);
        return runtime_;
    }



    JSRuntime* runtimeFromAnyThread() const {
        return runtime_;
    }

    static __attribute__((always_inline)) inline JS::shadow::Zone* asShadowZone(JS::Zone* zone) {
        return reinterpret_cast<JS::shadow::Zone*>(zone);
    }
};

}
class GCCellPtr
{
  public:

    GCCellPtr(void* gcthing, JS::TraceKind traceKind) : ptr(checkedCast(gcthing, traceKind)) {}


                 GCCellPtr(decltype(nullptr)) : ptr(checkedCast(nullptr, JS::TraceKind::Null)) {}


    template <typename T>
    explicit GCCellPtr(T* p) : ptr(checkedCast(p, JS::MapTypeToTraceKind<T>::kind)) { }
    explicit GCCellPtr(JSFunction* p) : ptr(checkedCast(p, JS::TraceKind::Object)) { }
    explicit GCCellPtr(JSFlatString* str) : ptr(checkedCast(str, JS::TraceKind::String)) { }
    explicit GCCellPtr(const Value& v);

    JS::TraceKind kind() const {
        JS::TraceKind traceKind = JS::TraceKind(ptr & OutOfLineTraceKindMask);
        if (uintptr_t(traceKind) != OutOfLineTraceKindMask)
            return traceKind;
        return outOfLineKind();
    }


    explicit operator bool() const {
        do { } while (0);
        return asCell();
    }


    template <typename T>
    bool is() const { return kind() == JS::MapTypeToTraceKind<T>::kind; }



    template <typename T>
    T& as() const {
        do { } while (0);


        return *reinterpret_cast<T*>(asCell());
    }




    js::gc::Cell* asCell() const {
        return reinterpret_cast<js::gc::Cell*>(ptr & ~OutOfLineTraceKindMask);
    }


    uint64_t unsafeAsInteger() const {
        return static_cast<uint64_t>(unsafeAsUIntPtr());
    }

    uintptr_t unsafeAsUIntPtr() const {
        do { } while (0);
        do { } while (0);
        return reinterpret_cast<uintptr_t>(asCell());
    }

    bool mayBeOwnedByOtherRuntime() const;

  private:
    static uintptr_t checkedCast(void* p, JS::TraceKind traceKind) {
        js::gc::Cell* cell = static_cast<js::gc::Cell*>(p);
        do { } while (0);
        AssertGCThingHasType(cell, traceKind);


        do { } while (0);

        return uintptr_t(p) | (uintptr_t(traceKind) & OutOfLineTraceKindMask);
    }

    JS::TraceKind outOfLineKind() const;

    uintptr_t ptr;
};

inline bool
operator==(const GCCellPtr& ptr1, const GCCellPtr& ptr2)
{
    return ptr1.asCell() == ptr2.asCell();
}

inline bool
operator!=(const GCCellPtr& ptr1, const GCCellPtr& ptr2)
{
    return !(ptr1 == ptr2);
}



template <typename F, typename... Args>
auto
DispatchTyped(F f, GCCellPtr thing, Args&&... args)
  -> decltype(f(static_cast<JSObject*>(nullptr), mozilla::Forward<Args>(args)...))
{
    switch (thing.kind()) {



      case JS::TraceKind::BaseShape: return f(&thing.as<js::BaseShape>(), mozilla::Forward<Args>(args)...); case JS::TraceKind::JitCode: return f(&thing.as<js::jit::JitCode>(), mozilla::Forward<Args>(args)...); case JS::TraceKind::LazyScript: return f(&thing.as<js::LazyScript>(), mozilla::Forward<Args>(args)...); case JS::TraceKind::Scope: return f(&thing.as<js::Scope>(), mozilla::Forward<Args>(args)...); case JS::TraceKind::Object: return f(&thing.as<JSObject>(), mozilla::Forward<Args>(args)...); case JS::TraceKind::ObjectGroup: return f(&thing.as<js::ObjectGroup>(), mozilla::Forward<Args>(args)...); case JS::TraceKind::Script: return f(&thing.as<JSScript>(), mozilla::Forward<Args>(args)...); case JS::TraceKind::Shape: return f(&thing.as<js::Shape>(), mozilla::Forward<Args>(args)...); case JS::TraceKind::String: return f(&thing.as<JSString>(), mozilla::Forward<Args>(args)...); case JS::TraceKind::Symbol: return f(&thing.as<JS::Symbol>(), mozilla::Forward<Args>(args)...); case JS::TraceKind::RegExpShared: return f(&thing.as<js::RegExpShared>(), mozilla::Forward<Args>(args)...);;

      default:
          do { AnnotateMozCrashReason("MOZ_CRASH(" "Invalid trace kind in DispatchTyped for GCCellPtr." ")"); do { *((volatile int*) __null) = 258; ::abort(); } while (0); } while (0);
    }
}

}

namespace js {
namespace gc {
namespace detail {

static __attribute__((always_inline)) inline uintptr_t*
GetGCThingMarkBitmap(const uintptr_t addr)
{
    do { } while (0);
    const uintptr_t bmap_addr = (addr & ~ChunkMask) | ChunkMarkBitmapOffset;
    return reinterpret_cast<uintptr_t*>(bmap_addr);
}

static __attribute__((always_inline)) inline void
GetGCThingMarkWordAndMask(const uintptr_t addr, uint32_t color,
                          uintptr_t** wordp, uintptr_t* maskp)
{
    do { } while (0);
    const size_t bit = (addr & js::gc::ChunkMask) / js::gc::CellSize + color;
    do { } while (0);
    uintptr_t* bitmap = GetGCThingMarkBitmap(addr);
    const uintptr_t nbits = sizeof(*bitmap) * 8;
    *maskp = uintptr_t(1) << (bit % nbits);
    *wordp = &bitmap[bit / nbits];
}

static __attribute__((always_inline)) inline JS::Zone*
GetGCThingZone(const uintptr_t addr)
{
    do { } while (0);
    const uintptr_t zone_addr = (addr & ~ArenaMask) | ArenaZoneOffset;
    return *reinterpret_cast<JS::Zone**>(zone_addr);

}

static __attribute__((always_inline)) inline bool
CellIsMarkedGray(const Cell* cell)
{
    do { } while (0);
    if (js::gc::IsInsideNursery(cell))
        return false;

    uintptr_t* word, mask;
    js::gc::detail::GetGCThingMarkWordAndMask(uintptr_t(cell), js::gc::GRAY, &word, &mask);
    return *word & mask;
}

extern bool
CellIsMarkedGrayIfKnown(const Cell* cell);






}

__attribute__((always_inline)) inline bool
IsInsideNursery(const js::gc::Cell* cell)
{
    if (!cell)
        return false;
    uintptr_t addr = uintptr_t(cell);
    addr &= ~js::gc::ChunkMask;
    addr |= js::gc::ChunkLocationOffset;
    auto location = *reinterpret_cast<ChunkLocation*>(addr);
    do { } while (0);
    return location == ChunkLocation::Nursery;
}

}
}

namespace JS {

static __attribute__((always_inline)) inline Zone*
GetTenuredGCThingZone(GCCellPtr thing)
{
    do { } while (0);
    return js::gc::detail::GetGCThingZone(thing.unsafeAsUIntPtr());
}

static __attribute__((always_inline)) inline Zone*
GetStringZone(JSString* str)
{
    return js::gc::detail::GetGCThingZone(uintptr_t(str));
}

extern Zone*
GetObjectZone(JSObject* obj);

static __attribute__((always_inline)) inline bool
GCThingIsMarkedGray(GCCellPtr thing)
{
    if (thing.mayBeOwnedByOtherRuntime())
        return false;
    return js::gc::detail::CellIsMarkedGrayIfKnown(thing.asCell());
}

extern JS::TraceKind
GCThingTraceKind(void* thing);

}

namespace js {
namespace gc {

static __attribute__((always_inline)) inline bool
IsIncrementalBarrierNeededOnTenuredGCThing(const JS::GCCellPtr thing)
{
    do { } while (0);
    do { } while (0);




    do { } while (0);

    JS::Zone* zone = JS::GetTenuredGCThingZone(thing);
    return JS::shadow::Zone::asShadowZone(zone)->needsIncrementalBarrier();
}






extern JSObject*
NewMemoryInfoObject(JSContext* cx);

}
}
typedef int64_t PRTime;



class nsAString;
class nsACString;
struct nsID
{





  uint32_t m0;
  uint16_t m1;
  uint16_t m2;
  uint8_t m3[8];
  void Clear();






  inline bool Equals(const nsID& aOther) const
  {

    return
      (((uint32_t*)&m0)[0] == ((uint32_t*)&aOther.m0)[0]) &&
      (((uint32_t*)&m0)[1] == ((uint32_t*)&aOther.m0)[1]) &&
      (((uint32_t*)&m0)[2] == ((uint32_t*)&aOther.m0)[2]) &&
      (((uint32_t*)&m0)[3] == ((uint32_t*)&aOther.m0)[3]);
  }

  inline bool operator==(const nsID& aOther) const
  {
    return Equals(aOther);
  }





  bool Parse(const char* aIDStr);







  char* ToString() const;






  void ToProvidedString(char (&aDest)[39]) const;




};
class nsIDToCString
{
public:
  explicit nsIDToCString(const nsID& aID)
  {
    aID.ToProvidedString(mStringBytes);
  }

  const char *get() const
  {
    return mStringBytes;
  }

protected:
  char mStringBytes[39];
};






typedef nsID nsCID;
typedef nsID nsIID;
class nsISupports
{
public:

  template<typename T, typename U> struct COMTypeInfo;
  virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) = 0;







  virtual MozExternalRefCountType AddRef(void) = 0;
  virtual MozExternalRefCountType Release(void) = 0;


};

template<typename T> struct nsISupports::COMTypeInfo<nsISupports, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsISupports::COMTypeInfo<nsISupports, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x00000000, 0x0000, 0x0000, {0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46} };
class nsAString;
class nsACString;

class nsISupports;
class nsIModule;
class nsIComponentManager;
class nsIComponentRegistrar;
class nsIServiceManager;
class nsIFile;
class nsILocalFile;
class nsIDirectoryServiceProvider;
class nsIMemory;
class nsIDebug2;


namespace mozilla {
struct Module;
}
extern "C" nsresult
NS_InitXPCOM2(nsIServiceManager** aResult,
              nsIFile* aBinDirectory,
              nsIDirectoryServiceProvider* aAppFileLocationProvider);





extern "C" nsresult
NS_InitMinimalXPCOM();
extern "C" nsresult NS_ShutdownXPCOM(nsIServiceManager* aServMgr);
extern "C" nsresult NS_GetServiceManager(nsIServiceManager** aResult);
extern "C" nsresult NS_GetComponentManager(nsIComponentManager** aResult);
extern "C" nsresult NS_GetComponentRegistrar(nsIComponentRegistrar** aResult);
extern "C" nsresult NS_GetMemoryManager(nsIMemory** aResult);
extern "C" nsresult NS_NewLocalFile(const nsAString& aPath,
                                    bool aFollowLinks,
                                    nsIFile** aResult);

extern "C" nsresult NS_NewNativeLocalFile(const nsACString& aPath,
                                          bool aFollowLinks,
                                          nsIFile** aResult);




class NS_ConvertUTF16toUTF8;
nsresult NS_NewNativeLocalFile(const NS_ConvertUTF16toUTF8& aPath,
                               bool aFollowLinks,
                               nsIFile** aResult) = delete;
enum
{
  NS_DEBUG_WARNING = 0,
  NS_DEBUG_ASSERTION = 1,
  NS_DEBUG_BREAK = 2,
  NS_DEBUG_ABORT = 3
};
extern "C" void NS_DebugBreak(uint32_t aSeverity,
                              const char* aStr, const char* aExpr,
                              const char* aFile, int32_t aLine);
extern "C" void NS_LogInit();

extern "C" void NS_LogTerm();







class ScopedLogging
{
public:
    ScopedLogging()
    {
        NS_LogInit();
    }

    ~ScopedLogging()
    {
        NS_LogTerm();
    }
};
extern "C" void NS_LogCtor(void* aPtr, const char* aTypeName,
                           uint32_t aInstanceSize);

extern "C" void NS_LogDtor(void* aPtr, const char* aTypeName,
                           uint32_t aInstanceSize);
extern "C" void NS_LogAddRef(void* aPtr, nsrefcnt aNewRefCnt,
                             const char* aTypeName, uint32_t aInstanceSize);

extern "C" void NS_LogRelease(void* aPtr, nsrefcnt aNewRefCnt,
                              const char* aTypeName);
extern "C" void NS_LogCOMPtrAddRef(void* aCOMPtr, nsISupports* aObject);

extern "C" void NS_LogCOMPtrRelease(void* aCOMPtr, nsISupports* aObject);
class nsCycleCollectionParticipant;
class nsCycleCollectingAutoRefCnt;

extern "C" void NS_CycleCollectorSuspect3(void* aPtr,
                                          nsCycleCollectionParticipant* aCp,
                                          nsCycleCollectingAutoRefCnt* aRefCnt,
                                          bool* aShouldDelete);
extern "C" nsresult NS_GetDebug(nsIDebug2** aResult);
void NS_ABORT_OOM(size_t aSize);
extern "C" {
void printf_stderr(const char* aFmt, ...) __attribute__ ((format (printf, 1, 2)));




void vprintf_stderr(const char* aFmt, va_list aArgs);
void fprintf_stderr(FILE* aFile, const char* aFmt, ...) __attribute__ ((format (printf, 2, 3)));


}





extern "C" {
typedef unsigned char PRUint8;
typedef signed char PRInt8;
typedef unsigned short PRUint16;
typedef short PRInt16;
typedef unsigned int PRUint32;
typedef int PRInt32;
typedef long PRInt64;
typedef unsigned long PRUint64;
typedef int PRIntn;
typedef unsigned int PRUintn;
typedef double PRFloat64;






typedef size_t PRSize;







typedef PRInt32 PROffset32;
typedef PRInt64 PROffset64;







typedef ptrdiff_t PRPtrdiff;
typedef unsigned long PRUptrdiff;
typedef PRIntn PRBool;
typedef PRUint8 PRPackedBool;





typedef enum { PR_FAILURE = -1, PR_SUCCESS = 0 } PRStatus;






typedef PRUint16 PRUnichar;
typedef long PRWord;
typedef unsigned long PRUword;
}
extern "C" {





typedef PRUint32 PRIntervalTime;
extern __attribute__((visibility("default"))) PRIntervalTime PR_IntervalNow(void);
extern __attribute__((visibility("default"))) PRUint32 PR_TicksPerSecond(void);
extern __attribute__((visibility("default"))) PRIntervalTime PR_SecondsToInterval(PRUint32 seconds);
extern __attribute__((visibility("default"))) PRIntervalTime PR_MillisecondsToInterval(PRUint32 milli);
extern __attribute__((visibility("default"))) PRIntervalTime PR_MicrosecondsToInterval(PRUint32 micro);
extern __attribute__((visibility("default"))) PRUint32 PR_IntervalToSeconds(PRIntervalTime ticks);
extern __attribute__((visibility("default"))) PRUint32 PR_IntervalToMilliseconds(PRIntervalTime ticks);
extern __attribute__((visibility("default"))) PRUint32 PR_IntervalToMicroseconds(PRIntervalTime ticks);

}

extern "C" {

typedef struct PRThread PRThread;
typedef struct PRThreadStack PRThreadStack;

typedef enum PRThreadType {
    PR_USER_THREAD,
    PR_SYSTEM_THREAD
} PRThreadType;

typedef enum PRThreadScope {
    PR_LOCAL_THREAD,
    PR_GLOBAL_THREAD,
    PR_GLOBAL_BOUND_THREAD
} PRThreadScope;

typedef enum PRThreadState {
    PR_JOINABLE_THREAD,
    PR_UNJOINABLE_THREAD
} PRThreadState;

typedef enum PRThreadPriority
{
    PR_PRIORITY_FIRST = 0,
    PR_PRIORITY_LOW = 0,
    PR_PRIORITY_NORMAL = 1,
    PR_PRIORITY_HIGH = 2,
    PR_PRIORITY_URGENT = 3,
    PR_PRIORITY_LAST = 3
} PRThreadPriority;
extern __attribute__((visibility("default"))) PRThread* PR_CreateThread(PRThreadType type,
                     void ( *start)(void *arg),
                     void *arg,
                     PRThreadPriority priority,
                     PRThreadScope scope,
                     PRThreadState state,
                     PRUint32 stackSize);
extern __attribute__((visibility("default"))) PRStatus PR_JoinThread(PRThread *thread);





extern __attribute__((visibility("default"))) PRThread* PR_GetCurrentThread(void);







extern __attribute__((visibility("default"))) PRThreadPriority PR_GetThreadPriority(const PRThread *thread);
extern __attribute__((visibility("default"))) void PR_SetThreadPriority(PRThread *thread, PRThreadPriority priority);





extern __attribute__((visibility("default"))) PRStatus PR_SetCurrentThreadName(const char *name);




extern __attribute__((visibility("default"))) const char * PR_GetThreadName(const PRThread *thread);
typedef void ( *PRThreadPrivateDTOR)(void *priv);

extern __attribute__((visibility("default"))) PRStatus PR_NewThreadPrivateIndex(
    PRUintn *newIndex, PRThreadPrivateDTOR destructor);
extern __attribute__((visibility("default"))) PRStatus PR_SetThreadPrivate(PRUintn tpdIndex, void *priv);
extern __attribute__((visibility("default"))) void* PR_GetThreadPrivate(PRUintn tpdIndex);
extern __attribute__((visibility("default"))) PRStatus PR_Interrupt(PRThread *thread);





extern __attribute__((visibility("default"))) void PR_ClearInterrupt(void);




extern __attribute__((visibility("default"))) void PR_BlockInterrupt(void);




extern __attribute__((visibility("default"))) void PR_UnblockInterrupt(void);
extern __attribute__((visibility("default"))) PRStatus PR_Sleep(PRIntervalTime ticks);




extern __attribute__((visibility("default"))) PRThreadScope PR_GetThreadScope(const PRThread *thread);




extern __attribute__((visibility("default"))) PRThreadType PR_GetThreadType(const PRThread *thread);




extern __attribute__((visibility("default"))) PRThreadState PR_GetThreadState(const PRThread *thread);

}







inline nsISupports*
ToSupports(nsISupports* aSupports)
{
  return aSupports;
}

inline nsISupports*
ToCanonicalSupports(nsISupports* aSupports)
{
  return nullptr;
}
class nsCycleCollectingAutoRefCnt
{
public:
  nsCycleCollectingAutoRefCnt() : mRefCntAndFlags(0) {}

  explicit nsCycleCollectingAutoRefCnt(uintptr_t aValue)
    : mRefCntAndFlags(aValue << 2)
  {
  }

  nsCycleCollectingAutoRefCnt(const nsCycleCollectingAutoRefCnt&) = delete;
  void operator=(const nsCycleCollectingAutoRefCnt&) = delete;

  __attribute__((always_inline)) inline uintptr_t incr(nsISupports* aOwner)
  {
    return incr(aOwner, nullptr);
  }

  __attribute__((always_inline)) inline uintptr_t incr(void* aOwner,
                                   nsCycleCollectionParticipant* aCp)
  {
    mRefCntAndFlags += (1 << 2);
    mRefCntAndFlags &= ~(1 << 1);


    if (!IsInPurpleBuffer()) {
      mRefCntAndFlags |= (1 << 0);

      do { } while (0);
      NS_CycleCollectorSuspect3(aOwner, aCp, this, nullptr);
    }
    return (mRefCntAndFlags >> 2);
  }

  __attribute__((always_inline)) inline void stabilizeForDeletion()
  {


    mRefCntAndFlags = (1 << 2) | (1 << 0);
  }

  __attribute__((always_inline)) inline uintptr_t decr(nsISupports* aOwner,
                                   bool* aShouldDelete = nullptr)
  {
    return decr(aOwner, nullptr, aShouldDelete);
  }

  __attribute__((always_inline)) inline uintptr_t decr(void* aOwner,
                                   nsCycleCollectionParticipant* aCp,
                                   bool* aShouldDelete = nullptr)
  {
    do { } while (0);
    if (!IsInPurpleBuffer()) {
      mRefCntAndFlags -= (1 << 2);
      mRefCntAndFlags |= ((1 << 0) | (1 << 1));
      uintptr_t retval = (mRefCntAndFlags >> 2);

      NS_CycleCollectorSuspect3(aOwner, aCp, this, aShouldDelete);
      return retval;
    }
    mRefCntAndFlags -= (1 << 2);
    mRefCntAndFlags |= ((1 << 0) | (1 << 1));
    return (mRefCntAndFlags >> 2);
  }

  __attribute__((always_inline)) inline void RemovePurple()
  {
    do { } while (0);
    mRefCntAndFlags &= ~(1 << 1);
  }

  __attribute__((always_inline)) inline void RemoveFromPurpleBuffer()
  {
    do { } while (0);
    mRefCntAndFlags &= ~((1 << 1) | (1 << 0));
  }

  __attribute__((always_inline)) inline bool IsPurple() const
  {
    return !!(mRefCntAndFlags & (1 << 1));
  }

  __attribute__((always_inline)) inline bool IsInPurpleBuffer() const
  {
    return !!(mRefCntAndFlags & (1 << 0));
  }

  __attribute__((always_inline)) inline nsrefcnt get() const
  {
    return (mRefCntAndFlags >> 2);
  }

  __attribute__((always_inline)) inline operator nsrefcnt() const
  {
    return get();
  }

private:
  uintptr_t mRefCntAndFlags;
};

class nsAutoRefCnt
{
public:
  nsAutoRefCnt() : mValue(0) {}
  explicit nsAutoRefCnt(nsrefcnt aValue) : mValue(aValue) {}

  nsAutoRefCnt(const nsAutoRefCnt&) = delete;
  void operator=(const nsAutoRefCnt&) = delete;


  nsrefcnt operator++() { return ++mValue; }
  nsrefcnt operator--() { return --mValue; }

  nsrefcnt operator=(nsrefcnt aValue) { return (mValue = aValue); }
  operator nsrefcnt() const { return mValue; }
  nsrefcnt get() const { return mValue; }

  static const bool isThreadSafe = false;
private:
  nsrefcnt operator++(int) = delete;
  nsrefcnt operator--(int) = delete;
  nsrefcnt mValue;
};

namespace mozilla {
class ThreadSafeAutoRefCnt
{
public:
  ThreadSafeAutoRefCnt() : mValue(0) {}
  explicit ThreadSafeAutoRefCnt(nsrefcnt aValue) : mValue(aValue) {}

  ThreadSafeAutoRefCnt(const ThreadSafeAutoRefCnt&) = delete;
  void operator=(const ThreadSafeAutoRefCnt&) = delete;


  __attribute__((always_inline)) inline nsrefcnt operator++()
  {
    return mValue.fetch_add(1, std::memory_order_relaxed) + 1;
  }
  __attribute__((always_inline)) inline nsrefcnt operator--()
  {




    nsrefcnt result = mValue.fetch_sub(1, std::memory_order_release) - 1;
    if (result == 0) {




      result = mValue.load(std::memory_order_acquire);
    }
    return result;
  }

  __attribute__((always_inline)) inline nsrefcnt operator=(nsrefcnt aValue)
  {


    mValue.store(aValue, std::memory_order_release);
    return aValue;
  }
  __attribute__((always_inline)) inline operator nsrefcnt() const { return get(); }
  __attribute__((always_inline)) inline nsrefcnt get() const
  {


    return mValue.load(std::memory_order_acquire);
  }

  static const bool isThreadSafe = true;
private:
  nsrefcnt operator++(int) = delete;
  nsrefcnt operator--(int) = delete;
  std::atomic<nsrefcnt> mValue;
};
}
struct QITableEntry
{
  const nsIID* iid;
  int32_t offset;
};

nsresult
NS_TableDrivenQI(void* aThis, const nsIID& aIID,
                 void** aInstancePtr, const QITableEntry* aEntries);
template<class T>
inline void
ns_if_addref(T aExpr)
{
  if (aExpr) {
    aExpr->AddRef();
  }
}
template<class T, class DestinationType>
inline nsresult
CallQueryInterface(T* aSource, DestinationType** aDestination)
{


  static_assert(!mozilla::IsSame<T, DestinationType>::value ||
                mozilla::IsSame<DestinationType, nsISupports>::value,
                "don't use CallQueryInterface for compile-time-determinable casts");

  do { } while(0);
  do { } while(0);

  return aSource->QueryInterface((DestinationType::template COMTypeInfo<DestinationType, void>::kIID),
                                 reinterpret_cast<void**>(aDestination));
}

template <class SourceType, class DestinationType>
inline nsresult
CallQueryInterface(RefPtr<SourceType>& aSourcePtr, DestinationType** aDestPtr)
{
  return CallQueryInterface(aSourcePtr.get(), aDestPtr);
}

class nsCycleCollectionParticipant;

class nsCycleCollectionTraversalCallback
{
public:




  virtual void DescribeRefCountedNode(nsrefcnt aRefcount,
                                           const char* aObjName) = 0;

  virtual void DescribeGCedNode(bool aIsMarked,
                                     const char* aObjName,
                                     uint64_t aCompartmentAddress = 0) = 0;

  virtual void NoteXPCOMChild(nsISupports* aChild) = 0;
  virtual void NoteJSChild(const JS::GCCellPtr& aThing) = 0;
  virtual void NoteNativeChild(void* aChild,
                                    nsCycleCollectionParticipant* aHelper) = 0;





  virtual void NoteNextEdgeName(const char* aName) = 0;

  enum
  {




    WANT_DEBUG_INFO = (1 << 0),



    WANT_ALL_TRACES = (1 << 1)
  };
  uint32_t Flags() const { return mFlags; }
  bool WantDebugInfo() const { return (mFlags & WANT_DEBUG_INFO) != 0; }
  bool WantAllTraces() const { return (mFlags & WANT_ALL_TRACES) != 0; }
protected:
  nsCycleCollectionTraversalCallback() : mFlags(0) {}

  uint32_t mFlags;
};



enum
{
  CycleCollectionEdgeNameArrayFlag = 1
};


void
CycleCollectionNoteEdgeNameImpl(nsCycleCollectionTraversalCallback& aCallback,
                                const char* aName,
                                uint32_t aFlags = 0);


__attribute__((always_inline)) inline void
CycleCollectionNoteEdgeName(nsCycleCollectionTraversalCallback& aCallback,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  if ((__builtin_expect(!!(aCallback.WantDebugInfo()), 0))) {
    CycleCollectionNoteEdgeNameImpl(aCallback, aName, aFlags);
  }
}
template<typename T>
nsISupports*
ToSupports(T* aPtr, typename T::cycleCollection* aDummy = 0)
{
  return T::cycleCollection::Upcast(aPtr);
}



template<typename T,
         bool IsXPCOM = mozilla::IsBaseOf<nsISupports, T>::value>
struct CycleCollectionNoteChildImpl
{
};

template<typename T>
struct CycleCollectionNoteChildImpl<T, true>
{
  static void Run(nsCycleCollectionTraversalCallback& aCallback, T* aChild)
  {
    aCallback.NoteXPCOMChild(ToSupports(aChild));
  }
};

template<typename T>
struct CycleCollectionNoteChildImpl<T, false>
{
  static void Run(nsCycleCollectionTraversalCallback& aCallback, T* aChild)
  {
    aCallback.NoteNativeChild(aChild, T::cycleCollection::GetParticipant());
  }
};




template<typename T>
inline void
CycleCollectionNoteChild(nsCycleCollectionTraversalCallback& aCallback,
                         T* aChild, const char* aName, uint32_t aFlags)
{
  CycleCollectionNoteEdgeName(aCallback, aName, aFlags);
  CycleCollectionNoteChildImpl<T>::Run(aCallback, aChild);
}

template<typename T>
inline void
CycleCollectionNoteChild(nsCycleCollectionTraversalCallback& aCallback,
                         T* aChild, const char* aName)
{
  CycleCollectionNoteChild(aCallback, aChild, aName, 0);
}
template <class CharT>
struct nsCharTraits
{
};

template <>
struct nsCharTraits<char16_t>
{
  typedef char16_t char_type;
  typedef uint16_t unsigned_char_type;
  typedef char incompatible_char_type;

  static char_type* const sEmptyBuffer;

  static void
  assign(char_type& aLhs, char_type aRhs)
  {
    aLhs = aRhs;
  }



  typedef int int_type;

  static char_type
  to_char_type(int_type aChar)
  {
    return char_type(aChar);
  }

  static int_type
  to_int_type(char_type aChar)
  {
    return int_type(static_cast<unsigned_char_type>(aChar));
  }

  static bool
  eq_int_type(int_type aLhs, int_type aRhs)
  {
    return aLhs == aRhs;
  }




  static bool
  eq(char_type aLhs, char_type aRhs)
  {
    return aLhs == aRhs;
  }

  static bool
  lt(char_type aLhs, char_type aRhs)
  {
    return aLhs < aRhs;
  }




  static char_type*
  move(char_type* aStr1, const char_type* aStr2, size_t aN)
  {
    return static_cast<char_type*>(memmove(aStr1, aStr2,
                                           aN * sizeof(char_type)));
  }

  static char_type*
  copy(char_type* aStr1, const char_type* aStr2, size_t aN)
  {
    return static_cast<char_type*>(memcpy(aStr1, aStr2,
                                          aN * sizeof(char_type)));
  }

  static char_type*
  copyASCII(char_type* aStr1, const char* aStr2, size_t aN)
  {
    for (char_type* s = aStr1; aN--; ++s, ++aStr2) {
      do { } while(0);
      *s = static_cast<char_type>(*aStr2);
    }
    return aStr1;
  }

  static char_type*
  assign(char_type* aStr, size_t aN, char_type aChar)
  {
    char_type* result = aStr;
    while (aN--) {
      assign(*aStr++, aChar);
    }
    return result;
  }

  static int
  compare(const char_type* aStr1, const char_type* aStr2, size_t aN)
  {
    for (; aN--; ++aStr1, ++aStr2) {
      if (!eq(*aStr1, *aStr2)) {
        return to_int_type(*aStr1) - to_int_type(*aStr2);
      }
    }

    return 0;
  }

  static int
  compareASCII(const char_type* aStr1, const char* aStr2, size_t aN)
  {
    for (; aN--; ++aStr1, ++aStr2) {
      do { } while(0);
      if (!eq_int_type(to_int_type(*aStr1),
                       to_int_type(static_cast<char_type>(*aStr2)))) {
        return to_int_type(*aStr1) -
               to_int_type(static_cast<char_type>(*aStr2));
      }
    }

    return 0;
  }




  static int
  compareASCIINullTerminated(const char_type* aStr1, size_t aN,
                             const char* aStr2)
  {
    for (; aN--; ++aStr1, ++aStr2) {
      if (!*aStr2) {
        return 1;
      }
      do { } while(0);
      if (!eq_int_type(to_int_type(*aStr1),
                       to_int_type(static_cast<char_type>(*aStr2)))) {
        return to_int_type(*aStr1) -
               to_int_type(static_cast<char_type>(*aStr2));
      }
    }

    if (*aStr2) {
      return -1;
    }

    return 0;
  }





  static char_type
  ASCIIToLower(char_type aChar)
  {
    if (aChar >= 'A' && aChar <= 'Z') {
      return char_type(aChar + ('a' - 'A'));
    }

    return aChar;
  }

  static int
  compareLowerCaseToASCII(const char_type* aStr1, const char* aStr2, size_t aN)
  {
    for (; aN--; ++aStr1, ++aStr2) {
      do { } while(0);
      do { } while(0);

      char_type lower_s1 = ASCIIToLower(*aStr1);
      if (lower_s1 != static_cast<char_type>(*aStr2)) {
        return to_int_type(lower_s1) -
               to_int_type(static_cast<char_type>(*aStr2));
      }
    }

    return 0;
  }




  static int
  compareLowerCaseToASCIINullTerminated(const char_type* aStr1,
                                        size_t aN, const char* aStr2)
  {
    for (; aN--; ++aStr1, ++aStr2) {
      if (!*aStr2) {
        return 1;
      }
      do { } while(0);
      do { } while(0);

      char_type lower_s1 = ASCIIToLower(*aStr1);
      if (lower_s1 != static_cast<char_type>(*aStr2)) {
        return to_int_type(lower_s1) -
               to_int_type(static_cast<char_type>(*aStr2));
      }
    }

    if (*aStr2) {
      return -1;
    }

    return 0;
  }

  static size_t
  length(const char_type* aStr)
  {
    size_t result = 0;
    while (!eq(*aStr++, char_type(0))) {
      ++result;
    }
    return result;
  }

  static const char_type*
  find(const char_type* aStr, size_t aN, char_type aChar)
  {
    while (aN--) {
      if (eq(*aStr, aChar)) {
        return aStr;
      }
      ++aStr;
    }

    return 0;
  }
};

template <>
struct nsCharTraits<char>
{
  typedef char char_type;
  typedef unsigned char unsigned_char_type;
  typedef char16_t incompatible_char_type;

  static char_type* const sEmptyBuffer;

  static void
  assign(char_type& aLhs, char_type aRhs)
  {
    aLhs = aRhs;
  }




  typedef int int_type;

  static char_type
  to_char_type(int_type aChar)
  {
    return char_type(aChar);
  }

  static int_type
  to_int_type(char_type aChar)
  {
    return int_type(static_cast<unsigned_char_type>(aChar));
  }

  static bool
  eq_int_type(int_type aLhs, int_type aRhs)
  {
    return aLhs == aRhs;
  }




  static bool eq(char_type aLhs, char_type aRhs)
  {
    return aLhs == aRhs;
  }

  static bool
  lt(char_type aLhs, char_type aRhs)
  {
    return aLhs < aRhs;
  }




  static char_type*
  move(char_type* aStr1, const char_type* aStr2, size_t aN)
  {
    return static_cast<char_type*>(memmove(aStr1, aStr2,
                                           aN * sizeof(char_type)));
  }

  static char_type*
  copy(char_type* aStr1, const char_type* aStr2, size_t aN)
  {
    return static_cast<char_type*>(memcpy(aStr1, aStr2,
                                          aN * sizeof(char_type)));
  }

  static char_type*
  copyASCII(char_type* aStr1, const char* aStr2, size_t aN)
  {
    return copy(aStr1, aStr2, aN);
  }

  static char_type*
  assign(char_type* aStr, size_t aN, char_type aChar)
  {
    return static_cast<char_type*>(memset(aStr, to_int_type(aChar), aN));
  }

  static int
  compare(const char_type* aStr1, const char_type* aStr2, size_t aN)
  {
    return memcmp(aStr1, aStr2, aN);
  }

  static int
  compareASCII(const char_type* aStr1, const char* aStr2, size_t aN)
  {





    return compare(aStr1, aStr2, aN);
  }




  static int
  compareASCIINullTerminated(const char_type* aStr1, size_t aN,
                             const char* aStr2)
  {


    for (; aN--; ++aStr1, ++aStr2) {
      if (!*aStr2) {
        return 1;
      }
      do { } while(0);
      if (*aStr1 != *aStr2) {
        return to_int_type(*aStr1) - to_int_type(*aStr2);
      }
    }

    if (*aStr2) {
      return -1;
    }

    return 0;
  }




  static char_type
  ASCIIToLower(char_type aChar)
  {
    if (aChar >= 'A' && aChar <= 'Z') {
      return char_type(aChar + ('a' - 'A'));
    }

    return aChar;
  }

  static int
  compareLowerCaseToASCII(const char_type* aStr1, const char* aStr2, size_t aN)
  {
    for (; aN--; ++aStr1, ++aStr2) {
      do { } while(0);
      do { } while(0);

      char_type lower_s1 = ASCIIToLower(*aStr1);
      if (lower_s1 != *aStr2) {
        return to_int_type(lower_s1) - to_int_type(*aStr2);
      }
    }
    return 0;
  }




  static int
  compareLowerCaseToASCIINullTerminated(const char_type* aStr1, size_t aN,
                                        const char* aStr2)
  {
    for (; aN--; ++aStr1, ++aStr2) {
      if (!*aStr2) {
        return 1;
      }
      do { } while(0);
      do { } while(0);

      char_type lower_s1 = ASCIIToLower(*aStr1);
      if (lower_s1 != *aStr2) {
        return to_int_type(lower_s1) - to_int_type(*aStr2);
      }
    }

    if (*aStr2) {
      return -1;
    }

    return 0;
  }

  static size_t
  length(const char_type* aStr)
  {
    return strlen(aStr);
  }

  static const char_type*
  find(const char_type* aStr, size_t aN, char_type aChar)
  {
    return reinterpret_cast<const char_type*>(memchr(aStr, to_int_type(aChar),
                                                     aN));
  }
};

template <class InputIterator>
struct nsCharSourceTraits
{
  typedef typename InputIterator::difference_type difference_type;

  static uint32_t
  readable_distance(const InputIterator& aFirst, const InputIterator& aLast)
  {

    return uint32_t(aLast.get() - aFirst.get());
  }

  static const typename InputIterator::value_type*
  read(const InputIterator& aIter)
  {
    return aIter.get();
  }

  static void
  advance(InputIterator& aStr, difference_type aN)
  {
    aStr.advance(aN);
  }
};

template <class CharT>
struct nsCharSourceTraits<CharT*>
{
  typedef ptrdiff_t difference_type;

  static uint32_t
  readable_distance(CharT* aStr)
  {
    return uint32_t(nsCharTraits<CharT>::length(aStr));

  }

  static uint32_t
  readable_distance(CharT* aFirst, CharT* aLast)
  {
    return uint32_t(aLast - aFirst);
  }

  static const CharT*
  read(CharT* aStr)
  {
    return aStr;
  }

  static void
  advance(CharT*& aStr, difference_type aN)
  {
    aStr += aN;
  }
};

template <class OutputIterator>
struct nsCharSinkTraits
{
  static void
  write(OutputIterator& aIter, const typename OutputIterator::value_type* aStr,
        uint32_t aN)
  {
    aIter.write(aStr, aN);
  }
};

template <class CharT>
struct nsCharSinkTraits<CharT*>
{
  static void
  write(CharT*& aIter, const CharT* aStr, uint32_t aN)
  {
    nsCharTraits<CharT>::move(aIter, aStr, aN);
    aIter += aN;
  }
};

template <class T>
inline T
NS_ROUNDUP(const T& aA, const T& aB)
{
  return ((aA + (aB - 1)) / aB) * aB;
}




template <class T>
inline const T&
XPCOM_MIN(const T& aA, const T& aB)
{
  return aB < aA ? aB : aA;
}


template <class T>
inline const T&
XPCOM_MAX(const T& aA, const T& aB)
{
  return aA > aB ? aA : aB;
}

namespace mozilla {

template <class T>
inline const T&
clamped(const T& aA, const T& aMin, const T& aMax)
{
  do { } while (0);

  return XPCOM_MIN(XPCOM_MAX(aA, aMin), aMax);
}

}

template <class InputIterator, class T>
inline uint32_t
NS_COUNT(InputIterator& aFirst, const InputIterator& aLast, const T& aValue)
{
  uint32_t result = 0;
  for (; aFirst != aLast; ++aFirst)
    if (*aFirst == aValue) {
      ++result;
    }
  return result;
}

template <class InputIterator, class OutputIterator>
inline OutputIterator&
copy_string(const InputIterator& aFirst, const InputIterator& aLast,
            OutputIterator& aResult)
{
  typedef nsCharSourceTraits<InputIterator> source_traits;
  typedef nsCharSinkTraits<OutputIterator> sink_traits;

  sink_traits::write(aResult, source_traits::read(aFirst),
                     source_traits::readable_distance(aFirst, aLast));
  return aResult;
}

extern "C" {
void NS_QuickSort(void*, unsigned int, unsigned int,
                  int (*)(const void*, const void*, void*),
                  void*);


}


namespace mozilla {
namespace gfx {

struct UnknownUnits;

template <class units>
class IntRegionTyped;

typedef IntRegionTyped<UnknownUnits> IntRegion;

}
}

typedef mozilla::gfx::IntRegion nsIntRegion;


namespace JS {
template<class T>
class Heap;
}

class nsRegion;
namespace mozilla {
namespace layers {
struct TileClient;
}
}

namespace mozilla {
struct SerializedStructuredCloneBuffer;
class SourceBufferTask;
}

namespace mozilla {
namespace dom {
namespace ipc {
class StructuredCloneData;
}
}
}

namespace mozilla {
namespace dom {
class ClonedMessageData;
class MessagePortMessage;
namespace indexedDB {
struct StructuredCloneReadInfo;
class SerializedStructuredCloneReadInfo;
class ObjectStoreCursorResponse;
}
}
}

class JSStructuredCloneData;
struct nsTArrayFallibleResult
{

               nsTArrayFallibleResult(bool aResult) : mResult(aResult) {}

               operator bool() { return mResult; }

private:
  bool mResult;
};

struct nsTArrayInfallibleResult
{
};






struct nsTArrayFallibleAllocatorBase
{
  typedef bool ResultType;
  typedef nsTArrayFallibleResult ResultTypeProxy;

  static ResultType Result(ResultTypeProxy aResult) { return aResult; }
  static bool Successful(ResultTypeProxy aResult) { return aResult; }
  static ResultTypeProxy SuccessResult() { return true; }
  static ResultTypeProxy FailureResult() { return false; }
  static ResultType ConvertBoolToResultType(bool aValue) { return aValue; }
};

struct nsTArrayInfallibleAllocatorBase
{
  typedef void ResultType;
  typedef nsTArrayInfallibleResult ResultTypeProxy;

  static ResultType Result(ResultTypeProxy aResult) {}
  static bool Successful(ResultTypeProxy) { return true; }
  static ResultTypeProxy SuccessResult() { return ResultTypeProxy(); }

  static ResultTypeProxy FailureResult()
  {
    do { AnnotateMozCrashReason("MOZ_CRASH(" "Infallible nsTArray should never fail" ")"); do { *((volatile int*) __null) = 180; ::abort(); } while (0); } while (0);
    return ResultTypeProxy();
  }

  static ResultType ConvertBoolToResultType(bool aValue)
  {
    if (!aValue) {
      do { AnnotateMozCrashReason("MOZ_CRASH(" "infallible nsTArray should never convert false to ResultType" ")"); do { *((volatile int*) __null) = 187; ::abort(); } while (0); } while (0);
    }
  }
};

struct nsTArrayFallibleAllocator : nsTArrayFallibleAllocatorBase
{
  static void* Malloc(size_t aSize) { return malloc(aSize); }
  static void* Realloc(void* aPtr, size_t aSize)
  {
    return realloc(aPtr, aSize);
  }

  static void Free(void* aPtr) { free(aPtr); }
  static void SizeTooBig(size_t) {}
};




struct nsTArrayInfallibleAllocator : nsTArrayInfallibleAllocatorBase
{
  static void* Malloc(size_t aSize) { return moz_xmalloc(aSize); }
  static void* Realloc(void* aPtr, size_t aSize)
  {
    return moz_xrealloc(aPtr, aSize);
  }

  static void Free(void* aPtr) { free(aPtr); }
  static void SizeTooBig(size_t aSize) { NS_ABORT_OOM(aSize); }
};
struct nsTArrayHeader
{
  static nsTArrayHeader sEmptyHdr;

  uint32_t mLength;
  uint32_t mCapacity : 31;
  uint32_t mIsAutoArray : 1;
};



template<class E, class Derived>
struct nsTArray_SafeElementAtHelper
{
  typedef E* elem_type;
  typedef size_t index_type;




  elem_type& SafeElementAt(index_type aIndex);
  const elem_type& SafeElementAt(index_type aIndex) const;
};

template<class E, class Derived>
struct nsTArray_SafeElementAtHelper<E*, Derived>
{
  typedef E* elem_type;

  typedef size_t index_type;

  elem_type SafeElementAt(index_type aIndex)
  {
    return static_cast<Derived*>(this)->SafeElementAt(aIndex, nullptr);
  }





  elem_type SafeElementAt(index_type aIndex) const
  {
    return static_cast<const Derived*>(this)->SafeElementAt(aIndex, nullptr);
  }
};



template<class E, class Derived>
struct nsTArray_SafeElementAtSmartPtrHelper
{
  typedef E* elem_type;
  typedef const E* const_elem_type;
  typedef size_t index_type;

  elem_type SafeElementAt(index_type aIndex)
  {
    return static_cast<Derived*>(this)->SafeElementAt(aIndex, nullptr);
  }


  elem_type SafeElementAt(index_type aIndex) const
  {
    return static_cast<const Derived*>(this)->SafeElementAt(aIndex, nullptr);
  }
};

template<class T> class nsCOMPtr;

template<class E, class Derived>
struct nsTArray_SafeElementAtHelper<nsCOMPtr<E>, Derived>
  : public nsTArray_SafeElementAtSmartPtrHelper<E, Derived>
{
};

template<class E, class Derived>
struct nsTArray_SafeElementAtHelper<RefPtr<E>, Derived>
  : public nsTArray_SafeElementAtSmartPtrHelper<E, Derived>
{
};

namespace mozilla {
template<class T> class OwningNonNull;
}

template<class E, class Derived>
struct nsTArray_SafeElementAtHelper<mozilla::OwningNonNull<E>, Derived>
{
  typedef E* elem_type;
  typedef const E* const_elem_type;
  typedef size_t index_type;

  elem_type SafeElementAt(index_type aIndex)
  {
    if (aIndex < static_cast<Derived*>(this)->Length()) {
      return static_cast<Derived*>(this)->ElementAt(aIndex);
    }
    return nullptr;
  }


  elem_type SafeElementAt(index_type aIndex) const
  {
    if (aIndex < static_cast<const Derived*>(this)->Length()) {
      return static_cast<const Derived*>(this)->ElementAt(aIndex);
    }
    return nullptr;
  }
};


extern "C" void Gecko_EnsureTArrayCapacity(void* aArray,
                                           size_t aCapacity,
                                           size_t aElementSize);
extern "C" void Gecko_ClearPODTArray(void* aArray,
                                     size_t aElementSize,
                                     size_t aElementAlign);

__attribute__((noreturn)) __attribute__ ((cold)) void
InvalidArrayIndex_CRASH(size_t aIndex, size_t aLength);






template<class Alloc, class Copy>
class nsTArray_base
{



  template<class Allocator, class Copier>
  friend class nsTArray_base;
  friend void Gecko_EnsureTArrayCapacity(void* aArray, size_t aCapacity,
                                         size_t aElemSize);
  friend void Gecko_ClearPODTArray(void* aTArray, size_t aElementSize,
                                   size_t aElementAlign);

protected:
  typedef nsTArrayHeader Header;

public:
  typedef size_t size_type;
  typedef size_t index_type;


  size_type Length() const { return mHdr->mLength; }


  bool IsEmpty() const { return Length() == 0; }




  size_type Capacity() const { return mHdr->mCapacity; }





protected:
  nsTArray_base();

  ~nsTArray_base();





  template<typename ActualAlloc>
  typename ActualAlloc::ResultTypeProxy EnsureCapacity(size_type aCapacity,
                                                       size_type aElemSize);





  void ShrinkCapacity(size_type aElemSize, size_t aElemAlign);
  template<typename ActualAlloc>
  void ShiftData(index_type aStart, size_type aOldLen, size_type aNewLen,
                 size_type aElemSize, size_t aElemAlign);





  void IncrementLength(size_t aNum)
  {
    if (mHdr == EmptyHdr()) {
      if ((__builtin_expect(!!(aNum != 0), 0))) {

        do { AnnotateMozCrashReason("MOZ_CRASH(" ")"); do { *((volatile int*) __null) = 452; ::abort(); } while (0); } while (0);
      }
    } else {
      mHdr->mLength += aNum;
    }
  }







  template<typename ActualAlloc>
  bool InsertSlotsAt(index_type aIndex, size_type aCount,
                     size_type aElementSize, size_t aElemAlign);

  template<typename ActualAlloc, class Allocator>
  typename ActualAlloc::ResultTypeProxy
  SwapArrayElements(nsTArray_base<Allocator, Copy>& aOther,
                    size_type aElemSize,
                    size_t aElemAlign);


  class IsAutoArrayRestorer
  {
  public:
    IsAutoArrayRestorer(nsTArray_base<Alloc, Copy>& aArray, size_t aElemAlign);
    ~IsAutoArrayRestorer();

  private:
    nsTArray_base<Alloc, Copy>& mArray;
    size_t mElemAlign;
    bool mIsAuto;
  };



  template<typename ActualAlloc>
  bool EnsureNotUsingAutoArrayBuffer(size_type aElemSize);


  bool IsAutoArray() const { return mHdr->mIsAutoArray; }


  Header* GetAutoArrayBuffer(size_t aElemAlign)
  {
    do { } while (0);
    return GetAutoArrayBufferUnsafe(aElemAlign);
  }
  const Header* GetAutoArrayBuffer(size_t aElemAlign) const
  {
    do { } while (0);
    return GetAutoArrayBufferUnsafe(aElemAlign);
  }



  Header* GetAutoArrayBufferUnsafe(size_t aElemAlign)
  {
    return const_cast<Header*>(static_cast<const nsTArray_base<Alloc, Copy>*>(
      this)->GetAutoArrayBufferUnsafe(aElemAlign));
  }
  const Header* GetAutoArrayBufferUnsafe(size_t aElemAlign) const;



  bool UsesAutoArrayBuffer() const;



  Header* mHdr;

  Header* Hdr() const { return mHdr; }
  Header** PtrToHdr() { return &mHdr; }
  static Header* EmptyHdr() { return &Header::sEmptyHdr; }
};





template<class E>
class nsTArrayElementTraits
{
public:

  static inline void Construct(E* aE)
  {





    new (static_cast<void*>(aE)) E;
  }

  template<class A>
  static inline void Construct(E* aE, A&& aArg)
  {
    typedef typename mozilla::RemoveCV<E>::Type E_NoCV;
    typedef typename mozilla::RemoveCV<A>::Type A_NoCV;
    static_assert(!mozilla::IsSame<E_NoCV*, A_NoCV>::value,
                  "For safety, we disallow constructing nsTArray<E> elements "
                  "from E* pointers. See bug 960591.");
    new (static_cast<void*>(aE)) E(mozilla::Forward<A>(aArg));
  }

  static inline void Destruct(E* aE) { aE->~E(); }
};


template<class A, class B>
class nsDefaultComparator
{
public:
  bool Equals(const A& aA, const B& aB) const { return aA == aB; }
  bool LessThan(const A& aA, const B& aB) const { return aA < aB; }
};

template<bool IsPod, bool IsSameType>
struct AssignRangeAlgorithm
{
  template<class Item, class ElemType, class IndexType, class SizeType>
  static void implementation(ElemType* aElements, IndexType aStart,
                             SizeType aCount, const Item* aValues)
  {
    ElemType* iter = aElements + aStart;
    ElemType* end = iter + aCount;
    for (; iter != end; ++iter, ++aValues) {
      nsTArrayElementTraits<ElemType>::Construct(iter, *aValues);
    }
  }
};

template<>
struct AssignRangeAlgorithm<true, true>
{
  template<class Item, class ElemType, class IndexType, class SizeType>
  static void implementation(ElemType* aElements, IndexType aStart,
                             SizeType aCount, const Item* aValues)
  {
    memcpy(aElements + aStart, aValues, aCount * sizeof(ElemType));
  }
};
struct nsTArray_CopyWithMemutils
{
  const static bool allowRealloc = true;

  static void MoveNonOverlappingRegionWithHeader(void* aDest, const void* aSrc,
                                                 size_t aCount, size_t aElemSize)
  {
    memcpy(aDest, aSrc, sizeof(nsTArrayHeader) + aCount * aElemSize);
  }

  static void MoveOverlappingRegion(void* aDest, void* aSrc, size_t aCount,
                                    size_t aElemSize)
  {
    memmove(aDest, aSrc, aCount * aElemSize);
  }

  static void MoveNonOverlappingRegion(void* aDest, void* aSrc, size_t aCount,
                                       size_t aElemSize)
  {
    memcpy(aDest, aSrc, aCount * aElemSize);
  }
};





template<class ElemType>
struct nsTArray_CopyWithConstructors
{
  typedef nsTArrayElementTraits<ElemType> traits;

  const static bool allowRealloc = false;

  static void MoveNonOverlappingRegionWithHeader(void* aDest, void* aSrc, size_t aCount,
                                                 size_t aElemSize)
  {
    nsTArrayHeader* destHeader = static_cast<nsTArrayHeader*>(aDest);
    nsTArrayHeader* srcHeader = static_cast<nsTArrayHeader*>(aSrc);
    *destHeader = *srcHeader;
    MoveNonOverlappingRegion(static_cast<uint8_t*>(aDest) + sizeof(nsTArrayHeader),
                             static_cast<uint8_t*>(aSrc) + sizeof(nsTArrayHeader),
                             aCount, aElemSize);
  }
  static void MoveOverlappingRegion(void* aDest, void* aSrc, size_t aCount,
                                    size_t aElemSize)
  {
    ElemType* destElem = static_cast<ElemType*>(aDest);
    ElemType* srcElem = static_cast<ElemType*>(aSrc);
    ElemType* destElemEnd = destElem + aCount;
    ElemType* srcElemEnd = srcElem + aCount;
    if (destElem == srcElem) {
      return;
    }


    if (srcElemEnd > destElem && srcElemEnd < destElemEnd) {
      while (destElemEnd != destElem) {
        --destElemEnd;
        --srcElemEnd;
        traits::Construct(destElemEnd, mozilla::Move(*srcElemEnd));
        traits::Destruct(srcElemEnd);
      }
    } else {
      MoveNonOverlappingRegion(aDest, aSrc, aCount, aElemSize);
    }
  }

  static void MoveNonOverlappingRegion(void* aDest, void* aSrc, size_t aCount,
                                       size_t aElemSize)
  {
    ElemType* destElem = static_cast<ElemType*>(aDest);
    ElemType* srcElem = static_cast<ElemType*>(aSrc);
    ElemType* destElemEnd = destElem + aCount;




    while (destElem != destElemEnd) {
      traits::Construct(destElem, mozilla::Move(*srcElem));
      traits::Destruct(srcElem);
      ++destElem;
      ++srcElem;
    }
  }
};




template<class E>
struct nsTArray_CopyChooser
{
  typedef nsTArray_CopyWithMemutils Type;
};
template<class E>
struct nsTArray_CopyChooser<JS::Heap<E>>
{
  typedef nsTArray_CopyWithConstructors<JS::Heap<E>> Type;
};

template<> struct nsTArray_CopyChooser<nsRegion> { typedef nsTArray_CopyWithConstructors<nsRegion> Type; };
template<> struct nsTArray_CopyChooser<nsIntRegion> { typedef nsTArray_CopyWithConstructors<nsIntRegion> Type; };
template<> struct nsTArray_CopyChooser<mozilla::layers::TileClient> { typedef nsTArray_CopyWithConstructors<mozilla::layers::TileClient> Type; };
template<> struct nsTArray_CopyChooser<mozilla::SerializedStructuredCloneBuffer> { typedef nsTArray_CopyWithConstructors<mozilla::SerializedStructuredCloneBuffer> Type; };
template<> struct nsTArray_CopyChooser<mozilla::dom::ipc::StructuredCloneData> { typedef nsTArray_CopyWithConstructors<mozilla::dom::ipc::StructuredCloneData> Type; };
template<> struct nsTArray_CopyChooser<mozilla::dom::ClonedMessageData> { typedef nsTArray_CopyWithConstructors<mozilla::dom::ClonedMessageData> Type; };
template<> struct nsTArray_CopyChooser<mozilla::dom::indexedDB::StructuredCloneReadInfo> { typedef nsTArray_CopyWithConstructors<mozilla::dom::indexedDB::StructuredCloneReadInfo> Type; };;
template<> struct nsTArray_CopyChooser<mozilla::dom::indexedDB::ObjectStoreCursorResponse> { typedef nsTArray_CopyWithConstructors<mozilla::dom::indexedDB::ObjectStoreCursorResponse> Type; };
template<> struct nsTArray_CopyChooser<mozilla::dom::indexedDB::SerializedStructuredCloneReadInfo> { typedef nsTArray_CopyWithConstructors<mozilla::dom::indexedDB::SerializedStructuredCloneReadInfo> Type; };;
template<> struct nsTArray_CopyChooser<JSStructuredCloneData> { typedef nsTArray_CopyWithConstructors<JSStructuredCloneData> Type; };
template<> struct nsTArray_CopyChooser<mozilla::dom::MessagePortMessage> { typedef nsTArray_CopyWithConstructors<mozilla::dom::MessagePortMessage> Type; };
template<> struct nsTArray_CopyChooser<mozilla::SourceBufferTask> { typedef nsTArray_CopyWithConstructors<mozilla::SourceBufferTask> Type; };

template<typename T>
struct nsTArray_CopyChooser<std::function<T>>
{
  typedef nsTArray_CopyWithConstructors<std::function<T>> Type;
};







template<class E, class Derived>
struct nsTArray_TypedBase : public nsTArray_SafeElementAtHelper<E, Derived>
{
};
template<class E, class Derived>
struct nsTArray_TypedBase<JS::Heap<E>, Derived>
  : public nsTArray_SafeElementAtHelper<JS::Heap<E>, Derived>
{
  operator const nsTArray<E>&()
  {
    static_assert(sizeof(E) == sizeof(JS::Heap<E>),
                  "JS::Heap<E> must be binary compatible with E.");
    Derived* self = static_cast<Derived*>(this);
    return *reinterpret_cast<nsTArray<E> *>(self);
  }

  operator const FallibleTArray<E>&()
  {
    Derived* self = static_cast<Derived*>(this);
    return *reinterpret_cast<FallibleTArray<E> *>(self);
  }
};

namespace detail {

template<class Item, class Comparator>
struct ItemComparatorEq
{
  const Item& mItem;
  const Comparator& mComp;
  ItemComparatorEq(const Item& aItem, const Comparator& aComp)
    : mItem(aItem)
    , mComp(aComp)
  {}
  template<class T>
  int operator()(const T& aElement) const {
    if (mComp.Equals(aElement, mItem)) {
      return 0;
    }

    return mComp.LessThan(aElement, mItem) ? 1 : -1;
  }
};

template<class Item, class Comparator>
struct ItemComparatorFirstElementGT
{
  const Item& mItem;
  const Comparator& mComp;
  ItemComparatorFirstElementGT(const Item& aItem, const Comparator& aComp)
    : mItem(aItem)
    , mComp(aComp)
  {}
  template<class T>
  int operator()(const T& aElement) const {
    if (mComp.LessThan(aElement, mItem) ||
        mComp.Equals(aElement, mItem)) {
      return 1;
    } else {
      return -1;
    }
  }
};

}
template<class E, class Alloc>
class nsTArray_Impl
  : public nsTArray_base<Alloc, typename nsTArray_CopyChooser<E>::Type>
  , public nsTArray_TypedBase<E, nsTArray_Impl<E, Alloc>>
{
private:
  typedef nsTArrayFallibleAllocator FallibleAlloc;
  typedef nsTArrayInfallibleAllocator InfallibleAlloc;

public:
  typedef typename nsTArray_CopyChooser<E>::Type copy_type;
  typedef nsTArray_base<Alloc, copy_type> base_type;
  typedef typename base_type::size_type size_type;
  typedef typename base_type::index_type index_type;
  typedef E elem_type;
  typedef nsTArray_Impl<E, Alloc> self_type;
  typedef nsTArrayElementTraits<E> elem_traits;
  typedef nsTArray_SafeElementAtHelper<E, self_type> safeelementat_helper_type;
  typedef mozilla::ArrayIterator<elem_type&, nsTArray<E>> iterator;
  typedef mozilla::ArrayIterator<const elem_type&, nsTArray<E>> const_iterator;
  typedef mozilla::ReverseIterator<iterator> reverse_iterator;
  typedef mozilla::ReverseIterator<const_iterator> const_reverse_iterator;

  using safeelementat_helper_type::SafeElementAt;
  using base_type::EmptyHdr;



  static const index_type NoIndex = index_type(-1);

  using base_type::Length;





  ~nsTArray_Impl() { Clear(); }





  nsTArray_Impl() {}


  explicit nsTArray_Impl(size_type aCapacity) { SetCapacity(aCapacity); }



  template<typename Allocator>
  explicit nsTArray_Impl(nsTArray_Impl<E, Allocator>&& aOther)
  {
    SwapElements(aOther);
  }
  explicit nsTArray_Impl(const self_type& aOther) { AppendElements(aOther); }

  explicit nsTArray_Impl(std::initializer_list<E> aIL) { AppendElements(aIL.begin(), aIL.size()); }


  template<typename Allocator>
  operator const nsTArray_Impl<E, Allocator>&() const
  {
    return *reinterpret_cast<const nsTArray_Impl<E, Allocator>*>(this);
  }

  operator const nsTArray<E>&() const
  {
    return *reinterpret_cast<const InfallibleTArray<E>*>(this);
  }
  operator const FallibleTArray<E>&() const
  {
    return *reinterpret_cast<const FallibleTArray<E>*>(this);
  }




  self_type& operator=(const self_type& aOther)
  {
    if (this != &aOther) {
      ReplaceElementsAt(0, Length(), aOther.Elements(), aOther.Length());
    }
    return *this;
  }




  self_type& operator=(self_type&& aOther)
  {
    if (this != &aOther) {
      Clear();
      SwapElements(aOther);
    }
    return *this;
  }



  template<typename Allocator>
  bool operator==(const nsTArray_Impl<E, Allocator>& aOther) const
  {
    size_type len = Length();
    if (len != aOther.Length()) {
      return false;
    }


    for (index_type i = 0; i < len; ++i) {
      if (!(operator[](i) == aOther[i])) {
        return false;
      }
    }

    return true;
  }



  bool operator!=(const self_type& aOther) const { return !operator==(aOther); }

  template<typename Allocator>
  self_type& operator=(const nsTArray_Impl<E, Allocator>& aOther)
  {
    ReplaceElementsAt(0, Length(), aOther.Elements(), aOther.Length());
    return *this;
  }

  template<typename Allocator>
  self_type& operator=(nsTArray_Impl<E, Allocator>&& aOther)
  {
    Clear();
    SwapElements(aOther);
    return *this;
  }





  size_t ShallowSizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    if (this->UsesAutoArrayBuffer() || Hdr() == EmptyHdr()) {
      return 0;
    }
    return aMallocSizeOf(this->Hdr());
  }





  size_t ShallowSizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return aMallocSizeOf(this) + ShallowSizeOfExcludingThis(aMallocSizeOf);
  }
  elem_type* Elements() { return reinterpret_cast<elem_type*>(Hdr() + 1); }




  const elem_type* Elements() const
  {
    return reinterpret_cast<const elem_type*>(Hdr() + 1);
  }





  elem_type& ElementAt(index_type aIndex)
  {
    if ((__builtin_expect(!!(aIndex >= Length()), 0))) {
      InvalidArrayIndex_CRASH(aIndex, Length());
    }
    return Elements()[aIndex];
  }





  const elem_type& ElementAt(index_type aIndex) const
  {
    if ((__builtin_expect(!!(aIndex >= Length()), 0))) {
      InvalidArrayIndex_CRASH(aIndex, Length());
    }
    return Elements()[aIndex];
  }






  elem_type& SafeElementAt(index_type aIndex, elem_type& aDef)
  {
    return aIndex < Length() ? Elements()[aIndex] : aDef;
  }






  const elem_type& SafeElementAt(index_type aIndex, const elem_type& aDef) const
  {
    return aIndex < Length() ? Elements()[aIndex] : aDef;
  }


  elem_type& operator[](index_type aIndex) { return ElementAt(aIndex); }


  const elem_type& operator[](index_type aIndex) const { return ElementAt(aIndex); }


  elem_type& LastElement() { return ElementAt(Length() - 1); }


  const elem_type& LastElement() const { return ElementAt(Length() - 1); }


  elem_type& SafeLastElement(elem_type& aDef)
  {
    return SafeElementAt(Length() - 1, aDef);
  }


  const elem_type& SafeLastElement(const elem_type& aDef) const
  {
    return SafeElementAt(Length() - 1, aDef);
  }


  iterator begin() { return iterator(*this, 0); }
  const_iterator begin() const { return const_iterator(*this, 0); }
  const_iterator cbegin() const { return begin(); }
  iterator end() { return iterator(*this, Length()); }
  const_iterator end() const { return const_iterator(*this, Length()); }
  const_iterator cend() const { return end(); }


  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
  const_reverse_iterator crbegin() const { return rbegin(); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
  const_reverse_iterator crend() const { return rend(); }



  operator mozilla::Span<elem_type>()
  {
    return mozilla::Span<elem_type>(Elements(), Length());
  }

  operator mozilla::Span<const elem_type>() const
  {
    return mozilla::Span<const elem_type>(Elements(), Length());
  }
  template<class Item, class Comparator>
  bool Contains(const Item& aItem, const Comparator& aComp) const
  {
    return IndexOf(aItem, 0, aComp) != NoIndex;
  }






  template<class Item>
  bool Contains(const Item& aItem) const
  {
    return IndexOf(aItem) != NoIndex;
  }







  template<class Item, class Comparator>
  index_type IndexOf(const Item& aItem, index_type aStart,
                     const Comparator& aComp) const
  {
    const elem_type* iter = Elements() + aStart;
    const elem_type* iend = Elements() + Length();
    for (; iter != iend; ++iter) {
      if (aComp.Equals(*iter, aItem)) {
        return index_type(iter - Elements());
      }
    }
    return NoIndex;
  }







  template<class Item>
  index_type IndexOf(const Item& aItem, index_type aStart = 0) const
  {
    return IndexOf(aItem, aStart, nsDefaultComparator<elem_type, Item>());
  }
  template<class Item, class Comparator>
  index_type LastIndexOf(const Item& aItem, index_type aStart,
                         const Comparator& aComp) const
  {
    size_type endOffset = aStart >= Length() ? Length() : aStart + 1;
    const elem_type* iend = Elements() - 1;
    const elem_type* iter = iend + endOffset;
    for (; iter != iend; --iter) {
      if (aComp.Equals(*iter, aItem)) {
        return index_type(iter - Elements());
      }
    }
    return NoIndex;
  }
  template<class Item>
  index_type LastIndexOf(const Item& aItem,
                         index_type aStart = NoIndex) const
  {
    return LastIndexOf(aItem, aStart, nsDefaultComparator<elem_type, Item>());
  }
  template<class Item, class Comparator>
  index_type BinaryIndexOf(const Item& aItem, const Comparator& aComp) const
  {
    using mozilla::BinarySearchIf;
    typedef ::detail::ItemComparatorEq<Item, Comparator> Cmp;

    size_t index;
    bool found = BinarySearchIf(*this, 0, Length(), Cmp(aItem, aComp), &index);
    return found ? index : NoIndex;
  }






  template<class Item>
  index_type BinaryIndexOf(const Item& aItem) const
  {
    return BinaryIndexOf(aItem, nsDefaultComparator<elem_type, Item>());
  }





  template<class Allocator, typename ActualAlloc = Alloc>
  typename ActualAlloc::ResultType Assign(
      const nsTArray_Impl<E, Allocator>& aOther)
  {
    return ActualAlloc::ConvertBoolToResultType(
      !!ReplaceElementsAt<E, ActualAlloc>(0, Length(),
                                          aOther.Elements(), aOther.Length()));
  }

  template<class Allocator>
  __attribute__ ((warn_unused_result))
  bool Assign(const nsTArray_Impl<E, Allocator>& aOther,
              const mozilla::fallible_t&)
  {
    return Assign<Allocator, FallibleAlloc>(aOther);
  }

  template<class Allocator>
  void Assign(nsTArray_Impl<E, Allocator>&& aOther)
  {
    Clear();
    SwapElements(aOther);
  }






  void ClearAndRetainStorage()
  {
    if (base_type::mHdr == EmptyHdr()) {
      return;
    }

    DestructRange(0, Length());
    base_type::mHdr->mLength = 0;
  }
  void SetLengthAndRetainStorage(size_type aNewLen)
  {
    do { } while (0);
    size_type oldLen = Length();
    if (aNewLen > oldLen) {
      InsertElementsAt(oldLen, aNewLen - oldLen);
      return;
    }
    if (aNewLen < oldLen) {
      DestructRange(aNewLen, oldLen - aNewLen);
      base_type::mHdr->mLength = aNewLen;
    }
  }
protected:
  template<class Item, typename ActualAlloc = Alloc>
  elem_type* ReplaceElementsAt(index_type aStart, size_type aCount,
                               const Item* aArray, size_type aArrayLen);

public:

  template<class Item>
  __attribute__ ((warn_unused_result))
  elem_type* ReplaceElementsAt(index_type aStart, size_type aCount,
                               const Item* aArray, size_type aArrayLen,
                               const mozilla::fallible_t&)
  {
    return ReplaceElementsAt<Item, FallibleAlloc>(aStart, aCount,
                                                  aArray, aArrayLen);
  }


protected:
  template<class Item, typename ActualAlloc = Alloc>
  elem_type* ReplaceElementsAt(index_type aStart, size_type aCount,
                               const nsTArray<Item>& aArray)
  {
    return ReplaceElementsAt<Item, ActualAlloc>(
      aStart, aCount, aArray.Elements(), aArray.Length());
  }

  template<class Item, typename ActualAlloc = Alloc>
  elem_type* ReplaceElementsAt(index_type aStart,
                               size_type aCount,
                               mozilla::Span<const Item> aSpan)
  {
    return ReplaceElementsAt<Item, ActualAlloc>(
      aStart, aCount, aSpan.Elements(), aSpan.Length());
  }

public:

  template<class Item>
  __attribute__ ((warn_unused_result))
  elem_type* ReplaceElementsAt(index_type aStart, size_type aCount,
                               const nsTArray<Item>& aArray,
                               const mozilla::fallible_t&)
  {
    return ReplaceElementsAt<Item, FallibleAlloc>(aStart, aCount, aArray);
  }

  template<class Item>
  __attribute__ ((warn_unused_result)) elem_type* ReplaceElementsAt(index_type aStart,
                                            size_type aCount,
                                            mozilla::Span<const Item> aSpan,
                                            const mozilla::fallible_t&)
  {
    return ReplaceElementsAt<Item, FallibleAlloc>(aStart, aCount, aSpan);
  }


protected:
  template<class Item, typename ActualAlloc = Alloc>
  elem_type* ReplaceElementsAt(index_type aStart, size_type aCount,
                               const Item& aItem)
  {
    return ReplaceElementsAt<Item, ActualAlloc>(aStart, aCount, &aItem, 1);
  }
public:

  template<class Item>
  __attribute__ ((warn_unused_result))
  elem_type* ReplaceElementsAt(index_type aStart, size_type aCount,
                               const Item& aItem, const mozilla::fallible_t&)
  {
    return ReplaceElementsAt<Item, FallibleAlloc>(aStart, aCount, aItem);
  }


  template<class Item>
  elem_type* ReplaceElementAt(index_type aIndex, const Item& aItem)
  {
    return ReplaceElementsAt(aIndex, 1, &aItem, 1);
  }


protected:
  template<class Item, typename ActualAlloc = Alloc>
  elem_type* InsertElementsAt(index_type aIndex, const Item* aArray,
                              size_type aArrayLen)
  {
    return ReplaceElementsAt<Item, ActualAlloc>(aIndex, 0, aArray, aArrayLen);
  }
public:

  template<class Item>
  __attribute__ ((warn_unused_result))
  elem_type* InsertElementsAt(index_type aIndex, const Item* aArray,
                              size_type aArrayLen, const mozilla::fallible_t&)
  {
    return InsertElementsAt<Item, FallibleAlloc>(aIndex, aArray, aArrayLen);
  }


protected:
  template<class Item, class Allocator, typename ActualAlloc = Alloc>
  elem_type* InsertElementsAt(index_type aIndex,
                              const nsTArray_Impl<Item, Allocator>& aArray)
  {
    return ReplaceElementsAt<Item, ActualAlloc>(
      aIndex, 0, aArray.Elements(), aArray.Length());
  }

  template<class Item, typename ActualAlloc = Alloc>
  elem_type* InsertElementsAt(index_type aIndex,
                              mozilla::Span<const Item> aSpan)
  {
    return ReplaceElementsAt<Item, ActualAlloc>(
      aIndex, 0, aSpan.Elements(), aSpan.Length());
  }

public:

  template<class Item, class Allocator>
  __attribute__ ((warn_unused_result))
  elem_type* InsertElementsAt(index_type aIndex,
                              const nsTArray_Impl<Item, Allocator>& aArray,
                              const mozilla::fallible_t&)
  {
    return InsertElementsAt<Item, Allocator, FallibleAlloc>(aIndex, aArray);
  }

  template<class Item>
  __attribute__ ((warn_unused_result)) elem_type* InsertElementsAt(index_type aIndex,
                                           mozilla::Span<const Item> aSpan,
                                           const mozilla::fallible_t&)
  {
    return InsertElementsAt<Item, FallibleAlloc>(aIndex, aSpan);
  }




protected:
  template<typename ActualAlloc = Alloc>
  elem_type* InsertElementAt(index_type aIndex);

public:

  __attribute__ ((warn_unused_result))
  elem_type* InsertElementAt(index_type aIndex, const mozilla::fallible_t&)
  {
    return InsertElementAt<FallibleAlloc>(aIndex);
  }


protected:
  template<class Item, typename ActualAlloc = Alloc>
  elem_type* InsertElementAt(index_type aIndex, Item&& aItem);

public:

  template<class Item>
  __attribute__ ((warn_unused_result))
  elem_type* InsertElementAt(index_type aIndex, Item&& aItem,
                             const mozilla::fallible_t&)
  {
    return InsertElementAt<Item, FallibleAlloc>(aIndex,
                                                mozilla::Forward<Item>(aItem));
  }
  elem_type* ReconstructElementAt(index_type aIndex)
  {
    elem_type* elem = &ElementAt(aIndex);
    elem_traits::Destruct(elem);
    elem_traits::Construct(elem);
    return elem;
  }
  template<class Item, class Comparator>
  index_type IndexOfFirstElementGt(const Item& aItem,
                                   const Comparator& aComp) const
  {
    using mozilla::BinarySearchIf;
    typedef ::detail::ItemComparatorFirstElementGT<Item, Comparator> Cmp;

    size_t index;
    BinarySearchIf(*this, 0, Length(), Cmp(aItem, aComp), &index);
    return index;
  }


  template<class Item>
  index_type
  IndexOfFirstElementGt(const Item& aItem) const
  {
    return IndexOfFirstElementGt(aItem, nsDefaultComparator<elem_type, Item>());
  }




protected:
  template<class Item, class Comparator, typename ActualAlloc = Alloc>
  elem_type* InsertElementSorted(Item&& aItem, const Comparator& aComp)
  {
    index_type index = IndexOfFirstElementGt<Item, Comparator>(aItem, aComp);
    return InsertElementAt<Item, ActualAlloc>(
      index, mozilla::Forward<Item>(aItem));
  }
public:

  template<class Item, class Comparator>
  __attribute__ ((warn_unused_result))
  elem_type* InsertElementSorted(Item&& aItem, const Comparator& aComp,
                                 const mozilla::fallible_t&)
  {
    return InsertElementSorted<Item, Comparator, FallibleAlloc>(
      mozilla::Forward<Item>(aItem), aComp);
  }


protected:
  template<class Item, typename ActualAlloc = Alloc>
  elem_type* InsertElementSorted(Item&& aItem)
  {
    nsDefaultComparator<elem_type, Item> comp;
    return InsertElementSorted<Item, decltype(comp), ActualAlloc>(
      mozilla::Forward<Item>(aItem), comp);
  }
public:

  template<class Item>
  __attribute__ ((warn_unused_result))
  elem_type* InsertElementSorted(Item&& aItem, const mozilla::fallible_t&)
  {
    return InsertElementSorted<Item, FallibleAlloc>(
      mozilla::Forward<Item>(aItem));
  }






protected:
  template<class Item, typename ActualAlloc = Alloc>
  elem_type* AppendElements(const Item* aArray, size_type aArrayLen);

  template<class Item, typename ActualAlloc = Alloc>
  elem_type* AppendElements(mozilla::Span<const Item> aSpan)
  {
    return AppendElements<Item, FallibleAlloc>(aSpan.Elements(),
                                               aSpan.Length());
  }

  template<class Item, size_t Length, typename ActualAlloc = Alloc>
  elem_type* AppendElements(const mozilla::Array<Item, Length>& aArray)
  {
    return AppendElements<Item, ActualAlloc>(&aArray[0], Length);
  }

public:

  template<class Item>

  elem_type* AppendElements(const Item* aArray, size_type aArrayLen,
                            const mozilla::fallible_t&)
  {
    return AppendElements<Item, FallibleAlloc>(aArray, aArrayLen);
  }

  template<class Item>

  elem_type* AppendElements(mozilla::Span<const Item> aSpan,
                            const mozilla::fallible_t&)
  {
    return AppendElements<Item, FallibleAlloc>(aSpan.Elements(),
                                               aSpan.Length());
  }


protected:
  template<class Item, class Allocator, typename ActualAlloc = Alloc>
  elem_type* AppendElements(const nsTArray_Impl<Item, Allocator>& aArray)
  {
    return AppendElements<Item, ActualAlloc>(aArray.Elements(), aArray.Length());
  }
public:

  template<class Item, class Allocator>

  elem_type* AppendElements(const nsTArray_Impl<Item, Allocator>& aArray,
                            const mozilla::fallible_t&)
  {
    return AppendElements<Item, Allocator, FallibleAlloc>(aArray);
  }



protected:
  template<class Item, class Allocator, typename ActualAlloc = Alloc>
  elem_type* AppendElements(nsTArray_Impl<Item, Allocator>&& aArray);

public:

  template<class Item, class Allocator, typename ActualAlloc = Alloc>

  elem_type* AppendElements(nsTArray_Impl<Item, Allocator>&& aArray,
                            const mozilla::fallible_t&)
  {
    return AppendElements<Item, Allocator>(mozilla::Move(aArray));
  }


protected:
  template<class Item, typename ActualAlloc = Alloc>
  elem_type* AppendElement(Item&& aItem);

public:

  template<class Item>

  elem_type* AppendElement(Item&& aItem,
                           const mozilla::fallible_t&)
  {
    return AppendElement<Item, FallibleAlloc>(mozilla::Forward<Item>(aItem));
  }




protected:
  template<typename ActualAlloc = Alloc>
  elem_type* AppendElements(size_type aCount) {
    if (!ActualAlloc::Successful(this->template EnsureCapacity<ActualAlloc>(
          Length() + aCount, sizeof(elem_type)))) {
      return nullptr;
    }
    elem_type* elems = Elements() + Length();
    size_type i;
    for (i = 0; i < aCount; ++i) {
      elem_traits::Construct(elems + i);
    }
    this->IncrementLength(aCount);
    return elems;
  }
public:


  elem_type* AppendElements(size_type aCount,
                            const mozilla::fallible_t&)
  {
    return AppendElements<FallibleAlloc>(aCount);
  }




protected:
  template<typename ActualAlloc = Alloc>
  elem_type* AppendElement()
  {
    return AppendElements<ActualAlloc>(1);
  }
public:


  elem_type* AppendElement(const mozilla::fallible_t&)
  {
    return AppendElement<FallibleAlloc>();
  }




  void RemoveElementsAt(index_type aStart, size_type aCount);


  void RemoveElementAt(index_type aIndex) { RemoveElementsAt(aIndex, 1); }


  void Clear() { RemoveElementsAt(0, Length()); }






  template<typename Predicate>
  void RemoveElementsBy(Predicate aPredicate);






  template<class Item, class Comparator>
  bool RemoveElement(const Item& aItem, const Comparator& aComp)
  {
    index_type i = IndexOf(aItem, 0, aComp);
    if (i == NoIndex) {
      return false;
    }

    RemoveElementAt(i);
    return true;
  }



  template<class Item>
  bool RemoveElement(const Item& aItem)
  {
    return RemoveElement(aItem, nsDefaultComparator<elem_type, Item>());
  }







  template<class Item, class Comparator>
  bool RemoveElementSorted(const Item& aItem, const Comparator& aComp)
  {
    index_type index = IndexOfFirstElementGt(aItem, aComp);
    if (index > 0 && aComp.Equals(ElementAt(index - 1), aItem)) {
      RemoveElementAt(index - 1);
      return true;
    }
    return false;
  }


  template<class Item>
  bool RemoveElementSorted(const Item& aItem)
  {
    return RemoveElementSorted(aItem, nsDefaultComparator<elem_type, Item>());
  }



  template<class Allocator>
  typename Alloc::ResultType SwapElements(nsTArray_Impl<E, Allocator>& aOther)
  {
    return Alloc::Result(this->template SwapArrayElements<Alloc>(
      aOther, sizeof(elem_type), mozilla::AlignmentFinder<elem_type>::alignment));
  }
protected:
  template<typename ActualAlloc = Alloc>
  typename ActualAlloc::ResultType SetCapacity(size_type aCapacity)
  {
    return ActualAlloc::Result(this->template EnsureCapacity<ActualAlloc>(
      aCapacity, sizeof(elem_type)));
  }
public:

  __attribute__ ((warn_unused_result))
  bool SetCapacity(size_type aCapacity, const mozilla::fallible_t&)
  {
    return SetCapacity<FallibleAlloc>(aCapacity);
  }
protected:
  template<typename ActualAlloc = Alloc>
  typename ActualAlloc::ResultType SetLength(size_type aNewLen)
  {
    size_type oldLen = Length();
    if (aNewLen > oldLen) {
      return ActualAlloc::ConvertBoolToResultType(
        InsertElementsAt<ActualAlloc>(oldLen, aNewLen - oldLen) != nullptr);
    }

    TruncateLength(aNewLen);
    return ActualAlloc::ConvertBoolToResultType(true);
  }
public:

  __attribute__ ((warn_unused_result))
  bool SetLength(size_type aNewLen, const mozilla::fallible_t&)
  {
    return SetLength<FallibleAlloc>(aNewLen);
  }







  void TruncateLength(size_type aNewLen)
  {
    size_type oldLen = Length();
    do { } while (0);

    RemoveElementsAt(aNewLen, oldLen - aNewLen);
  }







protected:
  template<typename ActualAlloc = Alloc>
  typename ActualAlloc::ResultType EnsureLengthAtLeast(size_type aMinLen)
  {
    size_type oldLen = Length();
    if (aMinLen > oldLen) {
      return ActualAlloc::ConvertBoolToResultType(
        !!InsertElementsAt<ActualAlloc>(oldLen, aMinLen - oldLen));
    }
    return ActualAlloc::ConvertBoolToResultType(true);
  }
public:

  __attribute__ ((warn_unused_result))
  bool EnsureLengthAtLeast(size_type aMinLen, const mozilla::fallible_t&)
  {
    return EnsureLengthAtLeast<FallibleAlloc>(aMinLen);
  }






protected:
  template<typename ActualAlloc = Alloc>
  elem_type* InsertElementsAt(index_type aIndex, size_type aCount)
  {
    if (!base_type::template InsertSlotsAt<ActualAlloc>(aIndex, aCount,
                                                        sizeof(elem_type),
                                                        mozilla::AlignmentFinder<elem_type>::alignment)) {
      return nullptr;
    }


    elem_type* iter = Elements() + aIndex;
    elem_type* iend = iter + aCount;
    for (; iter != iend; ++iter) {
      elem_traits::Construct(iter);
    }

    return Elements() + aIndex;
  }
public:

  __attribute__ ((warn_unused_result))
  elem_type* InsertElementsAt(index_type aIndex, size_type aCount,
                              const mozilla::fallible_t&)
  {
    return InsertElementsAt<FallibleAlloc>(aIndex, aCount);
  }
protected:
  template<class Item, typename ActualAlloc = Alloc>
  elem_type* InsertElementsAt(index_type aIndex, size_type aCount,
                              const Item& aItem);

public:

  template<class Item>
  __attribute__ ((warn_unused_result))
  elem_type* InsertElementsAt(index_type aIndex, size_type aCount,
                              const Item& aItem, const mozilla::fallible_t&)
  {
    return InsertElementsAt<Item, FallibleAlloc>(aIndex, aCount, aItem);
  }


  void Compact()
  {
    ShrinkCapacity(sizeof(elem_type), mozilla::AlignmentFinder<elem_type>::alignment);
  }
  template<class Comparator>
  static int Compare(const void* aE1, const void* aE2, void* aData)
  {
    const Comparator* c = reinterpret_cast<const Comparator*>(aData);
    const elem_type* a = static_cast<const elem_type*>(aE1);
    const elem_type* b = static_cast<const elem_type*>(aE2);
    return c->LessThan(*a, *b) ? -1 : (c->Equals(*a, *b) ? 0 : 1);
  }




  template<class Comparator>
  void Sort(const Comparator& aComp)
  {
    NS_QuickSort(Elements(), Length(), sizeof(elem_type),
                 Compare<Comparator>, const_cast<Comparator*>(&aComp));
  }



  void Sort() { Sort(nsDefaultComparator<elem_type, elem_type>()); }


  void Reverse()
  {
    elem_type* elements = Elements();
    const size_type len = Length();
    for (index_type i = 0, iend = len / 2; i < iend; ++i) {
      mozilla::Swap(elements[i], elements[len - i - 1]);
    }
  }

protected:
  using base_type::Hdr;
  using base_type::ShrinkCapacity;




  void DestructRange(index_type aStart, size_type aCount)
  {
    elem_type* iter = Elements() + aStart;
    elem_type *iend = iter + aCount;
    for (; iter != iend; ++iter) {
      elem_traits::Destruct(iter);
    }
  }





  template<class Item>
  void AssignRange(index_type aStart, size_type aCount, const Item* aValues)
  {
    AssignRangeAlgorithm<mozilla::IsPod<Item>::value,
                         mozilla::IsSame<Item, elem_type>::value>
                         ::implementation(Elements(), aStart, aCount, aValues);
  }
};

template<typename E, class Alloc>
template<class Item, typename ActualAlloc>
auto
nsTArray_Impl<E, Alloc>::ReplaceElementsAt(index_type aStart, size_type aCount,
                                           const Item* aArray, size_type aArrayLen) -> elem_type*
{
  if ((__builtin_expect(!!(aStart > Length()), 0))) {
    InvalidArrayIndex_CRASH(aStart, Length());
  }


  if (!ActualAlloc::Successful(this->template EnsureCapacity<ActualAlloc>(
        Length() + aArrayLen - aCount, sizeof(elem_type)))) {
    return nullptr;
  }
  DestructRange(aStart, aCount);
  this->template ShiftData<ActualAlloc>(aStart, aCount, aArrayLen,
                                        sizeof(elem_type),
                                        mozilla::AlignmentFinder<elem_type>::alignment);
  AssignRange(aStart, aArrayLen, aArray);
  return Elements() + aStart;
}

template<typename E, class Alloc>
void
nsTArray_Impl<E, Alloc>::RemoveElementsAt(index_type aStart, size_type aCount)
{
  do { } while (0);
  do { } while (0);

  do { } while (0);
  DestructRange(aStart, aCount);
  this->template ShiftData<InfallibleAlloc>(aStart, aCount, 0,
                                            sizeof(elem_type),
                                            mozilla::AlignmentFinder<elem_type>::alignment);
}

template<typename E, class Alloc>
template<typename Predicate>
void
nsTArray_Impl<E, Alloc>::RemoveElementsBy(Predicate aPredicate)
{
  if (base_type::mHdr == EmptyHdr()) {
    return;
  }

  index_type j = 0;
  index_type len = Length();
  for (index_type i = 0; i < len; ++i) {
    if (aPredicate(Elements()[i])) {
      elem_traits::Destruct(Elements() + i);
    } else {
      if (j < i) {
        copy_type::MoveNonOverlappingRegion(Elements() + j, Elements() + i,
                                            1, sizeof(elem_type));
      }
      ++j;
    }
  }
  base_type::mHdr->mLength = j;
}

template<typename E, class Alloc>
template<class Item, typename ActualAlloc>
auto
nsTArray_Impl<E, Alloc>::InsertElementsAt(index_type aIndex, size_type aCount,
                                          const Item& aItem) -> elem_type*
{
  if (!base_type::template InsertSlotsAt<ActualAlloc>(aIndex, aCount,
                                                      sizeof(elem_type),
                                                      mozilla::AlignmentFinder<elem_type>::alignment)) {
    return nullptr;
  }


  elem_type* iter = Elements() + aIndex;
  elem_type* iend = iter + aCount;
  for (; iter != iend; ++iter) {
    elem_traits::Construct(iter, aItem);
  }

  return Elements() + aIndex;
}

template<typename E, class Alloc>
template<typename ActualAlloc>
auto
nsTArray_Impl<E, Alloc>::InsertElementAt(index_type aIndex) -> elem_type*
{
  if ((__builtin_expect(!!(aIndex > Length()), 0))) {
    InvalidArrayIndex_CRASH(aIndex, Length());
  }

  if (!ActualAlloc::Successful(this->template EnsureCapacity<ActualAlloc>(
        Length() + 1, sizeof(elem_type)))) {
    return nullptr;
  }
  this->template ShiftData<ActualAlloc>(aIndex, 0, 1, sizeof(elem_type),
                                        mozilla::AlignmentFinder<elem_type>::alignment);
  elem_type* elem = Elements() + aIndex;
  elem_traits::Construct(elem);
  return elem;
}

template<typename E, class Alloc>
template<class Item, typename ActualAlloc>
auto
nsTArray_Impl<E, Alloc>::InsertElementAt(index_type aIndex, Item&& aItem) -> elem_type*
{
  if ((__builtin_expect(!!(aIndex > Length()), 0))) {
    InvalidArrayIndex_CRASH(aIndex, Length());
  }

  if (!ActualAlloc::Successful(this->template EnsureCapacity<ActualAlloc>(
         Length() + 1, sizeof(elem_type)))) {
    return nullptr;
  }
  this->template ShiftData<ActualAlloc>(aIndex, 0, 1, sizeof(elem_type),
                                        mozilla::AlignmentFinder<elem_type>::alignment);
  elem_type* elem = Elements() + aIndex;
  elem_traits::Construct(elem, mozilla::Forward<Item>(aItem));
  return elem;
}

template<typename E, class Alloc>
template<class Item, typename ActualAlloc>
auto
nsTArray_Impl<E, Alloc>::AppendElements(const Item* aArray, size_type aArrayLen) -> elem_type*
{
  if (!ActualAlloc::Successful(this->template EnsureCapacity<ActualAlloc>(
        Length() + aArrayLen, sizeof(elem_type)))) {
    return nullptr;
  }
  index_type len = Length();
  AssignRange(len, aArrayLen, aArray);
  this->IncrementLength(aArrayLen);
  return Elements() + len;
}

template<typename E, class Alloc>
template<class Item, class Allocator, typename ActualAlloc>
auto
nsTArray_Impl<E, Alloc>::AppendElements(nsTArray_Impl<Item, Allocator>&& aArray) -> elem_type*
{
  do { } while (0);
  if (Length() == 0) {
    SwapElements<ActualAlloc>(aArray);
    return Elements();
  }

  index_type len = Length();
  index_type otherLen = aArray.Length();
  if (!Alloc::Successful(this->template EnsureCapacity<Alloc>(
        len + otherLen, sizeof(elem_type)))) {
    return nullptr;
  }
  copy_type::MoveNonOverlappingRegion(Elements() + len, aArray.Elements(), otherLen,
                                      sizeof(elem_type));
  this->IncrementLength(otherLen);
  aArray.template ShiftData<Alloc>(0, otherLen, 0, sizeof(elem_type),
                                   mozilla::AlignmentFinder<elem_type>::alignment);
  return Elements() + len;
}

template<typename E, class Alloc>
template<class Item, typename ActualAlloc>
auto
nsTArray_Impl<E, Alloc>::AppendElement(Item&& aItem) -> elem_type*
{
  if (!ActualAlloc::Successful(this->template EnsureCapacity<ActualAlloc>(
         Length() + 1, sizeof(elem_type)))) {
    return nullptr;
  }
  elem_type* elem = Elements() + Length();
  elem_traits::Construct(elem, mozilla::Forward<Item>(aItem));
  this->IncrementLength(1);
  return elem;
}

template<typename E, typename Alloc>
inline void
ImplCycleCollectionUnlink(nsTArray_Impl<E, Alloc>& aField)
{
  aField.Clear();
}

template<typename E, typename Alloc>
inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            nsTArray_Impl<E, Alloc>& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  aFlags |= CycleCollectionEdgeNameArrayFlag;
  size_t length = aField.Length();
  for (size_t i = 0; i < length; ++i) {
    ImplCycleCollectionTraverse(aCallback, aField[i], aName, aFlags);
  }
}





template<class E>
class nsTArray : public nsTArray_Impl<E, nsTArrayInfallibleAllocator>
{
public:
  typedef nsTArray_Impl<E, nsTArrayInfallibleAllocator> base_type;
  typedef nsTArray<E> self_type;
  typedef typename base_type::size_type size_type;

  nsTArray() {}
  explicit nsTArray(size_type aCapacity) : base_type(aCapacity) {}
  explicit nsTArray(const nsTArray& aOther) : base_type(aOther) {}
               nsTArray(nsTArray&& aOther) : base_type(mozilla::Move(aOther)) {}
               nsTArray(std::initializer_list<E> aIL) : base_type(aIL) {}

  template<class Allocator>
  explicit nsTArray(const nsTArray_Impl<E, Allocator>& aOther)
    : base_type(aOther)
  {
  }
  template<class Allocator>
               nsTArray(nsTArray_Impl<E, Allocator>&& aOther)
    : base_type(mozilla::Move(aOther))
  {
  }

  self_type& operator=(const self_type& aOther)
  {
    base_type::operator=(aOther);
    return *this;
  }
  template<class Allocator>
  self_type& operator=(const nsTArray_Impl<E, Allocator>& aOther)
  {
    base_type::operator=(aOther);
    return *this;
  }
  self_type& operator=(self_type&& aOther)
  {
    base_type::operator=(mozilla::Move(aOther));
    return *this;
  }
  template<class Allocator>
  self_type& operator=(nsTArray_Impl<E, Allocator>&& aOther)
  {
    base_type::operator=(mozilla::Move(aOther));
    return *this;
  }

  using base_type::AppendElement;
  using base_type::AppendElements;
  using base_type::EnsureLengthAtLeast;
  using base_type::InsertElementAt;
  using base_type::InsertElementsAt;
  using base_type::InsertElementSorted;
  using base_type::ReplaceElementsAt;
  using base_type::SetCapacity;
  using base_type::SetLength;
};




template<class E>
class FallibleTArray : public nsTArray_Impl<E, nsTArrayFallibleAllocator>
{
public:
  typedef nsTArray_Impl<E, nsTArrayFallibleAllocator> base_type;
  typedef FallibleTArray<E> self_type;
  typedef typename base_type::size_type size_type;

  FallibleTArray() {}
  explicit FallibleTArray(size_type aCapacity) : base_type(aCapacity) {}
  explicit FallibleTArray(const FallibleTArray<E>& aOther) : base_type(aOther) {}
  FallibleTArray(FallibleTArray<E>&& aOther)
    : base_type(mozilla::Move(aOther))
  {
  }

  template<class Allocator>
  explicit FallibleTArray(const nsTArray_Impl<E, Allocator>& aOther)
    : base_type(aOther)
  {
  }
  template<class Allocator>
  explicit FallibleTArray(nsTArray_Impl<E, Allocator>&& aOther)
    : base_type(mozilla::Move(aOther))
  {
  }

  self_type& operator=(const self_type& aOther)
  {
    base_type::operator=(aOther);
    return *this;
  }
  template<class Allocator>
  self_type& operator=(const nsTArray_Impl<E, Allocator>& aOther)
  {
    base_type::operator=(aOther);
    return *this;
  }
  self_type& operator=(self_type&& aOther)
  {
    base_type::operator=(mozilla::Move(aOther));
    return *this;
  }
  template<class Allocator>
  self_type& operator=(nsTArray_Impl<E, Allocator>&& aOther)
  {
    base_type::operator=(mozilla::Move(aOther));
    return *this;
  }
};





template<class E, size_t N>
class AutoTArray : public nsTArray<E>
{
  static_assert(N != 0, "AutoTArray<E, 0> should be specialized");
public:
  typedef AutoTArray<E, N> self_type;
  typedef nsTArray<E> base_type;
  typedef typename base_type::Header Header;
  typedef typename base_type::elem_type elem_type;

  AutoTArray()
  {
    Init();
  }

  AutoTArray(const self_type& aOther)
  {
    Init();
    this->AppendElements(aOther);
  }

  explicit AutoTArray(const base_type& aOther)
  {
    Init();
    this->AppendElements(aOther);
  }

  explicit AutoTArray(base_type&& aOther)
  {
    Init();
    this->SwapElements(aOther);
  }

  template<typename Allocator>
  explicit AutoTArray(nsTArray_Impl<elem_type, Allocator>&& aOther)
  {
    Init();
    this->SwapElements(aOther);
  }

               AutoTArray(std::initializer_list<E> aIL)
  {
    Init();
    this->AppendElements(aIL.begin(), aIL.size());
  }

  self_type& operator=(const self_type& aOther)
  {
    base_type::operator=(aOther);
    return *this;
  }

  template<typename Allocator>
  self_type& operator=(const nsTArray_Impl<elem_type, Allocator>& aOther)
  {
    base_type::operator=(aOther);
    return *this;
  }

private:


  template<class Allocator, class Copier>
  friend class nsTArray_base;

  void Init()
  {
    static_assert(mozilla::AlignmentFinder<elem_type>::alignment <= 8,
                  "can't handle alignments greater than 8, "
                  "see nsTArray_base::UsesAutoArrayBuffer()");

    Header** phdr = base_type::PtrToHdr();
    *phdr = reinterpret_cast<Header*>(&mAutoBuf);
    (*phdr)->mLength = 0;
    (*phdr)->mCapacity = N;
    (*phdr)->mIsAutoArray = 1;

    do { } while (0);


  }





  union
  {
    char mAutoBuf[sizeof(nsTArrayHeader) + N * sizeof(elem_type)];

    mozilla::AlignedElem<(mozilla::AlignmentFinder<Header>::alignment > mozilla::AlignmentFinder<elem_type>::alignment) ?
                         mozilla::AlignmentFinder<Header>::alignment : mozilla::AlignmentFinder<elem_type>::alignment> mAlign;
  };
};
template<class E>
class AutoTArray<E, 0> : public nsTArray<E>
{
};

template<class E, size_t N>
struct nsTArray_CopyChooser<AutoTArray<E, N>>
{
  typedef nsTArray_CopyWithConstructors<AutoTArray<E, N>> Type;
};


namespace mozilla {

template<class ElementType, class TArrayAlloc>
Span<ElementType>
MakeSpan(nsTArray_Impl<ElementType, TArrayAlloc>& aTArray)
{
  return aTArray;
}

template<class ElementType, class TArrayAlloc>
Span<const ElementType>
MakeSpan(const nsTArray_Impl<ElementType, TArrayAlloc>& aTArray)
{
  return aTArray;
}

}
static_assert(sizeof(AutoTArray<uint32_t, 2>) ==
              sizeof(void*) + sizeof(nsTArrayHeader) + sizeof(uint32_t) * 2,
              "AutoTArray shouldn't contain any extra padding, "
              "see the comment");



template<class Alloc, class Copy>
nsTArray_base<Alloc, Copy>::nsTArray_base()
  : mHdr(EmptyHdr())
{
                               ;
}

template<class Alloc, class Copy>
nsTArray_base<Alloc, Copy>::~nsTArray_base()
{
  if (mHdr != EmptyHdr() && !UsesAutoArrayBuffer()) {
    Alloc::Free(mHdr);
  }
                               ;
}

template<class Alloc, class Copy>
const nsTArrayHeader*
nsTArray_base<Alloc, Copy>::GetAutoArrayBufferUnsafe(size_t aElemAlign) const
{



  const void* autoBuf =
    &reinterpret_cast<const AutoTArray<nsTArray<uint32_t>, 1>*>(this)->mAutoBuf;




  static_assert(sizeof(void*) != 4 ||
                (mozilla::AlignmentFinder<mozilla::AlignedElem<8> >::alignment == 8 &&
                 sizeof(AutoTArray<mozilla::AlignedElem<8>, 1>) ==
                   sizeof(void*) + sizeof(nsTArrayHeader) +
                   4 + sizeof(mozilla::AlignedElem<8>)),
                "auto array padding wasn't what we expected");


  do { } while (0);

  if (sizeof(void*) == 4 && aElemAlign == 8) {
    autoBuf = reinterpret_cast<const char*>(autoBuf) + 4;
  }

  return reinterpret_cast<const Header*>(autoBuf);
}

template<class Alloc, class Copy>
bool
nsTArray_base<Alloc, Copy>::UsesAutoArrayBuffer() const
{
  if (!mHdr->mIsAutoArray) {
    return false;
  }
  static_assert(sizeof(nsTArrayHeader) > 4,
                "see comment above");
  return mHdr == GetAutoArrayBuffer(4) || mHdr == GetAutoArrayBuffer(8);
}


bool IsTwiceTheRequiredBytesRepresentableAsUint32(size_t aCapacity,
                                                  size_t aElemSize);

template<class Alloc, class Copy>
template<typename ActualAlloc>
typename ActualAlloc::ResultTypeProxy
nsTArray_base<Alloc, Copy>::EnsureCapacity(size_type aCapacity,
                                           size_type aElemSize)
{

  if (aCapacity <= mHdr->mCapacity) {
    return ActualAlloc::SuccessResult();
  }






  if (!IsTwiceTheRequiredBytesRepresentableAsUint32(aCapacity, aElemSize)) {
    ActualAlloc::SizeTooBig((size_t)aCapacity * aElemSize);
    return ActualAlloc::FailureResult();
  }

  size_t reqSize = sizeof(Header) + aCapacity * aElemSize;

  if (mHdr == EmptyHdr()) {

    Header* header = static_cast<Header*>(ActualAlloc::Malloc(reqSize));
    if (!header) {
      return ActualAlloc::FailureResult();
    }
    header->mLength = 0;
    header->mCapacity = aCapacity;
    header->mIsAutoArray = 0;
    mHdr = header;

    return ActualAlloc::SuccessResult();
  }





  const size_t slowGrowthThreshold = 8 * 1024 * 1024;

  size_t bytesToAlloc;
  if (reqSize >= slowGrowthThreshold) {
    size_t currSize = sizeof(Header) + Capacity() * aElemSize;
    size_t minNewSize = currSize + (currSize >> 3);
    bytesToAlloc = reqSize > minNewSize ? reqSize : minNewSize;


    const size_t MiB = 1 << 20;
    bytesToAlloc = MiB * ((bytesToAlloc + MiB - 1) / MiB);
  } else {

    bytesToAlloc = mozilla::RoundUpPow2(reqSize);
  }

  Header* header;
  if (UsesAutoArrayBuffer() || !Copy::allowRealloc) {

    header = static_cast<Header*>(ActualAlloc::Malloc(bytesToAlloc));
    if (!header) {
      return ActualAlloc::FailureResult();
    }

    Copy::MoveNonOverlappingRegionWithHeader(header, mHdr, Length(), aElemSize);

    if (!UsesAutoArrayBuffer()) {
      ActualAlloc::Free(mHdr);
    }
  } else {

    header = static_cast<Header*>(ActualAlloc::Realloc(mHdr, bytesToAlloc));
    if (!header) {
      return ActualAlloc::FailureResult();
    }
  }


  size_t newCapacity = (bytesToAlloc - sizeof(Header)) / aElemSize;
  do { } while (0);
  header->mCapacity = newCapacity;

  mHdr = header;

  return ActualAlloc::SuccessResult();
}



template<class Alloc, class Copy>
void
nsTArray_base<Alloc, Copy>::ShrinkCapacity(size_type aElemSize,
                                           size_t aElemAlign)
{
  if (mHdr == EmptyHdr() || UsesAutoArrayBuffer()) {
    return;
  }

  if (mHdr->mLength >= mHdr->mCapacity) {
    return;
  }

  size_type length = Length();

  if (IsAutoArray() && GetAutoArrayBuffer(aElemAlign)->mCapacity >= length) {
    Header* header = GetAutoArrayBuffer(aElemAlign);


    header->mLength = length;
    Copy::MoveNonOverlappingRegion(header + 1, mHdr + 1, length, aElemSize);

    nsTArrayFallibleAllocator::Free(mHdr);
    mHdr = header;
    return;
  }

  if (length == 0) {
    do { } while (0);
    nsTArrayFallibleAllocator::Free(mHdr);
    mHdr = EmptyHdr();
    return;
  }

  size_type size = sizeof(Header) + length * aElemSize;
  void* ptr = nsTArrayFallibleAllocator::Realloc(mHdr, size);
  if (!ptr) {
    return;
  }
  mHdr = static_cast<Header*>(ptr);
  mHdr->mCapacity = length;
}

template<class Alloc, class Copy>
template<typename ActualAlloc>
void
nsTArray_base<Alloc, Copy>::ShiftData(index_type aStart,
                                      size_type aOldLen, size_type aNewLen,
                                      size_type aElemSize, size_t aElemAlign)
{
  if (aOldLen == aNewLen) {
    return;
  }


  size_type num = mHdr->mLength - (aStart + aOldLen);


  mHdr->mLength += aNewLen - aOldLen;
  if (mHdr->mLength == 0) {
    ShrinkCapacity(aElemSize, aElemAlign);
  } else {

    if (num == 0) {
      return;
    }

    aStart *= aElemSize;
    aNewLen *= aElemSize;
    aOldLen *= aElemSize;
    char* baseAddr = reinterpret_cast<char*>(mHdr + 1) + aStart;
    Copy::MoveOverlappingRegion(baseAddr + aNewLen, baseAddr + aOldLen, num, aElemSize);
  }
}

template<class Alloc, class Copy>
template<typename ActualAlloc>
bool
nsTArray_base<Alloc, Copy>::InsertSlotsAt(index_type aIndex, size_type aCount,
                                          size_type aElemSize,
                                          size_t aElemAlign)
{
  if ((__builtin_expect(!!(aIndex > Length()), 0))) {
    InvalidArrayIndex_CRASH(aIndex, Length());
  }

  size_type newLen = Length() + aCount;

  EnsureCapacity<ActualAlloc>(newLen, aElemSize);


  if (Capacity() < newLen) {
    return false;
  }



  ShiftData<ActualAlloc>(aIndex, 0, aCount, aElemSize, aElemAlign);

  return true;
}
template<class Alloc, class Copy>
nsTArray_base<Alloc, Copy>::IsAutoArrayRestorer::IsAutoArrayRestorer(
      nsTArray_base<Alloc, Copy>& aArray,
      size_t aElemAlign)
  : mArray(aArray)
  , mElemAlign(aElemAlign)
  , mIsAuto(aArray.IsAutoArray())
{
}

template<class Alloc, class Copy>
nsTArray_base<Alloc, Copy>::IsAutoArrayRestorer::~IsAutoArrayRestorer()
{

  if (mIsAuto && mArray.mHdr == mArray.EmptyHdr()) {


    mArray.mHdr = mArray.GetAutoArrayBufferUnsafe(mElemAlign);
    mArray.mHdr->mLength = 0;
  } else if (mArray.mHdr != mArray.EmptyHdr()) {
    mArray.mHdr->mIsAutoArray = mIsAuto;
  }
}

template<class Alloc, class Copy>
template<typename ActualAlloc, class Allocator>
typename ActualAlloc::ResultTypeProxy
nsTArray_base<Alloc, Copy>::SwapArrayElements(nsTArray_base<Allocator,
                                                            Copy>& aOther,
                                              size_type aElemSize,
                                              size_t aElemAlign)
{






  IsAutoArrayRestorer ourAutoRestorer(*this, aElemAlign);
  typename nsTArray_base<Allocator, Copy>::IsAutoArrayRestorer
    otherAutoRestorer(aOther, aElemAlign);




  if ((!UsesAutoArrayBuffer() || Capacity() < aOther.Length()) &&
      (!aOther.UsesAutoArrayBuffer() || aOther.Capacity() < Length())) {

    if (!EnsureNotUsingAutoArrayBuffer<ActualAlloc>(aElemSize) ||
        !aOther.template EnsureNotUsingAutoArrayBuffer<ActualAlloc>(aElemSize)) {
      return ActualAlloc::FailureResult();
    }

    Header* temp = mHdr;
    mHdr = aOther.mHdr;
    aOther.mHdr = temp;

    return ActualAlloc::SuccessResult();
  }
  if (!ActualAlloc::Successful(EnsureCapacity<ActualAlloc>(aOther.Length(), aElemSize)) ||
      !Allocator::Successful(aOther.template EnsureCapacity<Allocator>(Length(), aElemSize))) {
    return ActualAlloc::FailureResult();
  }



  do { } while (0);


  size_type smallerLength = XPCOM_MIN(Length(), aOther.Length());
  size_type largerLength = XPCOM_MAX(Length(), aOther.Length());
  void* smallerElements;
  void* largerElements;
  if (Length() <= aOther.Length()) {
    smallerElements = Hdr() + 1;
    largerElements = aOther.Hdr() + 1;
  } else {
    smallerElements = aOther.Hdr() + 1;
    largerElements = Hdr() + 1;
  }






  AutoTArray<nsTArray_Impl<uint8_t, ActualAlloc>, 64> temp;
  if (!ActualAlloc::Successful(temp.template EnsureCapacity<ActualAlloc>(smallerLength,
                                                                         aElemSize))) {
    return ActualAlloc::FailureResult();
  }

  Copy::MoveNonOverlappingRegion(temp.Elements(), smallerElements, smallerLength, aElemSize);
  Copy::MoveNonOverlappingRegion(smallerElements, largerElements, largerLength, aElemSize);
  Copy::MoveNonOverlappingRegion(largerElements, temp.Elements(), smallerLength, aElemSize);


  do { } while (0);


  size_type tempLength = Length();



  if (mHdr != EmptyHdr()) {
    mHdr->mLength = aOther.Length();
  }
  if (aOther.mHdr != EmptyHdr()) {
    aOther.mHdr->mLength = tempLength;
  }

  return ActualAlloc::SuccessResult();
}

template<class Alloc, class Copy>
template<typename ActualAlloc>
bool
nsTArray_base<Alloc, Copy>::EnsureNotUsingAutoArrayBuffer(size_type aElemSize)
{
  if (UsesAutoArrayBuffer()) {





    if (Length() == 0) {
      mHdr = EmptyHdr();
      return true;
    }

    size_type size = sizeof(Header) + Length() * aElemSize;

    Header* header = static_cast<Header*>(ActualAlloc::Malloc(size));
    if (!header) {
      return false;
    }

    Copy::MoveNonOverlappingRegionWithHeader(header, mHdr, Length(), aElemSize);
    header->mCapacity = Length();
    mHdr = header;
  }

  return true;
}






template<typename T>
class nsStyleAutoArray
{
public:

  enum WithSingleInitialElement { WITH_SINGLE_INITIAL_ELEMENT };
  explicit nsStyleAutoArray(WithSingleInitialElement) {}
  nsStyleAutoArray(const nsStyleAutoArray& aOther) { *this = aOther; }
  nsStyleAutoArray& operator=(const nsStyleAutoArray& aOther) {
    mFirstElement = aOther.mFirstElement;
    mOtherElements = aOther.mOtherElements;
    return *this;
  }

  bool operator==(const nsStyleAutoArray& aOther) const {
    return Length() == aOther.Length() &&
           mFirstElement == aOther.mFirstElement &&
           mOtherElements == aOther.mOtherElements;
  }
  bool operator!=(const nsStyleAutoArray& aOther) const {
    return !(*this == aOther);
  }

  nsStyleAutoArray& operator=(nsStyleAutoArray&& aOther) {
    mFirstElement = aOther.mFirstElement;
    mOtherElements.SwapElements(aOther.mOtherElements);

    return *this;
  }

  size_t Length() const {
    return mOtherElements.Length() + 1;
  }
  const T& operator[](size_t aIndex) const {
    return aIndex == 0 ? mFirstElement : mOtherElements[aIndex - 1];
  }
  T& operator[](size_t aIndex) {
    return aIndex == 0 ? mFirstElement : mOtherElements[aIndex - 1];
  }

  void EnsureLengthAtLeast(size_t aMinLen) {
    if (aMinLen > 0) {
      mOtherElements.EnsureLengthAtLeast(aMinLen - 1);
    }
  }

  void SetLengthNonZero(size_t aNewLen) {
    do { } while (0);
    mOtherElements.SetLength(aNewLen - 1);
  }

  void TruncateLengthNonZero(size_t aNewLen) {
    do { } while (0);
    do { } while (0);
    mOtherElements.TruncateLength(aNewLen - 1);
  }

private:
  T mFirstElement;
  nsTArray<T> mOtherElements;
};


struct RawServoStyleSet;











struct ServoCssRules;
struct RawServoStyleSheet;
struct ServoComputedValues;
struct RawServoDeclarationBlock;
struct RawServoStyleRule;
struct RawServoImportRule;
struct RawServoAnimationValue;
struct RawServoAnimationValueMap;
struct RawServoMediaList;
struct RawServoMediaRule;
struct RawServoNamespaceRule;


namespace mozilla {
  class ServoElementSnapshot;
  struct StyleAnimation;
namespace css {
struct URLExtraData;
}
namespace dom {
class Element;
class StyleChildrenIterator;
}
struct AnimationPropertySegment;
struct ComputedTiming;
struct Keyframe;
struct PropertyStyleAnimationValuePair;
using ComputedKeyframeValues = nsTArray<PropertyStyleAnimationValuePair>;
}

class nsCSSValue;
struct nsFontFaceRuleContainer;
class nsIDocument;
class nsINode;
class nsPresContext;
struct nsTimingFunction;

using mozilla::dom::StyleChildrenIterator;
using mozilla::ServoElementSnapshot;

typedef nsINode RawGeckoNode;
typedef mozilla::dom::Element RawGeckoElement;
typedef nsIDocument RawGeckoDocument;
typedef nsPresContext RawGeckoPresContext;
typedef mozilla::css::URLExtraData RawGeckoURLExtraData;
typedef nsTArray<mozilla::Keyframe> RawGeckoKeyframeList;
typedef nsTArray<mozilla::ComputedKeyframeValues> RawGeckoComputedKeyframeValuesList;
typedef nsTArray<mozilla::PropertyStyleAnimationValuePair> RawGeckoAnimationValueList;
typedef nsStyleAutoArray<mozilla::StyleAnimation> RawGeckoStyleAnimationList;
typedef nsTArray<nsFontFaceRuleContainer> RawGeckoFontFaceRuleList;
typedef mozilla::AnimationPropertySegment RawGeckoAnimationPropertySegment;
typedef mozilla::ComputedTiming RawGeckoComputedTiming;








typedef ServoCssRules const* ServoCssRulesBorrowedOrNull; typedef ServoCssRules const* ServoCssRulesBorrowed; typedef ServoCssRules* ServoCssRulesBorrowedMut; struct ServoCssRulesStrong { ServoCssRules* mPtr; already_AddRefed<ServoCssRules> Consume(); };
typedef RawServoStyleSheet const* RawServoStyleSheetBorrowedOrNull; typedef RawServoStyleSheet const* RawServoStyleSheetBorrowed; typedef RawServoStyleSheet* RawServoStyleSheetBorrowedMut; struct RawServoStyleSheetStrong { RawServoStyleSheet* mPtr; already_AddRefed<RawServoStyleSheet> Consume(); };
typedef ServoComputedValues const* ServoComputedValuesBorrowedOrNull; typedef ServoComputedValues const* ServoComputedValuesBorrowed; typedef ServoComputedValues* ServoComputedValuesBorrowedMut; struct ServoComputedValuesStrong { ServoComputedValues* mPtr; already_AddRefed<ServoComputedValues> Consume(); };
typedef RawServoDeclarationBlock const* RawServoDeclarationBlockBorrowedOrNull; typedef RawServoDeclarationBlock const* RawServoDeclarationBlockBorrowed; typedef RawServoDeclarationBlock* RawServoDeclarationBlockBorrowedMut; struct RawServoDeclarationBlockStrong { RawServoDeclarationBlock* mPtr; already_AddRefed<RawServoDeclarationBlock> Consume(); };
typedef RawServoStyleRule const* RawServoStyleRuleBorrowedOrNull; typedef RawServoStyleRule const* RawServoStyleRuleBorrowed; typedef RawServoStyleRule* RawServoStyleRuleBorrowedMut; struct RawServoStyleRuleStrong { RawServoStyleRule* mPtr; already_AddRefed<RawServoStyleRule> Consume(); };
typedef RawServoImportRule const* RawServoImportRuleBorrowedOrNull; typedef RawServoImportRule const* RawServoImportRuleBorrowed; typedef RawServoImportRule* RawServoImportRuleBorrowedMut; struct RawServoImportRuleStrong { RawServoImportRule* mPtr; already_AddRefed<RawServoImportRule> Consume(); };
typedef RawServoAnimationValue const* RawServoAnimationValueBorrowedOrNull; typedef RawServoAnimationValue const* RawServoAnimationValueBorrowed; typedef RawServoAnimationValue* RawServoAnimationValueBorrowedMut; struct RawServoAnimationValueStrong { RawServoAnimationValue* mPtr; already_AddRefed<RawServoAnimationValue> Consume(); };
typedef RawServoAnimationValueMap const* RawServoAnimationValueMapBorrowedOrNull; typedef RawServoAnimationValueMap const* RawServoAnimationValueMapBorrowed; typedef RawServoAnimationValueMap* RawServoAnimationValueMapBorrowedMut; struct RawServoAnimationValueMapStrong { RawServoAnimationValueMap* mPtr; already_AddRefed<RawServoAnimationValueMap> Consume(); };
typedef RawServoMediaList const* RawServoMediaListBorrowedOrNull; typedef RawServoMediaList const* RawServoMediaListBorrowed; typedef RawServoMediaList* RawServoMediaListBorrowedMut; struct RawServoMediaListStrong { RawServoMediaList* mPtr; already_AddRefed<RawServoMediaList> Consume(); };
typedef RawServoMediaRule const* RawServoMediaRuleBorrowedOrNull; typedef RawServoMediaRule const* RawServoMediaRuleBorrowed; typedef RawServoMediaRule* RawServoMediaRuleBorrowedMut; struct RawServoMediaRuleStrong { RawServoMediaRule* mPtr; already_AddRefed<RawServoMediaRule> Consume(); };
typedef RawServoNamespaceRule const* RawServoNamespaceRuleBorrowedOrNull; typedef RawServoNamespaceRule const* RawServoNamespaceRuleBorrowed; typedef RawServoNamespaceRule* RawServoNamespaceRuleBorrowedMut; struct RawServoNamespaceRuleStrong { RawServoNamespaceRule* mPtr; already_AddRefed<RawServoNamespaceRule> Consume(); };
typedef RawServoDeclarationBlockStrong const* RawServoDeclarationBlockStrongBorrowedOrNull;

typedef RawServoStyleSet* RawServoStyleSetOwned; typedef RawServoStyleSet const* RawServoStyleSetBorrowed; typedef RawServoStyleSet* RawServoStyleSetBorrowedMut;
typedef StyleChildrenIterator* StyleChildrenIteratorOwnedOrNull; typedef StyleChildrenIterator const* StyleChildrenIteratorBorrowedOrNull; typedef StyleChildrenIterator* StyleChildrenIteratorBorrowedMutOrNull;
typedef StyleChildrenIterator* StyleChildrenIteratorOwned; typedef StyleChildrenIterator const* StyleChildrenIteratorBorrowed; typedef StyleChildrenIterator* StyleChildrenIteratorBorrowedMut;
typedef ServoElementSnapshot* ServoElementSnapshotOwned; typedef ServoElementSnapshot const* ServoElementSnapshotBorrowed; typedef ServoElementSnapshot* ServoElementSnapshotBorrowedMut;






typedef RawGeckoNode const* RawGeckoNodeBorrowed;
typedef RawGeckoNode const* RawGeckoNodeBorrowedOrNull;
typedef RawGeckoElement const* RawGeckoElementBorrowed;
typedef RawGeckoElement const* RawGeckoElementBorrowedOrNull;
typedef RawGeckoDocument const* RawGeckoDocumentBorrowed;
typedef RawGeckoDocument const* RawGeckoDocumentBorrowedOrNull;
typedef StyleChildrenIterator* StyleChildrenIteratorBorrowedMut;
typedef ServoElementSnapshot* ServoElementSnapshotBorrowedMut;
typedef nsCSSValue const* nsCSSValueBorrowed;
typedef nsCSSValue* nsCSSValueBorrowedMut;
typedef RawGeckoPresContext* RawGeckoPresContextOwned; typedef RawGeckoPresContext const* RawGeckoPresContextBorrowed; typedef RawGeckoPresContext* RawGeckoPresContextBorrowedMut;
typedef RawGeckoPresContext const* RawGeckoPresContextBorrowed;
typedef RawGeckoAnimationValueList* RawGeckoAnimationValueListBorrowedMut;
typedef RawGeckoKeyframeList* RawGeckoKeyframeListBorrowedMut;
typedef RawGeckoKeyframeList const* RawGeckoKeyframeListBorrowed;
typedef RawGeckoComputedKeyframeValuesList* RawGeckoComputedKeyframeValuesListBorrowedMut;
typedef RawGeckoStyleAnimationList const* RawGeckoStyleAnimationListBorrowed;
typedef nsTimingFunction* nsTimingFunctionBorrowedMut;
typedef nsTimingFunction const* nsTimingFunctionBorrowed;
typedef RawGeckoFontFaceRuleList* RawGeckoFontFaceRuleListBorrowedMut;
typedef RawGeckoAnimationPropertySegment const* RawGeckoAnimationPropertySegmentBorrowed;
typedef RawGeckoComputedTiming const* RawGeckoComputedTimingBorrowed;








extern "C" { void Servo_CssRules_AddRef( ServoCssRulesBorrowed ptr); void Servo_CssRules_Release( ServoCssRulesBorrowed ptr); } namespace mozilla { template<> struct RefPtrTraits<ServoCssRules> { static void AddRef(ServoCssRules* aPtr) { Servo_CssRules_AddRef(aPtr); } static void Release(ServoCssRules* aPtr) { Servo_CssRules_Release(aPtr); } }; }
extern "C" { void Servo_StyleSheet_AddRef( RawServoStyleSheetBorrowed ptr); void Servo_StyleSheet_Release( RawServoStyleSheetBorrowed ptr); } namespace mozilla { template<> struct RefPtrTraits<RawServoStyleSheet> { static void AddRef(RawServoStyleSheet* aPtr) { Servo_StyleSheet_AddRef(aPtr); } static void Release(RawServoStyleSheet* aPtr) { Servo_StyleSheet_Release(aPtr); } }; }
extern "C" { void Servo_ComputedValues_AddRef( ServoComputedValuesBorrowed ptr); void Servo_ComputedValues_Release( ServoComputedValuesBorrowed ptr); } namespace mozilla { template<> struct RefPtrTraits<ServoComputedValues> { static void AddRef(ServoComputedValues* aPtr) { Servo_ComputedValues_AddRef(aPtr); } static void Release(ServoComputedValues* aPtr) { Servo_ComputedValues_Release(aPtr); } }; }
extern "C" { void Servo_DeclarationBlock_AddRef( RawServoDeclarationBlockBorrowed ptr); void Servo_DeclarationBlock_Release( RawServoDeclarationBlockBorrowed ptr); } namespace mozilla { template<> struct RefPtrTraits<RawServoDeclarationBlock> { static void AddRef(RawServoDeclarationBlock* aPtr) { Servo_DeclarationBlock_AddRef(aPtr); } static void Release(RawServoDeclarationBlock* aPtr) { Servo_DeclarationBlock_Release(aPtr); } }; }
extern "C" { void Servo_StyleRule_AddRef( RawServoStyleRuleBorrowed ptr); void Servo_StyleRule_Release( RawServoStyleRuleBorrowed ptr); } namespace mozilla { template<> struct RefPtrTraits<RawServoStyleRule> { static void AddRef(RawServoStyleRule* aPtr) { Servo_StyleRule_AddRef(aPtr); } static void Release(RawServoStyleRule* aPtr) { Servo_StyleRule_Release(aPtr); } }; }
extern "C" { void Servo_ImportRule_AddRef( RawServoImportRuleBorrowed ptr); void Servo_ImportRule_Release( RawServoImportRuleBorrowed ptr); } namespace mozilla { template<> struct RefPtrTraits<RawServoImportRule> { static void AddRef(RawServoImportRule* aPtr) { Servo_ImportRule_AddRef(aPtr); } static void Release(RawServoImportRule* aPtr) { Servo_ImportRule_Release(aPtr); } }; }
extern "C" { void Servo_AnimationValue_AddRef( RawServoAnimationValueBorrowed ptr); void Servo_AnimationValue_Release( RawServoAnimationValueBorrowed ptr); } namespace mozilla { template<> struct RefPtrTraits<RawServoAnimationValue> { static void AddRef(RawServoAnimationValue* aPtr) { Servo_AnimationValue_AddRef(aPtr); } static void Release(RawServoAnimationValue* aPtr) { Servo_AnimationValue_Release(aPtr); } }; }
extern "C" { void Servo_AnimationValueMap_AddRef( RawServoAnimationValueMapBorrowed ptr); void Servo_AnimationValueMap_Release( RawServoAnimationValueMapBorrowed ptr); } namespace mozilla { template<> struct RefPtrTraits<RawServoAnimationValueMap> { static void AddRef(RawServoAnimationValueMap* aPtr) { Servo_AnimationValueMap_AddRef(aPtr); } static void Release(RawServoAnimationValueMap* aPtr) { Servo_AnimationValueMap_Release(aPtr); } }; }
extern "C" { void Servo_MediaList_AddRef( RawServoMediaListBorrowed ptr); void Servo_MediaList_Release( RawServoMediaListBorrowed ptr); } namespace mozilla { template<> struct RefPtrTraits<RawServoMediaList> { static void AddRef(RawServoMediaList* aPtr) { Servo_MediaList_AddRef(aPtr); } static void Release(RawServoMediaList* aPtr) { Servo_MediaList_Release(aPtr); } }; }
extern "C" { void Servo_MediaRule_AddRef( RawServoMediaRuleBorrowed ptr); void Servo_MediaRule_Release( RawServoMediaRuleBorrowed ptr); } namespace mozilla { template<> struct RefPtrTraits<RawServoMediaRule> { static void AddRef(RawServoMediaRule* aPtr) { Servo_MediaRule_AddRef(aPtr); } static void Release(RawServoMediaRule* aPtr) { Servo_MediaRule_Release(aPtr); } }; }
extern "C" { void Servo_NamespaceRule_AddRef( RawServoNamespaceRuleBorrowed ptr); void Servo_NamespaceRule_Release( RawServoNamespaceRuleBorrowed ptr); } namespace mozilla { template<> struct RefPtrTraits<RawServoNamespaceRule> { static void AddRef(RawServoNamespaceRule* aPtr) { Servo_NamespaceRule_AddRef(aPtr); } static void Release(RawServoNamespaceRule* aPtr) { Servo_NamespaceRule_Release(aPtr); } }; }
extern "C" void Servo_StyleSet_Drop( RawServoStyleSetOwned ptr); namespace mozilla { template<> class DefaultDelete<RawServoStyleSet> { public: void operator()(RawServoStyleSet* aPtr) const { Servo_StyleSet_Drop(aPtr); } }; };
namespace mozilla {
class EventStates
{
public:
  typedef uint64_t InternalType;
  typedef uint64_t ServoType;

  constexpr EventStates()
    : mStates(0)
  {
  }






  explicit constexpr EventStates(InternalType aStates)
    : mStates(aStates)
  {
  }

  EventStates constexpr operator|(const EventStates& aEventStates) const
  {
    return EventStates(mStates | aEventStates.mStates);
  }

  EventStates& operator|=(const EventStates& aEventStates)
  {
    mStates |= aEventStates.mStates;
    return *this;
  }




  EventStates constexpr operator&(const EventStates& aEventStates) const
  {
    return EventStates(mStates & aEventStates.mStates);
  }

  EventStates& operator&=(const EventStates& aEventStates)
  {
    mStates &= aEventStates.mStates;
    return *this;
  }

  bool operator==(const EventStates& aEventStates) const
  {
    return mStates == aEventStates.mStates;
  }

  bool operator!=(const EventStates& aEventStates) const
  {
    return mStates != aEventStates.mStates;
  }

  EventStates operator~() const
  {
    return EventStates(~mStates);
  }

  EventStates operator^(const EventStates& aEventStates) const
  {
    return EventStates(mStates ^ aEventStates.mStates);
  }

  EventStates& operator^=(const EventStates& aEventStates)
  {
    mStates ^= aEventStates.mStates;
    return *this;
  }







  bool IsEmpty() const
  {
    return mStates == 0;
  }
  bool HasState(EventStates aEventStates) const
  {
    return mStates & aEventStates.mStates;
  }
  bool HasAtLeastOneOfStates(EventStates aEventStates) const
  {
    return mStates & aEventStates.mStates;
  }
  bool HasAllStates(EventStates aEventStates) const
  {
    return (mStates & aEventStates.mStates) == aEventStates.mStates;
  }



  InternalType GetInternalValue() const {
    return mStates;
  }




  ServoType ServoValue() const
  {
    return mStates;
  }

private:
  InternalType mStates;
};

}

class nsAttrName;
class nsAttrValue;

namespace mozilla {
namespace dom {
struct BorrowedAttrInfo
{
  BorrowedAttrInfo()
    : mName(nullptr)
    , mValue(nullptr)
  {
  }

  BorrowedAttrInfo(const nsAttrName* aName, const nsAttrValue* aValue);

  BorrowedAttrInfo(const BorrowedAttrInfo& aOther);

  const nsAttrName* mName;
  const nsAttrValue* mValue;

  explicit operator bool() const { return mName != nullptr; }
};

}
}
namespace mozilla {
struct FloatTypeTraits
{
  typedef uint32_t Bits;

  static const unsigned kExponentBias = 127;
  static const unsigned kExponentShift = 23;

  static const Bits kSignBit = 0x80000000UL;
  static const Bits kExponentBits = 0x7F800000UL;
  static const Bits kSignificandBits = 0x007FFFFFUL;
};

struct DoubleTypeTraits
{
  typedef uint64_t Bits;

  static const unsigned kExponentBias = 1023;
  static const unsigned kExponentShift = 52;

  static const Bits kSignBit = 0x8000000000000000ULL;
  static const Bits kExponentBits = 0x7ff0000000000000ULL;
  static const Bits kSignificandBits = 0x000fffffffffffffULL;
};

template<typename T> struct SelectTrait;
template<> struct SelectTrait<float> : public FloatTypeTraits {};
template<> struct SelectTrait<double> : public DoubleTypeTraits {};
template<typename T>
struct FloatingPoint : public SelectTrait<T>
{
  typedef SelectTrait<T> Base;
  typedef typename Base::Bits Bits;

  static_assert((Base::kSignBit & Base::kExponentBits) == 0,
                "sign bit shouldn't overlap exponent bits");
  static_assert((Base::kSignBit & Base::kSignificandBits) == 0,
                "sign bit shouldn't overlap significand bits");
  static_assert((Base::kExponentBits & Base::kSignificandBits) == 0,
                "exponent bits shouldn't overlap significand bits");

  static_assert((Base::kSignBit | Base::kExponentBits | Base::kSignificandBits) ==
                ~Bits(0),
                "all bits accounted for");
  static_assert(sizeof(T) == sizeof(Bits), "Bits must be same size as T");
};


template<typename T>
static __attribute__((always_inline)) inline bool
IsNaN(T aValue)
{




  typedef FloatingPoint<T> Traits;
  typedef typename Traits::Bits Bits;
  return (BitwiseCast<Bits>(aValue) & Traits::kExponentBits) == Traits::kExponentBits &&
         (BitwiseCast<Bits>(aValue) & Traits::kSignificandBits) != 0;
}


template<typename T>
static __attribute__((always_inline)) inline bool
IsInfinite(T aValue)
{

  typedef FloatingPoint<T> Traits;
  typedef typename Traits::Bits Bits;
  Bits bits = BitwiseCast<Bits>(aValue);
  return (bits & ~Traits::kSignBit) == Traits::kExponentBits;
}


template<typename T>
static __attribute__((always_inline)) inline bool
IsFinite(T aValue)
{




  typedef FloatingPoint<T> Traits;
  typedef typename Traits::Bits Bits;
  Bits bits = BitwiseCast<Bits>(aValue);
  return (bits & Traits::kExponentBits) != Traits::kExponentBits;
}





template<typename T>
static __attribute__((always_inline)) inline bool
IsNegative(T aValue)
{
  do { } while (0);


  typedef FloatingPoint<T> Traits;
  typedef typename Traits::Bits Bits;
  Bits bits = BitwiseCast<Bits>(aValue);
  return (bits & Traits::kSignBit) != 0;
}


template<typename T>
static __attribute__((always_inline)) inline bool
IsNegativeZero(T aValue)
{

  typedef FloatingPoint<T> Traits;
  typedef typename Traits::Bits Bits;
  Bits bits = BitwiseCast<Bits>(aValue);
  return bits == Traits::kSignBit;
}


template<typename T>
static __attribute__((always_inline)) inline bool
IsPositiveZero(T aValue)
{

  typedef FloatingPoint<T> Traits;
  typedef typename Traits::Bits Bits;
  Bits bits = BitwiseCast<Bits>(aValue);
  return bits == 0;
}





template<typename T>
static __attribute__((always_inline)) inline T
ToZeroIfNonfinite(T aValue)
{
  return IsFinite(aValue) ? aValue : 0;
}







template<typename T>
static __attribute__((always_inline)) inline int_fast16_t
ExponentComponent(T aValue)
{




  typedef FloatingPoint<T> Traits;
  typedef typename Traits::Bits Bits;
  Bits bits = BitwiseCast<Bits>(aValue);
  return int_fast16_t((bits & Traits::kExponentBits) >> Traits::kExponentShift) -
         int_fast16_t(Traits::kExponentBias);
}


template<typename T>
static __attribute__((always_inline)) inline T
PositiveInfinity()
{




  typedef FloatingPoint<T> Traits;
  return BitwiseCast<T>(Traits::kExponentBits);
}


template<typename T>
static __attribute__((always_inline)) inline T
NegativeInfinity()
{




  typedef FloatingPoint<T> Traits;
  return BitwiseCast<T>(Traits::kSignBit | Traits::kExponentBits);
}





template<typename T,
         int SignBit,
         typename FloatingPoint<T>::Bits Significand>
struct SpecificNaNBits
{
  using Traits = FloatingPoint<T>;

  static_assert(SignBit == 0 || SignBit == 1, "bad sign bit");
  static_assert((Significand & ~Traits::kSignificandBits) == 0,
                "significand must only have significand bits set");
  static_assert(Significand & Traits::kSignificandBits,
                "significand must be nonzero");

  static constexpr typename Traits::Bits value =
    (SignBit * Traits::kSignBit) | Traits::kExponentBits | Significand;
};
template<typename T>
static __attribute__((always_inline)) inline void
SpecificNaN(int signbit, typename FloatingPoint<T>::Bits significand, T* result)
{
  typedef FloatingPoint<T> Traits;
  do { } while (0);
  do { } while (0);
  do { } while (0);

  BitwiseCast<T>((signbit ? Traits::kSignBit : 0) |
                  Traits::kExponentBits |
                  significand,
                  result);
  do { } while (0);
}

template<typename T>
static __attribute__((always_inline)) inline T
SpecificNaN(int signbit, typename FloatingPoint<T>::Bits significand)
{
  T t;
  SpecificNaN(signbit, significand, &t);
  return t;
}


template<typename T>
static __attribute__((always_inline)) inline T
MinNumberValue()
{
  typedef FloatingPoint<T> Traits;
  typedef typename Traits::Bits Bits;
  return BitwiseCast<T>(Bits(1));
}
template<typename T>
static __attribute__((always_inline)) inline bool
NumberEqualsInt32(T aValue, int32_t* aInt32)
{






  return aValue == (*aInt32 = int32_t(aValue));
}
template<typename T>
static __attribute__((always_inline)) inline bool
NumberIsInt32(T aValue, int32_t* aInt32)
{
  return !IsNegativeZero(aValue) && NumberEqualsInt32(aValue, aInt32);
}





template<typename T>
static __attribute__((always_inline)) inline T
UnspecifiedNaN()
{






  typedef FloatingPoint<T> Traits;
  return SpecificNaN<T>(1, Traits::kSignificandBits);
}






template<typename T>
static inline bool
NumbersAreIdentical(T aValue1, T aValue2)
{
  typedef FloatingPoint<T> Traits;
  typedef typename Traits::Bits Bits;
  if (IsNaN(aValue1)) {
    return IsNaN(aValue2);
  }
  return BitwiseCast<Bits>(aValue1) == BitwiseCast<Bits>(aValue2);
}

namespace detail {

template<typename T>
struct FuzzyEqualsEpsilon;

template<>
struct FuzzyEqualsEpsilon<float>
{

  static float value() { return 1.0f / (1 << 17); }
};

template<>
struct FuzzyEqualsEpsilon<double>
{

  static double value() { return 1.0 / (1LL << 40); }
};

}
template<typename T>
static __attribute__((always_inline)) inline bool
FuzzyEqualsAdditive(T aValue1, T aValue2,
                    T aEpsilon = detail::FuzzyEqualsEpsilon<T>::value())
{
  static_assert(IsFloatingPoint<T>::value, "floating point type required");
  return Abs(aValue1 - aValue2) <= aEpsilon;
}
template<typename T>
static __attribute__((always_inline)) inline bool
FuzzyEqualsMultiplicative(T aValue1, T aValue2,
                          T aEpsilon = detail::FuzzyEqualsEpsilon<T>::value())
{
  static_assert(IsFloatingPoint<T>::value, "floating point type required");

  T smaller = Abs(aValue1) < Abs(aValue2) ? Abs(aValue1) : Abs(aValue2);
  return Abs(aValue1 - aValue2) <= aEpsilon * smaller;
}
__attribute__ ((warn_unused_result))
extern __attribute__((weak)) __attribute__((visibility("default"))) bool
IsFloat32Representable(double aFloat32);

}



namespace IPC {
template<typename T> struct ParamTraits;
}







namespace mozilla {


typedef uint64_t TimeStampValue;


class TimeStamp;




class BaseTimeDurationPlatformUtils
{
public:
  static __attribute__((weak)) __attribute__((visibility("default"))) double ToSeconds(int64_t aTicks);
  static __attribute__((weak)) __attribute__((visibility("default"))) double ToSecondsSigDigits(int64_t aTicks);
  static __attribute__((weak)) __attribute__((visibility("default"))) int64_t TicksFromMilliseconds(double aMilliseconds);
  static __attribute__((weak)) __attribute__((visibility("default"))) int64_t ResolutionInTicks();
};
template <typename ValueCalculator>
class BaseTimeDuration
{
public:

  constexpr BaseTimeDuration() : mValue(0) {}


  struct _SomethingVeryRandomHere;
               BaseTimeDuration(_SomethingVeryRandomHere* aZero) : mValue(0)
  {
    do { } while (0);
  }



  template <typename E>
  explicit BaseTimeDuration(const BaseTimeDuration<E>& aOther)
    : mValue(aOther.mValue)
  { }

  template <typename E>
  BaseTimeDuration& operator=(const BaseTimeDuration<E>& aOther)
  {
    mValue = aOther.mValue;
    return *this;
  }

  double ToSeconds() const
  {
    if (mValue == (9223372036854775807L)) {
      return PositiveInfinity<double>();
    }
    if (mValue == (-9223372036854775807L -1)) {
      return NegativeInfinity<double>();
    }
    return BaseTimeDurationPlatformUtils::ToSeconds(mValue);
  }



  double ToSecondsSigDigits() const
  {
    if (mValue == (9223372036854775807L)) {
      return PositiveInfinity<double>();
    }
    if (mValue == (-9223372036854775807L -1)) {
      return NegativeInfinity<double>();
    }
    return BaseTimeDurationPlatformUtils::ToSecondsSigDigits(mValue);
  }
  double ToMilliseconds() const { return ToSeconds() * 1000.0; }
  double ToMicroseconds() const { return ToMilliseconds() * 1000.0; }






  static inline BaseTimeDuration FromSeconds(double aSeconds)
  {
    return FromMilliseconds(aSeconds * 1000.0);
  }
  static BaseTimeDuration FromMilliseconds(double aMilliseconds)
  {
    if (aMilliseconds == PositiveInfinity<double>()) {
      return Forever();
    }
    if (aMilliseconds == NegativeInfinity<double>()) {
      return FromTicks((-9223372036854775807L -1));
    }
    return FromTicks(
      BaseTimeDurationPlatformUtils::TicksFromMilliseconds(aMilliseconds));
  }
  static inline BaseTimeDuration FromMicroseconds(double aMicroseconds)
  {
    return FromMilliseconds(aMicroseconds / 1000.0);
  }

  static BaseTimeDuration Forever()
  {
    return FromTicks((9223372036854775807L));
  }

  BaseTimeDuration operator+(const BaseTimeDuration& aOther) const
  {
    return FromTicks(ValueCalculator::Add(mValue, aOther.mValue));
  }
  BaseTimeDuration operator-(const BaseTimeDuration& aOther) const
  {
    return FromTicks(ValueCalculator::Subtract(mValue, aOther.mValue));
  }
  BaseTimeDuration& operator+=(const BaseTimeDuration& aOther)
  {
    mValue = ValueCalculator::Add(mValue, aOther.mValue);
    return *this;
  }
  BaseTimeDuration& operator-=(const BaseTimeDuration& aOther)
  {
    mValue = ValueCalculator::Subtract(mValue, aOther.mValue);
    return *this;
  }
  BaseTimeDuration operator-() const
  {


    int64_t ticks;
    if (mValue == (9223372036854775807L)) {
      ticks = (-9223372036854775807L -1);
    } else if (mValue == (-9223372036854775807L -1)) {
      ticks = (9223372036854775807L);
    } else {
      ticks = -mValue;
    }

    return FromTicks(ticks);
  }

  static BaseTimeDuration Max(const BaseTimeDuration& aA,
                              const BaseTimeDuration& aB)
  {
    return FromTicks(std::max(aA.mValue, aB.mValue));
  }
  static BaseTimeDuration Min(const BaseTimeDuration& aA,
                              const BaseTimeDuration& aB)
  {
    return FromTicks(std::min(aA.mValue, aB.mValue));
  }

private:


  BaseTimeDuration operator*(const double aMultiplier) const = delete;




  BaseTimeDuration operator/(const double aDivisor) const = delete;

public:
  BaseTimeDuration MultDouble(double aMultiplier) const
  {
    return FromTicks(ValueCalculator::Multiply(mValue, aMultiplier));
  }
  BaseTimeDuration operator*(const int32_t aMultiplier) const
  {
    return FromTicks(ValueCalculator::Multiply(mValue, aMultiplier));
  }
  BaseTimeDuration operator*(const uint32_t aMultiplier) const
  {
    return FromTicks(ValueCalculator::Multiply(mValue, aMultiplier));
  }
  BaseTimeDuration operator*(const int64_t aMultiplier) const
  {
    return FromTicks(ValueCalculator::Multiply(mValue, aMultiplier));
  }
  BaseTimeDuration operator*(const uint64_t aMultiplier) const
  {
    if (aMultiplier > (9223372036854775807L)) {
      return Forever();
    }
    return FromTicks(ValueCalculator::Multiply(mValue, aMultiplier));
  }
  BaseTimeDuration operator/(const int64_t aDivisor) const
  {
    do { } while (0);
    return FromTicks(ValueCalculator::Divide(mValue, aDivisor));
  }
  double operator/(const BaseTimeDuration& aOther) const
  {


    do { } while (0);

    return ValueCalculator::DivideDouble(mValue, aOther.mValue);
  }
  BaseTimeDuration operator%(const BaseTimeDuration& aOther) const
  {
    do { } while (0);
    return FromTicks(ValueCalculator::Modulo(mValue, aOther.mValue));
  }

  template<typename E>
  bool operator<(const BaseTimeDuration<E>& aOther) const
  {
    return mValue < aOther.mValue;
  }
  template<typename E>
  bool operator<=(const BaseTimeDuration<E>& aOther) const
  {
    return mValue <= aOther.mValue;
  }
  template<typename E>
  bool operator>=(const BaseTimeDuration<E>& aOther) const
  {
    return mValue >= aOther.mValue;
  }
  template<typename E>
  bool operator>(const BaseTimeDuration<E>& aOther) const
  {
    return mValue > aOther.mValue;
  }
  template<typename E>
  bool operator==(const BaseTimeDuration<E>& aOther) const
  {
    return mValue == aOther.mValue;
  }
  template<typename E>
  bool operator!=(const BaseTimeDuration<E>& aOther) const
  {
    return mValue != aOther.mValue;
  }
  bool IsZero() const
  {
    return mValue == 0;
  }
  explicit operator bool() const
  {
    return mValue != 0;
  }

  friend std::ostream& operator<<(std::ostream& aStream,
                                  const BaseTimeDuration& aDuration) {
    return aStream << aDuration.ToMilliseconds() << " ms";
  }





  static BaseTimeDuration Resolution() {
    return FromTicks(BaseTimeDurationPlatformUtils::ResolutionInTicks());
  }
private:
  friend class TimeStamp;
  friend struct IPC::ParamTraits<mozilla::BaseTimeDuration<ValueCalculator>>;
  template <typename>
  friend class BaseTimeDuration;

  static BaseTimeDuration FromTicks(int64_t aTicks)
  {
    BaseTimeDuration t;
    t.mValue = aTicks;
    return t;
  }

  static BaseTimeDuration FromTicks(double aTicks)
  {


    if (aTicks >= double((9223372036854775807L))) {
      return FromTicks((9223372036854775807L));
    }


    if (aTicks <= double((-9223372036854775807L -1))) {
      return FromTicks((-9223372036854775807L -1));
    }

    return FromTicks(int64_t(aTicks));
  }


  int64_t mValue;
};





class TimeDurationValueCalculator
{
public:
  static int64_t Add(int64_t aA, int64_t aB) { return aA + aB; }
  static int64_t Subtract(int64_t aA, int64_t aB) { return aA - aB; }

  template <typename T>
  static int64_t Multiply(int64_t aA, T aB)
  {
    static_assert(IsIntegral<T>::value,
                  "Using integer multiplication routine with non-integer type."
                  " Further specialization required");
    return aA * static_cast<int64_t>(aB);
  }

  static int64_t Divide(int64_t aA, int64_t aB) { return aA / aB; }
  static double DivideDouble(int64_t aA, int64_t aB)
  {
    return static_cast<double>(aA) / aB;
  }
  static int64_t Modulo(int64_t aA, int64_t aB) { return aA % aB; }
};

template <>
inline int64_t
TimeDurationValueCalculator::Multiply<double>(int64_t aA, double aB)
{
  return static_cast<int64_t>(aA * aB);
}
typedef BaseTimeDuration<TimeDurationValueCalculator> TimeDuration;
class TimeStamp
{
public:



  constexpr TimeStamp() : mValue(0) {}
  bool IsNull() const { return mValue == 0; }





  explicit operator bool() const
  {
    return mValue != 0;
  }
  static TimeStamp Now() { return Now(true); }
  static TimeStamp NowLoRes() { return Now(false); }
  static __attribute__((weak)) __attribute__((visibility("default"))) TimeStamp ProcessCreation(bool& aIsInconsistent);






  static __attribute__((weak)) __attribute__((visibility("default"))) void RecordProcessRestart();




  TimeDuration operator-(const TimeStamp& aOther) const
  {
    do { } while (0);
    do { } while (0);
    static_assert(-(9223372036854775807L) > (-9223372036854775807L -1), "int64_t sanity check");
    int64_t ticks = int64_t(mValue - aOther.mValue);

    if (mValue > aOther.mValue) {
      if (ticks < 0) {
        ticks = (9223372036854775807L);
      }
    } else {
      if (ticks > 0) {
        ticks = (-9223372036854775807L -1);
      }
    }
    return TimeDuration::FromTicks(ticks);
  }

  TimeStamp operator+(const TimeDuration& aOther) const
  {
    TimeStamp result = *this;
    result += aOther;
    return result;
  }
  TimeStamp operator-(const TimeDuration& aOther) const
  {
    TimeStamp result = *this;
    result -= aOther;
    return result;
  }
  TimeStamp& operator+=(const TimeDuration& aOther)
  {
    do { } while (0);
    TimeStampValue value = mValue + aOther.mValue;



    if (aOther.mValue < 0 && value > mValue) {
      value = 0;
    }
    mValue = value;
    return *this;
  }
  TimeStamp& operator-=(const TimeDuration& aOther)
  {
    do { } while (0);
    TimeStampValue value = mValue - aOther.mValue;



    if (aOther.mValue > 0 && value > mValue) {
      value = 0;
    }
    mValue = value;
    return *this;
  }

  bool operator<(const TimeStamp& aOther) const
  {
    do { } while (0);
    do { } while (0);
    return mValue < aOther.mValue;
  }
  bool operator<=(const TimeStamp& aOther) const
  {
    do { } while (0);
    do { } while (0);
    return mValue <= aOther.mValue;
  }
  bool operator>=(const TimeStamp& aOther) const
  {
    do { } while (0);
    do { } while (0);
    return mValue >= aOther.mValue;
  }
  bool operator>(const TimeStamp& aOther) const
  {
    do { } while (0);
    do { } while (0);
    return mValue > aOther.mValue;
  }
  bool operator==(const TimeStamp& aOther) const
  {
    return IsNull()
           ? aOther.IsNull()
           : !aOther.IsNull() && mValue == aOther.mValue;
  }
  bool operator!=(const TimeStamp& aOther) const
  {
    return !(*this == aOther);
  }





  static __attribute__((weak)) __attribute__((visibility("default"))) void Startup();
  static __attribute__((weak)) __attribute__((visibility("default"))) void Shutdown();

private:
  friend struct IPC::ParamTraits<mozilla::TimeStamp>;
  friend void StartupTimelineRecordExternal(int, uint64_t);

               TimeStamp(TimeStampValue aValue) : mValue(aValue) {}

  static __attribute__((weak)) __attribute__((visibility("default"))) TimeStamp Now(bool aHighResolution);
  static __attribute__((weak)) __attribute__((visibility("default"))) uint64_t ComputeProcessUptime();
  TimeStampValue mValue;
};

}

namespace mozilla {
class MallocAllocPolicy
{
public:
  template <typename T>
  T* maybe_pod_malloc(size_t aNumElems)
  {
    if (aNumElems & mozilla::tl::MulOverflowMask<sizeof(T)>::value) {
      return nullptr;
    }
    return static_cast<T*>(malloc(aNumElems * sizeof(T)));
  }

  template <typename T>
  T* maybe_pod_calloc(size_t aNumElems)
  {
    return static_cast<T*>(calloc(aNumElems, sizeof(T)));
  }

  template <typename T>
  T* maybe_pod_realloc(T* aPtr, size_t aOldSize, size_t aNewSize)
  {
    if (aNewSize & mozilla::tl::MulOverflowMask<sizeof(T)>::value) {
      return nullptr;
    }
    return static_cast<T*>(realloc(aPtr, aNewSize * sizeof(T)));
  }

  template <typename T>
  T* pod_malloc(size_t aNumElems)
  {
    return maybe_pod_malloc<T>(aNumElems);
  }

  template <typename T>
  T* pod_calloc(size_t aNumElems)
  {
    return maybe_pod_calloc<T>(aNumElems);
  }

  template <typename T>
  T* pod_realloc(T* aPtr, size_t aOldSize, size_t aNewSize)
  {
    return maybe_pod_realloc<T>(aPtr, aOldSize, aNewSize);
  }

  void free_(void* aPtr)
  {
    free(aPtr);
  }

  void reportAllocOverflow() const
  {
  }

  __attribute__ ((warn_unused_result)) bool checkSimulatedOOM() const
  {
    return true;
  }
};

}







namespace mozilla {


class ReentrancyGuard
{





public:
  template<class T>





  explicit ReentrancyGuard(T&
                                                          )

  {
    do { } while (0);




  }
  ~ReentrancyGuard()
  {



  }

private:
  ReentrancyGuard(const ReentrancyGuard&) = delete;
  void operator=(const ReentrancyGuard&) = delete;
};

}
namespace mozilla {

template<typename T, size_t N, class AllocPolicy>
class Vector;

namespace detail {






template<typename T>
static bool CapacityHasExcessSpace(size_t aCapacity)
{
  size_t size = aCapacity * sizeof(T);
  return RoundUpPow2(size) - size >= sizeof(T);
}





template<typename T, size_t N, class AP, bool IsPod>
struct VectorImpl
{



  template<typename... Args>
  __attribute__ ((nonnull(1)))
  static inline void new_(T* aDst, Args&&... aArgs)
  {
    new(KnownNotNull, aDst) T(Forward<Args>(aArgs)...);
  }


  static inline void destroy(T* aBegin, T* aEnd)
  {
    do { } while (0);
    for (T* p = aBegin; p < aEnd; ++p) {
      p->~T();
    }
  }


  static inline void initialize(T* aBegin, T* aEnd)
  {
    do { } while (0);
    for (T* p = aBegin; p < aEnd; ++p) {
      new_(p);
    }
  }





  template<typename U>
  static inline void copyConstruct(T* aDst,
                                   const U* aSrcStart, const U* aSrcEnd)
  {
    do { } while (0);
    for (const U* p = aSrcStart; p < aSrcEnd; ++p, ++aDst) {
      new_(aDst, *p);
    }
  }





  template<typename U>
  static inline void moveConstruct(T* aDst, U* aSrcStart, U* aSrcEnd)
  {
    do { } while (0);
    for (U* p = aSrcStart; p < aSrcEnd; ++p, ++aDst) {
      new_(aDst, Move(*p));
    }
  }





  template<typename U>
  static inline void copyConstructN(T* aDst, size_t aN, const U& aU)
  {
    for (T* end = aDst + aN; aDst < end; ++aDst) {
      new_(aDst, aU);
    }
  }







  static inline __attribute__ ((warn_unused_result)) bool
  growTo(Vector<T, N, AP>& aV, size_t aNewCap)
  {
    do { } while (0);
    do { } while (0);
    T* newbuf = aV.template pod_malloc<T>(aNewCap);
    if ((__builtin_expect(!!(!newbuf), 0))) {
      return false;
    }
    T* dst = newbuf;
    T* src = aV.beginNoCheck();
    for (; src < aV.endNoCheck(); ++dst, ++src) {
      new_(dst, Move(*src));
    }
    VectorImpl::destroy(aV.beginNoCheck(), aV.endNoCheck());
    aV.free_(aV.mBegin);
    aV.mBegin = newbuf;

    aV.mTail.mCapacity = aNewCap;
    return true;
  }
};






template<typename T, size_t N, class AP>
struct VectorImpl<T, N, AP, true>
{
  template<typename... Args>
  __attribute__ ((nonnull(1)))
  static inline void new_(T* aDst, Args&&... aArgs)
  {




    T temp(Forward<Args>(aArgs)...);
    *aDst = temp;
  }

  static inline void destroy(T*, T*) {}

  static inline void initialize(T* aBegin, T* aEnd)
  {
    do { } while (0);
    for (T* p = aBegin; p < aEnd; ++p) {
      new_(p);
    }
  }

  template<typename U>
  static inline void copyConstruct(T* aDst,
                                   const U* aSrcStart, const U* aSrcEnd)
  {







    do { } while (0);
    for (const U* p = aSrcStart; p < aSrcEnd; ++p, ++aDst) {
      new_(aDst, *p);
    }
  }

  template<typename U>
  static inline void moveConstruct(T* aDst,
                                   const U* aSrcStart, const U* aSrcEnd)
  {
    copyConstruct(aDst, aSrcStart, aSrcEnd);
  }

  static inline void copyConstructN(T* aDst, size_t aN, const T& aT)
  {
    for (T* end = aDst + aN; aDst < end; ++aDst) {
      new_(aDst, aT);
    }
  }

  static inline __attribute__ ((warn_unused_result)) bool
  growTo(Vector<T, N, AP>& aV, size_t aNewCap)
  {
    do { } while (0);
    do { } while (0);
    T* newbuf =
      aV.template pod_realloc<T>(aV.mBegin, aV.mTail.mCapacity, aNewCap);
    if ((__builtin_expect(!!(!newbuf), 0))) {
      return false;
    }
    aV.mBegin = newbuf;

    aV.mTail.mCapacity = aNewCap;
    return true;
  }

  static inline void
  podResizeToFit(Vector<T, N, AP>& aV)
  {
    if (aV.usingInlineStorage() || aV.mLength == aV.mTail.mCapacity) {
      return;
    }
    T* newbuf =
      aV.template pod_realloc<T>(aV.mBegin, aV.mTail.mCapacity, aV.mLength);
    if ((__builtin_expect(!!(!newbuf), 0))) {
      return;
    }
    aV.mBegin = newbuf;
    aV.mTail.mCapacity = aV.mLength;
  }
};



struct VectorTesting;

}
template<typename T,
         size_t MinInlineCapacity = 0,
         class AllocPolicy = MallocAllocPolicy>
class Vector final : private AllocPolicy
{


  static const bool kElemIsPod = IsPod<T>::value;
  typedef detail::VectorImpl<T, MinInlineCapacity, AllocPolicy, kElemIsPod> Impl;
  friend struct detail::VectorImpl<T, MinInlineCapacity, AllocPolicy, kElemIsPod>;

  friend struct detail::VectorTesting;

  __attribute__ ((warn_unused_result)) bool growStorageBy(size_t aIncr);
  __attribute__ ((warn_unused_result)) bool convertToHeapStorage(size_t aNewCap);
  __attribute__ ((warn_unused_result)) bool maybeCheckSimulatedOOM(size_t aRequestedSize);
  static constexpr size_t kMaxInlineBytes =
    1024 - (sizeof(AllocPolicy) + sizeof(T*) + sizeof(size_t) + sizeof(size_t));
  template<size_t MinimumInlineCapacity, size_t Dummy>
  struct ComputeCapacity
  {
    static constexpr size_t value =
      tl::Min<MinimumInlineCapacity, kMaxInlineBytes / sizeof(T)>::value;
  };

  template<size_t Dummy>
  struct ComputeCapacity<0, Dummy>
  {
    static constexpr size_t value = 0;
  };


  static constexpr size_t kInlineCapacity =
    ComputeCapacity<MinInlineCapacity, 0>::value;
  T* mBegin;


  size_t mLength;
  struct CapacityAndReserved
  {
    explicit CapacityAndReserved(size_t aCapacity, size_t aReserved)
      : mCapacity(aCapacity)



    {}
    CapacityAndReserved() = default;


    size_t mCapacity;





  };
  template<size_t Capacity, size_t Dummy>
  struct CRAndStorage : CapacityAndReserved
  {
    explicit CRAndStorage(size_t aCapacity, size_t aReserved)
      : CapacityAndReserved(aCapacity, aReserved)
    {}
    CRAndStorage() = default;

    alignas(T) unsigned char mBytes[Capacity * sizeof(T)];



    void* data() { return mBytes; }

    T* storage() { return static_cast<T*>(data()); }
  };

  template<size_t Dummy>
  struct CRAndStorage<0, Dummy> : CapacityAndReserved
  {
    explicit CRAndStorage(size_t aCapacity, size_t aReserved)
      : CapacityAndReserved(aCapacity, aReserved)
    {}
    CRAndStorage() = default;

    T* storage() { return nullptr; }
  };

  CRAndStorage<kInlineCapacity, 0> mTail;
  bool usingInlineStorage() const
  {
    return mBegin == const_cast<Vector*>(this)->inlineStorage();
  }

  T* inlineStorage()
  {
    return mTail.storage();
  }

  T* beginNoCheck() const
  {
    return mBegin;
  }

  T* endNoCheck()
  {
    return mBegin + mLength;
  }

  const T* endNoCheck() const
  {
    return mBegin + mLength;
  }
  template<typename U> void internalAppend(U&& aU);
  template<typename U, size_t O, class BP>
  void internalAppendAll(const Vector<U, O, BP>& aU);
  void internalAppendN(const T& aT, size_t aN);
  template<typename U> void internalAppend(const U* aBegin, size_t aLength);

public:
  static const size_t sMaxInlineStorage = MinInlineCapacity;

  typedef T ElementType;

  explicit Vector(AllocPolicy = AllocPolicy());
  Vector(Vector&&);
  Vector& operator=(Vector&&);
  ~Vector();



  const AllocPolicy& allocPolicy() const { return *this; }

  AllocPolicy& allocPolicy() { return *this; }

  enum { InlineLength = MinInlineCapacity };

  size_t length() const { return mLength; }

  bool empty() const { return mLength == 0; }

  size_t capacity() const { return mTail.mCapacity; }

  T* begin()
  {
    do { } while (0);
    return mBegin;
  }

  const T* begin() const
  {
    do { } while (0);
    return mBegin;
  }

  T* end()
  {
    do { } while (0);
    return mBegin + mLength;
  }

  const T* end() const
  {
    do { } while (0);
    return mBegin + mLength;
  }

  T& operator[](size_t aIndex)
  {
    do { } while (0);
    do { } while (0);
    return begin()[aIndex];
  }

  const T& operator[](size_t aIndex) const
  {
    do { } while (0);
    do { } while (0);
    return begin()[aIndex];
  }

  T& back()
  {
    do { } while (0);
    do { } while (0);
    return *(end() - 1);
  }

  const T& back() const
  {
    do { } while (0);
    do { } while (0);
    return *(end() - 1);
  }

  class Range
  {
    friend class Vector;
    T* mCur;
    T* mEnd;
    Range(T* aCur, T* aEnd)
      : mCur(aCur)
      , mEnd(aEnd)
    {
      do { } while (0);
    }

  public:
    bool empty() const { return mCur == mEnd; }
    size_t remain() const { return PointerRangeSize(mCur, mEnd); }
    T& front() const { do { } while (0); return *mCur; }
    void popFront() { do { } while (0); ++mCur; }
    T popCopyFront() { do { } while (0); return *mCur++; }
  };

  class ConstRange
  {
    friend class Vector;
    const T* mCur;
    const T* mEnd;
    ConstRange(const T* aCur, const T* aEnd)
      : mCur(aCur)
      , mEnd(aEnd)
    {
      do { } while (0);
    }

  public:
    bool empty() const { return mCur == mEnd; }
    size_t remain() const { return PointerRangeSize(mCur, mEnd); }
    const T& front() const { do { } while (0); return *mCur; }
    void popFront() { do { } while (0); ++mCur; }
    T popCopyFront() { do { } while (0); return *mCur++; }
  };

  Range all() { return Range(begin(), end()); }
  ConstRange all() const { return ConstRange(begin(), end()); }






  void reverse();





  __attribute__ ((warn_unused_result)) bool initCapacity(size_t aRequest);
  __attribute__ ((warn_unused_result)) bool initLengthUninitialized(size_t aRequest);
  __attribute__ ((warn_unused_result)) bool reserve(size_t aRequest);





  void shrinkBy(size_t aIncr);





  void shrinkTo(size_t aNewLength);


  __attribute__ ((warn_unused_result)) bool growBy(size_t aIncr);


  __attribute__ ((warn_unused_result)) bool resize(size_t aNewLength);





  __attribute__ ((warn_unused_result)) bool growByUninitialized(size_t aIncr);
  void infallibleGrowByUninitialized(size_t aIncr);
  __attribute__ ((warn_unused_result)) bool resizeUninitialized(size_t aNewLength);


  void clear();


  void clearAndFree();






  void podResizeToFit();







  bool canAppendWithoutRealloc(size_t aNeeded) const;
  template<typename U> __attribute__ ((warn_unused_result)) bool append(U&& aU);




  template<typename... Args>
  __attribute__ ((warn_unused_result)) bool emplaceBack(Args&&... aArgs)
  {
    if (!growByUninitialized(1))
      return false;
    Impl::new_(&back(), Forward<Args>(aArgs)...);
    return true;
  }

  template<typename U, size_t O, class BP>
  __attribute__ ((warn_unused_result)) bool appendAll(const Vector<U, O, BP>& aU);
  __attribute__ ((warn_unused_result)) bool appendN(const T& aT, size_t aN);
  template<typename U> __attribute__ ((warn_unused_result)) bool append(const U* aBegin, const U* aEnd);
  template<typename U> __attribute__ ((warn_unused_result)) bool append(const U* aBegin, size_t aLength);






  template<typename U> void infallibleAppend(U&& aU)
  {
    internalAppend(Forward<U>(aU));
  }
  void infallibleAppendN(const T& aT, size_t aN)
  {
    internalAppendN(aT, aN);
  }
  template<typename U> void infallibleAppend(const U* aBegin, const U* aEnd)
  {
    internalAppend(aBegin, PointerRangeSize(aBegin, aEnd));
  }
  template<typename U> void infallibleAppend(const U* aBegin, size_t aLength)
  {
    internalAppend(aBegin, aLength);
  }
  template<typename... Args>
  void infallibleEmplaceBack(Args&&... aArgs)
  {
    infallibleGrowByUninitialized(1);
    Impl::new_(&back(), Forward<Args>(aArgs)...);
  }

  void popBack();

  T popCopy();
  __attribute__ ((warn_unused_result)) T* extractRawBuffer();
  __attribute__ ((warn_unused_result)) T* extractOrCopyRawBuffer();
  void replaceRawBuffer(T* aP, size_t aLength);
  template<typename U>
  __attribute__ ((warn_unused_result)) T* insert(T* aP, U&& aVal);





  void erase(T* aT);






  void erase(T* aBegin, T* aEnd);




  size_t sizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const;





  size_t sizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const;

  void swap(Vector& aOther);

private:
  Vector(const Vector&) = delete;
  void operator=(const Vector&) = delete;
};
template<typename T, size_t N, class AP>
__attribute__((always_inline)) inline
Vector<T, N, AP>::Vector(AP aAP)
  : AP(aAP)
  , mLength(0)
  , mTail(kInlineCapacity, 0)



{
  mBegin = inlineStorage();
}


template<typename T, size_t N, class AllocPolicy>
__attribute__((always_inline)) inline
Vector<T, N, AllocPolicy>::Vector(Vector&& aRhs)
  : AllocPolicy(Move(aRhs))



{
  mLength = aRhs.mLength;
  mTail.mCapacity = aRhs.mTail.mCapacity;




  if (aRhs.usingInlineStorage()) {

    mBegin = inlineStorage();
    Impl::moveConstruct(mBegin, aRhs.beginNoCheck(), aRhs.endNoCheck());




  } else {




    mBegin = aRhs.mBegin;
    aRhs.mBegin = aRhs.inlineStorage();
    aRhs.mTail.mCapacity = kInlineCapacity;
    aRhs.mLength = 0;



  }
}


template<typename T, size_t N, class AP>
__attribute__((always_inline)) inline Vector<T, N, AP>&
Vector<T, N, AP>::operator=(Vector&& aRhs)
{
  do { } while (0);
  this->~Vector();
  new(KnownNotNull, this) Vector(Move(aRhs));
  return *this;
}

template<typename T, size_t N, class AP>
__attribute__((always_inline)) inline
Vector<T, N, AP>::~Vector()
{
  ReentrancyGuard g(*this); do { } while (0); do { } while (0); do { } while (0); do { } while (0);
  Impl::destroy(beginNoCheck(), endNoCheck());
  if (!usingInlineStorage()) {
    this->free_(beginNoCheck());
  }
}

template<typename T, size_t N, class AP>
__attribute__((always_inline)) inline void
Vector<T, N, AP>::reverse() {
  ReentrancyGuard g(*this); do { } while (0); do { } while (0); do { } while (0); do { } while (0);
  T* elems = mBegin;
  size_t len = mLength;
  size_t mid = len / 2;
  for (size_t i = 0; i < mid; i++) {
    Swap(elems[i], elems[len - i - 1]);
  }
}






template<typename T, size_t N, class AP>
inline bool
Vector<T, N, AP>::convertToHeapStorage(size_t aNewCap)
{
  do { } while (0);


  do { } while (0);
  T* newBuf = this->template pod_malloc<T>(aNewCap);
  if ((__builtin_expect(!!(!newBuf), 0))) {
    return false;
  }


  Impl::moveConstruct(newBuf, beginNoCheck(), endNoCheck());
  Impl::destroy(beginNoCheck(), endNoCheck());


  mBegin = newBuf;

  mTail.mCapacity = aNewCap;
  return true;
}

template<typename T, size_t N, class AP>
__attribute__((noinline)) bool
Vector<T, N, AP>::growStorageBy(size_t aIncr)
{
  do { } while (0);
  size_t newCap;

  if (aIncr == 1) {
    if (usingInlineStorage()) {

      size_t newSize =
        tl::RoundUpPow2<(kInlineCapacity + 1) * sizeof(T)>::value;
      newCap = newSize / sizeof(T);
      goto convert;
    }

    if (mLength == 0) {

      newCap = 1;
      goto grow;
    }
    if ((__builtin_expect(!!(mLength & tl::MulOverflowMask<4 * sizeof(T)>::value), 0))) {
      this->reportAllocOverflow();
      return false;
    }






    newCap = mLength * 2;
    if (detail::CapacityHasExcessSpace<T>(newCap)) {
      newCap += 1;
    }
  } else {

    size_t newMinCap = mLength + aIncr;


    if ((__builtin_expect(!!(newMinCap < mLength || newMinCap & tl::MulOverflowMask<2 * sizeof(T)>::value), 0)))

    {
      this->reportAllocOverflow();
      return false;
    }

    size_t newMinSize = newMinCap * sizeof(T);
    size_t newSize = RoundUpPow2(newMinSize);
    newCap = newSize / sizeof(T);
  }

  if (usingInlineStorage()) {
convert:
    return convertToHeapStorage(newCap);
  }

grow:
  return Impl::growTo(*this, newCap);
}

template<typename T, size_t N, class AP>
inline bool
Vector<T, N, AP>::initCapacity(size_t aRequest)
{
  do { } while (0);
  do { } while (0);
  if (aRequest == 0) {
    return true;
  }
  T* newbuf = this->template pod_malloc<T>(aRequest);
  if ((__builtin_expect(!!(!newbuf), 0))) {
    return false;
  }
  mBegin = newbuf;
  mTail.mCapacity = aRequest;



  return true;
}

template<typename T, size_t N, class AP>
inline bool
Vector<T, N, AP>::initLengthUninitialized(size_t aRequest)
{
  if (!initCapacity(aRequest)) {
    return false;
  }
  infallibleGrowByUninitialized(aRequest);
  return true;
}

template<typename T, size_t N, class AP>
inline bool
Vector<T, N, AP>::maybeCheckSimulatedOOM(size_t aRequestedSize)
{
  if (aRequestedSize <= N) {
    return true;
  }







  return allocPolicy().checkSimulatedOOM();
}

template<typename T, size_t N, class AP>
inline bool
Vector<T, N, AP>::reserve(size_t aRequest)
{
  ReentrancyGuard g(*this); do { } while (0); do { } while (0); do { } while (0); do { } while (0);
  if (aRequest > mTail.mCapacity) {
    if ((__builtin_expect(!!(!growStorageBy(aRequest - mLength)), 0))) {
      return false;
    }
  } else if (!maybeCheckSimulatedOOM(aRequest)) {
    return false;
  }







  return true;
}

template<typename T, size_t N, class AP>
inline void
Vector<T, N, AP>::shrinkBy(size_t aIncr)
{
  ReentrancyGuard g(*this); do { } while (0); do { } while (0); do { } while (0); do { } while (0);
  do { } while (0);
  Impl::destroy(endNoCheck() - aIncr, endNoCheck());
  mLength -= aIncr;
}

template<typename T, size_t N, class AP>
__attribute__((always_inline)) inline void
Vector<T, N, AP>::shrinkTo(size_t aNewLength)
{
  do { } while (0);
  shrinkBy(mLength - aNewLength);
}

template<typename T, size_t N, class AP>
__attribute__((always_inline)) inline bool
Vector<T, N, AP>::growBy(size_t aIncr)
{
  ReentrancyGuard g(*this); do { } while (0); do { } while (0); do { } while (0); do { } while (0);
  if (aIncr > mTail.mCapacity - mLength) {
    if ((__builtin_expect(!!(!growStorageBy(aIncr)), 0))) {
      return false;
    }
  } else if (!maybeCheckSimulatedOOM(mLength + aIncr)) {
    return false;
  }
  do { } while (0);
  T* newend = endNoCheck() + aIncr;
  Impl::initialize(endNoCheck(), newend);
  mLength += aIncr;





  return true;
}

template<typename T, size_t N, class AP>
__attribute__((always_inline)) inline bool
Vector<T, N, AP>::growByUninitialized(size_t aIncr)
{
  ReentrancyGuard g(*this); do { } while (0); do { } while (0); do { } while (0); do { } while (0);
  if (aIncr > mTail.mCapacity - mLength) {
    if ((__builtin_expect(!!(!growStorageBy(aIncr)), 0))) {
      return false;
    }
  } else if (!maybeCheckSimulatedOOM(mLength + aIncr)) {
    return false;
  }





  infallibleGrowByUninitialized(aIncr);
  return true;
}

template<typename T, size_t N, class AP>
__attribute__((always_inline)) inline void
Vector<T, N, AP>::infallibleGrowByUninitialized(size_t aIncr)
{
  do { } while (0);
  mLength += aIncr;
}

template<typename T, size_t N, class AP>
inline bool
Vector<T, N, AP>::resize(size_t aNewLength)
{
  size_t curLength = mLength;
  if (aNewLength > curLength) {
    return growBy(aNewLength - curLength);
  }
  shrinkBy(curLength - aNewLength);
  return true;
}

template<typename T, size_t N, class AP>
__attribute__((always_inline)) inline bool
Vector<T, N, AP>::resizeUninitialized(size_t aNewLength)
{
  size_t curLength = mLength;
  if (aNewLength > curLength) {
    return growByUninitialized(aNewLength - curLength);
  }
  shrinkBy(curLength - aNewLength);
  return true;
}

template<typename T, size_t N, class AP>
inline void
Vector<T, N, AP>::clear()
{
  ReentrancyGuard g(*this); do { } while (0); do { } while (0); do { } while (0); do { } while (0);
  Impl::destroy(beginNoCheck(), endNoCheck());
  mLength = 0;
}

template<typename T, size_t N, class AP>
inline void
Vector<T, N, AP>::clearAndFree()
{
  clear();

  if (usingInlineStorage()) {
    return;
  }
  this->free_(beginNoCheck());
  mBegin = inlineStorage();
  mTail.mCapacity = kInlineCapacity;



}

template<typename T, size_t N, class AP>
inline void
Vector<T, N, AP>::podResizeToFit()
{


  Impl::podResizeToFit(*this);
}

template<typename T, size_t N, class AP>
inline bool
Vector<T, N, AP>::canAppendWithoutRealloc(size_t aNeeded) const
{
  return mLength + aNeeded <= mTail.mCapacity;
}

template<typename T, size_t N, class AP>
template<typename U, size_t O, class BP>
__attribute__((always_inline)) inline void
Vector<T, N, AP>::internalAppendAll(const Vector<U, O, BP>& aOther)
{
  internalAppend(aOther.begin(), aOther.length());
}

template<typename T, size_t N, class AP>
template<typename U>
__attribute__((always_inline)) inline void
Vector<T, N, AP>::internalAppend(U&& aU)
{
  do { } while (0);
  do { } while (0);
  Impl::new_(endNoCheck(), Forward<U>(aU));
  ++mLength;
}

template<typename T, size_t N, class AP>
__attribute__((always_inline)) inline bool
Vector<T, N, AP>::appendN(const T& aT, size_t aNeeded)
{
  ReentrancyGuard g(*this); do { } while (0); do { } while (0); do { } while (0); do { } while (0);
  if (mLength + aNeeded > mTail.mCapacity) {
    if ((__builtin_expect(!!(!growStorageBy(aNeeded)), 0))) {
      return false;
    }
  } else if (!maybeCheckSimulatedOOM(mLength + aNeeded)) {
    return false;
  }





  internalAppendN(aT, aNeeded);
  return true;
}

template<typename T, size_t N, class AP>
__attribute__((always_inline)) inline void
Vector<T, N, AP>::internalAppendN(const T& aT, size_t aNeeded)
{
  do { } while (0);
  do { } while (0);
  Impl::copyConstructN(endNoCheck(), aNeeded, aT);
  mLength += aNeeded;
}

template<typename T, size_t N, class AP>
template<typename U>
inline T*
Vector<T, N, AP>::insert(T* aP, U&& aVal)
{
  do { } while (0);
  do { } while (0);
  size_t pos = aP - begin();
  do { } while (0);
  size_t oldLength = mLength;
  if (pos == oldLength) {
    if (!append(Forward<U>(aVal))) {
      return nullptr;
    }
  } else {
    T oldBack = Move(back());
    if (!append(Move(oldBack))) {
      return nullptr;
    }
    for (size_t i = oldLength - 1; i > pos; --i) {
      (*this)[i] = Move((*this)[i - 1]);
    }
    (*this)[pos] = Forward<U>(aVal);
  }
  return begin() + pos;
}

template<typename T, size_t N, class AP>
inline void
Vector<T, N, AP>::erase(T* aIt)
{
  do { } while (0);
  do { } while (0);
  while (aIt + 1 < end()) {
    *aIt = Move(*(aIt + 1));
    ++aIt;
  }
  popBack();
}

template<typename T, size_t N, class AP>
inline void
Vector<T, N, AP>::erase(T* aBegin, T* aEnd)
{
  do { } while (0);
  do { } while (0);
  do { } while (0);
  while (aEnd < end()) {
    *aBegin++ = Move(*aEnd++);
  }
  shrinkBy(aEnd - aBegin);
}

template<typename T, size_t N, class AP>
template<typename U>
__attribute__((always_inline)) inline bool
Vector<T, N, AP>::append(const U* aInsBegin, const U* aInsEnd)
{
  ReentrancyGuard g(*this); do { } while (0); do { } while (0); do { } while (0); do { } while (0);
  size_t aNeeded = PointerRangeSize(aInsBegin, aInsEnd);
  if (mLength + aNeeded > mTail.mCapacity) {
    if ((__builtin_expect(!!(!growStorageBy(aNeeded)), 0))) {
      return false;
    }
  } else if (!maybeCheckSimulatedOOM(mLength + aNeeded)) {
      return false;
  }





  internalAppend(aInsBegin, aNeeded);
  return true;
}

template<typename T, size_t N, class AP>
template<typename U>
__attribute__((always_inline)) inline void
Vector<T, N, AP>::internalAppend(const U* aInsBegin, size_t aInsLength)
{
  do { } while (0);
  do { } while (0);
  Impl::copyConstruct(endNoCheck(), aInsBegin, aInsBegin + aInsLength);
  mLength += aInsLength;
}

template<typename T, size_t N, class AP>
template<typename U>
__attribute__((always_inline)) inline bool
Vector<T, N, AP>::append(U&& aU)
{
  ReentrancyGuard g(*this); do { } while (0); do { } while (0); do { } while (0); do { } while (0);
  if (mLength == mTail.mCapacity) {
    if ((__builtin_expect(!!(!growStorageBy(1)), 0))) {
      return false;
    }
  } else if (!maybeCheckSimulatedOOM(mLength + 1)) {
      return false;
  }





  internalAppend(Forward<U>(aU));
  return true;
}

template<typename T, size_t N, class AP>
template<typename U, size_t O, class BP>
__attribute__((always_inline)) inline bool
Vector<T, N, AP>::appendAll(const Vector<U, O, BP>& aOther)
{
  return append(aOther.begin(), aOther.length());
}

template<typename T, size_t N, class AP>
template<class U>
__attribute__((always_inline)) inline bool
Vector<T, N, AP>::append(const U* aInsBegin, size_t aInsLength)
{
  return append(aInsBegin, aInsBegin + aInsLength);
}

template<typename T, size_t N, class AP>
__attribute__((always_inline)) inline void
Vector<T, N, AP>::popBack()
{
  ReentrancyGuard g(*this); do { } while (0); do { } while (0); do { } while (0); do { } while (0);
  do { } while (0);
  --mLength;
  endNoCheck()->~T();
}

template<typename T, size_t N, class AP>
__attribute__((always_inline)) inline T
Vector<T, N, AP>::popCopy()
{
  T ret = back();
  popBack();
  return ret;
}

template<typename T, size_t N, class AP>
inline T*
Vector<T, N, AP>::extractRawBuffer()
{
  ReentrancyGuard g(*this); do { } while (0); do { } while (0); do { } while (0); do { } while (0);

  if (usingInlineStorage()) {
    return nullptr;
  }

  T* ret = mBegin;
  mBegin = inlineStorage();
  mLength = 0;
  mTail.mCapacity = kInlineCapacity;



  return ret;
}

template<typename T, size_t N, class AP>
inline T*
Vector<T, N, AP>::extractOrCopyRawBuffer()
{
  if (T* ret = extractRawBuffer()) {
    return ret;
  }

  ReentrancyGuard g(*this); do { } while (0); do { } while (0); do { } while (0); do { } while (0);

  T* copy = this->template pod_malloc<T>(mLength);
  if (!copy) {
    return nullptr;
  }

  Impl::moveConstruct(copy, beginNoCheck(), endNoCheck());
  Impl::destroy(beginNoCheck(), endNoCheck());
  mBegin = inlineStorage();
  mLength = 0;
  mTail.mCapacity = kInlineCapacity;



  return copy;
}

template<typename T, size_t N, class AP>
inline void
Vector<T, N, AP>::replaceRawBuffer(T* aP, size_t aLength)
{
  ReentrancyGuard g(*this); do { } while (0); do { } while (0); do { } while (0); do { } while (0);


  Impl::destroy(beginNoCheck(), endNoCheck());
  if (!usingInlineStorage()) {
    this->free_(beginNoCheck());
  }


  if (aLength <= kInlineCapacity) {





    mBegin = inlineStorage();
    mLength = aLength;
    mTail.mCapacity = kInlineCapacity;
    Impl::moveConstruct(mBegin, aP, aP + aLength);
    Impl::destroy(aP, aP + aLength);
    this->free_(aP);
  } else {
    mBegin = aP;
    mLength = aLength;
    mTail.mCapacity = aLength;
  }



}

template<typename T, size_t N, class AP>
inline size_t
Vector<T, N, AP>::sizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const
{
  return usingInlineStorage() ? 0 : aMallocSizeOf(beginNoCheck());
}

template<typename T, size_t N, class AP>
inline size_t
Vector<T, N, AP>::sizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const
{
  return aMallocSizeOf(this) + sizeOfExcludingThis(aMallocSizeOf);
}

template<typename T, size_t N, class AP>
inline void
Vector<T, N, AP>::swap(Vector& aOther)
{
  static_assert(N == 0,
                "still need to implement this for N != 0");


  if (!usingInlineStorage() && aOther.usingInlineStorage()) {
    aOther.mBegin = mBegin;
    mBegin = inlineStorage();
  } else if (usingInlineStorage() && !aOther.usingInlineStorage()) {
    mBegin = aOther.mBegin;
    aOther.mBegin = aOther.inlineStorage();
  } else if (!usingInlineStorage() && !aOther.usingInlineStorage()) {
    Swap(mBegin, aOther.mBegin);
  } else {

  }

  Swap(mLength, aOther.mLength);
  Swap(mTail.mCapacity, aOther.mTail.mCapacity);



}

}



namespace js {


template <typename T, typename D = JS::DeletePolicy<T>>
using UniquePtr = mozilla::UniquePtr<T, D>;

namespace detail {

template<typename T>
struct UniqueSelector
{
  typedef UniquePtr<T> SingleObject;
};

template<typename T>
struct UniqueSelector<T[]>
{
  typedef UniquePtr<T[]> UnknownBound;
};

template<typename T, decltype(sizeof(int)) N>
struct UniqueSelector<T[N]>
{
  typedef UniquePtr<T[N]> KnownBound;
};

}



template<typename T, typename... Args>
typename detail::UniqueSelector<T>::SingleObject
MakeUnique(Args&&... aArgs)
{
  return UniquePtr<T>(js_new<T>(mozilla::Forward<Args>(aArgs)...));
}

template<typename T>
typename detail::UniqueSelector<T>::UnknownBound
MakeUnique(decltype(sizeof(int)) aN) = delete;

template<typename T, typename... Args>
typename detail::UniqueSelector<T>::KnownBound
MakeUnique(Args&&... aArgs) = delete;

}

namespace js {
namespace gc {
class GCRuntime;
}
namespace gcstats {
struct Statistics;
}
}

typedef enum JSGCMode {

    JSGC_MODE_GLOBAL = 0,


    JSGC_MODE_ZONE = 1,





    JSGC_MODE_INCREMENTAL = 2
} JSGCMode;




typedef enum JSGCInvocationKind {

    GC_NORMAL = 0,


    GC_SHRINK = 1
} JSGCInvocationKind;

namespace JS {
namespace gcreason {


enum Reason {

    API, EAGER_ALLOC_TRIGGER, DESTROY_RUNTIME, UNUSED0, LAST_DITCH, TOO_MUCH_MALLOC, ALLOC_TRIGGER, DEBUG_GC, COMPARTMENT_REVIVED, RESET, OUT_OF_NURSERY, EVICT_NURSERY, FULL_STORE_BUFFER, SHARED_MEMORY_LIMIT, UNUSED1, INCREMENTAL_TOO_SLOW, ABORT_GC, RESERVED0, RESERVED1, RESERVED2, RESERVED3, RESERVED4, RESERVED5, RESERVED6, RESERVED7, RESERVED8, RESERVED9, RESERVED10, RESERVED11, RESERVED12, RESERVED13, RESERVED14, RESERVED15, DOM_WINDOW_UTILS, COMPONENT_UTILS, MEM_PRESSURE, CC_WAITING, CC_FORCED, LOAD_END, POST_COMPARTMENT, PAGE_HIDE, NSJSCONTEXT_DESTROY, SET_NEW_DOCUMENT, SET_DOC_SHELL, DOM_UTILS, DOM_IPC, DOM_WORKER, INTER_SLICE_GC, REFRESH_FRAME, FULL_GC_TIMER, SHUTDOWN_CC, FINISH_LARGE_EVALUATE, USER_INACTIVE, XPCONNECT_SHUTDOWN,

    NO_REASON,
    NUM_REASONS,







    NUM_TELEMETRY_REASONS = 100
};




extern const char*
ExplainReason(JS::gcreason::Reason reason);

}
extern void
PrepareZoneForGC(Zone* zone);




extern void
PrepareForFullGC(JSContext* cx);






extern void
PrepareForIncrementalGC(JSContext* cx);





extern bool
IsGCScheduled(JSContext* cx);





extern void
SkipZoneForGC(Zone* zone);
extern void
GCForReason(JSContext* cx, JSGCInvocationKind gckind, gcreason::Reason reason);
extern void
StartIncrementalGC(JSContext* cx, JSGCInvocationKind gckind, gcreason::Reason reason,
                   int64_t millis = 0);
extern void
IncrementalGCSlice(JSContext* cx, gcreason::Reason reason, int64_t millis = 0);







extern void
FinishIncrementalGC(JSContext* cx, gcreason::Reason reason);







extern void
AbortIncrementalGC(JSContext* cx);

namespace dbg {




class GarbageCollectionEvent
{

    uint64_t majorGCNumber_;



    const char* reason;




    const char* nonincrementalReason;



    struct Collection {
        mozilla::TimeStamp startTimestamp;
        mozilla::TimeStamp endTimestamp;
    };


    mozilla::Vector<Collection> collections;

    GarbageCollectionEvent(const GarbageCollectionEvent& rhs) = delete;
    GarbageCollectionEvent& operator=(const GarbageCollectionEvent& rhs) = delete;

  public:
    explicit GarbageCollectionEvent(uint64_t majorGCNum)
        : majorGCNumber_(majorGCNum)
        , reason(nullptr)
        , nonincrementalReason(nullptr)
        , collections()
    { }

    using Ptr = js::UniquePtr<GarbageCollectionEvent>;
    static Ptr Create(JSRuntime* rt, ::js::gcstats::Statistics& stats, uint64_t majorGCNumber);

    JSObject* toJSObject(JSContext* cx) const;

    uint64_t majorGCNumber() const { return majorGCNumber_; }
};

}

enum GCProgress {
    GC_CYCLE_BEGIN,
    GC_SLICE_BEGIN,
    GC_SLICE_END,
    GC_CYCLE_END
};

struct GCDescription {
    bool isZone_;
    JSGCInvocationKind invocationKind_;
    gcreason::Reason reason_;

    GCDescription(bool isZone, JSGCInvocationKind kind, gcreason::Reason reason)
      : isZone_(isZone), invocationKind_(kind), reason_(reason) {}

    char16_t* formatSliceMessage(JSContext* cx) const;
    char16_t* formatSummaryMessage(JSContext* cx) const;
    char16_t* formatJSON(JSContext* cx, uint64_t timestamp) const;

    JS::dbg::GarbageCollectionEvent::Ptr toGCEvent(JSContext* cx) const;
};

typedef void
(* GCSliceCallback)(JSContext* cx, GCProgress progress, const GCDescription& desc);






extern GCSliceCallback
SetGCSliceCallback(JSContext* cx, GCSliceCallback callback);




enum class GCNurseryProgress {



    GC_NURSERY_COLLECTION_START,



    GC_NURSERY_COLLECTION_END
};





using GCNurseryCollectionCallback = void(*)(JSContext* cx, GCNurseryProgress progress,
                                            gcreason::Reason reason);





extern GCNurseryCollectionCallback
SetGCNurseryCollectionCallback(JSContext* cx, GCNurseryCollectionCallback callback);

typedef void
(* DoCycleCollectionCallback)(JSContext* cx);





extern DoCycleCollectionCallback
SetDoCycleCollectionCallback(JSContext* cx, DoCycleCollectionCallback callback);







extern void
DisableIncrementalGC(JSContext* cx);
extern bool
IsIncrementalGCEnabled(JSContext* cx);





extern bool
IsIncrementalGCInProgress(JSContext* cx);







extern bool
IsIncrementalBarrierNeeded(JSContext* cx);





extern void
IncrementalPreWriteBarrier(JSObject* obj);





extern void
IncrementalReadBarrier(GCCellPtr thing);




extern bool
WasIncrementalGC(JSContext* cx);
class AutoDisableGenerationalGC
{
    JSContext* cx;

  public:
    explicit AutoDisableGenerationalGC(JSContext* cx);
    ~AutoDisableGenerationalGC();
};





extern bool
IsGenerationalGCEnabled(JSRuntime* rt);






extern size_t
GetGCNumber();






class AutoRequireNoGC
{
  protected:
    AutoRequireNoGC() {}
    ~AutoRequireNoGC() {}
};
class AutoAssertNoGC : public AutoRequireNoGC
{
    JSContext* cx_;

  public:
    explicit AutoAssertNoGC(JSContext* cx = nullptr);
    ~AutoAssertNoGC();
};





class AutoAssertNoAlloc
{

    js::gc::GCRuntime* gc;

  public:
    AutoAssertNoAlloc() : gc(nullptr) {}
    explicit AutoAssertNoAlloc(JSContext* cx);
    void disallowAlloc(JSRuntime* rt);
    ~AutoAssertNoAlloc();






};





class AutoAssertOnBarrier
{
    JSContext* context;
    bool prev;

  public:
    explicit AutoAssertOnBarrier(JSContext* cx);
    ~AutoAssertOnBarrier();
};
class AutoSuppressGCAnalysis : public AutoAssertNoAlloc
{
  public:
    AutoSuppressGCAnalysis() : AutoAssertNoAlloc() {}
    explicit AutoSuppressGCAnalysis(JSContext* cx) : AutoAssertNoAlloc(cx) {}
} ;
class AutoAssertGCCallback : public AutoSuppressGCAnalysis
{
  public:
    explicit AutoAssertGCCallback(JSObject* obj);
};
class AutoCheckCannotGC : public AutoRequireNoGC
{
  public:
    explicit AutoCheckCannotGC(JSContext* cx = nullptr) {}
} ;







extern bool
UnmarkGrayGCThingRecursively(GCCellPtr thing);

}

namespace js {
namespace gc {

extern bool
BarriersAreAllowedOnCurrentThread();

static __attribute__((always_inline)) inline void
ExposeGCThingToActiveJS(JS::GCCellPtr thing)
{



    if (IsInsideNursery(thing.asCell()))
        return;



    if (thing.mayBeOwnedByOtherRuntime())
        return;

    do { static_assert(mozilla::detail::AssertionConditionType<decltype(BarriersAreAllowedOnCurrentThread())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(BarriersAreAllowedOnCurrentThread()))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "BarriersAreAllowedOnCurrentThread()" ")"); do { *((volatile int*) __null) = 645; ::abort(); } while (0); } } while (0);

    if (IsIncrementalBarrierNeededOnTenuredGCThing(thing))
        JS::IncrementalReadBarrier(thing);
    else if (js::gc::detail::CellIsMarkedGray(thing.asCell()))
        JS::UnmarkGrayGCThingRecursively(thing);

    do { } while (0);
}

static __attribute__((always_inline)) inline void
GCThingReadBarrier(JS::GCCellPtr thing)
{


    if (IsInsideNursery(thing.asCell()))
        return;



    if (thing.mayBeOwnedByOtherRuntime())
        return;

    do { static_assert(mozilla::detail::AssertionConditionType<decltype(BarriersAreAllowedOnCurrentThread())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(BarriersAreAllowedOnCurrentThread()))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "BarriersAreAllowedOnCurrentThread()" ")"); do { *((volatile int*) __null) = 668; ::abort(); } while (0); } } while (0);

    if (IsIncrementalBarrierNeededOnTenuredGCThing(thing))
        JS::IncrementalReadBarrier(thing);
}

}
}

namespace JS {







static __attribute__((always_inline)) inline void
ExposeObjectToActiveJS(JSObject* obj)
{
    do { } while (0);
    js::gc::ExposeGCThingToActiveJS(GCCellPtr(obj));
}

static __attribute__((always_inline)) inline void
ExposeScriptToActiveJS(JSScript* script)
{
    js::gc::ExposeGCThingToActiveJS(GCCellPtr(script));
}




static __attribute__((always_inline)) inline void
StringReadBarrier(JSString* string)
{
    do { } while (0);
    js::gc::GCThingReadBarrier(GCCellPtr(string));
}






extern void
PokeGC(JSContext* cx);




extern void
NotifyDidPaint(JSContext* cx);

}
namespace js {

enum class AllocFunction {
    Malloc,
    Calloc,
    Realloc
};


class SystemAllocPolicy
{
  public:
    template <typename T> T* maybe_pod_malloc(size_t numElems) { return js_pod_malloc<T>(numElems); }
    template <typename T> T* maybe_pod_calloc(size_t numElems) { return js_pod_calloc<T>(numElems); }
    template <typename T> T* maybe_pod_realloc(T* p, size_t oldSize, size_t newSize) {
        return js_pod_realloc<T>(p, oldSize, newSize);
    }
    template <typename T> T* pod_malloc(size_t numElems) { return maybe_pod_malloc<T>(numElems); }
    template <typename T> T* pod_calloc(size_t numElems) { return maybe_pod_calloc<T>(numElems); }
    template <typename T> T* pod_realloc(T* p, size_t oldSize, size_t newSize) {
        return maybe_pod_realloc<T>(p, oldSize, newSize);
    }
    void free_(void* p) { js_free(p); }
    void reportAllocOverflow() const {}
    bool checkSimulatedOOM() const {
        return !js::oom::ShouldFailWithOOM();
    }
};

void ReportOutOfMemory(JSContext* cx);
class TempAllocPolicy
{
    JSContext* const cx_;





    void* onOutOfMemory(AllocFunction allocFunc, size_t nbytes,
                                       void* reallocPtr = nullptr);

    template <typename T>
    T* onOutOfMemoryTyped(AllocFunction allocFunc, size_t numElems, void* reallocPtr = nullptr) {
        size_t bytes;
        if ((__builtin_expect(!!(!CalculateAllocSize<T>(numElems, &bytes)), 0)))
            return nullptr;
        return static_cast<T*>(onOutOfMemory(allocFunc, bytes, reallocPtr));
    }

  public:
                 TempAllocPolicy(JSContext* cx) : cx_(cx) {}

    template <typename T>
    T* maybe_pod_malloc(size_t numElems) {
        return js_pod_malloc<T>(numElems);
    }

    template <typename T>
    T* maybe_pod_calloc(size_t numElems) {
        return js_pod_calloc<T>(numElems);
    }

    template <typename T>
    T* maybe_pod_realloc(T* prior, size_t oldSize, size_t newSize) {
        return js_pod_realloc<T>(prior, oldSize, newSize);
    }

    template <typename T>
    T* pod_malloc(size_t numElems) {
        T* p = maybe_pod_malloc<T>(numElems);
        if ((__builtin_expect(!!(!p), 0)))
            p = onOutOfMemoryTyped<T>(AllocFunction::Malloc, numElems);
        return p;
    }

    template <typename T>
    T* pod_calloc(size_t numElems) {
        T* p = maybe_pod_calloc<T>(numElems);
        if ((__builtin_expect(!!(!p), 0)))
            p = onOutOfMemoryTyped<T>(AllocFunction::Calloc, numElems);
        return p;
    }

    template <typename T>
    T* pod_realloc(T* prior, size_t oldSize, size_t newSize) {
        T* p2 = maybe_pod_realloc<T>(prior, oldSize, newSize);
        if ((__builtin_expect(!!(!p2), 0)))
            p2 = onOutOfMemoryTyped<T>(AllocFunction::Realloc, newSize, prior);
        return p2;
    }

    void free_(void* p) {
        js_free(p);
    }

    void reportAllocOverflow() const;

    bool checkSimulatedOOM() const {
        if (js::oom::ShouldFailWithOOM()) {
            ReportOutOfMemory(cx_);
            return false;
        }

        return true;
    }
};

}

namespace mozilla {




static const uint32_t kGoldenRatioU32 = 0x9E3779B9U;

inline uint32_t
RotateBitsLeft32(uint32_t aValue, uint8_t aBits)
{
  do { } while (0);
  return (aValue << aBits) | (aValue >> (32 - aBits));
}

namespace detail {

inline uint32_t
AddU32ToHash(uint32_t aHash, uint32_t aValue)
{
  return kGoldenRatioU32 * (RotateBitsLeft32(aHash, 5) ^ aValue);
}




template<size_t PtrSize>
inline uint32_t
AddUintptrToHash(uint32_t aHash, uintptr_t aValue);

template<>
inline uint32_t
AddUintptrToHash<4>(uint32_t aHash, uintptr_t aValue)
{
  return AddU32ToHash(aHash, static_cast<uint32_t>(aValue));
}

template<>
inline uint32_t
AddUintptrToHash<8>(uint32_t aHash, uintptr_t aValue)
{







  uint32_t v1 = static_cast<uint32_t>(aValue);
  uint32_t v2 = static_cast<uint32_t>(static_cast<uint64_t>(aValue) >> 32);
  return AddU32ToHash(AddU32ToHash(aHash, v1), v2);
}

}
template<typename A>
__attribute__ ((warn_unused_result)) inline uint32_t
AddToHash(uint32_t aHash, A aA)
{




  return detail::AddU32ToHash(aHash, aA);
}

template<typename A>
__attribute__ ((warn_unused_result)) inline uint32_t
AddToHash(uint32_t aHash, A* aA)
{





  static_assert(sizeof(aA) == sizeof(uintptr_t), "Strange pointer!");

  return detail::AddUintptrToHash<sizeof(uintptr_t)>(aHash, uintptr_t(aA));
}

template<>
__attribute__ ((warn_unused_result)) inline uint32_t
AddToHash(uint32_t aHash, uintptr_t aA)
{
  return detail::AddUintptrToHash<sizeof(uintptr_t)>(aHash, aA);
}

template<typename A, typename... Args>
__attribute__ ((warn_unused_result)) uint32_t
AddToHash(uint32_t aHash, A aArg, Args... aArgs)
{
  return AddToHash(AddToHash(aHash, aArg), aArgs...);
}
template<typename... Args>
__attribute__ ((warn_unused_result)) inline uint32_t
HashGeneric(Args... aArgs)
{
  return AddToHash(0, aArgs...);
}

namespace detail {

template<typename T>
uint32_t
HashUntilZero(const T* aStr)
{
  uint32_t hash = 0;
  for (T c; (c = *aStr); aStr++) {
    hash = AddToHash(hash, c);
  }
  return hash;
}

template<typename T>
uint32_t
HashKnownLength(const T* aStr, size_t aLength)
{
  uint32_t hash = 0;
  for (size_t i = 0; i < aLength; i++) {
    hash = AddToHash(hash, aStr[i]);
  }
  return hash;
}

}







__attribute__ ((warn_unused_result)) inline uint32_t
HashString(const char* aStr)
{
  return detail::HashUntilZero(reinterpret_cast<const unsigned char*>(aStr));
}

__attribute__ ((warn_unused_result)) inline uint32_t
HashString(const char* aStr, size_t aLength)
{
  return detail::HashKnownLength(reinterpret_cast<const unsigned char*>(aStr), aLength);
}

__attribute__ ((warn_unused_result))
inline uint32_t
HashString(const unsigned char* aStr, size_t aLength)
{
  return detail::HashKnownLength(aStr, aLength);
}

__attribute__ ((warn_unused_result)) inline uint32_t
HashString(const char16_t* aStr)
{
  return detail::HashUntilZero(aStr);
}

__attribute__ ((warn_unused_result)) inline uint32_t
HashString(const char16_t* aStr, size_t aLength)
{
  return detail::HashKnownLength(aStr, aLength);
}
__attribute__ ((warn_unused_result)) extern __attribute__((weak)) __attribute__((visibility("default"))) uint32_t
HashBytes(const void* bytes, size_t aLength);
class HashCodeScrambler
{
  struct SipHasher;

  uint64_t mK0, mK1;

public:

  constexpr HashCodeScrambler(uint64_t aK0, uint64_t aK1) : mK0(aK0), mK1(aK1) {}





  uint32_t scramble(uint32_t aHashCode) const
  {
    SipHasher hasher(mK0, mK1);
    return uint32_t(hasher.sipHash(aHashCode));
  }

private:
  struct SipHasher
  {
    SipHasher(uint64_t aK0, uint64_t aK1)
    {

      mV0 = aK0 ^ 0x736f6d6570736575UL;
      mV1 = aK1 ^ 0x646f72616e646f6dUL;
      mV2 = aK0 ^ 0x6c7967656e657261UL;
      mV3 = aK1 ^ 0x7465646279746573UL;
    }

    uint64_t sipHash(uint64_t aM)
    {

      mV3 ^= aM;
      sipRound();
      mV0 ^= aM;


      mV2 ^= 0xff;
      for (int i = 0; i < 3; i++)
        sipRound();
      return mV0 ^ mV1 ^ mV2 ^ mV3;
    }

    void sipRound()
    {
      mV0 += mV1;
      mV1 = RotateLeft(mV1, 13);
      mV1 ^= mV0;
      mV0 = RotateLeft(mV0, 32);
      mV2 += mV3;
      mV3 = RotateLeft(mV3, 16);
      mV3 ^= mV2;
      mV0 += mV3;
      mV3 = RotateLeft(mV3, 21);
      mV3 ^= mV0;
      mV2 += mV1;
      mV1 = RotateLeft(mV1, 17);
      mV1 ^= mV2;
      mV2 = RotateLeft(mV2, 32);
    }

    uint64_t mV0, mV1, mV2, mV3;
  };
};

}


namespace mozilla {






template<typename T>
class Opaque final
{
  static_assert(mozilla::IsIntegral<T>::value,
                "mozilla::Opaque only supports integral types");

  T mValue;

public:
  Opaque() {}
  explicit Opaque(T aValue) : mValue(aValue) {}

  bool operator==(const Opaque& aOther) const {
    return mValue == aOther.mValue;
  }

  bool operator!=(const Opaque& aOther) const {
    return !(*this == aOther);
  }
};

}








namespace js {

class TempAllocPolicy;
template <class> struct DefaultHasher;
template <class, class> class HashMapEntry;
namespace detail {
    template <class T> class HashTableEntry;
    template <class T, class HashPolicy, class AllocPolicy> class HashTable;
}
using Generation = mozilla::Opaque<uint64_t>;
template <class Key,
          class Value,
          class HashPolicy = DefaultHasher<Key>,
          class AllocPolicy = TempAllocPolicy>
class HashMap
{
    typedef HashMapEntry<Key, Value> TableEntry;

    struct MapHashPolicy : HashPolicy
    {
        using Base = HashPolicy;
        typedef Key KeyType;
        static const Key& getKey(TableEntry& e) { return e.key(); }
        static void setKey(TableEntry& e, Key& k) { HashPolicy::rekey(e.mutableKey(), k); }
    };

    typedef detail::HashTable<TableEntry, MapHashPolicy, AllocPolicy> Impl;
    Impl impl;

  public:
    typedef typename HashPolicy::Lookup Lookup;
    typedef TableEntry Entry;



    explicit HashMap(AllocPolicy a = AllocPolicy()) : impl(a) {}
    __attribute__ ((warn_unused_result)) bool init(uint32_t len = 16) { return impl.init(len); }
    bool initialized() const { return impl.initialized(); }
    typedef typename Impl::Ptr Ptr;
    __attribute__((always_inline)) inline Ptr lookup(const Lookup& l) const { return impl.lookup(l); }



    __attribute__((always_inline)) inline Ptr readonlyThreadsafeLookup(const Lookup& l) const {
        return impl.readonlyThreadsafeLookup(l);
    }


    void remove(Ptr p) { impl.remove(p); }
    typedef typename Impl::AddPtr AddPtr;
    __attribute__((always_inline)) inline AddPtr lookupForAdd(const Lookup& l) const {
        return impl.lookupForAdd(l);
    }

    template<typename KeyInput, typename ValueInput>
    __attribute__ ((warn_unused_result)) bool add(AddPtr& p, KeyInput&& k, ValueInput&& v) {
        return impl.add(p,
                        mozilla::Forward<KeyInput>(k),
                        mozilla::Forward<ValueInput>(v));
    }

    template<typename KeyInput>
    __attribute__ ((warn_unused_result)) bool add(AddPtr& p, KeyInput&& k) {
        return impl.add(p, mozilla::Forward<KeyInput>(k), Value());
    }

    template<typename KeyInput, typename ValueInput>
    __attribute__ ((warn_unused_result)) bool relookupOrAdd(AddPtr& p, KeyInput&& k, ValueInput&& v) {
        return impl.relookupOrAdd(p, k,
                                  mozilla::Forward<KeyInput>(k),
                                  mozilla::Forward<ValueInput>(v));
    }
    typedef typename Impl::Range Range;
    Range all() const { return impl.all(); }
    typedef typename Impl::Enum Enum;



    void clear() { impl.clear(); }



    void clearAndShrink() { impl.clearAndShrink(); }



    void finish() { impl.finish(); }


    bool empty() const { return impl.empty(); }


    uint32_t count() const { return impl.count(); }



    size_t capacity() const { return impl.capacity(); }



    size_t sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
        return impl.sizeOfExcludingThis(mallocSizeOf);
    }
    size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
        return mallocSizeOf(this) + impl.sizeOfExcludingThis(mallocSizeOf);
    }

    Generation generation() const {
        return impl.generation();
    }



    bool has(const Lookup& l) const {
        return impl.lookup(l).found();
    }


    template<typename KeyInput, typename ValueInput>
    __attribute__ ((warn_unused_result)) bool put(KeyInput&& k, ValueInput&& v) {
        AddPtr p = lookupForAdd(k);
        if (p) {
            p->value() = mozilla::Forward<ValueInput>(v);
            return true;
        }
        return add(p, mozilla::Forward<KeyInput>(k), mozilla::Forward<ValueInput>(v));
    }


    template<typename KeyInput, typename ValueInput>
    __attribute__ ((warn_unused_result)) bool putNew(KeyInput&& k, ValueInput&& v) {
        return impl.putNew(k, mozilla::Forward<KeyInput>(k), mozilla::Forward<ValueInput>(v));
    }


    template<typename KeyInput, typename ValueInput>
    void putNewInfallible(KeyInput&& k, ValueInput&& v) {
        impl.putNewInfallible(k, mozilla::Forward<KeyInput>(k), mozilla::Forward<ValueInput>(v));
    }


    Ptr lookupWithDefault(const Key& k, const Value& defaultValue) {
        AddPtr p = lookupForAdd(k);
        if (p)
            return p;
        bool ok = add(p, k, defaultValue);
        do { } while (0);
        (void)ok;
        return p;
    }


    void remove(const Lookup& l) {
        if (Ptr p = lookup(l))
            remove(p);
    }



    void rekeyIfMoved(const Key& old_key, const Key& new_key) {
        if (old_key != new_key)
            rekeyAs(old_key, new_key, new_key);
    }


    bool rekeyAs(const Lookup& old_lookup, const Lookup& new_lookup, const Key& new_key) {
        if (Ptr p = lookup(old_lookup)) {
            impl.rekeyAndMaybeRehash(p, new_lookup, new_key);
            return true;
        }
        return false;
    }


    HashMap(HashMap&& rhs) : impl(mozilla::Move(rhs.impl)) {}
    void operator=(HashMap&& rhs) {
        do { } while (0);
        impl = mozilla::Move(rhs.impl);
    }

  private:

    HashMap(const HashMap& hm) = delete;
    HashMap& operator=(const HashMap& hm) = delete;

    friend class Impl::Enum;
};
template <class T,
          class HashPolicy = DefaultHasher<T>,
          class AllocPolicy = TempAllocPolicy>
class HashSet
{
    struct SetOps : HashPolicy
    {
        using Base = HashPolicy;
        typedef T KeyType;
        static const KeyType& getKey(const T& t) { return t; }
        static void setKey(T& t, KeyType& k) { HashPolicy::rekey(t, k); }
    };

    typedef detail::HashTable<const T, SetOps, AllocPolicy> Impl;
    Impl impl;

  public:
    typedef typename HashPolicy::Lookup Lookup;
    typedef T Entry;



    explicit HashSet(AllocPolicy a = AllocPolicy()) : impl(a) {}
    __attribute__ ((warn_unused_result)) bool init(uint32_t len = 16) { return impl.init(len); }
    bool initialized() const { return impl.initialized(); }
    typedef typename Impl::Ptr Ptr;
    __attribute__((always_inline)) inline Ptr lookup(const Lookup& l) const { return impl.lookup(l); }



    __attribute__((always_inline)) inline Ptr readonlyThreadsafeLookup(const Lookup& l) const {
        return impl.readonlyThreadsafeLookup(l);
    }


    void remove(Ptr p) { impl.remove(p); }
    typedef typename Impl::AddPtr AddPtr;
    __attribute__((always_inline)) inline AddPtr lookupForAdd(const Lookup& l) const {
        return impl.lookupForAdd(l);
    }

    template <typename U>
    __attribute__ ((warn_unused_result)) bool add(AddPtr& p, U&& u) {
        return impl.add(p, mozilla::Forward<U>(u));
    }

    template <typename U>
    __attribute__ ((warn_unused_result)) bool relookupOrAdd(AddPtr& p, const Lookup& l, U&& u) {
        return impl.relookupOrAdd(p, l, mozilla::Forward<U>(u));
    }
    typedef typename Impl::Range Range;
    Range all() const { return impl.all(); }
    typedef typename Impl::Enum Enum;



    void clear() { impl.clear(); }



    void clearAndShrink() { impl.clearAndShrink(); }



    void finish() { impl.finish(); }


    bool empty() const { return impl.empty(); }


    uint32_t count() const { return impl.count(); }



    size_t capacity() const { return impl.capacity(); }



    size_t sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
        return impl.sizeOfExcludingThis(mallocSizeOf);
    }
    size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
        return mallocSizeOf(this) + impl.sizeOfExcludingThis(mallocSizeOf);
    }

    Generation generation() const {
        return impl.generation();
    }



    bool has(const Lookup& l) const {
        return impl.lookup(l).found();
    }


    template <typename U>
    __attribute__ ((warn_unused_result)) bool put(U&& u) {
        AddPtr p = lookupForAdd(u);
        return p ? true : add(p, mozilla::Forward<U>(u));
    }


    template <typename U>
    __attribute__ ((warn_unused_result)) bool putNew(U&& u) {
        return impl.putNew(u, mozilla::Forward<U>(u));
    }

    template <typename U>
    __attribute__ ((warn_unused_result)) bool putNew(const Lookup& l, U&& u) {
        return impl.putNew(l, mozilla::Forward<U>(u));
    }


    template <typename U>
    void putNewInfallible(const Lookup& l, U&& u) {
        impl.putNewInfallible(l, mozilla::Forward<U>(u));
    }

    void remove(const Lookup& l) {
        if (Ptr p = lookup(l))
            remove(p);
    }



    void rekeyIfMoved(const Lookup& old_value, const T& new_value) {
        if (old_value != new_value)
            rekeyAs(old_value, new_value, new_value);
    }


    bool rekeyAs(const Lookup& old_lookup, const Lookup& new_lookup, const T& new_value) {
        if (Ptr p = lookup(old_lookup)) {
            impl.rekeyAndMaybeRehash(p, new_lookup, new_value);
            return true;
        }
        return false;
    }





    void replaceKey(Ptr p, const T& new_value) {
        do { } while (0);
        do { } while (0);
        do { } while (0);
        do { } while (0);
        const_cast<T&>(*p) = new_value;
    }


    HashSet(HashSet&& rhs) : impl(mozilla::Move(rhs.impl)) {}
    void operator=(HashSet&& rhs) {
        do { } while (0);
        impl = mozilla::Move(rhs.impl);
    }

  private:

    HashSet(const HashSet& hs) = delete;
    HashSet& operator=(const HashSet& hs) = delete;

    friend class Impl::Enum;
};
template <typename Key, size_t zeroBits>
struct PointerHasher
{
    typedef Key Lookup;
    static HashNumber hash(const Lookup& l) {
        size_t word = reinterpret_cast<size_t>(l) >> zeroBits;
        static_assert(sizeof(HashNumber) == 4,
                      "subsequent code assumes a four-byte hash");



        static_assert(sizeof(word) == 8,
                      "unexpected word size, new hashing strategy required to "
                      "properly incorporate all bits");
        return HashNumber((word >> 32) ^ word);

    }
    static bool match(const Key& k, const Lookup& l) {
        return k == l;
    }
    static void rekey(Key& k, const Key& newKey) {
        k = newKey;
    }
};





template <class Key>
struct DefaultHasher
{
    typedef Key Lookup;
    static HashNumber hash(const Lookup& l) {

        return l;
    }
    static bool match(const Key& k, const Lookup& l) {

        return k == l;
    }
    static void rekey(Key& k, const Key& newKey) {
        k = newKey;
    }
};



template <class T>
struct DefaultHasher<T*> : PointerHasher<T*, mozilla::tl::FloorLog2<sizeof(void*)>::value>
{};



template <class T, class D>
struct DefaultHasher<mozilla::UniquePtr<T, D>>
{
    using Lookup = mozilla::UniquePtr<T, D>;
    using PtrHasher = PointerHasher<T*, mozilla::tl::FloorLog2<sizeof(void*)>::value>;

    static HashNumber hash(const Lookup& l) {
        return PtrHasher::hash(l.get());
    }
    static bool match(const mozilla::UniquePtr<T, D>& k, const Lookup& l) {
        return PtrHasher::match(k.get(), l.get());
    }
    static void rekey(mozilla::UniquePtr<T, D>& k, mozilla::UniquePtr<T, D>&& newKey) {
        k = mozilla::Move(newKey);
    }
};


template <>
struct DefaultHasher<double>
{
    typedef double Lookup;
    static HashNumber hash(double d) {
        static_assert(sizeof(HashNumber) == 4,
                      "subsequent code assumes a four-byte hash");
        uint64_t u = mozilla::BitwiseCast<uint64_t>(d);
        return HashNumber(u ^ (u >> 32));
    }
    static bool match(double lhs, double rhs) {
        return mozilla::BitwiseCast<uint64_t>(lhs) == mozilla::BitwiseCast<uint64_t>(rhs);
    }
};

template <>
struct DefaultHasher<float>
{
    typedef float Lookup;
    static HashNumber hash(float f) {
        static_assert(sizeof(HashNumber) == 4,
                      "subsequent code assumes a four-byte hash");
        return HashNumber(mozilla::BitwiseCast<uint32_t>(f));
    }
    static bool match(float lhs, float rhs) {
        return mozilla::BitwiseCast<uint32_t>(lhs) == mozilla::BitwiseCast<uint32_t>(rhs);
    }
};


struct CStringHasher
{
    typedef const char* Lookup;
    static js::HashNumber hash(Lookup l) {
        return mozilla::HashString(l);
    }
    static bool match(const char* key, Lookup lookup) {
        return strcmp(key, lookup) == 0;
    }
};
template <typename HashPolicy>
struct FallibleHashMethods
{


    template <typename Lookup> static bool hasHash(Lookup&& l) { return true; }



    template <typename Lookup> static bool ensureHash(Lookup&& l) { return true; }
};

template <typename HashPolicy, typename Lookup>
static bool
HasHash(Lookup&& l) {
    return FallibleHashMethods<typename HashPolicy::Base>::hasHash(mozilla::Forward<Lookup>(l));
}

template <typename HashPolicy, typename Lookup>
static bool
EnsureHash(Lookup&& l) {
    return FallibleHashMethods<typename HashPolicy::Base>::ensureHash(mozilla::Forward<Lookup>(l));
}
template <class Key, class Value>
class HashMapEntry
{
    Key key_;
    Value value_;

    template <class, class, class> friend class detail::HashTable;
    template <class> friend class detail::HashTableEntry;
    template <class, class, class, class> friend class HashMap;

  public:
    template<typename KeyInput, typename ValueInput>
    HashMapEntry(KeyInput&& k, ValueInput&& v)
      : key_(mozilla::Forward<KeyInput>(k)),
        value_(mozilla::Forward<ValueInput>(v))
    {}

    HashMapEntry(HashMapEntry&& rhs)
      : key_(mozilla::Move(rhs.key_)),
        value_(mozilla::Move(rhs.value_))
    {}

    void operator=(HashMapEntry&& rhs) {
        key_ = mozilla::Move(rhs.key_);
        value_ = mozilla::Move(rhs.value_);
    }

    typedef Key KeyType;
    typedef Value ValueType;

    const Key& key() const { return key_; }
    Key& mutableKey() { return key_; }
    const Value& value() const { return value_; }
    Value& value() { return value_; }

  private:
    HashMapEntry(const HashMapEntry&) = delete;
    void operator=(const HashMapEntry&) = delete;
};

}

namespace mozilla {

template <typename T>
struct IsPod<js::detail::HashTableEntry<T> > : IsPod<T> {};

template <typename K, typename V>
struct IsPod<js::HashMapEntry<K, V> >
  : IntegralConstant<bool, IsPod<K>::value && IsPod<V>::value>
{};

}

namespace js {

namespace detail {

template <class T, class HashPolicy, class AllocPolicy>
class HashTable;

template <class T>
class HashTableEntry
{
    template <class, class, class> friend class HashTable;
    typedef typename mozilla::RemoveConst<T>::Type NonConstT;

    HashNumber keyHash;
    mozilla::AlignedStorage2<NonConstT> mem;

    static const HashNumber sFreeKey = 0;
    static const HashNumber sRemovedKey = 1;
    static const HashNumber sCollisionBit = 1;

    static bool isLiveHash(HashNumber hash)
    {
        return hash > sRemovedKey;
    }

    HashTableEntry(const HashTableEntry&) = delete;
    void operator=(const HashTableEntry&) = delete;
    ~HashTableEntry() = delete;

  public:


    void destroyIfLive() {
        if (isLive())
            mem.addr()->~T();
    }

    void destroy() {
        do { } while (0);
        mem.addr()->~T();
    }

    void swap(HashTableEntry* other) {
        if (this == other)
            return;
        do { } while (0);
        if (other->isLive()) {
            mozilla::Swap(*mem.addr(), *other->mem.addr());
        } else {
            *other->mem.addr() = mozilla::Move(*mem.addr());
            destroy();
        }
        mozilla::Swap(keyHash, other->keyHash);
    }

    T& get() { do { } while (0); return *mem.addr(); }
    NonConstT& getMutable() { do { } while (0); return *mem.addr(); }

    bool isFree() const { return keyHash == sFreeKey; }
    void clearLive() { do { } while (0); keyHash = sFreeKey; mem.addr()->~T(); }
    void clear() { if (isLive()) mem.addr()->~T(); keyHash = sFreeKey; }
    bool isRemoved() const { return keyHash == sRemovedKey; }
    void removeLive() { do { } while (0); keyHash = sRemovedKey; mem.addr()->~T(); }
    bool isLive() const { return isLiveHash(keyHash); }
    void setCollision() { do { } while (0); keyHash |= sCollisionBit; }
    void unsetCollision() { keyHash &= ~sCollisionBit; }
    bool hasCollision() const { return keyHash & sCollisionBit; }
    bool matchHash(HashNumber hn) { return (keyHash & ~sCollisionBit) == hn; }
    HashNumber getKeyHash() const { return keyHash & ~sCollisionBit; }

    template <typename... Args>
    void setLive(HashNumber hn, Args&&... args)
    {
        do { } while (0);
        keyHash = hn;
        new(mem.addr()) T(mozilla::Forward<Args>(args)...);
        do { } while (0);
    }
};

template <class T, class HashPolicy, class AllocPolicy>
class HashTable : private AllocPolicy
{
    friend class mozilla::ReentrancyGuard;

    typedef typename mozilla::RemoveConst<T>::Type NonConstT;
    typedef typename HashPolicy::KeyType Key;
    typedef typename HashPolicy::Lookup Lookup;

  public:
    typedef HashTableEntry<T> Entry;





    class Ptr
    {
        friend class HashTable;

        Entry* entry_;

        const HashTable* table_;
        Generation generation;


      protected:
        Ptr(Entry& entry, const HashTable& tableArg)
          : entry_(&entry)

          , table_(&tableArg)
          , generation(tableArg.generation())

        {}

      public:
        Ptr()
          : entry_(nullptr)

          , table_(nullptr)
          , generation(0)

        {}

        bool isValid() const {
            return !entry_;
        }

        bool found() const {
            if (isValid())
                return false;

            do { } while (0);

            return entry_->isLive();
        }

        explicit operator bool() const {
            return found();
        }

        bool operator==(const Ptr& rhs) const {
            do { } while (0);
            return entry_ == rhs.entry_;
        }

        bool operator!=(const Ptr& rhs) const {

            do { } while (0);

            return !(*this == rhs);
        }

        T& operator*() const {

            do { } while (0);
            do { } while (0);

            return entry_->get();
        }

        T* operator->() const {

            do { } while (0);
            do { } while (0);

            return &entry_->get();
        }
    };


    class AddPtr : public Ptr
    {
        friend class HashTable;
        HashNumber keyHash;

        uint64_t mutationCount;


        AddPtr(Entry& entry, const HashTable& tableArg, HashNumber hn)
          : Ptr(entry, tableArg)
          , keyHash(hn)

          , mutationCount(tableArg.mutationCount)

        {}

      public:
        AddPtr() : keyHash(0) {}
    };





    class Range
    {
      protected:
        friend class HashTable;

        Range(const HashTable& tableArg, Entry* c, Entry* e)
          : cur(c)
          , end(e)

          , table_(&tableArg)
          , mutationCount(tableArg.mutationCount)
          , generation(tableArg.generation())
          , validEntry(true)

        {
            while (cur < end && !cur->isLive())
                ++cur;
        }

        Entry* cur;
        Entry* end;

        const HashTable* table_;
        uint64_t mutationCount;
        Generation generation;
        bool validEntry;


      public:
        Range()
          : cur(nullptr)
          , end(nullptr)

          , table_(nullptr)
          , mutationCount(0)
          , generation(0)
          , validEntry(false)

        {}

        bool empty() const {

            do { } while (0);
            do { } while (0);

            return cur == end;
        }

        T& front() const {
            do { } while (0);

            do { } while (0);
            do { } while (0);
            do { } while (0);

            return cur->get();
        }

        void popFront() {
            do { } while (0);

            do { } while (0);
            do { } while (0);

            while (++cur < end && !cur->isLive())
                continue;

            validEntry = true;

        }
    };






    class Enum : public Range
    {
        friend class HashTable;

        HashTable& table_;
        bool rekeyed;
        bool removed;


        Enum(const Enum&) = delete;
        void operator=(const Enum&) = delete;

      public:
        template<class Map> explicit
        Enum(Map& map) : Range(map.all()), table_(map.impl), rekeyed(false), removed(false) {}
        void removeFront() {
            table_.remove(*this->cur);
            removed = true;

            this->validEntry = false;
            this->mutationCount = table_.mutationCount;

        }

        NonConstT& mutableFront() {
            do { } while (0);

            do { } while (0);
            do { } while (0);
            do { } while (0);

            return this->cur->getMutable();
        }




        void rekeyFront(const Lookup& l, const Key& k) {
            do { } while (0);
            Ptr p(*this->cur, table_);
            table_.rekeyWithoutRehash(p, l, k);
            rekeyed = true;

            this->validEntry = false;
            this->mutationCount = table_.mutationCount;

        }

        void rekeyFront(const Key& k) {
            rekeyFront(k, k);
        }


        ~Enum() {
            if (rekeyed) {
                table_.gen++;
                table_.checkOverRemoved();
            }

            if (removed)
                table_.compactIfUnderloaded();
        }
    };


    HashTable(HashTable&& rhs)
      : AllocPolicy(rhs)
    {
        mozilla::PodAssign(this, &rhs);
        rhs.table = nullptr;
    }
    void operator=(HashTable&& rhs) {
        do { } while (0);
        if (table)
            destroyTable(*this, table, capacity());
        mozilla::PodAssign(this, &rhs);
        rhs.table = nullptr;
    }

  private:

    HashTable(const HashTable&) = delete;
    void operator=(const HashTable&) = delete;

  private:
    static const size_t CAP_BITS = 30;

  public:
    uint64_t gen:56;
    uint64_t hashShift:8;
    Entry* table;
    uint32_t entryCount;
    uint32_t removedCount;


    uint64_t mutationCount;
    mutable bool mEntered;


    mutable struct Stats
    {
        uint32_t searches;
        uint32_t steps;
        uint32_t hits;
        uint32_t misses;
        uint32_t addOverRemoved;
        uint32_t removes;
        uint32_t removeFrees;
        uint32_t grows;
        uint32_t shrinks;
        uint32_t compresses;
        uint32_t rehashes;
    } stats;







    static const unsigned sMinCapacityLog2 = 2;
    static const unsigned sMinCapacity = 1 << sMinCapacityLog2;
    static const unsigned sMaxInit = ((uint32_t)1 << (CAP_BITS - 1));
    static const unsigned sMaxCapacity = ((uint32_t)1 << (CAP_BITS));
    static const unsigned sHashBits = mozilla::tl::BitSize<HashNumber>::value;



    static const uint8_t sAlphaDenominator = 4;
    static const uint8_t sMinAlphaNumerator = 1;
    static const uint8_t sMaxAlphaNumerator = 3;

    static const HashNumber sFreeKey = Entry::sFreeKey;
    static const HashNumber sRemovedKey = Entry::sRemovedKey;
    static const HashNumber sCollisionBit = Entry::sCollisionBit;

    void setTableSizeLog2(unsigned sizeLog2)
    {
        hashShift = sHashBits - sizeLog2;
    }

    static bool isLiveHash(HashNumber hash)
    {
        return Entry::isLiveHash(hash);
    }

    static HashNumber prepareHash(const Lookup& l)
    {
        HashNumber keyHash = ScrambleHashCode(HashPolicy::hash(l));


        if (!isLiveHash(keyHash))
            keyHash -= (sRemovedKey + 1);
        return keyHash & ~sCollisionBit;
    }

    enum FailureBehavior { DontReportFailure = false, ReportFailure = true };

    static Entry* createTable(AllocPolicy& alloc, uint32_t capacity,
                              FailureBehavior reportFailure = ReportFailure)
    {
        static_assert(sFreeKey == 0,
                      "newly-calloc'd tables have to be considered empty");
        if (reportFailure)
            return alloc.template pod_calloc<Entry>(capacity);

        return alloc.template maybe_pod_calloc<Entry>(capacity);
    }

    static Entry* maybeCreateTable(AllocPolicy& alloc, uint32_t capacity)
    {
        static_assert(sFreeKey == 0,
                      "newly-calloc'd tables have to be considered empty");
        return alloc.template maybe_pod_calloc<Entry>(capacity);
    }

    static void destroyTable(AllocPolicy& alloc, Entry* oldTable, uint32_t capacity)
    {
        Entry* end = oldTable + capacity;
        for (Entry* e = oldTable; e < end; ++e)
            e->destroyIfLive();
        alloc.free_(oldTable);
    }

  public:
    explicit HashTable(AllocPolicy ap)
      : AllocPolicy(ap)
      , gen(0)
      , hashShift(sHashBits)
      , table(nullptr)
      , entryCount(0)
      , removedCount(0)

      , mutationCount(0)
      , mEntered(false)

    {}

    __attribute__ ((warn_unused_result)) bool init(uint32_t length)
    {
        do { } while (0);




        if ((__builtin_expect(!!(length > sMaxInit), 0))) {
            this->reportAllocOverflow();
            return false;
        }

        static_assert((sMaxInit * sAlphaDenominator) / sAlphaDenominator == sMaxInit,
                      "multiplication in numerator below could overflow");
        static_assert(sMaxInit * sAlphaDenominator <= (4294967295U) - sMaxAlphaNumerator,
                      "numerator calculation below could potentially overflow");




        uint32_t newCapacity =
            (length * sAlphaDenominator + sMaxAlphaNumerator - 1) / sMaxAlphaNumerator;
        if (newCapacity < sMinCapacity)
            newCapacity = sMinCapacity;


        uint32_t roundUp = sMinCapacity, roundUpLog2 = sMinCapacityLog2;
        while (roundUp < newCapacity) {
            roundUp <<= 1;
            ++roundUpLog2;
        }

        newCapacity = roundUp;
        do { } while (0);
        do { } while (0);

        table = createTable(*this, newCapacity);
        if (!table)
            return false;

        setTableSizeLog2(roundUpLog2);
        memset(&stats, 0, sizeof(stats));
        return true;
    }

    bool initialized() const
    {
        return !!table;
    }

    ~HashTable()
    {
        if (table)
            destroyTable(*this, table, capacity());
    }

  private:
    HashNumber hash1(HashNumber hash0) const
    {
        return hash0 >> hashShift;
    }

    struct DoubleHash
    {
        HashNumber h2;
        HashNumber sizeMask;
    };

    DoubleHash hash2(HashNumber curKeyHash) const
    {
        unsigned sizeLog2 = sHashBits - hashShift;
        DoubleHash dh = {
            ((curKeyHash << sizeLog2) >> hashShift) | 1,
            (HashNumber(1) << sizeLog2) - 1
        };
        return dh;
    }

    static HashNumber applyDoubleHash(HashNumber h1, const DoubleHash& dh)
    {
        return (h1 - dh.h2) & dh.sizeMask;
    }

    bool overloaded()
    {
        static_assert(sMaxCapacity <= (4294967295U) / sMaxAlphaNumerator,
                      "multiplication below could overflow");
        return entryCount + removedCount >=
               capacity() * sMaxAlphaNumerator / sAlphaDenominator;
    }


    static bool wouldBeUnderloaded(uint32_t capacity, uint32_t entryCount)
    {
        static_assert(sMaxCapacity <= (4294967295U) / sMinAlphaNumerator,
                      "multiplication below could overflow");
        return capacity > sMinCapacity &&
               entryCount <= capacity * sMinAlphaNumerator / sAlphaDenominator;
    }

    bool underloaded()
    {
        return wouldBeUnderloaded(capacity(), entryCount);
    }

    static __attribute__((always_inline)) inline bool match(Entry& e, const Lookup& l)
    {
        return HashPolicy::match(HashPolicy::getKey(e.get()), l);
    }






    __attribute__((always_inline)) inline Entry&
    lookup(const Lookup& l, HashNumber keyHash, unsigned collisionBit) const
    {
        do { } while (0);
        do { } while (0);
        do { } while (0);
        do { } while (0);
        stats.searches++;


        HashNumber h1 = hash1(keyHash);
        Entry* entry = &table[h1];


        if (entry->isFree()) {
            stats.misses++;
            return *entry;
        }


        if (entry->matchHash(keyHash) && match(*entry, l)) {
            stats.hits++;
            return *entry;
        }


        DoubleHash dh = hash2(keyHash);


        Entry* firstRemoved = nullptr;

        while (true) {
            if ((__builtin_expect(!!(entry->isRemoved()), 0))) {
                if (!firstRemoved)
                    firstRemoved = entry;
            } else {
                if (collisionBit == sCollisionBit)
                    entry->setCollision();
            }

            stats.steps++;
            h1 = applyDoubleHash(h1, dh);

            entry = &table[h1];
            if (entry->isFree()) {
                stats.misses++;
                return firstRemoved ? *firstRemoved : *entry;
            }

            if (entry->matchHash(keyHash) && match(*entry, l)) {
                stats.hits++;
                return *entry;
            }
        }
    }







    Entry& findFreeEntry(HashNumber keyHash)
    {
        do { } while (0);
        do { } while (0);
        stats.searches++;




        HashNumber h1 = hash1(keyHash);
        Entry* entry = &table[h1];


        if (!entry->isLive()) {
            stats.misses++;
            return *entry;
        }


        DoubleHash dh = hash2(keyHash);

        while (true) {
            do { } while (0);
            entry->setCollision();

            stats.steps++;
            h1 = applyDoubleHash(h1, dh);

            entry = &table[h1];
            if (!entry->isLive()) {
                stats.misses++;
                return *entry;
            }
        }
    }

    enum RebuildStatus { NotOverloaded, Rehashed, RehashFailed };

    RebuildStatus changeTableSize(int deltaLog2, FailureBehavior reportFailure = ReportFailure)
    {

        Entry* oldTable = table;
        uint32_t oldCap = capacity();
        uint32_t newLog2 = sHashBits - hashShift + deltaLog2;
        uint32_t newCapacity = ((uint32_t)1 << (newLog2));
        if ((__builtin_expect(!!(newCapacity > sMaxCapacity), 0))) {
            if (reportFailure)
                this->reportAllocOverflow();
            return RehashFailed;
        }

        Entry* newTable = createTable(*this, newCapacity, reportFailure);
        if (!newTable)
            return RehashFailed;


        setTableSizeLog2(newLog2);
        removedCount = 0;
        gen++;
        table = newTable;


        Entry* end = oldTable + oldCap;
        for (Entry* src = oldTable; src < end; ++src) {
            if (src->isLive()) {
                HashNumber hn = src->getKeyHash();
                findFreeEntry(hn).setLive(
                    hn, mozilla::Move(const_cast<typename Entry::NonConstT&>(src->get())));
                src->destroy();
            }
        }


        this->free_(oldTable);
        return Rehashed;
    }

    bool shouldCompressTable()
    {

        return removedCount >= (capacity() >> 2);
    }

    RebuildStatus checkOverloaded(FailureBehavior reportFailure = ReportFailure)
    {
        if (!overloaded())
            return NotOverloaded;

        int deltaLog2;
        if (shouldCompressTable()) {
            stats.compresses++;
            deltaLog2 = 0;
        } else {
            stats.grows++;
            deltaLog2 = 1;
        }

        return changeTableSize(deltaLog2, reportFailure);
    }


    void checkOverRemoved()
    {
        if (overloaded()) {
            if (checkOverloaded(DontReportFailure) == RehashFailed)
                rehashTableInPlace();
        }
    }

    void remove(Entry& e)
    {
        do { } while (0);
        stats.removes++;

        if (e.hasCollision()) {
            e.removeLive();
            removedCount++;
        } else {
            stats.removeFrees++;
            e.clearLive();
        }
        entryCount--;

        mutationCount++;

    }

    void checkUnderloaded()
    {
        if (underloaded()) {
            stats.shrinks++;
            (void) changeTableSize(-1, DontReportFailure);
        }
    }




    void compactIfUnderloaded()
    {
        int32_t resizeLog2 = 0;
        uint32_t newCapacity = capacity();
        while (wouldBeUnderloaded(newCapacity, entryCount)) {
            newCapacity = newCapacity >> 1;
            resizeLog2--;
        }

        if (resizeLog2 != 0)
            (void) changeTableSize(resizeLog2, DontReportFailure);
    }






    void rehashTableInPlace()
    {
        stats.rehashes++;
        removedCount = 0;
        for (size_t i = 0; i < capacity(); ++i)
            table[i].unsetCollision();

        for (size_t i = 0; i < capacity();) {
            Entry* src = &table[i];

            if (!src->isLive() || src->hasCollision()) {
                ++i;
                continue;
            }

            HashNumber keyHash = src->getKeyHash();
            HashNumber h1 = hash1(keyHash);
            DoubleHash dh = hash2(keyHash);
            Entry* tgt = &table[h1];
            while (true) {
                if (!tgt->hasCollision()) {
                    src->swap(tgt);
                    tgt->setCollision();
                    break;
                }

                h1 = applyDoubleHash(h1, dh);
                tgt = &table[h1];
            }
        }






    }






    template <typename... Args>
    void putNewInfallibleInternal(const Lookup& l, Args&&... args)
    {
        do { } while (0);

        HashNumber keyHash = prepareHash(l);
        Entry* entry = &findFreeEntry(keyHash);
        do { } while (0);

        if (entry->isRemoved()) {
            stats.addOverRemoved++;
            removedCount--;
            keyHash |= sCollisionBit;
        }

        entry->setLive(keyHash, mozilla::Forward<Args>(args)...);
        entryCount++;

        mutationCount++;

    }

  public:
    void clear()
    {
        if (mozilla::IsPod<Entry>::value) {
            memset(table, 0, sizeof(*table) * capacity());
        } else {
            uint32_t tableCapacity = capacity();
            Entry* end = table + tableCapacity;
            for (Entry* e = table; e < end; ++e)
                e->clear();
        }
        removedCount = 0;
        entryCount = 0;

        mutationCount++;

    }

    void clearAndShrink()
    {
        clear();
        compactIfUnderloaded();
    }

    void finish()
    {

        do { } while (0);

        if (!table)
            return;

        destroyTable(*this, table, capacity());
        table = nullptr;
        gen++;
        entryCount = 0;
        removedCount = 0;

        mutationCount++;

    }

    Range all() const
    {
        do { } while (0);
        return Range(*this, table, table + capacity());
    }

    bool empty() const
    {
        do { } while (0);
        return !entryCount;
    }

    uint32_t count() const
    {
        do { } while (0);
        return entryCount;
    }

    uint32_t capacity() const
    {
        do { } while (0);
        return ((uint32_t)1 << (sHashBits - hashShift));
    }

    Generation generation() const
    {
        do { } while (0);
        return Generation(gen);
    }

    size_t sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const
    {
        return mallocSizeOf(table);
    }

    size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const
    {
        return mallocSizeOf(this) + sizeOfExcludingThis(mallocSizeOf);
    }

    __attribute__((always_inline)) inline Ptr lookup(const Lookup& l) const
    {
        mozilla::ReentrancyGuard g(*this);
        if (!HasHash<HashPolicy>(l))
            return Ptr();
        HashNumber keyHash = prepareHash(l);
        return Ptr(lookup(l, keyHash, 0), *this);
    }

    __attribute__((always_inline)) inline Ptr readonlyThreadsafeLookup(const Lookup& l) const
    {
        if (!HasHash<HashPolicy>(l))
            return Ptr();
        HashNumber keyHash = prepareHash(l);
        return Ptr(lookup(l, keyHash, 0), *this);
    }

    __attribute__((always_inline)) inline AddPtr lookupForAdd(const Lookup& l) const
    {
        mozilla::ReentrancyGuard g(*this);
        if (!EnsureHash<HashPolicy>(l))
            return AddPtr();
        HashNumber keyHash = prepareHash(l);
        Entry& entry = lookup(l, keyHash, sCollisionBit);
        AddPtr p(entry, *this, keyHash);
        return p;
    }

    template <typename... Args>
    __attribute__ ((warn_unused_result)) bool add(AddPtr& p, Args&&... args)
    {
        mozilla::ReentrancyGuard g(*this);
        do { } while (0);
        do { } while (0);
        do { } while (0);


        if (p.isValid())
            return false;



        if (p.entry_->isRemoved()) {
            if (!this->checkSimulatedOOM())
                return false;
            stats.addOverRemoved++;
            removedCount--;
            p.keyHash |= sCollisionBit;
        } else {

            RebuildStatus status = checkOverloaded();
            if (status == RehashFailed)
                return false;
            if (status == NotOverloaded && !this->checkSimulatedOOM())
                return false;
            if (status == Rehashed)
                p.entry_ = &findFreeEntry(p.keyHash);
        }

        p.entry_->setLive(p.keyHash, mozilla::Forward<Args>(args)...);
        entryCount++;

        mutationCount++;
        p.generation = generation();
        p.mutationCount = mutationCount;

        return true;
    }



    template <typename... Args>
    void putNewInfallible(const Lookup& l, Args&&... args)
    {
        do { } while (0);
        mozilla::ReentrancyGuard g(*this);
        putNewInfallibleInternal(l, mozilla::Forward<Args>(args)...);
    }



    template <typename... Args>
    __attribute__ ((warn_unused_result)) bool putNew(const Lookup& l, Args&&... args)
    {
        if (!this->checkSimulatedOOM())
            return false;

        if (!EnsureHash<HashPolicy>(l))
            return false;

        if (checkOverloaded() == RehashFailed)
            return false;

        putNewInfallible(l, mozilla::Forward<Args>(args)...);
        return true;
    }



    template <typename... Args>
    __attribute__ ((warn_unused_result)) bool relookupOrAdd(AddPtr& p, const Lookup& l, Args&&... args)
    {

        if (p.isValid())
            return false;


        p.generation = generation();
        p.mutationCount = mutationCount;

        {
            mozilla::ReentrancyGuard g(*this);
            do { } while (0);
            p.entry_ = &lookup(l, p.keyHash, sCollisionBit);
        }
        return p.found() || add(p, mozilla::Forward<Args>(args)...);
    }

    void remove(Ptr p)
    {
        do { } while (0);
        mozilla::ReentrancyGuard g(*this);
        do { } while (0);
        remove(*p.entry_);
        checkUnderloaded();
    }

    void rekeyWithoutRehash(Ptr p, const Lookup& l, const Key& k)
    {
        do { } while (0);
        mozilla::ReentrancyGuard g(*this);
        do { } while (0);
        typename HashTableEntry<T>::NonConstT t(mozilla::Move(*p));
        HashPolicy::setKey(t, const_cast<Key&>(k));
        remove(*p.entry_);
        putNewInfallibleInternal(l, mozilla::Move(t));
    }

    void rekeyAndMaybeRehash(Ptr p, const Lookup& l, const Key& k)
    {
        rekeyWithoutRehash(p, l, k);
        checkOverRemoved();
    }


};

}
}



class JSTracer;

namespace JS {
class CallbackTracer;
template <typename T> class Heap;
template <typename T> class TenuredHeap;


const char*
GCTraceKindToAscii(JS::TraceKind kind);

}

enum WeakMapTraceKind {




    DoNotTraceWeakMaps,





    ExpandWeakMaps,





    TraceWeakMapValues,





    TraceWeakMapKeysValues
};

class JSTracer
{
  public:

    JSRuntime* runtime() const { return runtime_; }


    WeakMapTraceKind weakMapAction() const { return weakMapAction_; }

    enum class TracerKindTag {



        Marking,





        WeakMarking,



        Tenuring,



        Callback
    };
    bool isMarkingTracer() const { return tag_ == TracerKindTag::Marking || tag_ == TracerKindTag::WeakMarking; }
    bool isWeakMarkingTracer() const { return tag_ == TracerKindTag::WeakMarking; }
    bool isTenuringTracer() const { return tag_ == TracerKindTag::Tenuring; }
    bool isCallbackTracer() const { return tag_ == TracerKindTag::Callback; }
    inline JS::CallbackTracer* asCallbackTracer();
    bool traceWeakEdges() const { return traceWeakEdges_; }




  protected:
    JSTracer(JSRuntime* rt, TracerKindTag tag,
             WeakMapTraceKind weakTraceKind = TraceWeakMapValues)
      : runtime_(rt)
      , weakMapAction_(weakTraceKind)



      , tag_(tag)
      , traceWeakEdges_(true)
    {}
  private:
    JSRuntime* runtime_;
    WeakMapTraceKind weakMapAction_;




  protected:
    TracerKindTag tag_;
    bool traceWeakEdges_;
};

namespace JS {

class AutoTracingName;
class AutoTracingIndex;
class AutoTracingCallback;

class CallbackTracer : public JSTracer
{
  public:
    CallbackTracer(JSRuntime* rt, WeakMapTraceKind weakTraceKind = TraceWeakMapValues)
      : JSTracer(rt, JSTracer::TracerKindTag::Callback, weakTraceKind),
        contextName_(nullptr), contextIndex_(InvalidIndex), contextFunctor_(nullptr)
    {}
    CallbackTracer(JSContext* cx, WeakMapTraceKind weakTraceKind = TraceWeakMapValues);






    virtual void onObjectEdge(JSObject** objp) { onChild(JS::GCCellPtr(*objp)); }
    virtual void onStringEdge(JSString** strp) { onChild(JS::GCCellPtr(*strp)); }
    virtual void onSymbolEdge(JS::Symbol** symp) { onChild(JS::GCCellPtr(*symp)); }
    virtual void onScriptEdge(JSScript** scriptp) { onChild(JS::GCCellPtr(*scriptp)); }
    virtual void onShapeEdge(js::Shape** shapep) {
        onChild(JS::GCCellPtr(*shapep, JS::TraceKind::Shape));
    }
    virtual void onObjectGroupEdge(js::ObjectGroup** groupp) {
        onChild(JS::GCCellPtr(*groupp, JS::TraceKind::ObjectGroup));
    }
    virtual void onBaseShapeEdge(js::BaseShape** basep) {
        onChild(JS::GCCellPtr(*basep, JS::TraceKind::BaseShape));
    }
    virtual void onJitCodeEdge(js::jit::JitCode** codep) {
        onChild(JS::GCCellPtr(*codep, JS::TraceKind::JitCode));
    }
    virtual void onLazyScriptEdge(js::LazyScript** lazyp) {
        onChild(JS::GCCellPtr(*lazyp, JS::TraceKind::LazyScript));
    }
    virtual void onScopeEdge(js::Scope** scopep) {
        onChild(JS::GCCellPtr(*scopep, JS::TraceKind::Scope));
    }
    virtual void onRegExpSharedEdge(js::RegExpShared** sharedp) {
        onChild(JS::GCCellPtr(*sharedp, JS::TraceKind::RegExpShared));
    }



    virtual void onChild(const JS::GCCellPtr& thing) = 0;
    const char* contextName() const { do { } while (0); return contextName_; }




    const static size_t InvalidIndex = size_t(-1);
    size_t contextIndex() const { return contextIndex_; }






    void getTracingEdgeName(char* buffer, size_t bufferSize);






    class ContextFunctor {
      public:
        virtual void operator()(CallbackTracer* trc, char* buf, size_t bufsize) = 0;
    };
    void dispatchToOnEdge(JSObject** objp) { onObjectEdge(objp); }
    void dispatchToOnEdge(JSString** strp) { onStringEdge(strp); }
    void dispatchToOnEdge(JS::Symbol** symp) { onSymbolEdge(symp); }
    void dispatchToOnEdge(JSScript** scriptp) { onScriptEdge(scriptp); }
    void dispatchToOnEdge(js::Shape** shapep) { onShapeEdge(shapep); }
    void dispatchToOnEdge(js::ObjectGroup** groupp) { onObjectGroupEdge(groupp); }
    void dispatchToOnEdge(js::BaseShape** basep) { onBaseShapeEdge(basep); }
    void dispatchToOnEdge(js::jit::JitCode** codep) { onJitCodeEdge(codep); }
    void dispatchToOnEdge(js::LazyScript** lazyp) { onLazyScriptEdge(lazyp); }
    void dispatchToOnEdge(js::Scope** scopep) { onScopeEdge(scopep); }
    void dispatchToOnEdge(js::RegExpShared** sharedp) { onRegExpSharedEdge(sharedp); }

  protected:
    void setTraceWeakEdges(bool value) {
        traceWeakEdges_ = value;
    }

  private:
    friend class AutoTracingName;
    const char* contextName_;

    friend class AutoTracingIndex;
    size_t contextIndex_;

    friend class AutoTracingDetails;
    ContextFunctor* contextFunctor_;
};


class AutoTracingName
{
    CallbackTracer* trc_;
    const char* prior_;

  public:
    AutoTracingName(CallbackTracer* trc, const char* name) : trc_(trc), prior_(trc->contextName_) {
        do { } while (0);
        trc->contextName_ = name;
    }
    ~AutoTracingName() {
        do { } while (0);
        trc_->contextName_ = prior_;
    }
};


class AutoTracingIndex
{
    CallbackTracer* trc_;

  public:
    explicit AutoTracingIndex(JSTracer* trc, size_t initial = 0) : trc_(nullptr) {
        if (trc->isCallbackTracer()) {
            trc_ = trc->asCallbackTracer();
            do { } while (0);
            trc_->contextIndex_ = initial;
        }
    }
    ~AutoTracingIndex() {
        if (trc_) {
            do { } while (0);
            trc_->contextIndex_ = CallbackTracer::InvalidIndex;
        }
    }

    void operator++() {
        if (trc_) {
            do { } while (0);
            ++trc_->contextIndex_;
        }
    }
};



class AutoTracingDetails
{
    CallbackTracer* trc_;

  public:
    AutoTracingDetails(JSTracer* trc, CallbackTracer::ContextFunctor& func) : trc_(nullptr) {
        if (trc->isCallbackTracer()) {
            trc_ = trc->asCallbackTracer();
            do { } while (0);
            trc_->contextFunctor_ = &func;
        }
    }
    ~AutoTracingDetails() {
        if (trc_) {
            do { } while (0);
            trc_->contextFunctor_ = nullptr;
        }
    }
};

}

JS::CallbackTracer*
JSTracer::asCallbackTracer()
{
    do { } while (0);
    return static_cast<JS::CallbackTracer*>(this);
}

namespace JS {
template <typename T>
extern void
TraceEdge(JSTracer* trc, JS::Heap<T>* edgep, const char* name);

extern void
TraceEdge(JSTracer* trc, JS::TenuredHeap<JSObject*>* edgep, const char* name);







template <typename T>
extern void
UnsafeTraceRoot(JSTracer* trc, T* edgep, const char* name);

extern void
TraceChildren(JSTracer* trc, GCCellPtr thing);

using ZoneSet = js::HashSet<Zone*, js::DefaultHasher<Zone*>, js::SystemAllocPolicy>;
using CompartmentSet = js::HashSet<JSCompartment*, js::DefaultHasher<JSCompartment*>,
                                   js::SystemAllocPolicy>;






extern void
TraceIncomingCCWs(JSTracer* trc, const JS::CompartmentSet& compartments);

}

extern void
JS_GetTraceThingInfo(char* buf, size_t bufsize, JSTracer* trc,
                     void* thing, JS::TraceKind kind, bool includeDetails);

namespace js {






template <typename T>
extern void
UnsafeTraceManuallyBarrieredEdge(JSTracer* trc, T* edgep, const char* name);

namespace gc {


template <typename T>
extern bool
EdgeNeedsSweep(JS::Heap<T>* edgep);



template <typename T>
bool
IsAboutToBeFinalizedUnbarriered(T* thingp);

}
}
class JSAtom;
class JSFunction;
class JSObject;
class JSScript;
class JSString;
namespace JS {
class Symbol;
}

namespace JS {



template <typename T>
struct StructGCPolicy
{
    static T initial() {
        return T();
    }

    static void trace(JSTracer* trc, T* tp, const char* name) {
        tp->trace(trc);
    }

    static void sweep(T* tp) {
        return tp->sweep();
    }

    static bool needsSweep(T* tp) {
        return tp->needsSweep();
    }
};





template <typename T> struct GCPolicy : public StructGCPolicy<T> {};


template <typename T>
struct IgnoreGCPolicy {
    static T initial() { return T(); }
    static void trace(JSTracer* trc, T* t, const char* name) {}
    static bool needsSweep(T* v) { return false; }
};
template <> struct GCPolicy<uint32_t> : public IgnoreGCPolicy<uint32_t> {};
template <> struct GCPolicy<uint64_t> : public IgnoreGCPolicy<uint64_t> {};

template <typename T>
struct GCPointerPolicy
{
    static T initial() { return nullptr; }
    static void trace(JSTracer* trc, T* vp, const char* name) {
        if (*vp)
            js::UnsafeTraceManuallyBarrieredEdge(trc, vp, name);
    }
    static bool needsSweep(T* vp) {
        if (*vp)
            return js::gc::IsAboutToBeFinalizedUnbarriered(vp);
        return false;
    }
};
template <> struct GCPolicy<JS::Symbol*> : public GCPointerPolicy<JS::Symbol*> {};
template <> struct GCPolicy<JSAtom*> : public GCPointerPolicy<JSAtom*> {};
template <> struct GCPolicy<JSFunction*> : public GCPointerPolicy<JSFunction*> {};
template <> struct GCPolicy<JSObject*> : public GCPointerPolicy<JSObject*> {};
template <> struct GCPolicy<JSScript*> : public GCPointerPolicy<JSScript*> {};
template <> struct GCPolicy<JSString*> : public GCPointerPolicy<JSString*> {};

template <typename T>
struct GCPolicy<JS::Heap<T>>
{
    static void trace(JSTracer* trc, JS::Heap<T>* thingp, const char* name) {
        TraceEdge(trc, thingp, name);
    }
    static bool needsSweep(JS::Heap<T>* thingp) {
        return js::gc::EdgeNeedsSweep(thingp);
    }
};


template <typename T, typename D>
struct GCPolicy<mozilla::UniquePtr<T, D>>
{
    static mozilla::UniquePtr<T,D> initial() { return mozilla::UniquePtr<T,D>(); }
    static void trace(JSTracer* trc, mozilla::UniquePtr<T,D>* tp, const char* name) {
        if (tp->get())
            GCPolicy<T>::trace(trc, tp->get(), name);
    }
    static bool needsSweep(mozilla::UniquePtr<T,D>* tp) {
        if (tp->get())
            return GCPolicy<T>::needsSweep(tp->get());
        return false;
    }
};

}
namespace js {

template <typename T>
struct BarrierMethods {
};

template <typename Element, typename Wrapper>
class WrappedPtrOperations {};

template <typename Element, typename Wrapper>
class MutableWrappedPtrOperations : public WrappedPtrOperations<Element, Wrapper> {};

template <typename T, typename Wrapper>
class RootedBase : public MutableWrappedPtrOperations<T, Wrapper> {};

template <typename T, typename Wrapper>
class HandleBase : public WrappedPtrOperations<T, Wrapper> {};

template <typename T, typename Wrapper>
class MutableHandleBase : public MutableWrappedPtrOperations<T, Wrapper> {};

template <typename T, typename Wrapper>
class HeapBase : public MutableWrappedPtrOperations<T, Wrapper> {};


template <typename T> struct IsHeapConstructibleType { static constexpr bool value = false; };


template <> struct IsHeapConstructibleType<JS::Symbol*> { static constexpr bool value = true; }; template <> struct IsHeapConstructibleType<JSAtom*> { static constexpr bool value = true; }; template <> struct IsHeapConstructibleType<JSFunction*> { static constexpr bool value = true; }; template <> struct IsHeapConstructibleType<JSObject*> { static constexpr bool value = true; }; template <> struct IsHeapConstructibleType<JSScript*> { static constexpr bool value = true; }; template <> struct IsHeapConstructibleType<JSString*> { static constexpr bool value = true; };
template <> struct IsHeapConstructibleType<JS::Value> { static constexpr bool value = true; }; template <> struct IsHeapConstructibleType<jsid> { static constexpr bool value = true; };


template <typename T, typename Wrapper>
class PersistentRootedBase : public MutableWrappedPtrOperations<T, Wrapper> {};

namespace gc {
struct Cell;
template<typename T>
struct PersistentRootedMarker;
}
}

namespace JS {

template <typename T> class Rooted;
template <typename T> class PersistentRooted;


bool isGCEnabled();

void HeapObjectPostBarrier(JSObject** objp, JSObject* prev, JSObject* next);






extern void
AssertGCThingMustBeTenured(JSObject* obj);
extern void
AssertGCThingIsNotAnObjectSubclass(js::gc::Cell* cell);
template <typename T>
class Heap : public js::HeapBase<T, Heap<T>>
{

    static_assert(js::IsHeapConstructibleType<T>::value,
                  "Type T must be a public GC pointer type");
  public:
    using ElementType = T;

    Heap() {
        static_assert(sizeof(T) == sizeof(Heap<T>),
                      "Heap<T> must be binary compatible with T.");
        init(GCPolicy<T>::initial());
    }
    explicit Heap(const T& p) { init(p); }







    explicit Heap(const Heap<T>& p) { init(p.ptr); }

    ~Heap() {
        post(ptr, GCPolicy<T>::initial());
    }

    operator const T&() const { return get(); } const T& operator->() const { return get(); };
    Heap<T>& operator=(const T& p) { set(p); return *this; } Heap<T>& operator=(const Heap<T>& other) { set(other.get()); return *this; };

    const T* address() const { return &ptr; }

    void exposeToActiveJS() const {
        js::BarrierMethods<T>::exposeToJS(ptr);
    }
    const T& get() const {
        exposeToActiveJS();
        return ptr;
    }
    const T& unbarrieredGet() const {
        return ptr;
    }

    T* unsafeGet() { return &ptr; }

    explicit operator bool() const {
        return bool(js::BarrierMethods<T>::asGCThingOrNull(ptr));
    }
    explicit operator bool() {
        return bool(js::BarrierMethods<T>::asGCThingOrNull(ptr));
    }

  private:
    void init(const T& newPtr) {
        ptr = newPtr;
        post(GCPolicy<T>::initial(), ptr);
    }

    void set(const T& newPtr) {
        T tmp = ptr;
        ptr = newPtr;
        post(tmp, ptr);
    }

    void post(const T& prev, const T& next) {
        js::BarrierMethods<T>::postBarrier(&ptr, prev, next);
    }

    T ptr;
};

static __attribute__((always_inline)) inline bool
ObjectIsTenured(JSObject* obj)
{
    return !js::gc::IsInsideNursery(reinterpret_cast<js::gc::Cell*>(obj));
}

static __attribute__((always_inline)) inline bool
ObjectIsTenured(const Heap<JSObject*>& obj)
{
    return ObjectIsTenured(obj.unbarrieredGet());
}

static __attribute__((always_inline)) inline bool
ObjectIsMarkedGray(JSObject* obj)
{
    auto cell = reinterpret_cast<js::gc::Cell*>(obj);
    return js::gc::detail::CellIsMarkedGrayIfKnown(cell);
}

static __attribute__((always_inline)) inline bool
ObjectIsMarkedGray(const JS::Heap<JSObject*>& obj)
{
    return ObjectIsMarkedGray(obj.unbarrieredGet());
}
template <typename T>
class TenuredHeap : public js::HeapBase<T, TenuredHeap<T>>
{
  public:
    using ElementType = T;

    TenuredHeap() : bits(0) {
        static_assert(sizeof(T) == sizeof(TenuredHeap<T>),
                      "TenuredHeap<T> must be binary compatible with T.");
    }
    explicit TenuredHeap(T p) : bits(0) { setPtr(p); }
    explicit TenuredHeap(const TenuredHeap<T>& p) : bits(0) { setPtr(p.getPtr()); }

    void setPtr(T newPtr) {
        do { } while (0);
        if (newPtr)
            AssertGCThingMustBeTenured(newPtr);
        bits = (bits & flagsMask) | reinterpret_cast<uintptr_t>(newPtr);
    }

    void setFlags(uintptr_t flagsToSet) {
        do { } while (0);
        bits |= flagsToSet;
    }

    void unsetFlags(uintptr_t flagsToUnset) {
        do { } while (0);
        bits &= ~flagsToUnset;
    }

    bool hasFlag(uintptr_t flag) const {
        do { } while (0);
        return (bits & flag) != 0;
    }

    T unbarrieredGetPtr() const { return reinterpret_cast<T>(bits & ~flagsMask); }
    uintptr_t getFlags() const { return bits & flagsMask; }

    void exposeToActiveJS() const {
        js::BarrierMethods<T>::exposeToJS(unbarrieredGetPtr());
    }
    T getPtr() const {
        exposeToActiveJS();
        return unbarrieredGetPtr();
    }

    operator T() const { return getPtr(); }
    T operator->() const { return getPtr(); }

    explicit operator bool() const {
        return bool(js::BarrierMethods<T>::asGCThingOrNull(unbarrieredGetPtr()));
    }
    explicit operator bool() {
        return bool(js::BarrierMethods<T>::asGCThingOrNull(unbarrieredGetPtr()));
    }

    TenuredHeap<T>& operator=(T p) {
        setPtr(p);
        return *this;
    }

    TenuredHeap<T>& operator=(const TenuredHeap<T>& other) {
        bits = other.bits;
        return *this;
    }

  private:
    enum {
        maskBits = 3,
        flagsMask = (1 << maskBits) - 1,
    };

    uintptr_t bits;
};
template <typename T>
class Handle : public js::HandleBase<T, Handle<T>>
{
    friend class JS::MutableHandle<T>;

  public:
    using ElementType = T;


    template <typename S>
                 Handle(Handle<S> handle,
                        typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy = 0)
    {
        static_assert(sizeof(Handle<T>) == sizeof(T*),
                      "Handle must be binary compatible with T*.");
        ptr = reinterpret_cast<const T*>(handle.address());
    }

                 Handle(decltype(nullptr)) {
        static_assert(mozilla::IsPointer<T>::value,
                      "nullptr_t overload not valid for non-pointer types");
        static void* const ConstNullValue = nullptr;
        ptr = reinterpret_cast<const T*>(&ConstNullValue);
    }

                 Handle(MutableHandle<T> handle) {
        ptr = handle.address();
    }
    static constexpr Handle fromMarkedLocation(const T* p) {
        return Handle(p, DeliberatelyChoosingThisOverload,
                      ImUsingThisOnlyInFromFromMarkedLocation);
    }





    template <typename S>
    inline
                 Handle(const Rooted<S>& root,
                        typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy = 0);

    template <typename S>
    inline
                 Handle(const PersistentRooted<S>& root,
                        typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy = 0);


    template <typename S>
    inline
                 Handle(MutableHandle<S>& root,
                        typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy = 0);

    operator const T&() const { return get(); } const T& operator->() const { return get(); };
    const T* address() const { return &(*ptr); } const T& get() const { return (*ptr); };

  private:
    Handle() {}
    template <typename S> Handle<T>& operator=(S) = delete; Handle<T>& operator=(const Handle<T>&) = delete;;

    enum Disambiguator { DeliberatelyChoosingThisOverload = 42 };
    enum CallerIdentity { ImUsingThisOnlyInFromFromMarkedLocation = 17 };
    constexpr Handle(const T* p, Disambiguator, CallerIdentity) : ptr(p) {}

    const T* ptr;
};
template <typename T>
class MutableHandle : public js::MutableHandleBase<T, MutableHandle<T>>
{
  public:
    using ElementType = T;

    inline MutableHandle(Rooted<T>* root);
    inline MutableHandle(PersistentRooted<T>* root);

  private:

    MutableHandle(decltype(nullptr)) = delete;

  public:
    void set(const T& v) {
        *ptr = v;
    }
    static MutableHandle fromMarkedLocation(T* p) {
        MutableHandle h;
        h.ptr = p;
        return h;
    }

    operator const T&() const { return get(); } const T& operator->() const { return get(); };
    const T* address() const { return &(*ptr); } const T& get() const { return (*ptr); };
    T* address() { return &(*ptr); } T& get() { return (*ptr); };

  private:
    MutableHandle() {}
    template <typename S> MutableHandle<T>& operator=(S) = delete; MutableHandle<T>& operator=(const MutableHandle<T>&) = delete;;

    T* ptr;
};

}

namespace js {

template <typename T>
struct BarrierMethods<T*>
{
    static T* initial() { return nullptr; }
    static gc::Cell* asGCThingOrNull(T* v) {
        if (!v)
            return nullptr;
        do { } while (0);
        return reinterpret_cast<gc::Cell*>(v);
    }
    static void postBarrier(T** vp, T* prev, T* next) {
        if (next)
            JS::AssertGCThingIsNotAnObjectSubclass(reinterpret_cast<js::gc::Cell*>(next));
    }
    static void exposeToJS(T* t) {
        if (t)
            js::gc::ExposeGCThingToActiveJS(JS::GCCellPtr(t));
    }
};

template <>
struct BarrierMethods<JSObject*>
{
    static JSObject* initial() { return nullptr; }
    static gc::Cell* asGCThingOrNull(JSObject* v) {
        if (!v)
            return nullptr;
        do { } while (0);
        return reinterpret_cast<gc::Cell*>(v);
    }
    static void postBarrier(JSObject** vp, JSObject* prev, JSObject* next) {
        JS::HeapObjectPostBarrier(vp, prev, next);
    }
    static void exposeToJS(JSObject* obj) {
        if (obj)
            JS::ExposeObjectToActiveJS(obj);
    }
};

template <>
struct BarrierMethods<JSFunction*>
{
    static JSFunction* initial() { return nullptr; }
    static gc::Cell* asGCThingOrNull(JSFunction* v) {
        if (!v)
            return nullptr;
        do { } while (0);
        return reinterpret_cast<gc::Cell*>(v);
    }
    static void postBarrier(JSFunction** vp, JSFunction* prev, JSFunction* next) {
        JS::HeapObjectPostBarrier(reinterpret_cast<JSObject**>(vp),
                                  reinterpret_cast<JSObject*>(prev),
                                  reinterpret_cast<JSObject*>(next));
    }
    static void exposeToJS(JSFunction* fun) {
        if (fun)
            JS::ExposeObjectToActiveJS(reinterpret_cast<JSObject*>(fun));
    }
};
template <typename T>
struct MovableCellHasher
{
    using Key = T;
    using Lookup = T;

    static bool hasHash(const Lookup& l);
    static bool ensureHash(const Lookup& l);
    static HashNumber hash(const Lookup& l);
    static bool match(const Key& k, const Lookup& l);
    static void rekey(Key& k, const Key& newKey) { k = newKey; }
};

template <typename T>
struct MovableCellHasher<JS::Heap<T>>
{
    using Key = JS::Heap<T>;
    using Lookup = T;

    static bool hasHash(const Lookup& l) { return MovableCellHasher<T>::hasHash(l); }
    static bool ensureHash(const Lookup& l) { return MovableCellHasher<T>::ensureHash(l); }
    static HashNumber hash(const Lookup& l) { return MovableCellHasher<T>::hash(l); }
    static bool match(const Key& k, const Lookup& l) {
        return MovableCellHasher<T>::match(k.unbarrieredGet(), l);
    }
    static void rekey(Key& k, const Key& newKey) { k.unsafeSet(newKey); }
};

template <typename T>
struct FallibleHashMethods<MovableCellHasher<T>>
{
    template <typename Lookup> static bool hasHash(Lookup&& l) {
        return MovableCellHasher<T>::hasHash(mozilla::Forward<Lookup>(l));
    }
    template <typename Lookup> static bool ensureHash(Lookup&& l) {
        return MovableCellHasher<T>::ensureHash(mozilla::Forward<Lookup>(l));
    }
};

}

namespace js {
template <typename T>
class alignas(8) DispatchWrapper
{
    static_assert(JS::MapTypeToRootKind<T>::kind == JS::RootKind::Traceable,
                  "DispatchWrapper is intended only for usage with a Traceable");

    using TraceFn = void (*)(JSTracer*, T*, const char*);
    TraceFn tracer;
    alignas(gc::CellSize) T storage;

  public:
    template <typename U>
                 DispatchWrapper(U&& initial)
      : tracer(&JS::GCPolicy<T>::trace),
        storage(mozilla::Forward<U>(initial))
    { }


    T* operator &() { return &storage; }
    const T* operator &() const { return &storage; }
    operator T&() { return storage; }
    operator const T&() const { return storage; }



    static void TraceWrapped(JSTracer* trc, T* thingp, const char* name) {
        auto wrapper = reinterpret_cast<DispatchWrapper*>(
                           uintptr_t(thingp) - __builtin_offsetof(DispatchWrapper, storage));
        wrapper->tracer(trc, &wrapper->storage, name);
    }
};

}

namespace JS {
template <typename T>
class Rooted : public js::RootedBase<T, Rooted<T>>
{
    inline void registerWithRootLists(RootedListHeads& roots) {
        this->stack = &roots[JS::MapTypeToRootKind<T>::kind];
        this->prev = *stack;
        *stack = reinterpret_cast<Rooted<void*>*>(this);
    }

    inline RootedListHeads& rootLists(RootingContext* cx) {
        return cx->stackRoots_;
    }
    inline RootedListHeads& rootLists(JSContext* cx) {
        return rootLists(RootingContext::get(cx));
    }

  public:
    using ElementType = T;

    template <typename RootingContext>
    explicit Rooted(const RootingContext& cx)
      : ptr(GCPolicy<T>::initial())
    {
        registerWithRootLists(rootLists(cx));
    }

    template <typename RootingContext, typename S>
    Rooted(const RootingContext& cx, S&& initial)
      : ptr(mozilla::Forward<S>(initial))
    {
        registerWithRootLists(rootLists(cx));
    }

    ~Rooted() {
        do { } while (0);
        *stack = prev;
    }

    Rooted<T>* previous() { return reinterpret_cast<Rooted<T>*>(prev); }





    void set(const T& value) {
        ptr = value;
    }

    operator const T&() const { return get(); } const T& operator->() const { return get(); };
    Rooted<T>& operator=(const T& p) { set(p); return *this; } Rooted<T>& operator=(const Rooted<T>& other) { set(other.get()); return *this; };
    const T* address() const { return &(ptr); } const T& get() const { return (ptr); };
    T* address() { return &(ptr); } T& get() { return (ptr); };

  private:





    Rooted<void*>** stack;
    Rooted<void*>* prev;
    using MaybeWrapped = typename mozilla::Conditional<
        MapTypeToRootKind<T>::kind == JS::RootKind::Traceable,
        js::DispatchWrapper<T>,
        T>::Type;
    MaybeWrapped ptr;

    Rooted(const Rooted&) = delete;
} ;

}

namespace js {
template <typename Container>
class RootedBase<JSObject*, Container> : public MutableWrappedPtrOperations<JSObject*, Container>
{
  public:
    template <class U>
    JS::Handle<U*> as() const;
};
template <typename Container>
class HandleBase<JSObject*, Container> : public WrappedPtrOperations<JSObject*, Container>
{
  public:
    template <class U>
    JS::Handle<U*> as() const;
};


template <typename T>
class FakeRooted : public RootedBase<T, FakeRooted<T>>
{
  public:
    using ElementType = T;

    template <typename CX>
    explicit FakeRooted(CX* cx) : ptr(JS::GCPolicy<T>::initial()) {}

    template <typename CX>
    FakeRooted(CX* cx, T initial) : ptr(initial) {}

    operator const T&() const { return get(); } const T& operator->() const { return get(); };
    FakeRooted<T>& operator=(const T& p) { set(p); return *this; } FakeRooted<T>& operator=(const FakeRooted<T>& other) { set(other.get()); return *this; };
    const T* address() const { return &(ptr); } const T& get() const { return (ptr); };
    T* address() { return &(ptr); } T& get() { return (ptr); };

  private:
    T ptr;

    void set(const T& value) {
        ptr = value;
    }

    FakeRooted(const FakeRooted&) = delete;
};


template <typename T>
class FakeMutableHandle : public js::MutableHandleBase<T, FakeMutableHandle<T>>
{
  public:
    using ElementType = T;

                 FakeMutableHandle(T* t) {
        ptr = t;
    }

                 FakeMutableHandle(FakeRooted<T>* root) {
        ptr = root->address();
    }

    void set(const T& v) {
        *ptr = v;
    }

    operator const T&() const { return get(); } const T& operator->() const { return get(); };
    const T* address() const { return &(*ptr); } const T& get() const { return (*ptr); };
    T* address() { return &(*ptr); } T& get() { return (*ptr); };

  private:
    FakeMutableHandle() {}
    template <typename S> FakeMutableHandle<T>& operator=(S) = delete; FakeMutableHandle<T>& operator=(const FakeMutableHandle<T>&) = delete;;

    T* ptr;
};
enum AllowGC {
    NoGC = 0,
    CanGC = 1
};
template <typename T, AllowGC allowGC>
class MaybeRooted
{
};

template <typename T> class MaybeRooted<T, CanGC>
{
  public:
    typedef JS::Handle<T> HandleType;
    typedef JS::Rooted<T> RootType;
    typedef JS::MutableHandle<T> MutableHandleType;

    static inline JS::Handle<T> toHandle(HandleType v) {
        return v;
    }

    static inline JS::MutableHandle<T> toMutableHandle(MutableHandleType v) {
        return v;
    }

    template <typename T2>
    static inline JS::Handle<T2*> downcastHandle(HandleType v) {
        return v.template as<T2>();
    }
};

template <typename T> class MaybeRooted<T, NoGC>
{
  public:
    typedef const T& HandleType;
    typedef FakeRooted<T> RootType;
    typedef FakeMutableHandle<T> MutableHandleType;

    static JS::Handle<T> toHandle(HandleType v) {
        do { AnnotateMozCrashReason("MOZ_CRASH(" "Bad conversion" ")"); do { *((volatile int*) __null) = 990; ::abort(); } while (0); } while (0);
    }

    static JS::MutableHandle<T> toMutableHandle(MutableHandleType v) {
        do { AnnotateMozCrashReason("MOZ_CRASH(" "Bad conversion" ")"); do { *((volatile int*) __null) = 994; ::abort(); } while (0); } while (0);
    }

    template <typename T2>
    static inline T2* downcastHandle(HandleType v) {
        return &v->template as<T2>();
    }
};

}

namespace JS {

template <typename T> template <typename S>
inline
Handle<T>::Handle(const Rooted<S>& root,
                  typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy)
{
    ptr = reinterpret_cast<const T*>(root.address());
}

template <typename T> template <typename S>
inline
Handle<T>::Handle(const PersistentRooted<S>& root,
                  typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy)
{
    ptr = reinterpret_cast<const T*>(root.address());
}

template <typename T> template <typename S>
inline
Handle<T>::Handle(MutableHandle<S>& root,
                  typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy)
{
    ptr = reinterpret_cast<const T*>(root.address());
}

template <typename T>
inline
MutableHandle<T>::MutableHandle(Rooted<T>* root)
{
    static_assert(sizeof(MutableHandle<T>) == sizeof(T*),
                  "MutableHandle must be binary compatible with T*.");
    ptr = root->address();
}

template <typename T>
inline
MutableHandle<T>::MutableHandle(PersistentRooted<T>* root)
{
    static_assert(sizeof(MutableHandle<T>) == sizeof(T*),
                  "MutableHandle must be binary compatible with T*.");
    ptr = root->address();
}

void
AddPersistentRoot(RootingContext* cx, RootKind kind, PersistentRooted<void*>* root);
template<typename T>
class PersistentRooted : public js::RootedBase<T, PersistentRooted<T>>,
                         private mozilla::LinkedListElement<PersistentRooted<T>>
{
    using ListBase = mozilla::LinkedListElement<PersistentRooted<T>>;

    friend class mozilla::LinkedList<PersistentRooted>;
    friend class mozilla::LinkedListElement<PersistentRooted>;

    void registerWithRootLists(RootingContext* cx) {
        do { } while (0);
        JS::RootKind kind = JS::MapTypeToRootKind<T>::kind;
        AddPersistentRoot(cx, kind, reinterpret_cast<JS::PersistentRooted<void*>*>(this));
    }

  public:
    using ElementType = T;

    PersistentRooted() : ptr(GCPolicy<T>::initial()) {}

    explicit PersistentRooted(RootingContext* cx)
      : ptr(GCPolicy<T>::initial())
    {
        registerWithRootLists(cx);
    }

    explicit PersistentRooted(JSContext* cx)
      : ptr(GCPolicy<T>::initial())
    {
        registerWithRootLists(RootingContext::get(cx));
    }

    template <typename U>
    PersistentRooted(RootingContext* cx, U&& initial)
      : ptr(mozilla::Forward<U>(initial))
    {
        registerWithRootLists(cx);
    }

    template <typename U>
    PersistentRooted(JSContext* cx, U&& initial)
      : ptr(mozilla::Forward<U>(initial))
    {
        registerWithRootLists(RootingContext::get(cx));
    }

    PersistentRooted(const PersistentRooted& rhs)
      : mozilla::LinkedListElement<PersistentRooted<T>>(),
        ptr(rhs.ptr)
    {
        const_cast<PersistentRooted&>(rhs).setNext(this);
    }

    bool initialized() {
        return ListBase::isInList();
    }

    void init(JSContext* cx) {
        init(cx, GCPolicy<T>::initial());
    }

    template <typename U>
    void init(JSContext* cx, U&& initial) {
        ptr = mozilla::Forward<U>(initial);
        registerWithRootLists(RootingContext::get(cx));
    }

    void reset() {
        if (initialized()) {
            set(GCPolicy<T>::initial());
            ListBase::remove();
        }
    }

    operator const T&() const { return get(); } const T& operator->() const { return get(); };
    PersistentRooted<T>& operator=(const T& p) { set(p); return *this; } PersistentRooted<T>& operator=(const PersistentRooted<T>& other) { set(other.get()); return *this; };
    const T* address() const { return &(ptr); } const T& get() const { return (ptr); };




    T* address() {
        do { } while (0);
        return &ptr;
    }
    T& get() {
        do { } while (0);
        return ptr;
    }

  private:
    template <typename U>
    void set(U&& value) {
        do { } while (0);
        ptr = mozilla::Forward<U>(value);
    }


    using MaybeWrapped = typename mozilla::Conditional<
        MapTypeToRootKind<T>::kind == JS::RootKind::Traceable,
        js::DispatchWrapper<T>,
        T>::Type;
    MaybeWrapped ptr;
} ;

class ObjectPtr
{
    Heap<JSObject*> value;

  public:
    using ElementType = JSObject*;

    ObjectPtr() : value(nullptr) {}

    explicit ObjectPtr(JSObject* obj) : value(obj) {}


    ~ObjectPtr() { do { } while (0); }

    void finalize(JSRuntime* rt);
    void finalize(JSContext* cx);

    void init(JSObject* obj) { value = obj; }

    JSObject* get() const { return value; }
    JSObject* unbarrieredGet() const { return value.unbarrieredGet(); }

    void writeBarrierPre(JSContext* cx) {
        IncrementalPreWriteBarrier(value);
    }

    void updateWeakPointerAfterGC();

    ObjectPtr& operator=(JSObject* obj) {
        IncrementalPreWriteBarrier(value);
        value = obj;
        return *this;
    }

    void trace(JSTracer* trc, const char* name);

    JSObject& operator*() const { return *value; }
    JSObject* operator->() const { return value; }
    operator JSObject*() const { return value; }

    explicit operator bool() const { return value.unbarrieredGet(); }
    explicit operator bool() { return value.unbarrieredGet(); }
};

}

namespace js {

template <typename T, typename D, typename Container>
class WrappedPtrOperations<UniquePtr<T, D>, Container>
{
    const UniquePtr<T, D>& uniquePtr() const { return static_cast<const Container*>(this)->get(); }

  public:
    explicit operator bool() const { return !!uniquePtr(); }
};

template <typename T, typename D, typename Container>
class MutableWrappedPtrOperations<UniquePtr<T, D>, Container>
  : public WrappedPtrOperations<UniquePtr<T, D>, Container>
{
    UniquePtr<T, D>& uniquePtr() { return static_cast<Container*>(this)->get(); }

  public:
    __attribute__ ((warn_unused_result)) typename UniquePtr<T, D>::Pointer release() { return uniquePtr().release(); }
};

namespace gc {

template <typename T, typename TraceCallbacks>
void
CallTraceCallbackOnNonHeap(T* v, const TraceCallbacks& aCallbacks, const char* aName, void* aClosure)
{
    static_assert(sizeof(T) == sizeof(JS::Heap<T>), "T and Heap<T> must be compatible.");
    do { } while (0);
    mozilla::DebugOnly<Cell*> cell = BarrierMethods<T>::asGCThingOrNull(*v);
    do { } while (0);
    do { } while (0);
    JS::Heap<T>* asHeapT = reinterpret_cast<JS::Heap<T>*>(v);
    aCallbacks.Trace(asHeapT, aName, aClosure);
}

}
}



namespace mozilla {

template <typename T>
inline void
Swap(JS::Heap<T>& aX, JS::Heap<T>& aY)
{
    T tmp = aX;
    aX = aY;
    aY = tmp;
}

template <typename T>
inline void
Swap(JS::TenuredHeap<T>& aX, JS::TenuredHeap<T>& aY)
{
    T tmp = aX;
    aX = aY;
    aY = tmp;
}

}

namespace js {
namespace detail {
template <typename T>
struct DefineComparisonOps : mozilla::FalseType {};

template <typename T>
struct DefineComparisonOps<JS::Heap<T>> : mozilla::TrueType {
    static const T& get(const JS::Heap<T>& v) { return v.unbarrieredGet(); }
};

template <typename T>
struct DefineComparisonOps<JS::TenuredHeap<T>> : mozilla::TrueType {
    static const T get(const JS::TenuredHeap<T>& v) { return v.unbarrieredGetPtr(); }
};

template <>
struct DefineComparisonOps<JS::ObjectPtr> : mozilla::TrueType {
    static const JSObject* get(const JS::ObjectPtr& v) { return v.unbarrieredGet(); }
};

template <typename T>
struct DefineComparisonOps<JS::Rooted<T>> : mozilla::TrueType {
    static const T& get(const JS::Rooted<T>& v) { return v.get(); }
};

template <typename T>
struct DefineComparisonOps<JS::Handle<T>> : mozilla::TrueType {
    static const T& get(const JS::Handle<T>& v) { return v.get(); }
};

template <typename T>
struct DefineComparisonOps<JS::MutableHandle<T>> : mozilla::TrueType {
    static const T& get(const JS::MutableHandle<T>& v) { return v.get(); }
};

template <typename T>
struct DefineComparisonOps<JS::PersistentRooted<T>> : mozilla::TrueType {
    static const T& get(const JS::PersistentRooted<T>& v) { return v.get(); }
};

template <typename T>
struct DefineComparisonOps<js::FakeRooted<T>> : mozilla::TrueType {
    static const T& get(const js::FakeRooted<T>& v) { return v.get(); }
};

template <typename T>
struct DefineComparisonOps<js::FakeMutableHandle<T>> : mozilla::TrueType {
    static const T& get(const js::FakeMutableHandle<T>& v) { return v.get(); }
};

}
}
template <typename T, typename U>
typename mozilla::EnableIf<js::detail::DefineComparisonOps<T>::value &&
                           js::detail::DefineComparisonOps<U>::value, bool>::Type
operator==(const T& a, const U& b) {
    return js::detail::DefineComparisonOps<T>::get(a) == js::detail::DefineComparisonOps<U>::get(b);
}

template <typename T, typename U>
typename mozilla::EnableIf<js::detail::DefineComparisonOps<T>::value &&
                           js::detail::DefineComparisonOps<U>::value, bool>::Type
operator!=(const T& a, const U& b) {
    return !(a == b);
}



template <typename T>
typename mozilla::EnableIf<js::detail::DefineComparisonOps<T>::value, bool>::Type
operator==(const T& a, const typename T::ElementType& b) {
    return js::detail::DefineComparisonOps<T>::get(a) == b;
}

template <typename T>
typename mozilla::EnableIf<js::detail::DefineComparisonOps<T>::value, bool>::Type
operator!=(const T& a, const typename T::ElementType& b) {
    return !(a == b);
}

template <typename T>
typename mozilla::EnableIf<js::detail::DefineComparisonOps<T>::value, bool>::Type
operator==(const typename T::ElementType& a, const T& b) {
    return a == js::detail::DefineComparisonOps<T>::get(b);
}

template <typename T>
typename mozilla::EnableIf<js::detail::DefineComparisonOps<T>::value, bool>::Type
operator!=(const typename T::ElementType& a, const T& b) {
    return !(a == b);
}




template <typename T>
typename mozilla::EnableIf<js::detail::DefineComparisonOps<T>::value &&
                           mozilla::IsPointer<typename T::ElementType>::value, bool>::Type
operator==(const typename mozilla::RemovePointer<typename T::ElementType>::Type* a, const T& b) {
    return a == js::detail::DefineComparisonOps<T>::get(b);
}

template <typename T>
typename mozilla::EnableIf<js::detail::DefineComparisonOps<T>::value &&
                           mozilla::IsPointer<typename T::ElementType>::value, bool>::Type
operator!=(const typename mozilla::RemovePointer<typename T::ElementType>::Type* a, const T& b) {
    return !(a == b);
}

template <typename T>
typename mozilla::EnableIf<js::detail::DefineComparisonOps<T>::value &&
                           mozilla::IsPointer<typename T::ElementType>::value, bool>::Type
operator==(const T& a, const typename mozilla::RemovePointer<typename T::ElementType>::Type* b) {
    return js::detail::DefineComparisonOps<T>::get(a) == b;
}

template <typename T>
typename mozilla::EnableIf<js::detail::DefineComparisonOps<T>::value &&
                           mozilla::IsPointer<typename T::ElementType>::value, bool>::Type
operator!=(const T& a, const typename mozilla::RemovePointer<typename T::ElementType>::Type* b) {
    return !(a == b);
}



template <typename T>
typename mozilla::EnableIf<js::detail::DefineComparisonOps<T>::value &&
                           mozilla::IsPointer<typename T::ElementType>::value, bool>::Type
operator==(std::nullptr_t a, const T& b) {
    return a == js::detail::DefineComparisonOps<T>::get(b);
}

template <typename T>
typename mozilla::EnableIf<js::detail::DefineComparisonOps<T>::value &&
                           mozilla::IsPointer<typename T::ElementType>::value, bool>::Type
operator!=(std::nullptr_t a, const T& b) {
    return !(a == b);
}

template <typename T>
typename mozilla::EnableIf<js::detail::DefineComparisonOps<T>::value &&
                           mozilla::IsPointer<typename T::ElementType>::value, bool>::Type
operator==(const T& a, std::nullptr_t b) {
    return js::detail::DefineComparisonOps<T>::get(a) == b;
}

template <typename T>
typename mozilla::EnableIf<js::detail::DefineComparisonOps<T>::value &&
                           mozilla::IsPointer<typename T::ElementType>::value, bool>::Type
operator!=(const T& a, std::nullptr_t b) {
    return !(a == b);
}
class nsCycleCollectionISupports
{
public:
  template<typename T, typename U> struct COMTypeInfo;
};

template<typename T> struct nsCycleCollectionISupports::COMTypeInfo<nsCycleCollectionISupports, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsCycleCollectionISupports::COMTypeInfo<nsCycleCollectionISupports, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0xc61eac14, 0x5f7a, 0x4481, { 0x96, 0x5e, 0x7e, 0xaa, 0x6e, 0xff, 0xa8, 0x5f } };


namespace JS {
template<class T> class Heap;
}






struct TraceCallbacks
{
  virtual void Trace(JS::Heap<JS::Value>* aPtr, const char* aName,
                     void* aClosure) const = 0;
  virtual void Trace(JS::Heap<jsid>* aPtr, const char* aName,
                     void* aClosure) const = 0;
  virtual void Trace(JS::Heap<JSObject*>* aPtr, const char* aName,
                     void* aClosure) const = 0;
  virtual void Trace(JSObject** aPtr, const char* aName,
                     void* aClosure) const = 0;
  virtual void Trace(JS::TenuredHeap<JSObject*>* aPtr, const char* aName,
                     void* aClosure) const = 0;
  virtual void Trace(JS::Heap<JSString*>* aPtr, const char* aName,
                     void* aClosure) const = 0;
  virtual void Trace(JS::Heap<JSScript*>* aPtr, const char* aName,
                     void* aClosure) const = 0;
  virtual void Trace(JS::Heap<JSFunction*>* aPtr, const char* aName,
                     void* aClosure) const = 0;
};





struct TraceCallbackFunc : public TraceCallbacks
{
  typedef void (*Func)(JS::GCCellPtr aPtr, const char* aName, void* aClosure);

  explicit TraceCallbackFunc(Func aCb) : mCallback(aCb) {}

  virtual void Trace(JS::Heap<JS::Value>* aPtr, const char* aName,
                     void* aClosure) const override;
  virtual void Trace(JS::Heap<jsid>* aPtr, const char* aName,
                     void* aClosure) const override;
  virtual void Trace(JS::Heap<JSObject*>* aPtr, const char* aName,
                     void* aClosure) const override;
  virtual void Trace(JSObject** aPtr, const char* aName,
                     void* aClosure) const override;
  virtual void Trace(JS::TenuredHeap<JSObject*>* aPtr, const char* aName,
                     void* aClosure) const override;
  virtual void Trace(JS::Heap<JSString*>* aPtr, const char* aName,
                     void* aClosure) const override;
  virtual void Trace(JS::Heap<JSScript*>* aPtr, const char* aName,
                     void* aClosure) const override;
  virtual void Trace(JS::Heap<JSFunction*>* aPtr, const char* aName,
                     void* aClosure) const override;

private:
  Func mCallback;
};




class nsCycleCollectionParticipant
{
public:
  constexpr explicit nsCycleCollectionParticipant(bool aSkip,
                                                  bool aTraverseShouldTrace = false)
    : mMightSkip(aSkip)
    , mTraverseShouldTrace(aTraverseShouldTrace)
  {
  }

  virtual nsresult TraverseNative(void* aPtr, nsCycleCollectionTraversalCallback& aCb) = 0;

  nsresult TraverseNativeAndJS(void* aPtr,
                               nsCycleCollectionTraversalCallback& aCb)
  {
    nsresult rv = TraverseNative(aPtr, aCb);
    if (mTraverseShouldTrace) {


      TraceCallbackFunc noteJsChild(&nsCycleCollectionParticipant::NoteJSChild);
      Trace(aPtr, noteJsChild, &aCb);
    }
    return rv;
  }


  static void NoteJSChild(JS::GCCellPtr aGCThing, const char* aName,
                          void* aClosure);

  virtual void Root(void* aPtr) = 0;
  virtual void Unlink(void* aPtr) = 0;
  virtual void Unroot(void* aPtr) = 0;
  virtual const char* ClassName() = 0;

  virtual void Trace(void* aPtr, const TraceCallbacks& aCb,
                          void* aClosure) {}
  bool CanSkip(void* aPtr, bool aRemovingAllowed)
  {
    return mMightSkip ? CanSkipReal(aPtr, aRemovingAllowed) : false;
  }
  bool CanSkipInCC(void* aPtr)
  {
    return mMightSkip ? CanSkipInCCReal(aPtr) : false;
  }
  bool CanSkipThis(void* aPtr)
  {
    return mMightSkip ? CanSkipThisReal(aPtr) : false;
  }

  virtual void DeleteCycleCollectable(void* aPtr) = 0;

protected:
  virtual bool CanSkipReal(void* aPtr, bool aRemovingAllowed)
  {
    do { } while(0);
    return false;
  }
  virtual bool CanSkipInCCReal(void* aPtr)
  {
    do { } while(0);
    return false;
  }
  virtual bool CanSkipThisReal(void* aPtr)
  {
    do { } while(0);
    return false;
  }

private:
  const bool mMightSkip;
  const bool mTraverseShouldTrace;
};

class nsScriptObjectTracer : public nsCycleCollectionParticipant
{
public:
  constexpr explicit nsScriptObjectTracer(bool aSkip)
    : nsCycleCollectionParticipant(aSkip, true)
  {
  }

  virtual void Trace(void* aPtr, const TraceCallbacks& aCb,
                          void* aClosure) override = 0;

};

class nsXPCOMCycleCollectionParticipant : public nsScriptObjectTracer
{
public:
  constexpr explicit nsXPCOMCycleCollectionParticipant(bool aSkip)
    : nsScriptObjectTracer(aSkip)
  {
  }

  template<typename T, typename U> struct COMTypeInfo;

  virtual void Root(void* aPtr) override;
  virtual void Unroot(void* aPtr) override;

  virtual void Trace(void* aPtr, const TraceCallbacks& aCb,
                          void* aClosure) override;

  static bool CheckForRightISupports(nsISupports* aSupports);
};

template<typename T> struct nsXPCOMCycleCollectionParticipant::COMTypeInfo<nsXPCOMCycleCollectionParticipant, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsXPCOMCycleCollectionParticipant::COMTypeInfo<nsXPCOMCycleCollectionParticipant, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x9674489b, 0x1f6f, 0x4550, { 0xa7, 0x30, 0xcc, 0xae, 0xdd, 0x10, 0x4c, 0xf9 } };
template<typename T,
         bool IsXPCOM = mozilla::IsBaseOf<nsISupports, T>::value>
struct DowncastCCParticipantImpl
{
};


template<typename T>
struct DowncastCCParticipantImpl<T, true>
{
  static T* Run(void* aPtr)
  {
    nsISupports* s = static_cast<nsISupports*>(aPtr);
    do { } while (0);

    T* rval = T::cycleCollection::Downcast(s);
                                        ;
    return rval;
  }
};


template<typename T>
struct DowncastCCParticipantImpl<T, false>
{
  static T* Run(void* aPtr) { return static_cast<T*>(aPtr); }
};

template<typename T>
T*
DowncastCCParticipant(void* aPtr)
{
  return DowncastCCParticipantImpl<T>::Run(aPtr);
}
static const int32_t kNameSpaceID_None = 0;
namespace mozilla {
namespace detail {

class nsStringRepr;
class nsCStringRepr;

}
}





class nsAString;
class nsSubstringTuple;
class nsString;
class nsAutoString;
class nsDependentString;
class nsDependentSubstring;
class nsPromiseFlatString;
class nsStringComparator;
class nsDefaultStringComparator;
class nsXPIDLString;






class nsACString;
class nsCSubstringTuple;
class nsCString;
class nsAutoCString;
class nsDependentCString;
class nsDependentCSubstring;
class nsPromiseFlatCString;
class nsCStringComparator;
class nsDefaultCStringComparator;
class nsXPIDLCString;






typedef nsAString nsSubstring;
typedef nsACString nsCSubstring;

typedef nsString nsAFlatString;
typedef nsSubstring nsASingleFragmentString;

typedef nsCString nsAFlatCString;
typedef nsCSubstring nsASingleFragmentCString;
template <class CharT>
class nsReadingIterator
{
public:
  typedef nsReadingIterator<CharT> self_type;
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef CharT value_type;
  typedef const CharT* pointer;
  typedef const CharT& reference;

private:
  friend class mozilla::detail::nsStringRepr;
  friend class mozilla::detail::nsCStringRepr;






  const CharT* mStart;
  const CharT* mEnd;
  const CharT* mPosition;

public:
  nsReadingIterator()
  {
  }



  pointer get() const
  {
    return mPosition;
  }

  CharT operator*() const
  {
    return *get();
  }

  self_type& operator++()
  {
    ++mPosition;
    return *this;
  }

  self_type operator++(int)
  {
    self_type result(*this);
    ++mPosition;
    return result;
  }

  self_type& operator--()
  {
    --mPosition;
    return *this;
  }

  self_type operator--(int)
  {
    self_type result(*this);
    --mPosition;
    return result;
  }

  self_type& advance(difference_type aN)
  {
    if (aN > 0) {
      difference_type step = XPCOM_MIN(aN, mEnd - mPosition);

      do { } while(0);


      mPosition += step;
    } else if (aN < 0) {
      difference_type step = XPCOM_MAX(aN, -(mPosition - mStart));

      do { } while(0);


      mPosition += step;
    }
    return *this;
  }






  size_type operator-(const self_type& aOther) const
  {
    do { } while (0);
    return mPosition - aOther.mPosition;
  }
};





template <class CharT>
class nsWritingIterator
{
public:
  typedef nsWritingIterator<CharT> self_type;
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef CharT value_type;
  typedef CharT* pointer;
  typedef CharT& reference;

private:
  friend class nsAString;
  friend class nsACString;






  CharT* mStart;
  CharT* mEnd;
  CharT* mPosition;

public:
  nsWritingIterator()
  {
  }



  pointer get() const
  {
    return mPosition;
  }

  reference operator*() const
  {
    return *get();
  }

  self_type& operator++()
  {
    ++mPosition;
    return *this;
  }

  self_type operator++(int)
  {
    self_type result(*this);
    ++mPosition;
    return result;
  }

  self_type& operator--()
  {
    --mPosition;
    return *this;
  }

  self_type operator--(int)
  {
    self_type result(*this);
    --mPosition;
    return result;
  }

  self_type& advance(difference_type aN)
  {
    if (aN > 0) {
      difference_type step = XPCOM_MIN(aN, mEnd - mPosition);

      do { } while(0);


      mPosition += step;
    } else if (aN < 0) {
      difference_type step = XPCOM_MAX(aN, -(mPosition - mStart));

      do { } while(0);


      mPosition += step;
    }
    return *this;
  }






  size_type operator-(const self_type& aOther) const
  {
    do { } while (0);
    return mPosition - aOther.mPosition;
  }
};

template <class CharT>
struct nsCharSinkTraits<nsWritingIterator<CharT>>
{
  static void
  write(nsWritingIterator<CharT>& aIter, const CharT* aStr, uint32_t aN)
  {
    nsCharTraits<CharT>::move(aIter.get(), aStr, aN);
    aIter.advance(aN);
  }
};

template <class CharT>
inline bool
operator==(const nsReadingIterator<CharT>& aLhs,
           const nsReadingIterator<CharT>& aRhs)
{
  return aLhs.get() == aRhs.get();
}

template <class CharT>
inline bool
operator!=(const nsReadingIterator<CharT>& aLhs,
           const nsReadingIterator<CharT>& aRhs)
{
  return aLhs.get() != aRhs.get();
}






template <class CharT>
inline bool
operator==(const nsWritingIterator<CharT>& aLhs,
           const nsWritingIterator<CharT>& aRhs)
{
  return aLhs.get() == aRhs.get();
}

template <class CharT>
inline bool
operator!=(const nsWritingIterator<CharT>& aLhs,
           const nsWritingIterator<CharT>& aRhs)
{
  return aLhs.get() != aRhs.get();
}















extern "C" {




typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
extern intmax_t imaxabs (intmax_t __n) throw () __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      throw () __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) throw ();


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) throw ();


extern intmax_t wcstoimax (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();


extern uintmax_t wcstoumax (const wchar_t *__restrict __nptr,
       wchar_t ** __restrict __endptr, int __base)
     throw ();
}
class nsStringComparator
{
public:
  typedef char16_t char_type;

  nsStringComparator()
  {
  }

  virtual int operator()(const char_type*, const char_type*,
                         uint32_t, uint32_t) const = 0;
};





class nsDefaultStringComparator
  : public nsStringComparator
{
public:
  typedef char16_t char_type;

  nsDefaultStringComparator()
  {
  }

  virtual int operator()(const char_type*, const char_type*,
                         uint32_t, uint32_t) const override;
};

class nsSubstringSplitter;

namespace mozilla {
namespace detail {
class nsStringRepr
{
public:
  typedef mozilla::fallible_t fallible_t;

  typedef char16_t char_type;

  typedef nsCharTraits<char_type> char_traits;
  typedef char_traits::incompatible_char_type incompatible_char_type;

  typedef nsStringRepr self_type;
  typedef self_type base_string_type;

  typedef nsAString substring_type;
  typedef nsSubstringTuple substring_tuple_type;
  typedef nsString string_type;

  typedef nsReadingIterator<char_type> const_iterator;
  typedef nsWritingIterator<char_type> iterator;

  typedef nsStringComparator comparator_type;

  typedef char_type* char_iterator;
  typedef const char_type* const_char_iterator;

  typedef uint32_t index_type;
  typedef uint32_t size_type;





  const_char_iterator BeginReading() const
  {
    return mData;
  }
  const_char_iterator EndReading() const
  {
    return mData + mLength;
  }





  const_iterator& BeginReading(const_iterator& aIter) const
  {
    aIter.mStart = mData;
    aIter.mEnd = mData + mLength;
    aIter.mPosition = aIter.mStart;
    return aIter;
  }

  const_iterator& EndReading(const_iterator& aIter) const
  {
    aIter.mStart = mData;
    aIter.mEnd = mData + mLength;
    aIter.mPosition = aIter.mEnd;
    return aIter;
  }

  const_char_iterator& BeginReading(const_char_iterator& aIter) const
  {
    return aIter = mData;
  }

  const_char_iterator& EndReading(const_char_iterator& aIter) const
  {
    return aIter = mData + mLength;
  }
  const char_type* Data() const

  {
    return mData;
  }

  size_type Length() const
  {
    return mLength;
  }

  uint32_t Flags() const
  {
    return mFlags;
  }

  bool IsEmpty() const
  {
    return mLength == 0;
  }

  bool IsLiteral() const
  {
    return (mFlags & F_LITERAL) != 0;
  }

  bool IsVoid() const
  {
    return (mFlags & F_VOIDED) != 0;
  }

  bool IsTerminated() const
  {
    return (mFlags & F_TERMINATED) != 0;
  }

  char_type CharAt(index_type aIndex) const
  {
    do { } while(0);
    return mData[aIndex];
  }

  char_type operator[](index_type aIndex) const
  {
    return CharAt(aIndex);
  }

  char_type First() const;

  char_type Last() const;

  size_type CountChar(char_type) const;
  int32_t FindChar(char_type, index_type aOffset = 0) const;

  inline bool Contains(char_type aChar) const
  {
    return FindChar(aChar) != -1;
  }





  bool Equals(const self_type&) const;
  bool Equals(const self_type&, const comparator_type&) const;

  bool Equals(const substring_tuple_type& aTuple) const;
  bool Equals(const substring_tuple_type& aTuple,
                          const comparator_type& aComp) const;

  bool Equals(const char_type* aData) const;
  bool Equals(const char_type* aData,
                          const comparator_type& aComp) const;
  bool EqualsASCII(const char* aData, size_type aLen) const;





  bool EqualsASCII(const char* aData) const;







  template<int N>
  inline bool EqualsLiteral(const char (&aStr)[N]) const
  {
    return EqualsASCII(aStr, N - 1);
  }







  bool LowerCaseEqualsASCII(const char* aData,
                                        size_type aLen) const;
  bool LowerCaseEqualsASCII(const char* aData) const;






  template<int N>
  inline bool LowerCaseEqualsLiteral(const char (&aStr)[N]) const
  {
    return LowerCaseEqualsASCII(aStr, N - 1);
  }




  bool IsDependentOn(const char_type* aStart, const char_type* aEnd) const
  {
    return (aStart < (mData + mLength) && aEnd > mData);
  }

protected:
  nsStringRepr() = delete;

  constexpr
  nsStringRepr(char_type* aData, size_type aLength, uint32_t aFlags)
    : mData(aData)
    , mLength(aLength)
    , mFlags(aFlags)
  {
  }

  char_type* mData;
  size_type mLength;
  uint32_t mFlags;

public:






  enum
  {
    F_NONE = 0,


    F_TERMINATED = 1 << 0,
    F_VOIDED = 1 << 1,
    F_SHARED = 1 << 2,
    F_OWNED = 1 << 3,
    F_FIXED = 1 << 4,
    F_LITERAL = 1 << 5,


    F_CLASS_FIXED = 1 << 16
  };
};

}
}
class nsAString : public mozilla::detail::nsStringRepr
{
public:
  typedef nsAString self_type;


  ~nsAString()
  {
    Finalize();
  }





  char_iterator BeginWriting()
  {
    if (!EnsureMutable()) {
      AllocFailed(mLength);
    }

    return mData;
  }

  char_iterator BeginWriting(const fallible_t&)
  {
    return EnsureMutable() ? mData : char_iterator(0);
  }

  char_iterator EndWriting()
  {
    if (!EnsureMutable()) {
      AllocFailed(mLength);
    }

    return mData + mLength;
  }

  char_iterator EndWriting(const fallible_t&)
  {
    return EnsureMutable() ? (mData + mLength) : char_iterator(0);
  }

  char_iterator& BeginWriting(char_iterator& aIter)
  {
    return aIter = BeginWriting();
  }

  char_iterator& BeginWriting(char_iterator& aIter, const fallible_t& aFallible)
  {
    return aIter = BeginWriting(aFallible);
  }

  char_iterator& EndWriting(char_iterator& aIter)
  {
    return aIter = EndWriting();
  }

  char_iterator& EndWriting(char_iterator& aIter, const fallible_t& aFallible)
  {
    return aIter = EndWriting(aFallible);
  }





  iterator& BeginWriting(iterator& aIter)
  {
    char_type* data = BeginWriting();
    aIter.mStart = data;
    aIter.mEnd = data + mLength;
    aIter.mPosition = aIter.mStart;
    return aIter;
  }

  iterator& EndWriting(iterator& aIter)
  {
    char_type* data = BeginWriting();
    aIter.mStart = data;
    aIter.mEnd = data + mLength;
    aIter.mPosition = aIter.mEnd;
    return aIter;
  }





  void Assign(char_type aChar);
  __attribute__ ((warn_unused_result)) bool Assign(char_type aChar, const fallible_t&);

  void Assign(const char_type* aData);
  __attribute__ ((warn_unused_result)) bool Assign(const char_type* aData,
                                       const fallible_t&);

  void Assign(const char_type* aData, size_type aLength);
  __attribute__ ((warn_unused_result)) bool Assign(const char_type* aData,
                                       size_type aLength, const fallible_t&);

  void Assign(const self_type&);
  __attribute__ ((warn_unused_result)) bool Assign(const self_type&, const fallible_t&);

  void Assign(const substring_tuple_type&);
  __attribute__ ((warn_unused_result)) bool Assign(const substring_tuple_type&,
                                       const fallible_t&);
  void AssignASCII(const char* aData, size_type aLength);
  __attribute__ ((warn_unused_result)) bool AssignASCII(const char* aData,
                                            size_type aLength,
                                            const fallible_t&);

  void AssignASCII(const char* aData)
  {
    AssignASCII(aData, mozilla::AssertedCast<size_type, size_t>(strlen(aData)));
  }
  __attribute__ ((warn_unused_result)) bool AssignASCII(const char* aData,
                                            const fallible_t& aFallible)
  {
    return AssignASCII(aData,
                       mozilla::AssertedCast<size_type, size_t>(strlen(aData)),
                       aFallible);
  }







  template<int N>
  void AssignLiteral(const char_type (&aStr)[N])
  {
    AssignLiteral(aStr, N - 1);
  }

  template<int N>
  void AssignLiteral(const char (&aStr)[N])
  {
    AssignASCII(aStr, N - 1);
  }


  self_type& operator=(char_type aChar)
  {
    Assign(aChar);
    return *this;
  }
  self_type& operator=(const char_type* aData)
  {
    Assign(aData);
    return *this;
  }







  self_type& operator=(const self_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_tuple_type& aTuple)
  {
    Assign(aTuple);
    return *this;
  }

  void Adopt(char_type* aData, size_type aLength = size_type(-1));






  void Replace(index_type aCutStart, size_type aCutLength,
                           char_type aChar);
  __attribute__ ((warn_unused_result)) bool Replace(index_type aCutStart,
                                        size_type aCutLength,
                                        char_type aChar,
                                        const fallible_t&);
  void Replace(index_type aCutStart, size_type aCutLength,
                           const char_type* aData,
                           size_type aLength = size_type(-1));
  __attribute__ ((warn_unused_result)) bool Replace(index_type aCutStart,
                                        size_type aCutLength,
                                        const char_type* aData,
                                        size_type aLength,
                                        const fallible_t&);
  void Replace(index_type aCutStart, size_type aCutLength,
               const self_type& aStr)
  {
    Replace(aCutStart, aCutLength, aStr.Data(), aStr.Length());
  }
  __attribute__ ((warn_unused_result)) bool Replace(index_type aCutStart,
                            size_type aCutLength,
                            const self_type& aStr,
                            const fallible_t& aFallible)
  {
    return Replace(aCutStart, aCutLength, aStr.Data(), aStr.Length(),
                   aFallible);
  }
  void Replace(index_type aCutStart, size_type aCutLength,
                           const substring_tuple_type& aTuple);

  void ReplaceASCII(index_type aCutStart, size_type aCutLength,
                                const char* aData,
                                size_type aLength = size_type(-1));

  __attribute__ ((warn_unused_result)) bool ReplaceASCII(index_type aCutStart, size_type aCutLength,
                                             const char* aData,
                                             size_type aLength,
                                             const fallible_t&);




  template<int N>
  void ReplaceLiteral(index_type aCutStart, size_type aCutLength,
                      const char_type (&aStr)[N])
  {
    ReplaceLiteral(aCutStart, aCutLength, aStr, N - 1);
  }

  void Append(char_type aChar)
  {
    Replace(mLength, 0, aChar);
  }
  __attribute__ ((warn_unused_result)) bool Append(char_type aChar, const fallible_t& aFallible)
  {
    return Replace(mLength, 0, aChar, aFallible);
  }
  void Append(const char_type* aData, size_type aLength = size_type(-1))
  {
    Replace(mLength, 0, aData, aLength);
  }
  __attribute__ ((warn_unused_result)) bool Append(const char_type* aData, size_type aLength,
                           const fallible_t& aFallible)
  {
    return Replace(mLength, 0, aData, aLength, aFallible);
  }
  void Append(const self_type& aStr)
  {
    Replace(mLength, 0, aStr);
  }
  __attribute__ ((warn_unused_result)) bool Append(const self_type& aStr, const fallible_t& aFallible)
  {
    return Replace(mLength, 0, aStr, aFallible);
  }
  void Append(const substring_tuple_type& aTuple)
  {
    Replace(mLength, 0, aTuple);
  }

  void AppendASCII(const char* aData, size_type aLength = size_type(-1))
  {
    ReplaceASCII(mLength, 0, aData, aLength);
  }

  __attribute__ ((warn_unused_result)) bool AppendASCII(const char* aData, const fallible_t& aFallible)
  {
    return ReplaceASCII(mLength, 0, aData, size_type(-1), aFallible);
  }

  __attribute__ ((warn_unused_result)) bool AppendASCII(const char* aData, size_type aLength, const fallible_t& aFallible)
  {
    return ReplaceASCII(mLength, 0, aData, aLength, aFallible);
  }







  void AppendPrintf(const char* aFormat, ...) __attribute__ ((format (printf, 2, 3)));
  void AppendPrintf(const char* aFormat, va_list aAp);
  void AppendInt(int32_t aInteger)
  {
    AppendPrintf("%" "d", aInteger);
  }
  void AppendInt(int32_t aInteger, int aRadix)
  {
    if (aRadix == 10) {
      AppendPrintf("%" "d", aInteger);
    } else {
      AppendPrintf(aRadix == 8 ? "%" "o" : "%" "x",
                   static_cast<uint32_t>(aInteger));
    }
  }
  void AppendInt(uint32_t aInteger)
  {
    AppendPrintf("%" "u", aInteger);
  }
  void AppendInt(uint32_t aInteger, int aRadix)
  {
    AppendPrintf(aRadix == 10 ? "%" "u" : aRadix == 8 ? "%" "o" : "%" "x",
                 aInteger);
  }
  void AppendInt(int64_t aInteger)
  {
    AppendPrintf("%" "l" "d", aInteger);
  }
  void AppendInt(int64_t aInteger, int aRadix)
  {
    if (aRadix == 10) {
      AppendPrintf("%" "l" "d", aInteger);
    } else {
      AppendPrintf(aRadix == 8 ? "%" "l" "o" : "%" "l" "x",
                   static_cast<uint64_t>(aInteger));
    }
  }
  void AppendInt(uint64_t aInteger)
  {
    AppendPrintf("%" "l" "u", aInteger);
  }
  void AppendInt(uint64_t aInteger, int aRadix)
  {
    AppendPrintf(aRadix == 10 ? "%" "l" "u" : aRadix == 8 ? "%" "l" "o" : "%" "l" "x",
                 aInteger);
  }




  void AppendFloat(float aFloat);
  void AppendFloat(double aFloat);
public:




  template<int N>
  void AppendLiteral(const char_type (&aStr)[N])
  {
    ReplaceLiteral(mLength, 0, aStr, N - 1);
  }

  template<int N>
  void AppendLiteral(const char (&aStr)[N])
  {
    AppendASCII(aStr, N - 1);
  }

  template<int N>
  __attribute__ ((warn_unused_result)) bool AppendLiteral(const char (&aStr)[N], const fallible_t& aFallible)
  {
    return AppendASCII(aStr, N - 1, aFallible);
  }


  self_type& operator+=(char_type aChar)
  {
    Append(aChar);
    return *this;
  }
  self_type& operator+=(const char_type* aData)
  {
    Append(aData);
    return *this;
  }







  self_type& operator+=(const self_type& aStr)
  {
    Append(aStr);
    return *this;
  }
  self_type& operator+=(const substring_tuple_type& aTuple)
  {
    Append(aTuple);
    return *this;
  }

  void Insert(char_type aChar, index_type aPos)
  {
    Replace(aPos, 0, aChar);
  }
  void Insert(const char_type* aData, index_type aPos,
              size_type aLength = size_type(-1))
  {
    Replace(aPos, 0, aData, aLength);
  }







  void Insert(const self_type& aStr, index_type aPos)
  {
    Replace(aPos, 0, aStr);
  }
  void Insert(const substring_tuple_type& aTuple, index_type aPos)
  {
    Replace(aPos, 0, aTuple);
  }




  template<int N>
  void InsertLiteral(const char_type (&aStr)[N], index_type aPos)
  {
    ReplaceLiteral(aPos, 0, aStr, N - 1);
  }

  void Cut(index_type aCutStart, size_type aCutLength)
  {
    Replace(aCutStart, aCutLength, char_traits::sEmptyBuffer, 0);
  }

  nsSubstringSplitter Split(const char_type aChar) const;
  void SetCapacity(size_type aNewCapacity);
  __attribute__ ((warn_unused_result)) bool SetCapacity(size_type aNewCapacity,
                                            const fallible_t&);

  void SetLength(size_type aNewLength);
  __attribute__ ((warn_unused_result)) bool SetLength(size_type aNewLength,
                                          const fallible_t&);

  void Truncate(size_type aNewLength = 0)
  {
    do { } while(0);
    SetLength(aNewLength);
  }
  inline size_type GetData(const char_type** aData) const
  {
    *aData = mData;
    return mLength;
  }
  size_type GetMutableData(char_type** aData, size_type aNewLen = size_type(-1))
  {
    if (!EnsureMutable(aNewLen)) {
      AllocFailed(aNewLen == size_type(-1) ? mLength : aNewLen);
    }

    *aData = mData;
    return mLength;
  }

  size_type GetMutableData(char_type** aData, size_type aNewLen, const fallible_t&)
  {
    if (!EnsureMutable(aNewLen)) {
      *aData = nullptr;
      return 0;
    }

    *aData = mData;
    return mLength;
  }
  operator mozilla::Span<char_type>()
  {
    return mozilla::MakeSpan(BeginWriting(), Length());
  }

  operator mozilla::Span<const char_type>() const
  {
    return mozilla::MakeSpan(BeginReading(), Length());
  }

  void Append(mozilla::Span<const char_type> aSpan)
  {
    auto len = aSpan.Length();
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(len <= mozilla::MaxValue<size_type>::value)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(len <= mozilla::MaxValue<size_type>::value))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "len <= mozilla::MaxValue<size_type>::value" ")"); do { *((volatile int*) __null) = 944; ::abort(); } while (0); } } while (0);
    Append(aSpan.Elements(), len);
  }

  __attribute__ ((warn_unused_result)) bool Append(mozilla::Span<const char_type> aSpan,
                           const fallible_t& aFallible)
  {
    auto len = aSpan.Length();
    if (len > mozilla::MaxValue<size_type>::value) {
      return false;
    }
    return Append(aSpan.Elements(), len, aFallible);
  }
  void SetIsVoid(bool);
  void StripChar(char_type aChar, int32_t aOffset = 0);
  void StripChars(const char_type* aChars, uint32_t aOffset = 0);





  void ForgetSharedBuffer()
  {
    if (mFlags & nsSubstring::F_SHARED) {
      mData = char_traits::sEmptyBuffer;
      mLength = 0;
      mFlags = F_TERMINATED;
    }
  }

public:





               nsAString(const substring_tuple_type& aTuple)
    : nsStringRepr(nullptr, 0, F_NONE)
  {
    Assign(aTuple);
  }

  size_t SizeOfExcludingThisIfUnshared(mozilla::MallocSizeOf aMallocSizeOf)
  const;
  size_t SizeOfIncludingThisIfUnshared(mozilla::MallocSizeOf aMallocSizeOf)
  const;







  size_t SizeOfExcludingThisEvenIfShared(mozilla::MallocSizeOf aMallocSizeOf)
  const;
  size_t SizeOfIncludingThisEvenIfShared(mozilla::MallocSizeOf aMallocSizeOf)
  const;

  template<class T>
  void NS_ABORT_OOM(T)
  {
    struct never {};
    static_assert(mozilla::IsSame<T, never>::value,
      "In string classes, use AllocFailed to account for sizeof(char_type). "
      "Use the global ::NS_ABORT_OOM if you really have a count of bytes.");
  }

  __attribute__((always_inline)) inline void AllocFailed(size_t aLength)
  {
    ::NS_ABORT_OOM(aLength * sizeof(char_type));
  }

protected:


  nsAString()
    : nsStringRepr(char_traits::sEmptyBuffer, 0, F_TERMINATED)
  {
  }



  nsAString(const self_type& aStr)
    : nsStringRepr(aStr.mData, aStr.mLength,
                          aStr.mFlags & (F_TERMINATED | F_VOIDED))
  {
  }
  nsAString(char_type* aData, size_type aLength, uint32_t aFlags)
    : nsStringRepr(aData, aLength, aFlags)
  {
  }







  void Finalize();
  bool MutatePrep(size_type aCapacity,
                              char_type** aOldData, uint32_t* aOldFlags);
  __attribute__ ((warn_unused_result)) bool ReplacePrep(index_type aCutStart,
                                size_type aCutLength,
                                size_type aNewLength);

  __attribute__ ((warn_unused_result)) bool ReplacePrepInternal(
    index_type aCutStart,
    size_type aCutLength,
    size_type aNewFragLength,
    size_type aNewTotalLength);
  size_type Capacity() const;





  __attribute__ ((warn_unused_result)) bool EnsureMutable(
    size_type aNewLen = size_type(-1));




  static __attribute__ ((warn_unused_result)) bool CheckCapacity(size_type aCapacity) {
    if (aCapacity > kMaxCapacity) {


      do { } while(0);
      return false;
    }

    return true;
  }




  void SetDataFlags(uint32_t aDataFlags)
  {
    do { } while(0);
    mFlags = aDataFlags | (mFlags & 0xFFFF0000);
  }

  void ReplaceLiteral(index_type aCutStart, size_type aCutLength,
                                  const char_type* aData, size_type aLength);

  static const size_type kMaxCapacity;
public:



  void AssignLiteral(const char_type* aData, size_type aLength);
};

static_assert(sizeof(nsAString) ==
              sizeof(mozilla::detail::nsStringRepr),
              "Don't add new data fields to nsTSubstring_CharT. "
              "Add to nsTStringRepr_CharT instead.");

int
Compare(const nsAString::base_string_type& aLhs,
        const nsAString::base_string_type& aRhs,
        const nsStringComparator& = nsDefaultStringComparator());


inline bool
operator!=(const nsAString::base_string_type& aLhs,
           const nsAString::base_string_type& aRhs)
{
  return !aLhs.Equals(aRhs);
}

inline bool
operator!=(const nsAString::base_string_type& aLhs,
           const nsAString::char_type* aRhs)
{
  return !aLhs.Equals(aRhs);
}

inline bool
operator<(const nsAString::base_string_type& aLhs,
          const nsAString::base_string_type& aRhs)
{
  return Compare(aLhs, aRhs) < 0;
}

inline bool
operator<=(const nsAString::base_string_type& aLhs,
           const nsAString::base_string_type& aRhs)
{
  return Compare(aLhs, aRhs) <= 0;
}

inline bool
operator==(const nsAString::base_string_type& aLhs,
           const nsAString::base_string_type& aRhs)
{
  return aLhs.Equals(aRhs);
}

inline bool
operator==(const nsAString::base_string_type& aLhs,
           const nsAString::char_type* aRhs)
{
  return aLhs.Equals(aRhs);
}


inline bool
operator>=(const nsAString::base_string_type& aLhs,
           const nsAString::base_string_type& aRhs)
{
  return Compare(aLhs, aRhs) >= 0;
}

inline bool
operator>(const nsAString::base_string_type& aLhs,
          const nsAString::base_string_type& aRhs)
{
  return Compare(aLhs, aRhs) > 0;
}



class nsSubstringSplitter
{
  typedef nsAString::size_type size_type;
  typedef nsAString::char_type char_type;

  class nsTSubstringSplit_Iter
  {
  public:
    nsTSubstringSplit_Iter(const nsSubstringSplitter& aObj,
                           size_type aPos)
      : mObj(aObj)
      , mPos(aPos)
    {
    }

    bool operator!=(const nsTSubstringSplit_Iter& other) const
    {
      return mPos != other.mPos;
    }

    const nsDependentSubstring& operator*() const;

    const nsTSubstringSplit_Iter& operator++()
    {
      ++mPos;
      return *this;
    }

  private:
    const nsSubstringSplitter& mObj;
    size_type mPos;
  };

private:
  const nsAString* const mStr;
  mozilla::UniquePtr<nsDependentSubstring[]> mArray;
  size_type mArraySize;
  const char_type mDelim;

public:
  nsSubstringSplitter(const nsAString* aStr, char_type aDelim);

  nsTSubstringSplit_Iter begin() const
  {
    return nsTSubstringSplit_Iter(*this, 0);
  }

  nsTSubstringSplit_Iter end() const
  {
    return nsTSubstringSplit_Iter(*this, mArraySize);
  }

  const nsDependentSubstring& Get(const size_type index) const
  {
    do { } while (0);
    return mArray[index];
  }
};




namespace mozilla {

inline Span<char16_t>
MakeSpan(nsAString& aString)
{
  return aString;
}

inline Span<const char16_t>
MakeSpan(const nsAString& aString)
{
  return aString;
}

}


class nsCStringComparator
{
public:
  typedef char char_type;

  nsCStringComparator()
  {
  }

  virtual int operator()(const char_type*, const char_type*,
                         uint32_t, uint32_t) const = 0;
};





class nsDefaultCStringComparator
  : public nsCStringComparator
{
public:
  typedef char char_type;

  nsDefaultCStringComparator()
  {
  }

  virtual int operator()(const char_type*, const char_type*,
                         uint32_t, uint32_t) const override;
};

class nsCSubstringSplitter;

namespace mozilla {
namespace detail {
class nsCStringRepr
{
public:
  typedef mozilla::fallible_t fallible_t;

  typedef char char_type;

  typedef nsCharTraits<char_type> char_traits;
  typedef char_traits::incompatible_char_type incompatible_char_type;

  typedef nsCStringRepr self_type;
  typedef self_type base_string_type;

  typedef nsACString substring_type;
  typedef nsCSubstringTuple substring_tuple_type;
  typedef nsCString string_type;

  typedef nsReadingIterator<char_type> const_iterator;
  typedef nsWritingIterator<char_type> iterator;

  typedef nsCStringComparator comparator_type;

  typedef char_type* char_iterator;
  typedef const char_type* const_char_iterator;

  typedef uint32_t index_type;
  typedef uint32_t size_type;





  const_char_iterator BeginReading() const
  {
    return mData;
  }
  const_char_iterator EndReading() const
  {
    return mData + mLength;
  }





  const_iterator& BeginReading(const_iterator& aIter) const
  {
    aIter.mStart = mData;
    aIter.mEnd = mData + mLength;
    aIter.mPosition = aIter.mStart;
    return aIter;
  }

  const_iterator& EndReading(const_iterator& aIter) const
  {
    aIter.mStart = mData;
    aIter.mEnd = mData + mLength;
    aIter.mPosition = aIter.mEnd;
    return aIter;
  }

  const_char_iterator& BeginReading(const_char_iterator& aIter) const
  {
    return aIter = mData;
  }

  const_char_iterator& EndReading(const_char_iterator& aIter) const
  {
    return aIter = mData + mLength;
  }
  const char_type* Data() const

  {
    return mData;
  }

  size_type Length() const
  {
    return mLength;
  }

  uint32_t Flags() const
  {
    return mFlags;
  }

  bool IsEmpty() const
  {
    return mLength == 0;
  }

  bool IsLiteral() const
  {
    return (mFlags & F_LITERAL) != 0;
  }

  bool IsVoid() const
  {
    return (mFlags & F_VOIDED) != 0;
  }

  bool IsTerminated() const
  {
    return (mFlags & F_TERMINATED) != 0;
  }

  char_type CharAt(index_type aIndex) const
  {
    do { } while(0);
    return mData[aIndex];
  }

  char_type operator[](index_type aIndex) const
  {
    return CharAt(aIndex);
  }

  char_type First() const;

  char_type Last() const;

  size_type CountChar(char_type) const;
  int32_t FindChar(char_type, index_type aOffset = 0) const;

  inline bool Contains(char_type aChar) const
  {
    return FindChar(aChar) != -1;
  }





  bool Equals(const self_type&) const;
  bool Equals(const self_type&, const comparator_type&) const;

  bool Equals(const substring_tuple_type& aTuple) const;
  bool Equals(const substring_tuple_type& aTuple,
                          const comparator_type& aComp) const;

  bool Equals(const char_type* aData) const;
  bool Equals(const char_type* aData,
                          const comparator_type& aComp) const;
  bool EqualsASCII(const char* aData, size_type aLen) const;





  bool EqualsASCII(const char* aData) const;







  template<int N>
  inline bool EqualsLiteral(const char (&aStr)[N]) const
  {
    return EqualsASCII(aStr, N - 1);
  }







  bool LowerCaseEqualsASCII(const char* aData,
                                        size_type aLen) const;
  bool LowerCaseEqualsASCII(const char* aData) const;






  template<int N>
  inline bool LowerCaseEqualsLiteral(const char (&aStr)[N]) const
  {
    return LowerCaseEqualsASCII(aStr, N - 1);
  }




  bool IsDependentOn(const char_type* aStart, const char_type* aEnd) const
  {
    return (aStart < (mData + mLength) && aEnd > mData);
  }

protected:
  nsCStringRepr() = delete;

  constexpr
  nsCStringRepr(char_type* aData, size_type aLength, uint32_t aFlags)
    : mData(aData)
    , mLength(aLength)
    , mFlags(aFlags)
  {
  }

  char_type* mData;
  size_type mLength;
  uint32_t mFlags;

public:






  enum
  {
    F_NONE = 0,


    F_TERMINATED = 1 << 0,
    F_VOIDED = 1 << 1,
    F_SHARED = 1 << 2,
    F_OWNED = 1 << 3,
    F_FIXED = 1 << 4,
    F_LITERAL = 1 << 5,


    F_CLASS_FIXED = 1 << 16
  };
};

}
}
class nsACString : public mozilla::detail::nsCStringRepr
{
public:
  typedef nsACString self_type;


  ~nsACString()
  {
    Finalize();
  }





  char_iterator BeginWriting()
  {
    if (!EnsureMutable()) {
      AllocFailed(mLength);
    }

    return mData;
  }

  char_iterator BeginWriting(const fallible_t&)
  {
    return EnsureMutable() ? mData : char_iterator(0);
  }

  char_iterator EndWriting()
  {
    if (!EnsureMutable()) {
      AllocFailed(mLength);
    }

    return mData + mLength;
  }

  char_iterator EndWriting(const fallible_t&)
  {
    return EnsureMutable() ? (mData + mLength) : char_iterator(0);
  }

  char_iterator& BeginWriting(char_iterator& aIter)
  {
    return aIter = BeginWriting();
  }

  char_iterator& BeginWriting(char_iterator& aIter, const fallible_t& aFallible)
  {
    return aIter = BeginWriting(aFallible);
  }

  char_iterator& EndWriting(char_iterator& aIter)
  {
    return aIter = EndWriting();
  }

  char_iterator& EndWriting(char_iterator& aIter, const fallible_t& aFallible)
  {
    return aIter = EndWriting(aFallible);
  }





  iterator& BeginWriting(iterator& aIter)
  {
    char_type* data = BeginWriting();
    aIter.mStart = data;
    aIter.mEnd = data + mLength;
    aIter.mPosition = aIter.mStart;
    return aIter;
  }

  iterator& EndWriting(iterator& aIter)
  {
    char_type* data = BeginWriting();
    aIter.mStart = data;
    aIter.mEnd = data + mLength;
    aIter.mPosition = aIter.mEnd;
    return aIter;
  }





  void Assign(char_type aChar);
  __attribute__ ((warn_unused_result)) bool Assign(char_type aChar, const fallible_t&);

  void Assign(const char_type* aData);
  __attribute__ ((warn_unused_result)) bool Assign(const char_type* aData,
                                       const fallible_t&);

  void Assign(const char_type* aData, size_type aLength);
  __attribute__ ((warn_unused_result)) bool Assign(const char_type* aData,
                                       size_type aLength, const fallible_t&);

  void Assign(const self_type&);
  __attribute__ ((warn_unused_result)) bool Assign(const self_type&, const fallible_t&);

  void Assign(const substring_tuple_type&);
  __attribute__ ((warn_unused_result)) bool Assign(const substring_tuple_type&,
                                       const fallible_t&);
  void AssignASCII(const char* aData, size_type aLength);
  __attribute__ ((warn_unused_result)) bool AssignASCII(const char* aData,
                                            size_type aLength,
                                            const fallible_t&);

  void AssignASCII(const char* aData)
  {
    AssignASCII(aData, mozilla::AssertedCast<size_type, size_t>(strlen(aData)));
  }
  __attribute__ ((warn_unused_result)) bool AssignASCII(const char* aData,
                                            const fallible_t& aFallible)
  {
    return AssignASCII(aData,
                       mozilla::AssertedCast<size_type, size_t>(strlen(aData)),
                       aFallible);
  }







  template<int N>
  void AssignLiteral(const char_type (&aStr)[N])
  {
    AssignLiteral(aStr, N - 1);
  }
  self_type& operator=(char_type aChar)
  {
    Assign(aChar);
    return *this;
  }
  self_type& operator=(const char_type* aData)
  {
    Assign(aData);
    return *this;
  }







  self_type& operator=(const self_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_tuple_type& aTuple)
  {
    Assign(aTuple);
    return *this;
  }

  void Adopt(char_type* aData, size_type aLength = size_type(-1));






  void Replace(index_type aCutStart, size_type aCutLength,
                           char_type aChar);
  __attribute__ ((warn_unused_result)) bool Replace(index_type aCutStart,
                                        size_type aCutLength,
                                        char_type aChar,
                                        const fallible_t&);
  void Replace(index_type aCutStart, size_type aCutLength,
                           const char_type* aData,
                           size_type aLength = size_type(-1));
  __attribute__ ((warn_unused_result)) bool Replace(index_type aCutStart,
                                        size_type aCutLength,
                                        const char_type* aData,
                                        size_type aLength,
                                        const fallible_t&);
  void Replace(index_type aCutStart, size_type aCutLength,
               const self_type& aStr)
  {
    Replace(aCutStart, aCutLength, aStr.Data(), aStr.Length());
  }
  __attribute__ ((warn_unused_result)) bool Replace(index_type aCutStart,
                            size_type aCutLength,
                            const self_type& aStr,
                            const fallible_t& aFallible)
  {
    return Replace(aCutStart, aCutLength, aStr.Data(), aStr.Length(),
                   aFallible);
  }
  void Replace(index_type aCutStart, size_type aCutLength,
                           const substring_tuple_type& aTuple);

  void ReplaceASCII(index_type aCutStart, size_type aCutLength,
                                const char* aData,
                                size_type aLength = size_type(-1));

  __attribute__ ((warn_unused_result)) bool ReplaceASCII(index_type aCutStart, size_type aCutLength,
                                             const char* aData,
                                             size_type aLength,
                                             const fallible_t&);




  template<int N>
  void ReplaceLiteral(index_type aCutStart, size_type aCutLength,
                      const char_type (&aStr)[N])
  {
    ReplaceLiteral(aCutStart, aCutLength, aStr, N - 1);
  }

  void Append(char_type aChar)
  {
    Replace(mLength, 0, aChar);
  }
  __attribute__ ((warn_unused_result)) bool Append(char_type aChar, const fallible_t& aFallible)
  {
    return Replace(mLength, 0, aChar, aFallible);
  }
  void Append(const char_type* aData, size_type aLength = size_type(-1))
  {
    Replace(mLength, 0, aData, aLength);
  }
  __attribute__ ((warn_unused_result)) bool Append(const char_type* aData, size_type aLength,
                           const fallible_t& aFallible)
  {
    return Replace(mLength, 0, aData, aLength, aFallible);
  }
  void Append(const self_type& aStr)
  {
    Replace(mLength, 0, aStr);
  }
  __attribute__ ((warn_unused_result)) bool Append(const self_type& aStr, const fallible_t& aFallible)
  {
    return Replace(mLength, 0, aStr, aFallible);
  }
  void Append(const substring_tuple_type& aTuple)
  {
    Replace(mLength, 0, aTuple);
  }

  void AppendASCII(const char* aData, size_type aLength = size_type(-1))
  {
    ReplaceASCII(mLength, 0, aData, aLength);
  }

  __attribute__ ((warn_unused_result)) bool AppendASCII(const char* aData, const fallible_t& aFallible)
  {
    return ReplaceASCII(mLength, 0, aData, size_type(-1), aFallible);
  }

  __attribute__ ((warn_unused_result)) bool AppendASCII(const char* aData, size_type aLength, const fallible_t& aFallible)
  {
    return ReplaceASCII(mLength, 0, aData, aLength, aFallible);
  }







  void AppendPrintf(const char* aFormat, ...) __attribute__ ((format (printf, 2, 3)));
  void AppendPrintf(const char* aFormat, va_list aAp);
  void AppendInt(int32_t aInteger)
  {
    AppendPrintf("%" "d", aInteger);
  }
  void AppendInt(int32_t aInteger, int aRadix)
  {
    if (aRadix == 10) {
      AppendPrintf("%" "d", aInteger);
    } else {
      AppendPrintf(aRadix == 8 ? "%" "o" : "%" "x",
                   static_cast<uint32_t>(aInteger));
    }
  }
  void AppendInt(uint32_t aInteger)
  {
    AppendPrintf("%" "u", aInteger);
  }
  void AppendInt(uint32_t aInteger, int aRadix)
  {
    AppendPrintf(aRadix == 10 ? "%" "u" : aRadix == 8 ? "%" "o" : "%" "x",
                 aInteger);
  }
  void AppendInt(int64_t aInteger)
  {
    AppendPrintf("%" "l" "d", aInteger);
  }
  void AppendInt(int64_t aInteger, int aRadix)
  {
    if (aRadix == 10) {
      AppendPrintf("%" "l" "d", aInteger);
    } else {
      AppendPrintf(aRadix == 8 ? "%" "l" "o" : "%" "l" "x",
                   static_cast<uint64_t>(aInteger));
    }
  }
  void AppendInt(uint64_t aInteger)
  {
    AppendPrintf("%" "l" "u", aInteger);
  }
  void AppendInt(uint64_t aInteger, int aRadix)
  {
    AppendPrintf(aRadix == 10 ? "%" "l" "u" : aRadix == 8 ? "%" "l" "o" : "%" "l" "x",
                 aInteger);
  }




  void AppendFloat(float aFloat);
  void AppendFloat(double aFloat);
public:




  template<int N>
  void AppendLiteral(const char_type (&aStr)[N])
  {
    ReplaceLiteral(mLength, 0, aStr, N - 1);
  }
  self_type& operator+=(char_type aChar)
  {
    Append(aChar);
    return *this;
  }
  self_type& operator+=(const char_type* aData)
  {
    Append(aData);
    return *this;
  }







  self_type& operator+=(const self_type& aStr)
  {
    Append(aStr);
    return *this;
  }
  self_type& operator+=(const substring_tuple_type& aTuple)
  {
    Append(aTuple);
    return *this;
  }

  void Insert(char_type aChar, index_type aPos)
  {
    Replace(aPos, 0, aChar);
  }
  void Insert(const char_type* aData, index_type aPos,
              size_type aLength = size_type(-1))
  {
    Replace(aPos, 0, aData, aLength);
  }







  void Insert(const self_type& aStr, index_type aPos)
  {
    Replace(aPos, 0, aStr);
  }
  void Insert(const substring_tuple_type& aTuple, index_type aPos)
  {
    Replace(aPos, 0, aTuple);
  }




  template<int N>
  void InsertLiteral(const char_type (&aStr)[N], index_type aPos)
  {
    ReplaceLiteral(aPos, 0, aStr, N - 1);
  }

  void Cut(index_type aCutStart, size_type aCutLength)
  {
    Replace(aCutStart, aCutLength, char_traits::sEmptyBuffer, 0);
  }

  nsCSubstringSplitter Split(const char_type aChar) const;
  void SetCapacity(size_type aNewCapacity);
  __attribute__ ((warn_unused_result)) bool SetCapacity(size_type aNewCapacity,
                                            const fallible_t&);

  void SetLength(size_type aNewLength);
  __attribute__ ((warn_unused_result)) bool SetLength(size_type aNewLength,
                                          const fallible_t&);

  void Truncate(size_type aNewLength = 0)
  {
    do { } while(0);
    SetLength(aNewLength);
  }
  inline size_type GetData(const char_type** aData) const
  {
    *aData = mData;
    return mLength;
  }
  size_type GetMutableData(char_type** aData, size_type aNewLen = size_type(-1))
  {
    if (!EnsureMutable(aNewLen)) {
      AllocFailed(aNewLen == size_type(-1) ? mLength : aNewLen);
    }

    *aData = mData;
    return mLength;
  }

  size_type GetMutableData(char_type** aData, size_type aNewLen, const fallible_t&)
  {
    if (!EnsureMutable(aNewLen)) {
      *aData = nullptr;
      return 0;
    }

    *aData = mData;
    return mLength;
  }
  operator mozilla::Span<char_type>()
  {
    return mozilla::MakeSpan(BeginWriting(), Length());
  }

  operator mozilla::Span<const char_type>() const
  {
    return mozilla::MakeSpan(BeginReading(), Length());
  }

  void Append(mozilla::Span<const char_type> aSpan)
  {
    auto len = aSpan.Length();
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(len <= mozilla::MaxValue<size_type>::value)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(len <= mozilla::MaxValue<size_type>::value))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "len <= mozilla::MaxValue<size_type>::value" ")"); do { *((volatile int*) __null) = 944; ::abort(); } while (0); } } while (0);
    Append(aSpan.Elements(), len);
  }

  __attribute__ ((warn_unused_result)) bool Append(mozilla::Span<const char_type> aSpan,
                           const fallible_t& aFallible)
  {
    auto len = aSpan.Length();
    if (len > mozilla::MaxValue<size_type>::value) {
      return false;
    }
    return Append(aSpan.Elements(), len, aFallible);
  }


  operator mozilla::Span<uint8_t>()
  {
    return mozilla::MakeSpan(reinterpret_cast<uint8_t*>(BeginWriting()),
                             Length());
  }

  operator mozilla::Span<const uint8_t>() const
  {
    return mozilla::MakeSpan(reinterpret_cast<const uint8_t*>(BeginReading()),
                             Length());
  }

  void Append(mozilla::Span<const uint8_t> aSpan)
  {
    auto len = aSpan.Length();
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(len <= mozilla::MaxValue<size_type>::value)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(len <= mozilla::MaxValue<size_type>::value))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "len <= mozilla::MaxValue<size_type>::value" ")"); do { *((volatile int*) __null) = 974; ::abort(); } while (0); } } while (0);
    Append(reinterpret_cast<const char*>(aSpan.Elements()), len);
  }

  __attribute__ ((warn_unused_result)) bool Append(mozilla::Span<const uint8_t> aSpan,
                           const fallible_t& aFallible)
  {
    auto len = aSpan.Length();
    if (len > mozilla::MaxValue<size_type>::value) {
      return false;
    }
    return Append(
      reinterpret_cast<const char*>(aSpan.Elements()), len, aFallible);
  }







  void SetIsVoid(bool);
  void StripChar(char_type aChar, int32_t aOffset = 0);
  void StripChars(const char_type* aChars, uint32_t aOffset = 0);





  void ForgetSharedBuffer()
  {
    if (mFlags & nsSubstring::F_SHARED) {
      mData = char_traits::sEmptyBuffer;
      mLength = 0;
      mFlags = F_TERMINATED;
    }
  }

public:





               nsACString(const substring_tuple_type& aTuple)
    : nsCStringRepr(nullptr, 0, F_NONE)
  {
    Assign(aTuple);
  }

  size_t SizeOfExcludingThisIfUnshared(mozilla::MallocSizeOf aMallocSizeOf)
  const;
  size_t SizeOfIncludingThisIfUnshared(mozilla::MallocSizeOf aMallocSizeOf)
  const;







  size_t SizeOfExcludingThisEvenIfShared(mozilla::MallocSizeOf aMallocSizeOf)
  const;
  size_t SizeOfIncludingThisEvenIfShared(mozilla::MallocSizeOf aMallocSizeOf)
  const;

  template<class T>
  void NS_ABORT_OOM(T)
  {
    struct never {};
    static_assert(mozilla::IsSame<T, never>::value,
      "In string classes, use AllocFailed to account for sizeof(char_type). "
      "Use the global ::NS_ABORT_OOM if you really have a count of bytes.");
  }

  __attribute__((always_inline)) inline void AllocFailed(size_t aLength)
  {
    ::NS_ABORT_OOM(aLength * sizeof(char_type));
  }

protected:


  nsACString()
    : nsCStringRepr(char_traits::sEmptyBuffer, 0, F_TERMINATED)
  {
  }



  nsACString(const self_type& aStr)
    : nsCStringRepr(aStr.mData, aStr.mLength,
                          aStr.mFlags & (F_TERMINATED | F_VOIDED))
  {
  }
  nsACString(char_type* aData, size_type aLength, uint32_t aFlags)
    : nsCStringRepr(aData, aLength, aFlags)
  {
  }







  void Finalize();
  bool MutatePrep(size_type aCapacity,
                              char_type** aOldData, uint32_t* aOldFlags);
  __attribute__ ((warn_unused_result)) bool ReplacePrep(index_type aCutStart,
                                size_type aCutLength,
                                size_type aNewLength);

  __attribute__ ((warn_unused_result)) bool ReplacePrepInternal(
    index_type aCutStart,
    size_type aCutLength,
    size_type aNewFragLength,
    size_type aNewTotalLength);
  size_type Capacity() const;





  __attribute__ ((warn_unused_result)) bool EnsureMutable(
    size_type aNewLen = size_type(-1));




  static __attribute__ ((warn_unused_result)) bool CheckCapacity(size_type aCapacity) {
    if (aCapacity > kMaxCapacity) {


      do { } while(0);
      return false;
    }

    return true;
  }




  void SetDataFlags(uint32_t aDataFlags)
  {
    do { } while(0);
    mFlags = aDataFlags | (mFlags & 0xFFFF0000);
  }

  void ReplaceLiteral(index_type aCutStart, size_type aCutLength,
                                  const char_type* aData, size_type aLength);

  static const size_type kMaxCapacity;
public:



  void AssignLiteral(const char_type* aData, size_type aLength);
};

static_assert(sizeof(nsACString) ==
              sizeof(mozilla::detail::nsCStringRepr),
              "Don't add new data fields to nsTSubstring_CharT. "
              "Add to nsTStringRepr_CharT instead.");

int
Compare(const nsACString::base_string_type& aLhs,
        const nsACString::base_string_type& aRhs,
        const nsCStringComparator& = nsDefaultCStringComparator());


inline bool
operator!=(const nsACString::base_string_type& aLhs,
           const nsACString::base_string_type& aRhs)
{
  return !aLhs.Equals(aRhs);
}

inline bool
operator!=(const nsACString::base_string_type& aLhs,
           const nsACString::char_type* aRhs)
{
  return !aLhs.Equals(aRhs);
}

inline bool
operator<(const nsACString::base_string_type& aLhs,
          const nsACString::base_string_type& aRhs)
{
  return Compare(aLhs, aRhs) < 0;
}

inline bool
operator<=(const nsACString::base_string_type& aLhs,
           const nsACString::base_string_type& aRhs)
{
  return Compare(aLhs, aRhs) <= 0;
}

inline bool
operator==(const nsACString::base_string_type& aLhs,
           const nsACString::base_string_type& aRhs)
{
  return aLhs.Equals(aRhs);
}

inline bool
operator==(const nsACString::base_string_type& aLhs,
           const nsACString::char_type* aRhs)
{
  return aLhs.Equals(aRhs);
}


inline bool
operator>=(const nsACString::base_string_type& aLhs,
           const nsACString::base_string_type& aRhs)
{
  return Compare(aLhs, aRhs) >= 0;
}

inline bool
operator>(const nsACString::base_string_type& aLhs,
          const nsACString::base_string_type& aRhs)
{
  return Compare(aLhs, aRhs) > 0;
}



class nsCSubstringSplitter
{
  typedef nsACString::size_type size_type;
  typedef nsACString::char_type char_type;

  class nsTSubstringSplit_Iter
  {
  public:
    nsTSubstringSplit_Iter(const nsCSubstringSplitter& aObj,
                           size_type aPos)
      : mObj(aObj)
      , mPos(aPos)
    {
    }

    bool operator!=(const nsTSubstringSplit_Iter& other) const
    {
      return mPos != other.mPos;
    }

    const nsDependentCSubstring& operator*() const;

    const nsTSubstringSplit_Iter& operator++()
    {
      ++mPos;
      return *this;
    }

  private:
    const nsCSubstringSplitter& mObj;
    size_type mPos;
  };

private:
  const nsACString* const mStr;
  mozilla::UniquePtr<nsDependentCSubstring[]> mArray;
  size_type mArraySize;
  const char_type mDelim;

public:
  nsCSubstringSplitter(const nsACString* aStr, char_type aDelim);

  nsTSubstringSplit_Iter begin() const
  {
    return nsTSubstringSplit_Iter(*this, 0);
  }

  nsTSubstringSplit_Iter end() const
  {
    return nsTSubstringSplit_Iter(*this, mArraySize);
  }

  const nsDependentCSubstring& Get(const size_type index) const
  {
    do { } while (0);
    return mArray[index];
  }
};




namespace mozilla {

inline Span<char>
MakeSpan(nsACString& aString)
{
  return aString;
}

inline Span<const char>
MakeSpan(const nsACString& aString)
{
  return aString;
}

}






class nsCaseInsensitiveCStringComparator
  : public nsCStringComparator
{
public:
  nsCaseInsensitiveCStringComparator()
  {
  }
  typedef char char_type;

  virtual int operator()(const char_type*, const char_type*,
                         uint32_t, uint32_t) const override;
};

class nsCaseInsensitiveCStringArrayComparator
{
public:
  template<class A, class B>
  bool Equals(const A& aStrA, const B& aStrB) const
  {
    return aStrA.Equals(aStrB, nsCaseInsensitiveCStringComparator());
  }
};






class nsSubstringTuple
{
public:

  typedef char16_t char_type;
  typedef nsCharTraits<char_type> char_traits;

  typedef nsSubstringTuple self_type;
  typedef mozilla::detail::nsStringRepr base_string_type;
  typedef uint32_t size_type;

public:

  nsSubstringTuple(const base_string_type* aStrA,
                          const base_string_type* aStrB)
    : mHead(nullptr)
    , mFragA(aStrA)
    , mFragB(aStrB)
  {
  }

  nsSubstringTuple(const self_type& aHead,
                          const base_string_type* aStrB)
    : mHead(&aHead)
    , mFragA(nullptr)
    , mFragB(aStrB)
  {
  }




  size_type Length() const;






  void WriteTo(char_type* aBuf, uint32_t aBufLen) const;





  bool IsDependentOn(const char_type* aStart, const char_type* aEnd) const;

private:

  const self_type* const mHead;
  const base_string_type* const mFragA;
  const base_string_type* const mFragB;
};

inline const nsSubstringTuple
operator+(const nsSubstringTuple::base_string_type& aStrA,
          const nsSubstringTuple::base_string_type& aStrB)
{
  return nsSubstringTuple(&aStrA, &aStrB);
}

inline const nsSubstringTuple
operator+(const nsSubstringTuple& aHead,
          const nsSubstringTuple::base_string_type& aStrB)
{
  return nsSubstringTuple(aHead, &aStrB);
}


class nsCSubstringTuple
{
public:

  typedef char char_type;
  typedef nsCharTraits<char_type> char_traits;

  typedef nsCSubstringTuple self_type;
  typedef mozilla::detail::nsCStringRepr base_string_type;
  typedef uint32_t size_type;

public:

  nsCSubstringTuple(const base_string_type* aStrA,
                          const base_string_type* aStrB)
    : mHead(nullptr)
    , mFragA(aStrA)
    , mFragB(aStrB)
  {
  }

  nsCSubstringTuple(const self_type& aHead,
                          const base_string_type* aStrB)
    : mHead(&aHead)
    , mFragA(nullptr)
    , mFragB(aStrB)
  {
  }




  size_type Length() const;






  void WriteTo(char_type* aBuf, uint32_t aBufLen) const;





  bool IsDependentOn(const char_type* aStart, const char_type* aEnd) const;

private:

  const self_type* const mHead;
  const base_string_type* const mFragA;
  const base_string_type* const mFragB;
};

inline const nsCSubstringTuple
operator+(const nsCSubstringTuple::base_string_type& aStrA,
          const nsCSubstringTuple::base_string_type& aStrB)
{
  return nsCSubstringTuple(&aStrA, &aStrB);
}

inline const nsCSubstringTuple
operator+(const nsCSubstringTuple& aHead,
          const nsCSubstringTuple::base_string_type& aStrB)
{
  return nsCSubstringTuple(aHead, &aStrB);
}
class nsDependentSubstring : public nsAString
{
public:

  typedef nsDependentSubstring self_type;

public:

  void Rebind(const substring_type&, uint32_t aStartPos,
              uint32_t aLength = size_type(-1));

  void Rebind(const char_type* aData, size_type aLength);

  void Rebind(const char_type* aStart, const char_type* aEnd);

  nsDependentSubstring(const substring_type& aStr, uint32_t aStartPos,
                              uint32_t aLength = size_type(-1))
    : substring_type()
  {
    Rebind(aStr, aStartPos, aLength);
  }

  nsDependentSubstring(const char_type* aData, size_type aLength)
    : substring_type(const_cast<char_type*>(aData), aLength, F_NONE)
  {
  }

  nsDependentSubstring(const char_type* aStart, const char_type* aEnd);
  nsDependentSubstring(const const_iterator& aStart,
                              const const_iterator& aEnd);


  nsDependentSubstring()
    : substring_type()
  {
  }



private:

  void operator=(const self_type&);
};

inline const nsDependentSubstring
Substring(const nsAString& aStr, uint32_t aStartPos,
          uint32_t aLength = uint32_t(-1))
{
  return nsDependentSubstring(aStr, aStartPos, aLength);
}

inline const nsDependentSubstring
Substring(const nsReadingIterator<char16_t>& aStart,
          const nsReadingIterator<char16_t>& aEnd)
{
  return nsDependentSubstring(aStart.get(), aEnd.get());
}

inline const nsDependentSubstring
Substring(const char16_t* aData, uint32_t aLength)
{
  return nsDependentSubstring(aData, aLength);
}

const nsDependentSubstring
Substring(const char16_t* aStart, const char16_t* aEnd);

inline const nsDependentSubstring
StringHead(const nsAString& aStr, uint32_t aCount)
{
  return nsDependentSubstring(aStr, 0, aCount);
}

inline const nsDependentSubstring
StringTail(const nsAString& aStr, uint32_t aCount)
{
  return nsDependentSubstring(aStr, aStr.Length() - aCount, aCount);
}


class nsDependentCSubstring : public nsACString
{
public:

  typedef nsDependentCSubstring self_type;

public:

  void Rebind(const substring_type&, uint32_t aStartPos,
              uint32_t aLength = size_type(-1));

  void Rebind(const char_type* aData, size_type aLength);

  void Rebind(const char_type* aStart, const char_type* aEnd);

  nsDependentCSubstring(const substring_type& aStr, uint32_t aStartPos,
                              uint32_t aLength = size_type(-1))
    : substring_type()
  {
    Rebind(aStr, aStartPos, aLength);
  }

  nsDependentCSubstring(const char_type* aData, size_type aLength)
    : substring_type(const_cast<char_type*>(aData), aLength, F_NONE)
  {
  }

  nsDependentCSubstring(const char_type* aStart, const char_type* aEnd);
  nsDependentCSubstring(const const_iterator& aStart,
                              const const_iterator& aEnd);


  nsDependentCSubstring()
    : substring_type()
  {
  }



private:

  void operator=(const self_type&);
};

inline const nsDependentCSubstring
Substring(const nsACString& aStr, uint32_t aStartPos,
          uint32_t aLength = uint32_t(-1))
{
  return nsDependentCSubstring(aStr, aStartPos, aLength);
}

inline const nsDependentCSubstring
Substring(const nsReadingIterator<char>& aStart,
          const nsReadingIterator<char>& aEnd)
{
  return nsDependentCSubstring(aStart.get(), aEnd.get());
}

inline const nsDependentCSubstring
Substring(const char* aData, uint32_t aLength)
{
  return nsDependentCSubstring(aData, aLength);
}

const nsDependentCSubstring
Substring(const char* aStart, const char* aEnd);

inline const nsDependentCSubstring
StringHead(const nsACString& aStr, uint32_t aCount)
{
  return nsDependentCSubstring(aStr, 0, aCount);
}

inline const nsDependentCSubstring
StringTail(const nsACString& aStr, uint32_t aCount)
{
  return nsDependentCSubstring(aStr, aStr.Length() - aCount, aCount);
}
inline size_t
Distance(const nsReadingIterator<char16_t>& aStart,
         const nsReadingIterator<char16_t>& aEnd)
{
  do { } while (0);
  return static_cast<size_t>(aEnd.get() - aStart.get());
}
inline size_t
Distance(const nsReadingIterator<char>& aStart,
         const nsReadingIterator<char>& aEnd)
{
  do { } while (0);
  return static_cast<size_t>(aEnd.get() - aStart.get());
}

void LossyCopyUTF16toASCII(const nsAString& aSource, nsACString& aDest);
void CopyASCIItoUTF16(const nsACString& aSource, nsAString& aDest);

void LossyCopyUTF16toASCII(const char16ptr_t aSource, nsACString& aDest);
void CopyASCIItoUTF16(const char* aSource, nsAString& aDest);

void CopyUTF16toUTF8(const nsAString& aSource, nsACString& aDest);
__attribute__ ((warn_unused_result)) bool CopyUTF16toUTF8(const nsAString& aSource, nsACString& aDest,
                                  const mozilla::fallible_t&);
void CopyUTF8toUTF16(const nsACString& aSource, nsAString& aDest);

void CopyUTF16toUTF8(const char16ptr_t aSource, nsACString& aDest);
void CopyUTF8toUTF16(const char* aSource, nsAString& aDest);

void LossyAppendUTF16toASCII(const nsAString& aSource, nsACString& aDest);
void AppendASCIItoUTF16(const nsACString& aSource, nsAString& aDest);
__attribute__ ((warn_unused_result)) bool AppendASCIItoUTF16(const nsACString& aSource,
                                     nsAString& aDest,
                                     const mozilla::fallible_t&);

void LossyAppendUTF16toASCII(const char16ptr_t aSource, nsACString& aDest);
__attribute__ ((warn_unused_result)) bool AppendASCIItoUTF16(const char* aSource,
                                     nsAString& aDest,
                                     const mozilla::fallible_t&);
void AppendASCIItoUTF16(const char* aSource, nsAString& aDest);

void AppendUTF16toUTF8(const nsAString& aSource, nsACString& aDest);
__attribute__ ((warn_unused_result)) bool AppendUTF16toUTF8(const nsAString& aSource,
                                    nsACString& aDest,
                                    const mozilla::fallible_t&);
void AppendUTF8toUTF16(const nsACString& aSource, nsAString& aDest);
__attribute__ ((warn_unused_result)) bool AppendUTF8toUTF16(const nsACString& aSource,
                                    nsAString& aDest,
                                    const mozilla::fallible_t&);

void AppendUTF16toUTF8(const char16ptr_t aSource, nsACString& aDest);
void AppendUTF8toUTF16(const char* aSource, nsAString& aDest);
char* ToNewCString(const nsAString& aSource);
char* ToNewCString(const nsACString& aSource);
char* ToNewUTF8String(const nsAString& aSource, uint32_t* aUTF8Count = nullptr);
char16_t* ToNewUnicode(const nsAString& aSource);
char16_t* ToNewUnicode(const nsACString& aSource);
uint32_t CalcUTF8ToUnicodeLength(const nsACString& aSource);
char16_t* UTF8ToUnicodeBuffer(const nsACString& aSource,
                              char16_t* aBuffer,
                              uint32_t* aUTF16Count = nullptr);
char16_t* UTF8ToNewUnicode(const nsACString& aSource,
                           uint32_t* aUTF16Count = nullptr);
char16_t* CopyUnicodeTo(const nsAString& aSource,
                        uint32_t aSrcOffset,
                        char16_t* aDest,
                        uint32_t aLength);
void CopyUnicodeTo(const nsAString::const_iterator& aSrcStart,
                   const nsAString::const_iterator& aSrcEnd,
                   nsAString& aDest);
void AppendUnicodeTo(const nsAString::const_iterator& aSrcStart,
                     const nsAString::const_iterator& aSrcEnd,
                     nsAString& aDest);






bool IsASCII(const nsAString& aString);






bool IsASCII(const nsACString& aString);
bool IsUTF8(const nsACString& aString, bool aRejectNonChar = true);

bool ParseString(const nsACString& aAstring, char aDelimiter,
                 nsTArray<nsCString>& aArray);




void ToUpperCase(nsACString&);

void ToLowerCase(nsACString&);

void ToUpperCase(nsCSubstring&);

void ToLowerCase(nsCSubstring&);




void ToUpperCase(const nsACString& aSource, nsACString& aDest);

void ToLowerCase(const nsACString& aSource, nsACString& aDest);
bool FindInReadable(const nsAString& aPattern, nsAString::const_iterator&,
                    nsAString::const_iterator&,
                    const nsStringComparator& = nsDefaultStringComparator());
bool FindInReadable(const nsACString& aPattern, nsACString::const_iterator&,
                    nsACString::const_iterator&,
                    const nsCStringComparator& = nsDefaultCStringComparator());



inline bool
FindInReadable(const nsAString& aPattern, const nsAString& aSource,
               const nsStringComparator& aCompare = nsDefaultStringComparator())
{
  nsAString::const_iterator start, end;
  aSource.BeginReading(start);
  aSource.EndReading(end);
  return FindInReadable(aPattern, start, end, aCompare);
}

inline bool
FindInReadable(const nsACString& aPattern, const nsACString& aSource,
               const nsCStringComparator& aCompare = nsDefaultCStringComparator())
{
  nsACString::const_iterator start, end;
  aSource.BeginReading(start);
  aSource.EndReading(end);
  return FindInReadable(aPattern, start, end, aCompare);
}


bool CaseInsensitiveFindInReadable(const nsACString& aPattern,
                                   nsACString::const_iterator&,
                                   nsACString::const_iterator&);







bool RFindInReadable(const nsAString& aPattern, nsAString::const_iterator&,
                     nsAString::const_iterator&,
                     const nsStringComparator& = nsDefaultStringComparator());
bool RFindInReadable(const nsACString& aPattern, nsACString::const_iterator&,
                     nsACString::const_iterator&,
                     const nsCStringComparator& = nsDefaultCStringComparator());
bool FindCharInReadable(char16_t aChar, nsAString::const_iterator& aSearchStart,
                        const nsAString::const_iterator& aSearchEnd);
bool FindCharInReadable(char aChar, nsACString::const_iterator& aSearchStart,
                        const nsACString::const_iterator& aSearchEnd);




uint32_t CountCharInReadable(const nsAString& aStr,
                             char16_t aChar);
uint32_t CountCharInReadable(const nsACString& aStr,
                             char aChar);

bool StringBeginsWith(const nsAString& aSource, const nsAString& aSubstring);
bool StringBeginsWith(const nsAString& aSource, const nsAString& aSubstring,
                      const nsStringComparator& aComparator);
bool StringBeginsWith(const nsACString& aSource, const nsACString& aSubstring);
bool StringBeginsWith(const nsACString& aSource, const nsACString& aSubstring,
                      const nsCStringComparator& aComparator);
bool StringEndsWith(const nsAString& aSource, const nsAString& aSubstring);
bool StringEndsWith(const nsAString& aSource, const nsAString& aSubstring,
                    const nsStringComparator& aComparator);
bool StringEndsWith(const nsACString& aSource, const nsACString& aSubstring);
bool StringEndsWith(const nsACString& aSource, const nsACString& aSubstring,
                    const nsCStringComparator& aComparator);

const nsAFlatString& EmptyString();
const nsAFlatCString& EmptyCString();

const nsAFlatString& NullString();
const nsAFlatCString& NullCString();
int32_t CompareUTF8toUTF16(const nsASingleFragmentCString& aUTF8String,
                           const nsASingleFragmentString& aUTF16String);

void AppendUCS4ToUTF16(const uint32_t aSource, nsAString& aDest);

template<class T>
inline bool
EnsureStringLength(T& aStr, uint32_t aLen)
{
  aStr.SetLength(aLen);
  return (aStr.Length() == aLen);
}
class nsString : public nsAString
{
public:

  typedef nsString self_type;

public:





  nsString()
    : substring_type()
  {
  }

  explicit
  nsString(const char_type* aData, size_type aLength = size_type(-1))
    : substring_type()
  {
    Assign(aData, aLength);
  }
  nsString(const self_type& aStr)
    : substring_type()
  {
    Assign(aStr);
  }

               nsString(const substring_tuple_type& aTuple)
    : substring_type()
  {
    Assign(aTuple);
  }

  explicit
  nsString(const substring_type& aReadable)
    : substring_type()
  {
    Assign(aReadable);
  }



  self_type& operator=(char_type aChar)
  {
    Assign(aChar);
    return *this;
  }
  self_type& operator=(const char_type* aData)
  {
    Assign(aData);
    return *this;
  }
  self_type& operator=(const self_type& aStr)
  {
    Assign(aStr);
    return *this;
  }







  self_type& operator=(const substring_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_tuple_type& aTuple)
  {
    Assign(aTuple);
    return *this;
  }
  const char_type* get() const

  {
    return mData;
  }
  char_type CharAt(index_type aIndex) const
  {
    do { } while(0);
    return mData[aIndex];
  }

  char_type operator[](index_type aIndex) const
  {
    return CharAt(aIndex);
  }
  int32_t Find(const nsCString& aString, bool aIgnoreCase = false,
               int32_t aOffset = 0, int32_t aCount = -1) const;
  int32_t Find(const char* aString, bool aIgnoreCase = false,
               int32_t aOffset = 0, int32_t aCount = -1) const;


  int32_t Find(const nsAFlatString& aString, int32_t aOffset = 0,
               int32_t aCount = -1) const;
  int32_t Find(const char16_t* aString, int32_t aOffset = 0,
               int32_t aCount = -1) const;
  int32_t RFind(const nsCString& aString, bool aIgnoreCase = false,
                int32_t aOffset = -1, int32_t aCount = -1) const;
  int32_t RFind(const char* aCString, bool aIgnoreCase = false,
                int32_t aOffset = -1, int32_t aCount = -1) const;


  int32_t RFind(const nsAFlatString& aString, int32_t aOffset = -1,
                int32_t aCount = -1) const;
  int32_t RFind(const char16_t* aString, int32_t aOffset = -1,
                int32_t aCount = -1) const;
  int32_t RFindChar(char16_t aChar, int32_t aOffset = -1,
                    int32_t aCount = -1) const;
  int32_t FindCharInSet(const char* aString, int32_t aOffset = 0) const;
  int32_t FindCharInSet(const self_type& aString, int32_t aOffset = 0) const
  {
    return FindCharInSet(aString.get(), aOffset);
  }


  int32_t FindCharInSet(const char16_t* aString, int32_t aOffset = 0) const;
  int32_t RFindCharInSet(const char_type* aString, int32_t aOffset = -1) const;
  int32_t RFindCharInSet(const self_type& aString, int32_t aOffset = -1) const
  {
    return RFindCharInSet(aString.get(), aOffset);
  }
  bool EqualsIgnoreCase(const char* aString, int32_t aCount = -1) const;
  double ToDouble(nsresult* aErrorCode) const;







  float ToFloat(nsresult* aErrorCode) const
  {
    return (float)ToDouble(aErrorCode);
  }
  int32_t ToInteger(nsresult* aErrorCode, uint32_t aRadix = (10)) const;







  int64_t ToInteger64(nsresult* aErrorCode, uint32_t aRadix = (10)) const;
  size_type Mid(self_type& aResult, uint32_t aStartPos, uint32_t aCount) const;

  size_type Left(self_type& aResult, size_type aCount) const
  {
    return Mid(aResult, 0, aCount);
  }

  size_type Right(self_type& aResult, size_type aCount) const
  {
    aCount = XPCOM_MIN(mLength, aCount);
    return Mid(aResult, mLength - aCount, aCount);
  }
  bool SetCharAt(char16_t aChar, uint32_t aIndex);
  using nsAString::StripChars;

  void StripChars(const char* aSet);
  bool StripChars(const char* aSet, const fallible_t&);





  void StripWhitespace();
  bool StripWhitespace(const fallible_t&);






  void ReplaceChar(char_type aOldChar, char_type aNewChar);
  void ReplaceChar(const char* aSet, char_type aNewChar);

  void ReplaceChar(const char16_t* aSet, char16_t aNewChar);






  void ReplaceSubstring(const self_type& aTarget, const self_type& aNewValue);
  void ReplaceSubstring(const char_type* aTarget, const char_type* aNewValue);
  __attribute__ ((warn_unused_result)) bool ReplaceSubstring(const self_type& aTarget,
                                     const self_type& aNewValue,
                                     const fallible_t&);
  __attribute__ ((warn_unused_result)) bool ReplaceSubstring(const char_type* aTarget,
                                     const char_type* aNewValue,
                                     const fallible_t&);
  void Trim(const char* aSet, bool aEliminateLeading = true,
            bool aEliminateTrailing = true, bool aIgnoreQuotes = false);
  void CompressWhitespace(bool aEliminateLeading = true,
                          bool aEliminateTrailing = true);






  void AssignWithConversion(const nsACString& aString);
  void AssignWithConversion(const incompatible_char_type* aData,
                            int32_t aLength = -1);
  void Rebind(const char_type* aData, size_type aLength);




  void AssertValidDependentString()
  {
    do { } while(0);
    do { } while(0);
    do { } while(0);


  }


protected:


  nsString(char_type* aData, size_type aLength, uint32_t aFlags)
    : substring_type(aData, aLength, aFlags)
  {
  }

  struct Segment {
    uint32_t mBegin, mLength;
    Segment(uint32_t aBegin, uint32_t aLength)
      : mBegin(aBegin)
      , mLength(aLength)
    {}
  };
};


class nsFixedString : public nsString
{
public:

  typedef nsFixedString self_type;
  typedef nsFixedString fixed_string_type;

public:
  nsFixedString(char_type* aData, size_type aStorageSize)
    : string_type(aData, uint32_t(char_traits::length(aData)),
                  F_TERMINATED | F_FIXED | F_CLASS_FIXED)
    , mFixedCapacity(aStorageSize - 1)
    , mFixedBuf(aData)
  {
  }

  nsFixedString(char_type* aData, size_type aStorageSize,
                       size_type aLength)
    : string_type(aData, aLength, F_TERMINATED | F_FIXED | F_CLASS_FIXED)
    , mFixedCapacity(aStorageSize - 1)
    , mFixedBuf(aData)
  {

    mFixedBuf[aLength] = char_type(0);
  }


  self_type& operator=(char_type aChar)
  {
    Assign(aChar);
    return *this;
  }
  self_type& operator=(const char_type* aData)
  {
    Assign(aData);
    return *this;
  }
  self_type& operator=(const substring_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_tuple_type& aTuple)
  {
    Assign(aTuple);
    return *this;
  }

protected:

  friend class nsAString;

  size_type mFixedCapacity;
  char_type* mFixedBuf;
};
class nsAutoString : public nsFixedString
{
public:

  typedef nsAutoString self_type;

public:





  nsAutoString()
    : fixed_string_type(mStorage, kDefaultStorageSize, 0)
  {
  }

  explicit
  nsAutoString(char_type aChar)
    : fixed_string_type(mStorage, kDefaultStorageSize, 0)
  {
    Assign(aChar);
  }

  explicit
  nsAutoString(const char_type* aData, size_type aLength = size_type(-1))
    : fixed_string_type(mStorage, kDefaultStorageSize, 0)
  {
    Assign(aData, aLength);
  }
  nsAutoString(const self_type& aStr)
    : fixed_string_type(mStorage, kDefaultStorageSize, 0)
  {
    Assign(aStr);
  }

  explicit
  nsAutoString(const substring_type& aStr)
    : fixed_string_type(mStorage, kDefaultStorageSize, 0)
  {
    Assign(aStr);
  }

               nsAutoString(const substring_tuple_type& aTuple)
    : fixed_string_type(mStorage, kDefaultStorageSize, 0)
  {
    Assign(aTuple);
  }


  self_type& operator=(char_type aChar)
  {
    Assign(aChar);
    return *this;
  }
  self_type& operator=(const char_type* aData)
  {
    Assign(aData);
    return *this;
  }







  self_type& operator=(const self_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_tuple_type& aTuple)
  {
    Assign(aTuple);
    return *this;
  }

  enum
  {
    kDefaultStorageSize = 64
  };

private:

  char_type mStorage[kDefaultStorageSize];
};







template<class E> class nsTArrayElementTraits;
template<>
class nsTArrayElementTraits<nsAutoString>
{
public:
  template<class A> struct Dont_Instantiate_nsTArray_of;
  template<class A> struct Instead_Use_nsTArray_of;

  static Dont_Instantiate_nsTArray_of<nsAutoString>*
  Construct(Instead_Use_nsTArray_of<nsString>* aE)
  {
    return 0;
  }
  template<class A>
  static Dont_Instantiate_nsTArray_of<nsAutoString>*
  Construct(Instead_Use_nsTArray_of<nsString>* aE, const A& aArg)
  {
    return 0;
  }
  static Dont_Instantiate_nsTArray_of<nsAutoString>*
  Destruct(Instead_Use_nsTArray_of<nsString>* aE)
  {
    return 0;
  }
};
class nsXPIDLString : public nsString
{
public:

  typedef nsXPIDLString self_type;

public:

  nsXPIDLString()
    : string_type(char_traits::sEmptyBuffer, 0, F_TERMINATED | F_VOIDED)
  {
  }


  nsXPIDLString(const self_type& aStr)
    : string_type(char_traits::sEmptyBuffer, 0, F_TERMINATED | F_VOIDED)
  {
    Assign(aStr);
  }





  const char_type* get() const

  {
    return (mFlags & F_VOIDED) ? nullptr : mData;
  }



  operator const char_type*() const
  {
    return get();
  }


  char_type operator[](int32_t aIndex) const
  {
    return CharAt(index_type(aIndex));
  }


  self_type& operator=(char_type aChar)
  {
    Assign(aChar);
    return *this;
  }
  self_type& operator=(const char_type* aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const self_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_tuple_type& aTuple)
  {
    Assign(aTuple);
    return *this;
  }
};
class nsGetterCopies
{
public:
  typedef char16_t char_type;

  explicit nsGetterCopies(nsAString& aStr)
    : mString(aStr)
    , mData(nullptr)
  {
  }

  ~nsGetterCopies()
  {
    mString.Adopt(mData);
  }

  operator char_type**()
  {
    return &mData;
  }

private:
  nsAString& mString;
  char_type* mData;
};

inline nsGetterCopies
getter_Copies(nsAString& aString)
{
  return nsGetterCopies(aString);
}
class nsAdoptingString : public nsXPIDLString
{
public:

  typedef nsAdoptingString self_type;

public:

  explicit nsAdoptingString()
  {
  }
  explicit nsAdoptingString(char_type* aStr,
                                   size_type aLength = size_type(-1))
  {
    Adopt(aStr, aLength);
  }





  nsAdoptingString(const self_type& aStr)
    : nsXPIDLString()
  {
    *this = aStr;
  }


  self_type& operator=(const substring_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_tuple_type& aTuple)
  {
    Assign(aTuple);
    return *this;
  }




  self_type& operator=(const self_type& aStr);

private:
  self_type& operator=(const char_type* aData) = delete;
  self_type& operator=(char_type* aData) = delete;
};


class nsCString : public nsACString
{
public:

  typedef nsCString self_type;

public:





  nsCString()
    : substring_type()
  {
  }

  explicit
  nsCString(const char_type* aData, size_type aLength = size_type(-1))
    : substring_type()
  {
    Assign(aData, aLength);
  }
  nsCString(const self_type& aStr)
    : substring_type()
  {
    Assign(aStr);
  }

               nsCString(const substring_tuple_type& aTuple)
    : substring_type()
  {
    Assign(aTuple);
  }

  explicit
  nsCString(const substring_type& aReadable)
    : substring_type()
  {
    Assign(aReadable);
  }



  self_type& operator=(char_type aChar)
  {
    Assign(aChar);
    return *this;
  }
  self_type& operator=(const char_type* aData)
  {
    Assign(aData);
    return *this;
  }
  self_type& operator=(const self_type& aStr)
  {
    Assign(aStr);
    return *this;
  }







  self_type& operator=(const substring_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_tuple_type& aTuple)
  {
    Assign(aTuple);
    return *this;
  }
  const char_type* get() const

  {
    return mData;
  }
  char_type CharAt(index_type aIndex) const
  {
    do { } while(0);
    return mData[aIndex];
  }

  char_type operator[](index_type aIndex) const
  {
    return CharAt(aIndex);
  }
  int32_t Find(const nsCString& aString, bool aIgnoreCase = false,
               int32_t aOffset = 0, int32_t aCount = -1) const;
  int32_t Find(const char* aString, bool aIgnoreCase = false,
               int32_t aOffset = 0, int32_t aCount = -1) const;
  int32_t RFind(const nsCString& aString, bool aIgnoreCase = false,
                int32_t aOffset = -1, int32_t aCount = -1) const;
  int32_t RFind(const char* aCString, bool aIgnoreCase = false,
                int32_t aOffset = -1, int32_t aCount = -1) const;
  int32_t RFindChar(char16_t aChar, int32_t aOffset = -1,
                    int32_t aCount = -1) const;
  int32_t FindCharInSet(const char* aString, int32_t aOffset = 0) const;
  int32_t FindCharInSet(const self_type& aString, int32_t aOffset = 0) const
  {
    return FindCharInSet(aString.get(), aOffset);
  }
  int32_t RFindCharInSet(const char_type* aString, int32_t aOffset = -1) const;
  int32_t RFindCharInSet(const self_type& aString, int32_t aOffset = -1) const
  {
    return RFindCharInSet(aString.get(), aOffset);
  }
  int32_t Compare(const char* aString, bool aIgnoreCase = false,
                  int32_t aCount = -1) const;
  bool EqualsIgnoreCase(const char* aString, int32_t aCount = -1) const
  {
    return Compare(aString, true, aCount) == 0;
  }
  double ToDouble(nsresult* aErrorCode) const;







  float ToFloat(nsresult* aErrorCode) const
  {
    return (float)ToDouble(aErrorCode);
  }
  int32_t ToInteger(nsresult* aErrorCode, uint32_t aRadix = (10)) const;







  int64_t ToInteger64(nsresult* aErrorCode, uint32_t aRadix = (10)) const;
  size_type Mid(self_type& aResult, uint32_t aStartPos, uint32_t aCount) const;

  size_type Left(self_type& aResult, size_type aCount) const
  {
    return Mid(aResult, 0, aCount);
  }

  size_type Right(self_type& aResult, size_type aCount) const
  {
    aCount = XPCOM_MIN(mLength, aCount);
    return Mid(aResult, mLength - aCount, aCount);
  }
  bool SetCharAt(char16_t aChar, uint32_t aIndex);
  void StripChars(const char* aSet);
  bool StripChars(const char* aSet, const fallible_t&);





  void StripWhitespace();
  bool StripWhitespace(const fallible_t&);






  void ReplaceChar(char_type aOldChar, char_type aNewChar);
  void ReplaceChar(const char* aSet, char_type aNewChar);
  void ReplaceSubstring(const self_type& aTarget, const self_type& aNewValue);
  void ReplaceSubstring(const char_type* aTarget, const char_type* aNewValue);
  __attribute__ ((warn_unused_result)) bool ReplaceSubstring(const self_type& aTarget,
                                     const self_type& aNewValue,
                                     const fallible_t&);
  __attribute__ ((warn_unused_result)) bool ReplaceSubstring(const char_type* aTarget,
                                     const char_type* aNewValue,
                                     const fallible_t&);
  void Trim(const char* aSet, bool aEliminateLeading = true,
            bool aEliminateTrailing = true, bool aIgnoreQuotes = false);
  void CompressWhitespace(bool aEliminateLeading = true,
                          bool aEliminateTrailing = true);






  void AssignWithConversion(const nsAString& aString);
  void AssignWithConversion(const incompatible_char_type* aData,
                            int32_t aLength = -1);
  void Rebind(const char_type* aData, size_type aLength);




  void AssertValidDependentString()
  {
    do { } while(0);
    do { } while(0);
    do { } while(0);


  }


protected:


  nsCString(char_type* aData, size_type aLength, uint32_t aFlags)
    : substring_type(aData, aLength, aFlags)
  {
  }

  struct Segment {
    uint32_t mBegin, mLength;
    Segment(uint32_t aBegin, uint32_t aLength)
      : mBegin(aBegin)
      , mLength(aLength)
    {}
  };
};


class nsFixedCString : public nsCString
{
public:

  typedef nsFixedCString self_type;
  typedef nsFixedCString fixed_string_type;

public:
  nsFixedCString(char_type* aData, size_type aStorageSize)
    : string_type(aData, uint32_t(char_traits::length(aData)),
                  F_TERMINATED | F_FIXED | F_CLASS_FIXED)
    , mFixedCapacity(aStorageSize - 1)
    , mFixedBuf(aData)
  {
  }

  nsFixedCString(char_type* aData, size_type aStorageSize,
                       size_type aLength)
    : string_type(aData, aLength, F_TERMINATED | F_FIXED | F_CLASS_FIXED)
    , mFixedCapacity(aStorageSize - 1)
    , mFixedBuf(aData)
  {

    mFixedBuf[aLength] = char_type(0);
  }


  self_type& operator=(char_type aChar)
  {
    Assign(aChar);
    return *this;
  }
  self_type& operator=(const char_type* aData)
  {
    Assign(aData);
    return *this;
  }
  self_type& operator=(const substring_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_tuple_type& aTuple)
  {
    Assign(aTuple);
    return *this;
  }

protected:

  friend class nsACString;

  size_type mFixedCapacity;
  char_type* mFixedBuf;
};
class nsAutoCString : public nsFixedCString
{
public:

  typedef nsAutoCString self_type;

public:





  nsAutoCString()
    : fixed_string_type(mStorage, kDefaultStorageSize, 0)
  {
  }

  explicit
  nsAutoCString(char_type aChar)
    : fixed_string_type(mStorage, kDefaultStorageSize, 0)
  {
    Assign(aChar);
  }

  explicit
  nsAutoCString(const char_type* aData, size_type aLength = size_type(-1))
    : fixed_string_type(mStorage, kDefaultStorageSize, 0)
  {
    Assign(aData, aLength);
  }
  nsAutoCString(const self_type& aStr)
    : fixed_string_type(mStorage, kDefaultStorageSize, 0)
  {
    Assign(aStr);
  }

  explicit
  nsAutoCString(const substring_type& aStr)
    : fixed_string_type(mStorage, kDefaultStorageSize, 0)
  {
    Assign(aStr);
  }

               nsAutoCString(const substring_tuple_type& aTuple)
    : fixed_string_type(mStorage, kDefaultStorageSize, 0)
  {
    Assign(aTuple);
  }


  self_type& operator=(char_type aChar)
  {
    Assign(aChar);
    return *this;
  }
  self_type& operator=(const char_type* aData)
  {
    Assign(aData);
    return *this;
  }







  self_type& operator=(const self_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_tuple_type& aTuple)
  {
    Assign(aTuple);
    return *this;
  }

  enum
  {
    kDefaultStorageSize = 64
  };

private:

  char_type mStorage[kDefaultStorageSize];
};







template<class E> class nsTArrayElementTraits;
template<>
class nsTArrayElementTraits<nsAutoCString>
{
public:
  template<class A> struct Dont_Instantiate_nsTArray_of;
  template<class A> struct Instead_Use_nsTArray_of;

  static Dont_Instantiate_nsTArray_of<nsAutoCString>*
  Construct(Instead_Use_nsTArray_of<nsCString>* aE)
  {
    return 0;
  }
  template<class A>
  static Dont_Instantiate_nsTArray_of<nsAutoCString>*
  Construct(Instead_Use_nsTArray_of<nsCString>* aE, const A& aArg)
  {
    return 0;
  }
  static Dont_Instantiate_nsTArray_of<nsAutoCString>*
  Destruct(Instead_Use_nsTArray_of<nsCString>* aE)
  {
    return 0;
  }
};
class nsXPIDLCString : public nsCString
{
public:

  typedef nsXPIDLCString self_type;

public:

  nsXPIDLCString()
    : string_type(char_traits::sEmptyBuffer, 0, F_TERMINATED | F_VOIDED)
  {
  }


  nsXPIDLCString(const self_type& aStr)
    : string_type(char_traits::sEmptyBuffer, 0, F_TERMINATED | F_VOIDED)
  {
    Assign(aStr);
  }





  const char_type* get() const

  {
    return (mFlags & F_VOIDED) ? nullptr : mData;
  }



  operator const char_type*() const
  {
    return get();
  }


  char_type operator[](int32_t aIndex) const
  {
    return CharAt(index_type(aIndex));
  }


  self_type& operator=(char_type aChar)
  {
    Assign(aChar);
    return *this;
  }
  self_type& operator=(const char_type* aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const self_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_tuple_type& aTuple)
  {
    Assign(aTuple);
    return *this;
  }
};
class nsCGetterCopies
{
public:
  typedef char char_type;

  explicit nsCGetterCopies(nsACString& aStr)
    : mString(aStr)
    , mData(nullptr)
  {
  }

  ~nsCGetterCopies()
  {
    mString.Adopt(mData);
  }

  operator char_type**()
  {
    return &mData;
  }

private:
  nsACString& mString;
  char_type* mData;
};

inline nsCGetterCopies
getter_Copies(nsACString& aString)
{
  return nsCGetterCopies(aString);
}
class nsAdoptingCString : public nsXPIDLCString
{
public:

  typedef nsAdoptingCString self_type;

public:

  explicit nsAdoptingCString()
  {
  }
  explicit nsAdoptingCString(char_type* aStr,
                                   size_type aLength = size_type(-1))
  {
    Adopt(aStr, aLength);
  }





  nsAdoptingCString(const self_type& aStr)
    : nsXPIDLCString()
  {
    *this = aStr;
  }


  self_type& operator=(const substring_type& aStr)
  {
    Assign(aStr);
    return *this;
  }
  self_type& operator=(const substring_tuple_type& aTuple)
  {
    Assign(aTuple);
    return *this;
  }




  self_type& operator=(const self_type& aStr);

private:
  self_type& operator=(const char_type* aData) = delete;
  self_type& operator=(char_type* aData) = delete;
};

static_assert(sizeof(char16_t) == 2, "size of char16_t must be 2");
static_assert(sizeof(nsString::char_type) == 2,
              "size of nsString::char_type must be 2");
static_assert(nsString::char_type(-1) > nsString::char_type(0),
              "nsString::char_type must be unsigned");
static_assert(sizeof(nsCString::char_type) == 1,
              "size of nsCString::char_type must be 1");





class NS_LossyConvertUTF16toASCII : public nsAutoCString
{
public:
  explicit NS_LossyConvertUTF16toASCII(const char16ptr_t aString)
  {
    LossyAppendUTF16toASCII(aString, *this);
  }

  NS_LossyConvertUTF16toASCII(const char16ptr_t aString, uint32_t aLength)
  {
    LossyAppendUTF16toASCII(Substring(aString, aLength), *this);
  }

  explicit NS_LossyConvertUTF16toASCII(const nsAString& aString)
  {
    LossyAppendUTF16toASCII(aString, *this);
  }

private:

  NS_LossyConvertUTF16toASCII(char) = delete;
};


class NS_ConvertASCIItoUTF16 : public nsAutoString
{
public:
  explicit NS_ConvertASCIItoUTF16(const char* aCString)
  {
    AppendASCIItoUTF16(aCString, *this);
  }

  NS_ConvertASCIItoUTF16(const char* aCString, uint32_t aLength)
  {
    AppendASCIItoUTF16(Substring(aCString, aLength), *this);
  }

  explicit NS_ConvertASCIItoUTF16(const nsACString& aCString)
  {
    AppendASCIItoUTF16(aCString, *this);
  }

private:

  NS_ConvertASCIItoUTF16(char16_t) = delete;
};





class NS_ConvertUTF16toUTF8 : public nsAutoCString
{
public:
  explicit NS_ConvertUTF16toUTF8(const char16ptr_t aString)
  {
    AppendUTF16toUTF8(aString, *this);
  }

  NS_ConvertUTF16toUTF8(const char16ptr_t aString, uint32_t aLength)
  {
    AppendUTF16toUTF8(Substring(aString, aLength), *this);
  }

  explicit NS_ConvertUTF16toUTF8(const nsAString& aString)
  {
    AppendUTF16toUTF8(aString, *this);
  }

private:

  NS_ConvertUTF16toUTF8(char) = delete;
};


class NS_ConvertUTF8toUTF16 : public nsAutoString
{
public:
  explicit NS_ConvertUTF8toUTF16(const char* aCString)
  {
    AppendUTF8toUTF16(aCString, *this);
  }

  NS_ConvertUTF8toUTF16(const char* aCString, uint32_t aLength)
  {
    AppendUTF8toUTF16(Substring(aCString, aLength), *this);
  }

  explicit NS_ConvertUTF8toUTF16(const nsACString& aCString)
  {
    AppendUTF8toUTF16(aCString, *this);
  }

private:

  NS_ConvertUTF8toUTF16(char16_t) = delete;
};
inline char16_t*
wwc(char16_t* aStr)
{
  return aStr;
}

inline const char16_t*
wwc(const char16_t* aStr)
{
  return aStr;
}




typedef nsAutoString nsVoidableString;





class nsDependentString : public nsString
{
public:

  typedef nsDependentString self_type;

public:





  nsDependentString(const char_type* aStart, const char_type* aEnd);

  nsDependentString(const char_type* aData, uint32_t aLength)
    : string_type(const_cast<char_type*>(aData), aLength, F_TERMINATED)
  {
    AssertValidDependentString();
  }
  explicit
  nsDependentString(const char_type* aData)
    : string_type(const_cast<char_type*>(aData),
                  uint32_t(char_traits::length(aData)), F_TERMINATED)
  {
    AssertValidDependentString();
  }
  nsDependentString(const string_type& aStr, uint32_t aStartPos)
    : string_type()
  {
    Rebind(aStr, aStartPos);
  }


  nsDependentString()
    : string_type()
  {
  }
  using nsString::Rebind;
  void Rebind(const char_type* aData)
  {
    Rebind(aData, uint32_t(char_traits::length(aData)));
  }

  void Rebind(const char_type* aStart, const char_type* aEnd);
  void Rebind(const string_type&, uint32_t aStartPos);

private:


  nsDependentString(const substring_tuple_type&) = delete;
};


class nsDependentCString : public nsCString
{
public:

  typedef nsDependentCString self_type;

public:





  nsDependentCString(const char_type* aStart, const char_type* aEnd);

  nsDependentCString(const char_type* aData, uint32_t aLength)
    : string_type(const_cast<char_type*>(aData), aLength, F_TERMINATED)
  {
    AssertValidDependentString();
  }
  explicit
  nsDependentCString(const char_type* aData)
    : string_type(const_cast<char_type*>(aData),
                  uint32_t(char_traits::length(aData)), F_TERMINATED)
  {
    AssertValidDependentString();
  }
  nsDependentCString(const string_type& aStr, uint32_t aStartPos)
    : string_type()
  {
    Rebind(aStr, aStartPos);
  }


  nsDependentCString()
    : string_type()
  {
  }
  using nsCString::Rebind;
  void Rebind(const char_type* aData)
  {
    Rebind(aData, uint32_t(char_traits::length(aData)));
  }

  void Rebind(const char_type* aStart, const char_type* aEnd);
  void Rebind(const string_type&, uint32_t aStartPos);

private:


  nsDependentCString(const substring_tuple_type&) = delete;
};


class nsLiteralString : public mozilla::detail::nsStringRepr
{
public:

  typedef nsLiteralString self_type;

public:





  template<size_type N>
  explicit nsLiteralString(const char_type (&aStr)[N])
    : base_string_type(const_cast<char_type*>(aStr), N - 1, F_TERMINATED | F_LITERAL)
  {
  }






  const nsString& AsString() const
  {
    return *reinterpret_cast<const nsString*>(this);
  }

  operator const nsString&() const
  {
    return AsString();
  }
  const char_type* get() const && = delete;
  const char_type* get() const &

  {
    return mData;
  }

private:


  template<size_type N>
  nsLiteralString(char_type (&aStr)[N]) = delete;

  self_type& operator=(const self_type&) = delete;
};

static_assert(sizeof(nsLiteralString) == sizeof(nsString),
              "nsTLiteralString_CharT can masquerade as nsTString_CharT, "
              "so they must have identical layout");


class nsLiteralCString : public mozilla::detail::nsCStringRepr
{
public:

  typedef nsLiteralCString self_type;

public:





  template<size_type N>
  explicit nsLiteralCString(const char_type (&aStr)[N])
    : base_string_type(const_cast<char_type*>(aStr), N - 1, F_TERMINATED | F_LITERAL)
  {
  }






  const nsCString& AsString() const
  {
    return *reinterpret_cast<const nsCString*>(this);
  }

  operator const nsCString&() const
  {
    return AsString();
  }
  const char_type* get() const && = delete;
  const char_type* get() const &

  {
    return mData;
  }

private:


  template<size_type N>
  nsLiteralCString(char_type (&aStr)[N]) = delete;

  self_type& operator=(const self_type&) = delete;
};

static_assert(sizeof(nsLiteralCString) == sizeof(nsCString),
              "nsTLiteralString_CharT can masquerade as nsTString_CharT, "
              "so they must have identical layout");


class nsPromiseFlatString : public nsString
{
public:

  typedef nsPromiseFlatString self_type;

private:

  void Init(const substring_type&);


  void operator=(const self_type&) = delete;


  nsPromiseFlatString() = delete;


  nsPromiseFlatString(const string_type& aStr) = delete;

public:

  explicit
  nsPromiseFlatString(const substring_type& aStr)
    : string_type()
  {
    Init(aStr);
  }

  explicit
  nsPromiseFlatString(const substring_tuple_type& aTuple)
    : string_type()
  {


    Assign(aTuple);
  }
};



template<class T>
const nsPromiseFlatString
PromiseFlatString(const T& aString)
{
  return nsPromiseFlatString(aString);
}


class nsPromiseFlatCString : public nsCString
{
public:

  typedef nsPromiseFlatCString self_type;

private:

  void Init(const substring_type&);


  void operator=(const self_type&) = delete;


  nsPromiseFlatCString() = delete;


  nsPromiseFlatCString(const string_type& aStr) = delete;

public:

  explicit
  nsPromiseFlatCString(const substring_type& aStr)
    : string_type()
  {
    Init(aStr);
  }

  explicit
  nsPromiseFlatCString(const substring_tuple_type& aTuple)
    : string_type()
  {


    Assign(aTuple);
  }
};



template<class T>
const nsPromiseFlatCString
PromiseFlatCString(const T& aString)
{
  return nsPromiseFlatCString(aString);
}


class nsIMemory;
class nsMemory
{
public:
  static nsresult HeapMinimize(bool aImmediate);
  static void* Clone(const void* aPtr, size_t aSize);
  static nsIMemory* GetGlobalMemoryService();
};
namespace mozilla {
template<class T>
struct AlignmentTestStruct
{
  char c;
  T t;
};
}







enum nsAssignmentType
{
  NS_ASSIGNMENT_COPY,
  NS_ASSIGNMENT_DEPEND,
  NS_ASSIGNMENT_ADOPT
};


extern "C" {

typedef struct PLHashEntry PLHashEntry;
typedef struct PLHashTable PLHashTable;
typedef PRUint32 PLHashNumber;

typedef PLHashNumber ( *PLHashFunction)(const void *key);
typedef PRIntn ( *PLHashComparator)(const void *v1, const void *v2);

typedef PRIntn ( *PLHashEnumerator)(PLHashEntry *he, PRIntn i, void *arg);







typedef struct PLHashAllocOps {
    void * ( *allocTable)(void *pool, PRSize size);
    void ( *freeTable)(void *pool, void *item);
    PLHashEntry * ( *allocEntry)(void *pool, const void *key);
    void ( *freeEntry)(void *pool, PLHashEntry *he, PRUintn flag);
} PLHashAllocOps;




struct PLHashEntry {
    PLHashEntry *next;
    PLHashNumber keyHash;
    const void *key;
    void *value;
};

struct PLHashTable {
    PLHashEntry **buckets;
    PRUint32 nentries;
    PRUint32 shift;
    PLHashFunction keyHash;
    PLHashComparator keyCompare;
    PLHashComparator valueCompare;
    const PLHashAllocOps *allocOps;
    void *allocPriv;






};





extern __attribute__((visibility("default"))) PLHashTable *
PL_NewHashTable(PRUint32 numBuckets, PLHashFunction keyHash,
                PLHashComparator keyCompare, PLHashComparator valueCompare,
                const PLHashAllocOps *allocOps, void *allocPriv);

extern __attribute__((visibility("default"))) void
PL_HashTableDestroy(PLHashTable *ht);


extern __attribute__((visibility("default"))) PLHashEntry *
PL_HashTableAdd(PLHashTable *ht, const void *key, void *value);

extern __attribute__((visibility("default"))) PRBool
PL_HashTableRemove(PLHashTable *ht, const void *key);

extern __attribute__((visibility("default"))) void *
PL_HashTableLookup(PLHashTable *ht, const void *key);

extern __attribute__((visibility("default"))) void *
PL_HashTableLookupConst(PLHashTable *ht, const void *key);

extern __attribute__((visibility("default"))) PRIntn
PL_HashTableEnumerateEntries(PLHashTable *ht, PLHashEnumerator f, void *arg);


extern __attribute__((visibility("default"))) PLHashNumber
PL_HashString(const void *key);


extern __attribute__((visibility("default"))) PRIntn
PL_CompareStrings(const void *v1, const void *v2);


extern __attribute__((visibility("default"))) PRIntn
PL_CompareValues(const void *v1, const void *v2);


extern __attribute__((visibility("default"))) PLHashEntry **
PL_HashTableRawLookup(PLHashTable *ht, PLHashNumber keyHash, const void *key);

extern __attribute__((visibility("default"))) PLHashEntry **
PL_HashTableRawLookupConst(PLHashTable *ht, PLHashNumber keyHash,
                           const void *key);

extern __attribute__((visibility("default"))) PLHashEntry *
PL_HashTableRawAdd(PLHashTable *ht, PLHashEntry **hep, PLHashNumber keyHash,
                   const void *key, void *value);

extern __attribute__((visibility("default"))) void
PL_HashTableRawRemove(PLHashTable *ht, PLHashEntry **hep, PLHashEntry *he);


extern __attribute__((visibility("default"))) PRIntn
PL_HashTableDump(PLHashTable *ht, PLHashEnumerator dump, FILE *fp);

}

namespace mozilla {
template<class T> class OwningNonNull;
}

template<class T>
inline already_AddRefed<T>
dont_AddRef(T* aRawPtr)
{
  return already_AddRefed<T>(aRawPtr);
}

template<class T>
inline already_AddRefed<T>&&
dont_AddRef(already_AddRefed<T>&& aAlreadyAddRefedPtr)
{
  return mozilla::Move(aAlreadyAddRefedPtr);
}
class nsCOMPtr_helper
{
public:
  virtual nsresult operator()(const nsIID&, void**) const = 0;
};







class nsQueryInterface final
{
public:
  explicit
  nsQueryInterface(nsISupports* aRawPtr) : mRawPtr(aRawPtr) {}

  nsresult operator()(const nsIID& aIID, void**) const;

private:
  nsISupports* mRawPtr;
};

class nsQueryInterfaceWithError final
{
public:
  nsQueryInterfaceWithError(nsISupports* aRawPtr, nsresult* aError)
    : mRawPtr(aRawPtr)
    , mErrorPtr(aError)
  {
  }

  nsresult operator()(const nsIID& aIID, void**) const;

private:
  nsISupports* mRawPtr;
  nsresult* mErrorPtr;
};

inline nsQueryInterface
do_QueryInterface(nsISupports* aRawPtr)
{
  return nsQueryInterface(aRawPtr);
}

inline nsQueryInterfaceWithError
do_QueryInterface(nsISupports* aRawPtr, nsresult* aError)
{
  return nsQueryInterfaceWithError(aRawPtr, aError);
}

template<class T>
inline void
do_QueryInterface(already_AddRefed<T>&)
{



}

template<class T>
inline void
do_QueryInterface(already_AddRefed<T>&, nsresult*)
{



}




class nsGetServiceByCID final
{
public:
  explicit nsGetServiceByCID(const nsCID& aCID) : mCID(aCID) {}

  nsresult operator()(const nsIID&, void**) const;

private:
  const nsCID& mCID;
};

class nsGetServiceByCIDWithError final
{
public:
  nsGetServiceByCIDWithError(const nsCID& aCID, nsresult* aErrorPtr)
    : mCID(aCID)
    , mErrorPtr(aErrorPtr)
  {
  }

  nsresult operator()(const nsIID&, void**) const;

private:
  const nsCID& mCID;
  nsresult* mErrorPtr;
};

class nsGetServiceByContractID final
{
public:
  explicit nsGetServiceByContractID(const char* aContractID)
    : mContractID(aContractID)
  {
  }

  nsresult operator()(const nsIID&, void**) const;

private:
  const char* mContractID;
};

class nsGetServiceByContractIDWithError final
{
public:
  nsGetServiceByContractIDWithError(const char* aContractID, nsresult* aErrorPtr)
    : mContractID(aContractID)
    , mErrorPtr(aErrorPtr)
  {
  }

  nsresult operator()(const nsIID&, void**) const;

private:
  const char* mContractID;
  nsresult* mErrorPtr;
};
class nsCOMPtr_base
{
public:
  explicit nsCOMPtr_base(nsISupports* aRawPtr = nullptr) : mRawPtr(aRawPtr) {}

                          ~nsCOMPtr_base()
  {
                                    ;
    if (mRawPtr) {
      (mRawPtr)->Release();
    }
  }

  void
  assign_with_AddRef(nsISupports*);
  void
  assign_from_qi(const nsQueryInterface, const nsIID&);
  void
  assign_from_qi_with_error(const nsQueryInterfaceWithError&, const nsIID&);
  void
  assign_from_gs_cid(const nsGetServiceByCID, const nsIID&);
  void
  assign_from_gs_cid_with_error(const nsGetServiceByCIDWithError&, const nsIID&);
  void
  assign_from_gs_contractid(const nsGetServiceByContractID, const nsIID&);
  void
  assign_from_gs_contractid_with_error(const nsGetServiceByContractIDWithError&,
                                       const nsIID&);
  void
  assign_from_helper(const nsCOMPtr_helper&, const nsIID&);
  void**
  begin_assignment();

protected:
  nsISupports* __attribute__((__may_alias__)) mRawPtr;

  void assign_assuming_AddRef(nsISupports* aNewPtr)
  {






    nsISupports* oldPtr = mRawPtr;
    mRawPtr = aNewPtr;
                                       ;
                                   ;
    if (oldPtr) {
      (oldPtr)->Release();
    }
  }
};




template<class T>
char (&TestForIID(decltype(&(T::template COMTypeInfo<T, void>::kIID))))[2];
template<class T>
char TestForIID(...);

template<class T>
class nsCOMPtr final

  : private nsCOMPtr_base

{
  void assert_validity()
  {
    static_assert(1 < sizeof(TestForIID<T>(nullptr)), "nsCOMPtr only works "
                  "for types with IIDs.  Either use RefPtr; add an IID to "
                  "your type with NS_DECLARE_STATIC_IID_ACCESSOR/"
                  "NS_DEFINE_STATIC_IID_ACCESSOR; or make the nsCOMPtr point "
                  "to a base class with an IID.");
  }

public:
  typedef T element_type;
  nsCOMPtr()
    : nsCOMPtr_base(nullptr)
  {
    assert_validity();
                                       ;
  }

               nsCOMPtr(decltype(nullptr))
    : nsCOMPtr_base(nullptr)
  {
    assert_validity();
                                       ;
  }

  nsCOMPtr(const nsCOMPtr<T>& aSmartPtr)
    : nsCOMPtr_base(aSmartPtr.mRawPtr)
  {
    assert_validity();
    if (mRawPtr) {
      (mRawPtr)->AddRef();
    }
                                                 ;
  }

  nsCOMPtr(nsCOMPtr<T>&& aSmartPtr)
    : nsCOMPtr_base(aSmartPtr.mRawPtr)
  {
    assert_validity();
    aSmartPtr.mRawPtr = nullptr;
                                       ;
                                  ;
  }

               nsCOMPtr(T* aRawPtr)
    : nsCOMPtr_base(aRawPtr)
  {
    assert_validity();
    if (mRawPtr) {
      (mRawPtr)->AddRef();
    }
                                       ;
                                  ;
  }

               nsCOMPtr(already_AddRefed<T>& aSmartPtr)
    : nsCOMPtr_base(aSmartPtr.take())
  {
    assert_validity();
                                       ;
                                  ;
  }


               nsCOMPtr(already_AddRefed<T>&& aSmartPtr)
    : nsCOMPtr_base(aSmartPtr.take())
  {
    assert_validity();
                                       ;
                                  ;
  }


  template<typename U>
               nsCOMPtr(already_AddRefed<U>& aSmartPtr)
    : nsCOMPtr_base(static_cast<T*>(aSmartPtr.take()))
  {
    assert_validity();

    static_assert(mozilla::IsBaseOf<T, U>::value,
                  "U is not a subclass of T");
                                                        ;
                                  ;
  }


  template<typename U>
               nsCOMPtr(already_AddRefed<U>&& aSmartPtr)
    : nsCOMPtr_base(static_cast<T*>(aSmartPtr.take()))
  {
    assert_validity();

    static_assert(mozilla::IsBaseOf<T, U>::value,
                  "U is not a subclass of T");
                                                        ;
                                  ;
  }


               nsCOMPtr(const nsQueryInterface aQI)
    : nsCOMPtr_base(nullptr)
  {
    assert_validity();
                                       ;
    assign_from_qi(aQI, (T::template COMTypeInfo<T, void>::kIID));
  }


               nsCOMPtr(const nsQueryInterfaceWithError& aQI)
    : nsCOMPtr_base(nullptr)
  {
    assert_validity();
                                       ;
    assign_from_qi_with_error(aQI, (T::template COMTypeInfo<T, void>::kIID));
  }


               nsCOMPtr(const nsGetServiceByCID aGS)
    : nsCOMPtr_base(nullptr)
  {
    assert_validity();
                                       ;
    assign_from_gs_cid(aGS, (T::template COMTypeInfo<T, void>::kIID));
  }


               nsCOMPtr(const nsGetServiceByCIDWithError& aGS)
    : nsCOMPtr_base(nullptr)
  {
    assert_validity();
                                       ;
    assign_from_gs_cid_with_error(aGS, (T::template COMTypeInfo<T, void>::kIID));
  }


               nsCOMPtr(const nsGetServiceByContractID aGS)
    : nsCOMPtr_base(nullptr)
  {
    assert_validity();
                                       ;
    assign_from_gs_contractid(aGS, (T::template COMTypeInfo<T, void>::kIID));
  }


               nsCOMPtr(const nsGetServiceByContractIDWithError& aGS)
    : nsCOMPtr_base(nullptr)
  {
    assert_validity();
                                       ;
    assign_from_gs_contractid_with_error(aGS, (T::template COMTypeInfo<T, void>::kIID));
  }



               nsCOMPtr(const nsCOMPtr_helper& aHelper)
    : nsCOMPtr_base(nullptr)
  {
    assert_validity();
                                       ;
    assign_from_helper(aHelper, (T::template COMTypeInfo<T, void>::kIID));
                                  ;
  }


  template<class U>
               nsCOMPtr(const mozilla::OwningNonNull<U>& aOther);




  nsCOMPtr<T>& operator=(const nsCOMPtr<T>& aRhs)
  {
    assign_with_AddRef(aRhs.mRawPtr);
    return *this;
  }

  nsCOMPtr<T>& operator=(T* aRhs)
  {
    assign_with_AddRef(aRhs);
                                  ;
    return *this;
  }

  nsCOMPtr<T>& operator=(decltype(nullptr))
  {
    assign_assuming_AddRef(nullptr);
    return *this;
  }


  template<typename U>
  nsCOMPtr<T>& operator=(already_AddRefed<U>& aRhs)
  {

    static_assert(mozilla::IsBaseOf<T, U>::value,
                  "U is not a subclass of T");
    assign_assuming_AddRef(static_cast<T*>(aRhs.take()));
                                  ;
    return *this;
  }


  template<typename U>
  nsCOMPtr<T>& operator=(already_AddRefed<U>&& aRhs)
  {

    static_assert(mozilla::IsBaseOf<T, U>::value,
                  "U is not a subclass of T");
    assign_assuming_AddRef(static_cast<T*>(aRhs.take()));
                                  ;
    return *this;
  }


  nsCOMPtr<T>& operator=(const nsQueryInterface aRhs)
  {
    assign_from_qi(aRhs, (T::template COMTypeInfo<T, void>::kIID));
    return *this;
  }


  nsCOMPtr<T>& operator=(const nsQueryInterfaceWithError& aRhs)
  {
    assign_from_qi_with_error(aRhs, (T::template COMTypeInfo<T, void>::kIID));
    return *this;
  }


  nsCOMPtr<T>& operator=(const nsGetServiceByCID aRhs)
  {
    assign_from_gs_cid(aRhs, (T::template COMTypeInfo<T, void>::kIID));
    return *this;
  }


  nsCOMPtr<T>& operator=(const nsGetServiceByCIDWithError& aRhs)
  {
    assign_from_gs_cid_with_error(aRhs, (T::template COMTypeInfo<T, void>::kIID));
    return *this;
  }


  nsCOMPtr<T>& operator=(const nsGetServiceByContractID aRhs)
  {
    assign_from_gs_contractid(aRhs, (T::template COMTypeInfo<T, void>::kIID));
    return *this;
  }


  nsCOMPtr<T>& operator=(const nsGetServiceByContractIDWithError& aRhs)
  {
    assign_from_gs_contractid_with_error(aRhs, (T::template COMTypeInfo<T, void>::kIID));
    return *this;
  }



  nsCOMPtr<T>& operator=(const nsCOMPtr_helper& aRhs)
  {
    assign_from_helper(aRhs, (T::template COMTypeInfo<T, void>::kIID));
                                  ;
    return *this;
  }


  template<class U>
  nsCOMPtr<T>& operator=(const mozilla::OwningNonNull<U>& aOther);


  void swap(nsCOMPtr<T>& aRhs)
  {

    nsISupports* temp = aRhs.mRawPtr;



                                        ;
                                    ;
                                    ;
                                  ;
    aRhs.mRawPtr = mRawPtr;
    mRawPtr = temp;

  }


  void swap(T*& aRhs)
  {

    nsISupports* temp = aRhs;



                                    ;
                                    ;
    aRhs = reinterpret_cast<T*>(mRawPtr);
    mRawPtr = temp;
                                  ;
  }






  already_AddRefed<T> forget()
  {
    T* temp = nullptr;
    swap(temp);
    return already_AddRefed<T>(temp);
  }




  template<typename I>
  void forget(I** aRhs)
  {
    do { } while(0);
                                    ;
    *aRhs = get();
    mRawPtr = nullptr;
  }




  T* get() const { return reinterpret_cast<T*>(mRawPtr); }







  operator T*() const & { return get(); }




  operator T*() const && = delete;


  explicit operator bool() const { return !!mRawPtr; }

  T* operator->() const
  {
    do { } while (0);

    return get();
  }


  nsCOMPtr<T>* get_address() { return this; }
  const nsCOMPtr<T>* get_address() const { return this; }

public:
  T& operator*() const
  {
    do { } while (0);

    return *get();
  }

  T** StartAssignment()
  {

    return reinterpret_cast<T**>(begin_assignment());




  }
};
template<>
class nsCOMPtr<nsISupports>
  : private nsCOMPtr_base
{
public:
  typedef nsISupports element_type;



  nsCOMPtr()
    : nsCOMPtr_base(nullptr)
  {
                                       ;
  }

               nsCOMPtr(decltype(nullptr))
    : nsCOMPtr_base(nullptr)
  {
                                       ;
  }

  nsCOMPtr(const nsCOMPtr<nsISupports>& aSmartPtr)
    : nsCOMPtr_base(aSmartPtr.mRawPtr)
  {
    if (mRawPtr) {
      (mRawPtr)->AddRef();
    }
                                                 ;
  }

               nsCOMPtr(nsISupports* aRawPtr)
    : nsCOMPtr_base(aRawPtr)
  {
    if (mRawPtr) {
      (mRawPtr)->AddRef();
    }
                                       ;
  }


               nsCOMPtr(already_AddRefed<nsISupports>& aSmartPtr)
    : nsCOMPtr_base(aSmartPtr.take())
  {
                                       ;
  }


               nsCOMPtr(already_AddRefed<nsISupports>&& aSmartPtr)
    : nsCOMPtr_base(aSmartPtr.take())
  {
                                       ;
  }


               nsCOMPtr(const nsQueryInterface aQI)
    : nsCOMPtr_base(nullptr)
  {
                                       ;
    assign_from_qi(aQI, (nsISupports::COMTypeInfo<nsISupports, void>::kIID));
  }


               nsCOMPtr(const nsQueryInterfaceWithError& aQI)
    : nsCOMPtr_base(nullptr)
  {
                                       ;
    assign_from_qi_with_error(aQI, (nsISupports::COMTypeInfo<nsISupports, void>::kIID));
  }


               nsCOMPtr(const nsGetServiceByCID aGS)
    : nsCOMPtr_base(nullptr)
  {
                                       ;
    assign_from_gs_cid(aGS, (nsISupports::COMTypeInfo<nsISupports, void>::kIID));
  }


               nsCOMPtr(const nsGetServiceByCIDWithError& aGS)
    : nsCOMPtr_base(nullptr)
  {
                                       ;
    assign_from_gs_cid_with_error(aGS, (nsISupports::COMTypeInfo<nsISupports, void>::kIID));
  }


               nsCOMPtr(const nsGetServiceByContractID aGS)
    : nsCOMPtr_base(nullptr)
  {
                                       ;
    assign_from_gs_contractid(aGS, (nsISupports::COMTypeInfo<nsISupports, void>::kIID));
  }


               nsCOMPtr(const nsGetServiceByContractIDWithError& aGS)
    : nsCOMPtr_base(nullptr)
  {
                                       ;
    assign_from_gs_contractid_with_error(aGS, (nsISupports::COMTypeInfo<nsISupports, void>::kIID));
  }



               nsCOMPtr(const nsCOMPtr_helper& aHelper)
    : nsCOMPtr_base(nullptr)
  {
                                       ;
    assign_from_helper(aHelper, (nsISupports::COMTypeInfo<nsISupports, void>::kIID));
  }




  nsCOMPtr<nsISupports>& operator=(const nsCOMPtr<nsISupports>& aRhs)
  {
    assign_with_AddRef(aRhs.mRawPtr);
    return *this;
  }

  nsCOMPtr<nsISupports>& operator=(nsISupports* aRhs)
  {
    assign_with_AddRef(aRhs);
    return *this;
  }

  nsCOMPtr<nsISupports>& operator=(decltype(nullptr))
  {
    assign_assuming_AddRef(nullptr);
    return *this;
  }


  nsCOMPtr<nsISupports>& operator=(already_AddRefed<nsISupports>& aRhs)
  {
    assign_assuming_AddRef(aRhs.take());
    return *this;
  }


  nsCOMPtr<nsISupports>& operator=(already_AddRefed<nsISupports>&& aRhs)
  {
    assign_assuming_AddRef(aRhs.take());
    return *this;
  }


  nsCOMPtr<nsISupports>& operator=(const nsQueryInterface aRhs)
  {
    assign_from_qi(aRhs, (nsISupports::COMTypeInfo<nsISupports, void>::kIID));
    return *this;
  }


  nsCOMPtr<nsISupports>& operator=(const nsQueryInterfaceWithError& aRhs)
  {
    assign_from_qi_with_error(aRhs, (nsISupports::COMTypeInfo<nsISupports, void>::kIID));
    return *this;
  }


  nsCOMPtr<nsISupports>& operator=(const nsGetServiceByCID aRhs)
  {
    assign_from_gs_cid(aRhs, (nsISupports::COMTypeInfo<nsISupports, void>::kIID));
    return *this;
  }


  nsCOMPtr<nsISupports>& operator=(const nsGetServiceByCIDWithError& aRhs)
  {
    assign_from_gs_cid_with_error(aRhs, (nsISupports::COMTypeInfo<nsISupports, void>::kIID));
    return *this;
  }


  nsCOMPtr<nsISupports>& operator=(const nsGetServiceByContractID aRhs)
  {
    assign_from_gs_contractid(aRhs, (nsISupports::COMTypeInfo<nsISupports, void>::kIID));
    return *this;
  }


  nsCOMPtr<nsISupports>& operator=(const nsGetServiceByContractIDWithError& aRhs)
  {
    assign_from_gs_contractid_with_error(aRhs, (nsISupports::COMTypeInfo<nsISupports, void>::kIID));
    return *this;
  }



  nsCOMPtr<nsISupports>& operator=(const nsCOMPtr_helper& aRhs)
  {
    assign_from_helper(aRhs, (nsISupports::COMTypeInfo<nsISupports, void>::kIID));
    return *this;
  }


  void swap(nsCOMPtr<nsISupports>& aRhs)
  {
    nsISupports* temp = aRhs.mRawPtr;
                                        ;
                                    ;
                                    ;
                                  ;
    aRhs.mRawPtr = mRawPtr;
    mRawPtr = temp;
  }


  void swap(nsISupports*& aRhs)
  {
    nsISupports* temp = aRhs;
                                    ;
                                    ;
    aRhs = mRawPtr;
    mRawPtr = temp;
  }



  already_AddRefed<nsISupports> forget()
  {
    nsISupports* temp = nullptr;
    swap(temp);
    return already_AddRefed<nsISupports>(temp);
  }




  void forget(nsISupports** aRhs)
  {
    do { } while(0);
    *aRhs = nullptr;
    swap(*aRhs);
  }






  nsISupports* get() const { return reinterpret_cast<nsISupports*>(mRawPtr); }







  operator nsISupports* () const { return get(); }

  nsISupports* operator->() const
  {
    do { } while (0);

    return get();
  }


  nsCOMPtr<nsISupports>* get_address() { return this; }
  const nsCOMPtr<nsISupports>* get_address() const { return this; }

public:

  nsISupports& operator*() const
  {
    do { } while (0);

    return *get();
  }

  nsISupports** StartAssignment()
  {

    return reinterpret_cast<nsISupports**>(begin_assignment());




  }
};

template<typename T>
inline void
ImplCycleCollectionUnlink(nsCOMPtr<T>& aField)
{
  aField = nullptr;
}

template<typename T>
inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            nsCOMPtr<T>& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  CycleCollectionNoteChild(aCallback, aField.get(), aName, aFlags);
}
template<class T>
inline nsCOMPtr<T>*
address_of(nsCOMPtr<T>& aPtr)
{
  return aPtr.get_address();
}

template<class T>
inline const nsCOMPtr<T>*
address_of(const nsCOMPtr<T>& aPtr)
{
  return aPtr.get_address();
}
template<class T>
class nsGetterAddRefs
{
public:
  explicit nsGetterAddRefs(nsCOMPtr<T>& aSmartPtr)
    : mTargetSmartPtr(aSmartPtr)
  {
  }
  operator void**()
  {
    return reinterpret_cast<void**>(mTargetSmartPtr.StartAssignment());
  }

  operator T**() { return mTargetSmartPtr.StartAssignment(); }
  T*& operator*() { return *(mTargetSmartPtr.StartAssignment()); }

private:
  nsCOMPtr<T>& mTargetSmartPtr;
};


template<>
class nsGetterAddRefs<nsISupports>
{
public:
  explicit nsGetterAddRefs(nsCOMPtr<nsISupports>& aSmartPtr)
    : mTargetSmartPtr(aSmartPtr)
  {
  }
  operator void**()
  {
    return reinterpret_cast<void**>(mTargetSmartPtr.StartAssignment());
  }

  operator nsISupports**() { return mTargetSmartPtr.StartAssignment(); }
  nsISupports*& operator*() { return *(mTargetSmartPtr.StartAssignment()); }

private:
  nsCOMPtr<nsISupports>& mTargetSmartPtr;
};

template<class T>
inline nsGetterAddRefs<T>
getter_AddRefs(nsCOMPtr<T>& aSmartPtr)
{
  return nsGetterAddRefs<T>(aSmartPtr);
}

template<class T, class DestinationType>
inline nsresult
CallQueryInterface(T* aSource, nsGetterAddRefs<DestinationType> aDestination)
{
  return CallQueryInterface(aSource,
                            static_cast<DestinationType**>(aDestination));
}




template<class T, class U>
inline bool
operator==(const nsCOMPtr<T>& aLhs, const nsCOMPtr<U>& aRhs)
{
  return static_cast<const T*>(aLhs.get()) == static_cast<const U*>(aRhs.get());
}


template<class T, class U>
inline bool
operator!=(const nsCOMPtr<T>& aLhs, const nsCOMPtr<U>& aRhs)
{
  return static_cast<const T*>(aLhs.get()) != static_cast<const U*>(aRhs.get());
}




template<class T, class U>
inline bool
operator==(const nsCOMPtr<T>& aLhs, const U* aRhs)
{
  return static_cast<const T*>(aLhs.get()) == aRhs;
}

template<class T, class U>
inline bool
operator==(const U* aLhs, const nsCOMPtr<T>& aRhs)
{
  return aLhs == static_cast<const T*>(aRhs.get());
}

template<class T, class U>
inline bool
operator!=(const nsCOMPtr<T>& aLhs, const U* aRhs)
{
  return static_cast<const T*>(aLhs.get()) != aRhs;
}

template<class T, class U>
inline bool
operator!=(const U* aLhs, const nsCOMPtr<T>& aRhs)
{
  return aLhs != static_cast<const T*>(aRhs.get());
}

template<class T, class U>
inline bool
operator==(const nsCOMPtr<T>& aLhs, U* aRhs)
{
  return static_cast<const T*>(aLhs.get()) == const_cast<const U*>(aRhs);
}

template<class T, class U>
inline bool
operator==(U* aLhs, const nsCOMPtr<T>& aRhs)
{
  return const_cast<const U*>(aLhs) == static_cast<const T*>(aRhs.get());
}

template<class T, class U>
inline bool
operator!=(const nsCOMPtr<T>& aLhs, U* aRhs)
{
  return static_cast<const T*>(aLhs.get()) != const_cast<const U*>(aRhs);
}

template<class T, class U>
inline bool
operator!=(U* aLhs, const nsCOMPtr<T>& aRhs)
{
  return const_cast<const U*>(aLhs) != static_cast<const T*>(aRhs.get());
}





template<class T>
inline bool
operator==(const nsCOMPtr<T>& aLhs, decltype(nullptr))
{
  return aLhs.get() == nullptr;
}

template<class T>
inline bool
operator==(decltype(nullptr), const nsCOMPtr<T>& aRhs)
{
  return nullptr == aRhs.get();
}

template<class T>
inline bool
operator!=(const nsCOMPtr<T>& aLhs, decltype(nullptr))
{
  return aLhs.get() != nullptr;
}

template<class T>
inline bool
operator!=(decltype(nullptr), const nsCOMPtr<T>& aRhs)
{
  return nullptr != aRhs.get();
}




inline bool
SameCOMIdentity(nsISupports* aLhs, nsISupports* aRhs)
{
  return nsCOMPtr<nsISupports>(do_QueryInterface(aLhs)) ==
    nsCOMPtr<nsISupports>(do_QueryInterface(aRhs));
}



template<class SourceType, class DestinationType>
inline nsresult
CallQueryInterface(nsCOMPtr<SourceType>& aSourcePtr, DestinationType** aDestPtr)
{
  return CallQueryInterface(aSourcePtr.get(), aDestPtr);
}

template <class T>
RefPtr<T>::RefPtr(const nsCOMPtr_helper& aHelper)
{
  void* newRawPtr;
  if (((bool)(__builtin_expect(!!(NS_FAILED_impl(aHelper((T::template COMTypeInfo<T, void>::kIID), &newRawPtr))), 0)))) {
    newRawPtr = nullptr;
  }
  mRawPtr = static_cast<T*>(newRawPtr);
}

template <class T>
RefPtr<T>&
RefPtr<T>::operator=(const nsCOMPtr_helper& aHelper)
{
  void* newRawPtr;
  if (((bool)(__builtin_expect(!!(NS_FAILED_impl(aHelper((T::template COMTypeInfo<T, void>::kIID), &newRawPtr))), 0)))) {
    newRawPtr = nullptr;
  }
  assign_assuming_AddRef(static_cast<T*>(newRawPtr));
  return *this;
}
template<class T> struct already_AddRefed;
class nsStringBuffer
{
private:
  friend class CheckStaticAtomSizes;

  std::atomic<uint32_t> mRefCount;
  uint32_t mStorageSize;

public:
  static already_AddRefed<nsStringBuffer> Alloc(size_t aStorageSize);
  static nsStringBuffer* Realloc(nsStringBuffer* aBuf, size_t aStorageSize);




  void AddRef();





  void Release();






  static nsStringBuffer* FromData(void* aData)
  {
    return reinterpret_cast<nsStringBuffer*>(aData) - 1;
  }




  void* Data() const
  {
    return const_cast<char*>(reinterpret_cast<const char*>(this + 1));
  }






  uint32_t StorageSize() const
  {
    return mStorageSize;
  }
  bool IsReadonly() const
  {
    return mRefCount.load(std::memory_order_relaxed) > 1;
  }
  static nsStringBuffer* FromString(const nsAString& aStr);
  static nsStringBuffer* FromString(const nsACString& aStr);
  void ToString(uint32_t aLen, nsAString& aStr, bool aMoveOwnership = false);
  void ToString(uint32_t aLen, nsACString& aStr, bool aMoveOwnership = false);




  size_t SizeOfIncludingThisIfUnshared(mozilla::MallocSizeOf aMallocSizeOf) const;
  size_t SizeOfIncludingThisEvenIfShared(mozilla::MallocSizeOf aMallocSizeOf) const;
};








class nsIAtom : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult ScriptableToString(nsAString & _retval) = 0;


  virtual nsresult ToUTF8String(nsACString & _retval) = 0;


  virtual nsresult ScriptableEquals(const nsAString & aString, bool *_retval) = 0;


  virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) = 0;


  inline bool Equals(char16ptr_t aString, uint32_t aLength) const
  {
    return mLength == aLength &&
           memcmp(mString, aString, mLength * sizeof(char16_t)) == 0;
  }
  inline bool Equals(const nsAString& aString) const {
    return Equals(aString.BeginReading(), aString.Length());
  }
  inline bool IsStaticAtom() const {
    return mIsStatic;
  }
  inline char16ptr_t GetUTF16String() const {
    return mString;
  }
  inline uint32_t GetLength() const {
    return mLength;
  }
  inline void ToString(nsAString& aBuf) const {

    nsStringBuffer::FromData(mString)->ToString(mLength, aBuf);
  }
  inline nsStringBuffer* GetStringBuffer() const {

    return nsStringBuffer::FromData(mString);
  }





  inline uint32_t hash() const {
    return mHash;
  }
protected:
  uint32_t mLength:31;
  uint32_t mIsStatic:1;
  uint32_t mHash;





  char16_t* mString;
};

  template<typename T> struct nsIAtom::COMTypeInfo<nsIAtom, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIAtom::COMTypeInfo<nsIAtom, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x8b8c11d4, 0x3ed5, 0x4079, { 0x89, 0x74, 0x73, 0xc7, 0x57, 0x6c, 0xdb, 0x34 }};
extern already_AddRefed<nsIAtom> NS_Atomize(const char* aUTF8String);



extern already_AddRefed<nsIAtom> NS_Atomize(const nsACString& aUTF8String);




extern already_AddRefed<nsIAtom> NS_Atomize(const char16_t* aUTF16String);



extern already_AddRefed<nsIAtom> NS_Atomize(const nsAString& aUTF16String);



extern already_AddRefed<nsIAtom> NS_AtomizeMainThread(const nsAString& aUTF16String);




extern nsrefcnt NS_GetNumberOfAtoms(void);




extern nsIAtom* NS_GetStaticAtom(const nsAString& aUTF16String);



extern void NS_SealStaticAtomTable();
class nsAtomString : public nsString
{
public:
  explicit nsAtomString(const nsIAtom* aAtom)
  {
    aAtom->ToString(*this);
  }
};
class nsAtomCString : public nsCString
{
public:
  explicit nsAtomCString(nsIAtom* aAtom)
  {
    aAtom->ToUTF8String(*this);
  }
};
class nsDependentAtomString : public nsDependentString
{
public:
  explicit nsDependentAtomString(const nsIAtom* aAtom)
    : nsDependentString(aAtom->GetUTF16String(), aAtom->GetLength())
  {
  }
};

class nsIDocument;
class nsNodeInfoManager;

namespace mozilla {
namespace dom {

class NodeInfo final
{
public:
  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<NodeInfo>::value, "Reference-counted class " "NodeInfo" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); nsrefcnt count = mRefCnt.incr(static_cast<void*>(this), NodeInfo::cycleCollection::GetParticipant()); ; return count; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); nsrefcnt count = mRefCnt.decr(static_cast<void*>(this), NodeInfo::cycleCollection::GetParticipant()); ; return count; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:
  class cycleCollection : public nsCycleCollectionParticipant { public: constexpr cycleCollection () : nsCycleCollectionParticipant(true) {} private: public: virtual void Root(void *n) override; virtual void Unlink(void *n) override; virtual void Unroot(void *n) override; virtual nsresult TraverseNative(void *n, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "NodeInfo"; }; virtual void DeleteCycleCollectable(void *n) override { DowncastCCParticipant<NodeInfo>(n)->DeleteCycleCollectable(); } static NodeInfo* Downcast(void* s) { return DowncastCCParticipant<NodeInfo>(s); } static void* Upcast(NodeInfo *p) { return static_cast<void*>(p); } virtual bool CanSkipReal(void *p, bool aRemovingAllowed) override; virtual bool CanSkipInCCReal(void *p) override; virtual bool CanSkipThisReal(void *p) override; static nsCycleCollectionParticipant* GetParticipant() { return &NodeInfo::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;







  void GetName(nsAString& aName) const;
  nsIAtom* NameAtom() const
  {
    return mInner.mName;
  }
  const nsString& QualifiedName() const {
    return mQualifiedName;
  }




  const nsString& NodeName() const {
    return mNodeName;
  }




  const nsString& LocalName() const {
    return mLocalName;
  }







  void GetPrefix(nsAString& aPrefix) const;







  nsIAtom* GetPrefixAtom() const
  {
    return mInner.mPrefix;
  }




  void GetNamespaceURI(nsAString& aNameSpaceURI) const;





  int32_t NamespaceID() const
  {
    return mInner.mNamespaceID;
  }





  uint16_t NodeType() const
  {
    return mInner.mNodeType;
  }




  nsIAtom* GetExtraName() const
  {
    return mInner.mExtraName;
  }





  nsNodeInfoManager* NodeInfoManager() const
  {
    return mOwnerManager;
  }






  inline bool Equals(NodeInfo* aNodeInfo) const;

  bool NameAndNamespaceEquals(NodeInfo* aNodeInfo) const;

  bool Equals(nsIAtom* aNameAtom) const
  {
    return mInner.mName == aNameAtom;
  }

  bool Equals(nsIAtom* aNameAtom, nsIAtom* aPrefixAtom) const
  {
    return (mInner.mName == aNameAtom) && (mInner.mPrefix == aPrefixAtom);
  }

  bool Equals(nsIAtom* aNameAtom, int32_t aNamespaceID) const
  {
    return ((mInner.mName == aNameAtom) &&
            (mInner.mNamespaceID == aNamespaceID));
  }

  bool Equals(nsIAtom* aNameAtom, nsIAtom* aPrefixAtom, int32_t aNamespaceID) const
  {
    return ((mInner.mName == aNameAtom) &&
            (mInner.mPrefix == aPrefixAtom) &&
            (mInner.mNamespaceID == aNamespaceID));
  }

  bool NamespaceEquals(int32_t aNamespaceID) const
  {
    return mInner.mNamespaceID == aNamespaceID;
  }

  inline bool Equals(const nsAString& aName) const;

  inline bool Equals(const nsAString& aName, const nsAString& aPrefix) const;

  inline bool Equals(const nsAString& aName, int32_t aNamespaceID) const;

  inline bool Equals(const nsAString& aName, const nsAString& aPrefix, int32_t aNamespaceID) const;

  bool NamespaceEquals(const nsAString& aNamespaceURI) const;

  inline bool QualifiedNameEquals(nsIAtom* aNameAtom) const;

  bool QualifiedNameEquals(const nsAString& aQualifiedName) const
  {
    return mQualifiedName == aQualifiedName;
  }




  nsIDocument* GetDocument() const
  {
    return mDocument;
  }

private:
  NodeInfo() = delete;
  NodeInfo(const NodeInfo& aOther) = delete;



  NodeInfo(nsIAtom* aName, nsIAtom* aPrefix, int32_t aNamespaceID,
           uint16_t aNodeType, nsIAtom* aExtraName,
           nsNodeInfoManager* aOwnerManager);

  ~NodeInfo();

public:
  bool CanSkip();





  void DeleteCycleCollectable();

protected:
  class NodeInfoInner
  {
  public:
    NodeInfoInner()
      : mName(nullptr), mPrefix(nullptr), mNamespaceID(-1),
        mNodeType(0), mNameString(nullptr), mExtraName(nullptr)
    {
    }
    NodeInfoInner(nsIAtom *aName, nsIAtom *aPrefix, int32_t aNamespaceID,
                    uint16_t aNodeType, nsIAtom* aExtraName)
      : mName(aName), mPrefix(aPrefix), mNamespaceID(aNamespaceID),
        mNodeType(aNodeType), mNameString(nullptr), mExtraName(aExtraName)
    {
    }
    NodeInfoInner(const nsAString& aTmpName, nsIAtom *aPrefix,
                    int32_t aNamespaceID, uint16_t aNodeType)
      : mName(nullptr), mPrefix(aPrefix), mNamespaceID(aNamespaceID),
        mNodeType(aNodeType), mNameString(&aTmpName), mExtraName(nullptr)
    {
    }

    nsCOMPtr<nsIAtom> mName;
    nsCOMPtr<nsIAtom> mPrefix;
    int32_t mNamespaceID;
    uint16_t mNodeType;
    const nsAString* mNameString;
    nsCOMPtr<nsIAtom> mExtraName;
  };


  friend class ::nsNodeInfoManager;



  nsIDocument* mDocument;

  NodeInfoInner mInner;

  RefPtr<nsNodeInfoManager> mOwnerManager;







  nsString mQualifiedName;


  nsString mNodeName;



  nsString mLocalName;
};

}
}

inline bool DOMStringIsNull(const nsAString& aString)
{
  return aString.IsVoid();
}

inline void SetDOMStringToNull(nsAString& aString)
{
  aString.SetIsVoid(true);
}


class nsAttrName
{
public:
  nsAttrName(const nsAttrName& aOther)
    : mBits(aOther.mBits)
  {
    AddRefInternalName();
  }

  explicit nsAttrName(nsIAtom* aAtom)
    : mBits(reinterpret_cast<uintptr_t>(aAtom))
  {
    do { } while(0);
    (aAtom)->AddRef();
  }

  explicit nsAttrName(mozilla::dom::NodeInfo* aNodeInfo)
  {
    do { } while(0);
    if (aNodeInfo->NamespaceEquals(kNameSpaceID_None)) {
      mBits = reinterpret_cast<uintptr_t>(aNodeInfo->NameAtom());
      (aNodeInfo->NameAtom())->AddRef();
    }
    else {
      mBits = reinterpret_cast<uintptr_t>(aNodeInfo) |
              1;
      (aNodeInfo)->AddRef();
    }
  }

  ~nsAttrName()
  {
    ReleaseInternalName();
  }

  void SetTo(mozilla::dom::NodeInfo* aNodeInfo)
  {
    do { } while(0);

    ReleaseInternalName();
    if (aNodeInfo->NamespaceEquals(kNameSpaceID_None)) {
      mBits = reinterpret_cast<uintptr_t>(aNodeInfo->NameAtom());
      (aNodeInfo->NameAtom())->AddRef();
    }
    else {
      mBits = reinterpret_cast<uintptr_t>(aNodeInfo) |
              1;
      (aNodeInfo)->AddRef();
    }
  }

  void SetTo(nsIAtom* aAtom)
  {
    do { } while(0);

    ReleaseInternalName();
    mBits = reinterpret_cast<uintptr_t>(aAtom);
    (aAtom)->AddRef();
  }

  bool IsAtom() const
  {
    return !(mBits & 1);
  }

  mozilla::dom::NodeInfo* NodeInfo() const
  {
    do { } while(0);
    return reinterpret_cast<mozilla::dom::NodeInfo*>(mBits & ~1);
  }

  nsIAtom* Atom() const
  {
    do { } while(0);
    return reinterpret_cast<nsIAtom*>(mBits);
  }

  bool Equals(const nsAttrName& aOther) const
  {
    return mBits == aOther.mBits;
  }


  bool Equals(nsIAtom* aAtom) const
  {
    return reinterpret_cast<uintptr_t>(aAtom) == mBits;
  }


  bool Equals(const nsAString& aLocalName) const
  {
    return IsAtom() && Atom()->Equals(aLocalName);
  }

  bool Equals(nsIAtom* aLocalName, int32_t aNamespaceID) const
  {
    if (aNamespaceID == kNameSpaceID_None) {
      return Equals(aLocalName);
    }
    return !IsAtom() && NodeInfo()->Equals(aLocalName, aNamespaceID);
  }

  bool Equals(mozilla::dom::NodeInfo* aNodeInfo) const
  {
    return Equals(aNodeInfo->NameAtom(), aNodeInfo->NamespaceID());
  }

  int32_t NamespaceID() const
  {
    return IsAtom() ? kNameSpaceID_None : NodeInfo()->NamespaceID();
  }

  int32_t NamespaceEquals(int32_t aNamespaceID) const
  {
    return aNamespaceID == kNameSpaceID_None ?
           IsAtom() :
           (!IsAtom() && NodeInfo()->NamespaceEquals(aNamespaceID));
  }

  nsIAtom* LocalName() const
  {
    return IsAtom() ? Atom() : NodeInfo()->NameAtom();
  }

  nsIAtom* GetPrefix() const
  {
    return IsAtom() ? nullptr : NodeInfo()->GetPrefixAtom();
  }

  bool QualifiedNameEquals(const nsAString& aName) const
  {
    return IsAtom() ? Atom()->Equals(aName) :
                      NodeInfo()->QualifiedNameEquals(aName);
  }

  void GetQualifiedName(nsAString& aStr) const
  {
    if (IsAtom()) {
      Atom()->ToString(aStr);
    }
    else {
      aStr = NodeInfo()->QualifiedName();
    }
  }


  void GetPrefix(nsAString& aStr) const
  {
    if (IsAtom()) {
      SetDOMStringToNull(aStr);
    }
    else {
      NodeInfo()->GetPrefix(aStr);
    }
  }


  uint32_t HashValue() const
  {



    return mBits - 0;
  }

  bool IsSmaller(nsIAtom* aOther) const
  {
    return mBits < reinterpret_cast<uintptr_t>(aOther);
  }

private:

  void AddRefInternalName()
  {
    if (IsAtom()) {
      (Atom())->AddRef();
    } else {
      (NodeInfo())->AddRef();
    }
  }

  void ReleaseInternalName()
  {
    if (IsAtom()) {
      Atom()->Release();
    } else {
      NodeInfo()->Release();
    }
  }

  uintptr_t mBits;
};


















inline double
NS_round(double aNum)
{
  return aNum >= 0.0 ? floor(aNum + 0.5) : ceil(aNum - 0.5);
}
inline float
NS_roundf(float aNum)
{
  return aNum >= 0.0f ? floorf(aNum + 0.5f) : ceilf(aNum - 0.5f);
}
inline int32_t
NS_lround(double aNum)
{
  return aNum >= 0.0 ? int32_t(aNum + 0.5) : int32_t(aNum - 0.5);
}
inline int32_t
NS_lroundf(float aNum)
{
  return aNum >= 0.0f ? int32_t(aNum + 0.5f) : int32_t(aNum - 0.5f);
}






inline double
NS_hypot(double aNum1, double aNum2)
{

  return __builtin_hypot(aNum1, aNum2);





}





inline bool
NS_finite(double aNum)
{
  return finite(aNum);

}







inline double
NS_floorModulo(double aNum1, double aNum2)
{
  return (aNum1 - aNum2 * floor(aNum1 / aNum2));
}

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;

inline float NS_IEEEPositiveInfinity() {
  union { uint32_t mPRUint32; float mFloat; } pun;
  pun.mPRUint32 = 0x7F800000;
  return pun.mFloat;
}
inline bool NS_IEEEIsNan(float aF) {
  union { uint32_t mBits; float mFloat; } pun;
  pun.mFloat = aF;
  return (pun.mBits & 0x7F800000) == 0x7F800000 &&
    (pun.mBits & 0x007FFFFF) != 0;
}





typedef int32_t nscoord;





inline void VERIFY_COORD(nscoord aCoord) {




}





inline nscoord NSCoordDivRem(nscoord aSpace, size_t aN, nscoord* aQuotient)
{




  div_t result = div(aSpace, aN);
  *aQuotient = nscoord(result.quot);
  return nscoord(result.rem);

}

inline nscoord NSCoordMulDiv(nscoord aMult1, nscoord aMult2, nscoord aDiv) {



  return (int64_t(aMult1) * int64_t(aMult2) / int64_t(aDiv));

}

inline nscoord NSToCoordRound(float aValue)
{



  return nscoord(floorf(aValue + 0.5f));

}

inline nscoord NSToCoordRound(double aValue)
{



  return nscoord(floor(aValue + 0.5f));

}

inline nscoord NSToCoordRoundWithClamp(float aValue)
{


  if (aValue >= nscoord(1 << 30)) {
    return nscoord(1 << 30);
  }
  if (aValue <= (-nscoord(1 << 30))) {
    return (-nscoord(1 << 30));
  }

  return NSToCoordRound(aValue);
}







inline nscoord _nscoordSaturatingMultiply(nscoord aCoord, float aScale,
                                          bool requireNotNegative) {
  VERIFY_COORD(aCoord);
  if (requireNotNegative) {
    do { } while (0);

  }



  float product = aCoord * aScale;
  if (requireNotNegative ? aCoord > 0 : (aCoord > 0) == (aScale > 0))
    return NSToCoordRoundWithClamp(std::min<float>(nscoord(1 << 30), product));
  return NSToCoordRoundWithClamp(std::max<float>((-nscoord(1 << 30)), product));

}







inline nscoord NSCoordSaturatingNonnegativeMultiply(nscoord aCoord, float aScale) {
  return _nscoordSaturatingMultiply(aCoord, aScale, true);
}





inline nscoord NSCoordSaturatingMultiply(nscoord aCoord, float aScale) {
  return _nscoordSaturatingMultiply(aCoord, aScale, false);
}
inline nscoord
NSCoordSaturatingAdd(nscoord a, nscoord b)
{
  VERIFY_COORD(a);
  VERIFY_COORD(b);





  if (a == nscoord(1 << 30) || b == nscoord(1 << 30)) {

    return nscoord(1 << 30);
  } else {


    return std::min(nscoord(1 << 30), a + b);
  }

}
inline nscoord
NSCoordSaturatingSubtract(nscoord a, nscoord b,
                          nscoord infMinusInfResult)
{
  VERIFY_COORD(a);
  VERIFY_COORD(b);

  if (b == nscoord(1 << 30)) {
    if (a == nscoord(1 << 30)) {

      return infMinusInfResult;
    } else {

      do { } while(0);
      return 0;
    }
  } else {




    if (a == nscoord(1 << 30)) {

      return nscoord(1 << 30);
    } else {


      return std::min(nscoord(1 << 30), a - b);
    }

  }
}

inline float NSCoordToFloat(nscoord aCoord) {
  VERIFY_COORD(aCoord);



  return (float)aCoord;
}




inline nscoord NSToCoordFloor(float aValue)
{
  return nscoord(floorf(aValue));
}

inline nscoord NSToCoordFloor(double aValue)
{
  return nscoord(floor(aValue));
}

inline nscoord NSToCoordFloorClamped(float aValue)
{


  if (aValue >= nscoord(1 << 30)) {
    return nscoord(1 << 30);
  }
  if (aValue <= (-nscoord(1 << 30))) {
    return (-nscoord(1 << 30));
  }

  return NSToCoordFloor(aValue);
}

inline nscoord NSToCoordCeil(float aValue)
{
  return nscoord(ceilf(aValue));
}

inline nscoord NSToCoordCeil(double aValue)
{
  return nscoord(ceil(aValue));
}

inline nscoord NSToCoordCeilClamped(double aValue)
{


  if (aValue >= nscoord(1 << 30)) {
    return nscoord(1 << 30);
  }
  if (aValue <= (-nscoord(1 << 30))) {
    return (-nscoord(1 << 30));
  }

  return NSToCoordCeil(aValue);
}





inline nscoord NSToCoordTrunc(float aValue)
{


  return nscoord(aValue);
}

inline nscoord NSToCoordTrunc(double aValue)
{


  return nscoord(aValue);
}

inline nscoord NSToCoordTruncClamped(float aValue)
{


  if (aValue >= nscoord(1 << 30)) {
    return nscoord(1 << 30);
  }
  if (aValue <= (-nscoord(1 << 30))) {
    return (-nscoord(1 << 30));
  }

  return NSToCoordTrunc(aValue);
}

inline nscoord NSToCoordTruncClamped(double aValue)
{


  if (aValue >= nscoord(1 << 30)) {
    return nscoord(1 << 30);
  }
  if (aValue <= (-nscoord(1 << 30))) {
    return (-nscoord(1 << 30));
  }

  return NSToCoordTrunc(aValue);
}




inline int32_t NSToIntFloor(float aValue)
{
  return int32_t(floorf(aValue));
}

inline int32_t NSToIntCeil(float aValue)
{
  return int32_t(ceilf(aValue));
}

inline int32_t NSToIntRound(float aValue)
{
  return NS_lroundf(aValue);
}

inline int32_t NSToIntRound(double aValue)
{
  return NS_lround(aValue);
}

inline int32_t NSToIntRoundUp(double aValue)
{
  return int32_t(floor(aValue + 0.5));
}




inline nscoord NSFloatPixelsToAppUnits(float aPixels, float aAppUnitsPerPixel)
{
  return NSToCoordRoundWithClamp(aPixels * aAppUnitsPerPixel);
}

inline nscoord NSIntPixelsToAppUnits(int32_t aPixels, int32_t aAppUnitsPerPixel)
{


  nscoord r = aPixels * (nscoord)aAppUnitsPerPixel;
  VERIFY_COORD(r);
  return r;
}

inline float NSAppUnitsToFloatPixels(nscoord aAppUnits, float aAppUnitsPerPixel)
{
  return (float(aAppUnits) / aAppUnitsPerPixel);
}

inline double NSAppUnitsToDoublePixels(nscoord aAppUnits, double aAppUnitsPerPixel)
{
  return (double(aAppUnits) / aAppUnitsPerPixel);
}

inline int32_t NSAppUnitsToIntPixels(nscoord aAppUnits, float aAppUnitsPerPixel)
{
  return NSToIntRound(float(aAppUnits) / aAppUnitsPerPixel);
}

inline float NSCoordScale(nscoord aCoord, int32_t aFromAPP, int32_t aToAPP)
{
  return (NSCoordToFloat(aCoord) * aToAPP) / aFromAPP;
}
inline float NSUnitsToTwips(float aValue, float aPointsPerUnit)
{
  return aValue * aPointsPerUnit * 20.0f;
}

inline float NSTwipsToUnits(float aTwips, float aUnitsPerPoint)
{
  return (aTwips * (aUnitsPerPoint / 20.0f));
}

class nsAString;
class nsString;



typedef uint32_t nscolor;
namespace mozilla {

template<typename T>
inline uint8_t ClampColor(T aColor)
{
  if (aColor >= 255) {
    return 255;
  }
  if (aColor <= 0) {
    return 0;
  }
  return NSToIntRound(aColor);
}

}
enum class nsHexColorType : uint8_t {
  NoAlpha,
  AllowAlpha,
};




bool
NS_HexToRGBA(const nsAString& aBuf, nsHexColorType aType, nscolor* aResult);



nscolor NS_ComposeColors(nscolor aBG, nscolor aFG);

namespace mozilla {

inline uint32_t RoundingDivideBy255(uint32_t n)
{



  return (n + 127) / 255;
}



nscolor LinearBlendColors(nscolor aBg, nscolor aFg, uint_fast8_t aFgRatio);

}




bool NS_LooseHexToRGB(const nsString& aBuf, nscolor* aResult);






bool NS_ColorNameToRGB(const nsAString& aBuf, nscolor* aResult);



const char * const * NS_AllColorNames(size_t *aSizeArray);



nscolor NS_HSL2RGB(float h, float s, float l);






const char* NS_RGBToColorName(nscolor aColor);
enum nsCaseTreatment {
  eCaseMatters,
  eIgnoreCase
};
namespace mozilla {
namespace gfx {






template <class T, class Sub>
struct BaseSize {
  union {
    struct {
      T width, height;
    };
    T components[2];
  };


  constexpr BaseSize() : width(0), height(0) {}
  constexpr BaseSize(T aWidth, T aHeight) : width(aWidth), height(aHeight) {}

  void SizeTo(T aWidth, T aHeight) { width = aWidth; height = aHeight; }

  bool IsEmpty() const {
    return width <= 0 || height <= 0;
  }

  bool IsSquare() const {
    return width == height;
  }




  bool operator==(const Sub& aSize) const {
    return width == aSize.width && height == aSize.height;
  }
  bool operator!=(const Sub& aSize) const {
    return width != aSize.width || height != aSize.height;
  }
  bool operator<=(const Sub& aSize) const {
    return width <= aSize.width && height <= aSize.height;
  }
  bool operator<(const Sub& aSize) const {
    return *this <= aSize && *this != aSize;
  }

  Sub operator+(const Sub& aSize) const {
    return Sub(width + aSize.width, height + aSize.height);
  }
  Sub operator-(const Sub& aSize) const {
    return Sub(width - aSize.width, height - aSize.height);
  }
  Sub& operator+=(const Sub& aSize) {
    width += aSize.width;
    height += aSize.height;
    return *static_cast<Sub*>(this);
  }
  Sub& operator-=(const Sub& aSize) {
    width -= aSize.width;
    height -= aSize.height;
    return *static_cast<Sub*>(this);
  }

  Sub operator*(T aScale) const {
    return Sub(width * aScale, height * aScale);
  }
  Sub operator/(T aScale) const {
    return Sub(width / aScale, height / aScale);
  }
  friend Sub operator*(T aScale, const Sub& aSize) {
    return Sub(aScale * aSize.width, aScale * aSize.height);
  }
  void Scale(T aXScale, T aYScale) {
    width *= aXScale;
    height *= aYScale;
  }

  Sub operator*(const Sub& aSize) const {
    return Sub(width * aSize.width, height * aSize.height);
  }
  Sub operator/(const Sub& aSize) const {
    return Sub(width / aSize.width, height / aSize.height);
  }

  friend Sub Min(const Sub& aA, const Sub& aB) {
    return Sub(std::min(aA.width, aB.width),
               std::min(aA.height, aB.height));
  }

  friend Sub Max(const Sub& aA, const Sub& aB) {
    return Sub(std::max(aA.width, aB.width),
               std::max(aA.height, aB.height));
  }

  friend std::ostream& operator<<(std::ostream& aStream,
      const BaseSize<T, Sub>& aSize) {
    return aStream << aSize.width << " x " << aSize.height;
  }
};

}
}













namespace mozilla {
namespace gfx {






template <class T, class Sub, class Coord = T>
struct BasePoint {
  union {
    struct {
      T x, y;
    };
    T components[2];
  };


  constexpr BasePoint() : x(0), y(0) {}
  constexpr BasePoint(Coord aX, Coord aY) : x(aX), y(aY) {}

  void MoveTo(T aX, T aY) { x = aX; y = aY; }
  void MoveBy(T aDx, T aDy) { x += aDx; y += aDy; }




  bool operator==(const Sub& aPoint) const {
    return x == aPoint.x && y == aPoint.y;
  }
  bool operator!=(const Sub& aPoint) const {
    return x != aPoint.x || y != aPoint.y;
  }

  Sub operator+(const Sub& aPoint) const {
    return Sub(x + aPoint.x, y + aPoint.y);
  }
  Sub operator-(const Sub& aPoint) const {
    return Sub(x - aPoint.x, y - aPoint.y);
  }
  Sub& operator+=(const Sub& aPoint) {
    x += aPoint.x;
    y += aPoint.y;
    return *static_cast<Sub*>(this);
  }
  Sub& operator-=(const Sub& aPoint) {
    x -= aPoint.x;
    y -= aPoint.y;
    return *static_cast<Sub*>(this);
  }

  Sub operator*(T aScale) const {
    return Sub(x * aScale, y * aScale);
  }
  Sub operator/(T aScale) const {
    return Sub(x / aScale, y / aScale);
  }

  Sub operator-() const {
    return Sub(-x, -y);
  }

  T DotProduct(const Sub& aPoint) const {
      return x * aPoint.x + y * aPoint.y;
  }

  Coord Length() const {
    return hypot(x, y);
  }

  T LengthSquare() const {
    return x * x + y * y;
  }




  Sub& Round() {
    x = Coord(floor(T(x) + T(0.5)));
    y = Coord(floor(T(y) + T(0.5)));
    return *static_cast<Sub*>(this);
  }


  bool IsFinite() const
  {
    typedef typename mozilla::Conditional<mozilla::IsSame<T, float>::value, float, double>::Type FloatType;
    return (mozilla::IsFinite(FloatType(x)) && mozilla::IsFinite(FloatType(y)));
    return true;
  }

  void Clamp(T aMaxAbsValue)
  {
    x = std::max(std::min(x, aMaxAbsValue), -aMaxAbsValue);
    y = std::max(std::min(y, aMaxAbsValue), -aMaxAbsValue);
  }

  friend std::ostream& operator<<(std::ostream& stream, const BasePoint<T, Sub, Coord>& aPoint) {
    return stream << '(' << aPoint.x << ',' << aPoint.y << ')';
  }

};

}
}


namespace mozilla {
namespace gfx {

typedef float Float;

enum class SurfaceType : int8_t {
  DATA,
  D2D1_BITMAP,
  D2D1_DRAWTARGET,
  CAIRO,
  CAIRO_IMAGE,
  COREGRAPHICS_IMAGE,
  COREGRAPHICS_CGCONTEXT,
  SKIA,
  DUAL_DT,
  D2D1_1_IMAGE,
  RECORDING,
  TILED,
  DATA_SHARED,
};

enum class SurfaceFormat : int8_t {




  B8G8R8A8,
  B8G8R8X8,
  R8G8B8A8,
  R8G8B8X8,
  A8R8G8B8,
  X8R8G8B8,

  R8G8B8,
  B8G8R8,




  R5G6B5_UINT16,


  A8,


  YUV,
  NV12,
  YUV422,
  HSV,
  Lab,
  Depth,


  UNKNOWN,





  A8R8G8B8_UINT32 = B8G8R8A8,
  X8R8G8B8_UINT32 = B8G8R8X8






};

inline bool IsOpaque(SurfaceFormat aFormat)
{
  switch (aFormat) {
  case SurfaceFormat::B8G8R8X8:
  case SurfaceFormat::R8G8B8X8:
  case SurfaceFormat::R5G6B5_UINT16:
  case SurfaceFormat::YUV:
  case SurfaceFormat::NV12:
  case SurfaceFormat::YUV422:
    return true;
  default:
    return false;
  }
}

enum class FilterType : int8_t {
  BLEND = 0,
  TRANSFORM,
  MORPHOLOGY,
  COLOR_MATRIX,
  FLOOD,
  TILE,
  TABLE_TRANSFER,
  DISCRETE_TRANSFER,
  LINEAR_TRANSFER,
  GAMMA_TRANSFER,
  CONVOLVE_MATRIX,
  DISPLACEMENT_MAP,
  TURBULENCE,
  ARITHMETIC_COMBINE,
  COMPOSITE,
  DIRECTIONAL_BLUR,
  GAUSSIAN_BLUR,
  POINT_DIFFUSE,
  POINT_SPECULAR,
  SPOT_DIFFUSE,
  SPOT_SPECULAR,
  DISTANT_DIFFUSE,
  DISTANT_SPECULAR,
  CROP,
  PREMULTIPLY,
  UNPREMULTIPLY
};

enum class DrawTargetType : int8_t {
  SOFTWARE_RASTER = 0,
  HARDWARE_RASTER,
  VECTOR
};

enum class BackendType : int8_t {
  NONE = 0,
  DIRECT2D,
  CAIRO,
  SKIA,
  RECORDING,
  DIRECT2D1_1,


  BACKEND_LAST
};

enum class FontType : int8_t {
  DWRITE,
  GDI,
  MAC,
  SKIA,
  CAIRO,
  COREGRAPHICS,
  FONTCONFIG
};

enum class NativeSurfaceType : int8_t {
  D3D10_TEXTURE,
  CAIRO_CONTEXT,
  CGCONTEXT,
  CGCONTEXT_ACCELERATED,
  OPENGL_TEXTURE
};

enum class NativeFontType : int8_t {
  DWRITE_FONT_FACE,
  GDI_FONT_FACE,
  MAC_FONT_FACE,
  SKIA_FONT_FACE,
  CAIRO_FONT_FACE
};

enum class FontStyle : int8_t {
  NORMAL,
  ITALIC,
  BOLD,
  BOLD_ITALIC
};

enum class FontHinting : int8_t {
  NONE,
  LIGHT,
  NORMAL,
  FULL
};

enum class CompositionOp : int8_t {
  OP_OVER,
  OP_ADD,
  OP_ATOP,
  OP_OUT,
  OP_IN,
  OP_SOURCE,
  OP_DEST_IN,
  OP_DEST_OUT,
  OP_DEST_OVER,
  OP_DEST_ATOP,
  OP_XOR,
  OP_MULTIPLY,
  OP_SCREEN,
  OP_OVERLAY,
  OP_DARKEN,
  OP_LIGHTEN,
  OP_COLOR_DODGE,
  OP_COLOR_BURN,
  OP_HARD_LIGHT,
  OP_SOFT_LIGHT,
  OP_DIFFERENCE,
  OP_EXCLUSION,
  OP_HUE,
  OP_SATURATION,
  OP_COLOR,
  OP_LUMINOSITY,
  OP_COUNT
};

enum class Axis : int8_t {
  X_AXIS,
  Y_AXIS,
  BOTH
};

enum class ExtendMode : int8_t {
  CLAMP,
  REPEAT,
  REPEAT_X,
  REPEAT_Y,
  REFLECT
};

enum class FillRule : int8_t {
  FILL_WINDING,
  FILL_EVEN_ODD
};

enum class AntialiasMode : int8_t {
  NONE,
  GRAY,
  SUBPIXEL,
  DEFAULT
};


enum class SamplingFilter : int8_t {
  GOOD,
  LINEAR,
  POINT,
  SENTINEL
};

enum class PatternType : int8_t {
  COLOR,
  SURFACE,
  LINEAR_GRADIENT,
  RADIAL_GRADIENT
};

enum class JoinStyle : int8_t {
  BEVEL,
  ROUND,
  MITER,


  MITER_OR_BEVEL
};

enum class CapStyle : int8_t {
  BUTT,
  ROUND,
  SQUARE
};

enum class SamplingBounds : int8_t {
  UNBOUNDED,
  BOUNDED
};


struct Color
{
public:
  Color()
    : r(0.0f), g(0.0f), b(0.0f), a(0.0f)
  {}
  Color(Float aR, Float aG, Float aB, Float aA)
    : r(aR), g(aG), b(aB), a(aA)
  {}
  Color(Float aR, Float aG, Float aB)
    : r(aR), g(aG), b(aB), a(1.0f)
  {}

  static Color FromABGR(uint32_t aColor)
  {
    Color newColor(((aColor >> 0) & 0xff) * (1.0f / 255.0f),
                   ((aColor >> 8) & 0xff) * (1.0f / 255.0f),
                   ((aColor >> 16) & 0xff) * (1.0f / 255.0f),
                   ((aColor >> 24) & 0xff) * (1.0f / 255.0f));

    return newColor;
  }



  static Color UnusualFromARGB(uint32_t aColor)
  {
    Color newColor(((aColor >> 16) & 0xff) * (1.0f / 255.0f),
                   ((aColor >> 8) & 0xff) * (1.0f / 255.0f),
                   ((aColor >> 0) & 0xff) * (1.0f / 255.0f),
                   ((aColor >> 24) & 0xff) * (1.0f / 255.0f));

    return newColor;
  }

  uint32_t ToABGR() const
  {
    return uint32_t(r * 255.0f) | uint32_t(g * 255.0f) << 8 |
           uint32_t(b * 255.0f) << 16 | uint32_t(a * 255.0f) << 24;
  }



  uint32_t UnusualToARGB() const
  {
    return uint32_t(b * 255.0f) | uint32_t(g * 255.0f) << 8 |
           uint32_t(r * 255.0f) << 16 | uint32_t(a * 255.0f) << 24;
  }

  bool operator==(const Color& aColor) const {
    return r == aColor.r && g == aColor.g && b == aColor.b && a == aColor.a;
  }

  bool operator!=(const Color& aColor) const {
    return !(*this == aColor);
  }

  Float r, g, b, a;
};

struct GradientStop
{
  bool operator<(const GradientStop& aOther) const {
    return offset < aOther.offset;
  }

  Float offset;
  Color color;
};

enum class JobStatus {
    Complete,
    Wait,
    Yield,
    Error
};

}
}


typedef mozilla::gfx::SurfaceFormat gfxImageFormat;
namespace mozilla {


enum Side { eSideTop, eSideRight, eSideBottom, eSideLeft };

enum SideBits {
  eSideBitsNone = 0,
  eSideBitsTop = 1 << eSideTop,
  eSideBitsRight = 1 << eSideRight,
  eSideBitsBottom = 1 << eSideBottom,
  eSideBitsLeft = 1 << eSideLeft,
  eSideBitsTopBottom = eSideBitsTop | eSideBitsBottom,
  eSideBitsLeftRight = eSideBitsLeft | eSideBitsRight,
  eSideBitsAll = eSideBitsTopBottom | eSideBitsLeftRight
};
static inline Side& operator++(Side& side) {
  do { } while (0);

  side = Side(side + 1);
  return side;
}

enum Corner {

  eCornerTopLeft = 0,
  eCornerTopRight = 1,
  eCornerBottomRight = 2,
  eCornerBottomLeft = 3
};




constexpr int eCornerCount = 4;
static inline Corner operator++(Corner& aCorner) {
  do { } while (0);

  aCorner = Corner(aCorner + 1);
  return aCorner;
}


enum HalfCorner {

  eCornerTopLeftX = 0,
  eCornerTopLeftY = 1,
  eCornerTopRightX = 2,
  eCornerTopRightY = 3,
  eCornerBottomRightX = 4,
  eCornerBottomRightY = 5,
  eCornerBottomLeftX = 6,
  eCornerBottomLeftY = 7
};
static inline HalfCorner operator++(HalfCorner& aHalfCorner) {
  do { } while (0);

  aHalfCorner = HalfCorner(aHalfCorner + 1);
  return aHalfCorner;
}




constexpr bool HalfCornerIsX(HalfCorner aHalfCorner)
{
  return !(aHalfCorner % 2);
}

constexpr Corner HalfToFullCorner(HalfCorner aHalfCorner)
{
  return Corner(aHalfCorner / 2);
}

constexpr HalfCorner FullToHalfCorner(Corner aCorner, bool aIsVertical)
{
  return HalfCorner(aCorner * 2 + aIsVertical);
}

constexpr bool SideIsVertical(Side aSide)
{
  return aSide % 2;
}





constexpr Corner SideToFullCorner(Side aSide, bool aIsSecond)
{
  return Corner((aSide + aIsSecond) % 4);
}
constexpr HalfCorner SideToHalfCorner(Side aSide, bool aIsSecond,
                                      bool aIsParallel)
{
  return HalfCorner(((aSide + aIsSecond) * 2 + (aSide + !aIsParallel) % 2) % 8);
}

}
namespace mozilla {
namespace gfx {






template <class T, class Sub>
struct BaseCoord {
  T value;


  constexpr BaseCoord() : value(0) {}
  explicit constexpr BaseCoord(T aValue) : value(aValue) {}




  operator T() const { return value; }

  friend bool operator==(Sub aA, Sub aB) {
    return aA.value == aB.value;
  }
  friend bool operator!=(Sub aA, Sub aB) {
    return aA.value != aB.value;
  }

  friend Sub operator+(Sub aA, Sub aB) {
    return Sub(aA.value + aB.value);
  }
  friend Sub operator-(Sub aA, Sub aB) {
    return Sub(aA.value - aB.value);
  }
  friend Sub operator*(Sub aCoord, T aScale) {
    return Sub(aCoord.value * aScale);
  }
  friend Sub operator*(T aScale, Sub aCoord) {
    return Sub(aScale * aCoord.value);
  }
  friend Sub operator/(Sub aCoord, T aScale) {
    return Sub(aCoord.value / aScale);
  }


  Sub& operator+=(Sub aCoord) {
    value += aCoord.value;
    return *static_cast<Sub*>(this);
  }
  Sub& operator-=(Sub aCoord) {
    value -= aCoord.value;
    return *static_cast<Sub*>(this);
  }
  Sub& operator*=(T aScale) {
    value *= aScale;
    return *static_cast<Sub*>(this);
  }
  Sub& operator/=(T aScale) {
    value /= aScale;
    return *static_cast<Sub*>(this);
  }





  friend bool operator==(Sub aA, T aB) {
    return aA.value == aB;
  }
  friend bool operator==(T aA, Sub aB) {
    return aA == aB.value;
  }
  friend bool operator!=(Sub aA, T aB) {
    return aA.value != aB;
  }
  friend bool operator!=(T aA, Sub aB) {
    return aA != aB.value;
  }
  friend T operator+(Sub aA, T aB) {
    return aA.value + aB;
  }
  friend T operator+(T aA, Sub aB) {
    return aA + aB.value;
  }
  friend T operator-(Sub aA, T aB) {
    return aA.value - aB;
  }
  friend T operator-(T aA, Sub aB) {
    return aA - aB.value;
  }

  Sub operator-() const {
    return Sub(-value);
  }
};

}
}


namespace mozilla {

template <typename> struct IsPixel;

namespace gfx {

template <class units> struct IntCoordTyped;
template <class units, class F = Float> struct CoordTyped;
template <class coord, class primitive>
struct CommonType;

template <class units, class primitive>
struct CommonType<IntCoordTyped<units>, primitive> {
    typedef decltype(int32_t() + primitive()) type;
};

template <class units, class F, class primitive>
struct CommonType<CoordTyped<units, F>, primitive> {
    typedef decltype(F() + primitive()) type;
};
template <bool B, class coord, class primitive>
struct CoordOperatorsHelper {


};

template <class coord, class primitive>
struct CoordOperatorsHelper<true, coord, primitive> {
  friend bool operator==(coord aA, primitive aB) {
    return aA.value == aB;
  }
  friend bool operator==(primitive aA, coord aB) {
    return aA == aB.value;
  }
  friend bool operator!=(coord aA, primitive aB) {
    return aA.value != aB;
  }
  friend bool operator!=(primitive aA, coord aB) {
    return aA != aB.value;
  }

  typedef typename CommonType<coord, primitive>::type result_type;

  friend result_type operator+(coord aA, primitive aB) {
    return aA.value + aB;
  }
  friend result_type operator+(primitive aA, coord aB) {
    return aA + aB.value;
  }
  friend result_type operator-(coord aA, primitive aB) {
    return aA.value - aB;
  }
  friend result_type operator-(primitive aA, coord aB) {
    return aA - aB.value;
  }
  friend result_type operator*(coord aCoord, primitive aScale) {
    return aCoord.value * aScale;
  }
  friend result_type operator*(primitive aScale, coord aCoord) {
    return aScale * aCoord.value;
  }
  friend result_type operator/(coord aCoord, primitive aScale) {
    return aCoord.value / aScale;
  }

};




template<class units>
struct IntCoordTyped :
  public BaseCoord< int32_t, IntCoordTyped<units> >,
  public CoordOperatorsHelper< true, IntCoordTyped<units>, float >,
  public CoordOperatorsHelper< true, IntCoordTyped<units>, double > {
  static_assert(IsPixel<units>::value,
                "'units' must be a coordinate system tag");

  typedef BaseCoord< int32_t, IntCoordTyped<units> > Super;

  constexpr IntCoordTyped() : Super() {}
  constexpr IntCoordTyped(int32_t aValue) : Super(aValue) {}
};

template<class units, class F>
struct CoordTyped :
  public BaseCoord< F, CoordTyped<units, F> >,
  public CoordOperatorsHelper< !IsSame<F, int32_t>::value, CoordTyped<units, F>, int32_t >,
  public CoordOperatorsHelper< !IsSame<F, uint32_t>::value, CoordTyped<units, F>, uint32_t >,
  public CoordOperatorsHelper< !IsSame<F, double>::value, CoordTyped<units, F>, double >,
  public CoordOperatorsHelper< !IsSame<F, float>::value, CoordTyped<units, F>, float > {
  static_assert(IsPixel<units>::value,
                "'units' must be a coordinate system tag");

  typedef BaseCoord< F, CoordTyped<units, F> > Super;

  constexpr CoordTyped() : Super() {}
  constexpr CoordTyped(F aValue) : Super(aValue) {}
  explicit constexpr CoordTyped(const IntCoordTyped<units>& aCoord) : Super(F(aCoord.value)) {}

  void Round() {
    this->value = floor(this->value + 0.5);
  }
  void Truncate() {
    this->value = int32_t(this->value);
  }

  IntCoordTyped<units> Rounded() const {
    return IntCoordTyped<units>(int32_t(floor(this->value + 0.5)));
  }
  IntCoordTyped<units> Truncated() const {
    return IntCoordTyped<units>(int32_t(this->value));
  }
};

}
}


namespace mozilla {
namespace gfx {






template <class T, class Sub>
struct BasePoint3D {
  union {
    struct {
      T x, y, z;
    };
    T components[3];
  };


  BasePoint3D() : x(0), y(0), z(0) {}
  BasePoint3D(T aX, T aY, T aZ) : x(aX), y(aY), z(aZ) {}

  void MoveTo(T aX, T aY, T aZ) { x = aX; y = aY; z = aZ; }
  void MoveBy(T aDx, T aDy, T aDz) { x += aDx; y += aDy; z += aDz; }




  T& operator[](int aIndex) {
    do { } while (0);
    return *((&x)+aIndex);
  }

  const T& operator[](int aIndex) const {
    do { } while (0);
    return *((&x)+aIndex);
  }

  bool operator==(const Sub& aPoint) const {
    return x == aPoint.x && y == aPoint.y && z == aPoint.z;
  }
  bool operator!=(const Sub& aPoint) const {
    return x != aPoint.x || y != aPoint.y || z != aPoint.z;
  }

  Sub operator+(const Sub& aPoint) const {
    return Sub(x + aPoint.x, y + aPoint.y, z + aPoint.z);
  }
  Sub operator-(const Sub& aPoint) const {
    return Sub(x - aPoint.x, y - aPoint.y, z - aPoint.z);
  }
  Sub& operator+=(const Sub& aPoint) {
    x += aPoint.x;
    y += aPoint.y;
    z += aPoint.z;
    return *static_cast<Sub*>(this);
  }
  Sub& operator-=(const Sub& aPoint) {
    x -= aPoint.x;
    y -= aPoint.y;
    z -= aPoint.z;
    return *static_cast<Sub*>(this);
  }

  Sub operator*(T aScale) const {
    return Sub(x * aScale, y * aScale, z * aScale);
  }
  Sub operator/(T aScale) const {
    return Sub(x / aScale, y / aScale, z / aScale);
  }

  Sub& operator*=(T aScale) {
    x *= aScale;
    y *= aScale;
    z *= aScale;
    return *static_cast<Sub*>(this);
  }

  Sub& operator/=(T aScale) {
      x /= aScale;
      y /= aScale;
      z /= aScale;
      return *static_cast<Sub*>(this);
  }

  Sub operator-() const {
    return Sub(-x, -y, -z);
  }

  Sub CrossProduct(const Sub& aPoint) const {
      return Sub(y * aPoint.z - aPoint.y * z,
                 z * aPoint.x - aPoint.z * x,
                 x * aPoint.y - aPoint.x * y);
  }

  T DotProduct(const Sub& aPoint) const {
      return x * aPoint.x + y * aPoint.y + z * aPoint.z;
  }

  T Length() const {
      return sqrt(x*x + y*y + z*z);
  }


  void Normalize() {
      *this /= Length();
  }
};

}
}
namespace mozilla {
namespace gfx {






template <class T, class Sub>
struct BasePoint4D {
  union {
    struct {
      T x, y, z, w;
    };
    T components[4];
  };


  BasePoint4D() : x(0), y(0), z(0), w(0) {}
  BasePoint4D(T aX, T aY, T aZ, T aW) : x(aX), y(aY), z(aZ), w(aW) {}

  void MoveTo(T aX, T aY, T aZ, T aW) { x = aX; y = aY; z = aZ; w = aW; }
  void MoveBy(T aDx, T aDy, T aDz, T aDw) { x += aDx; y += aDy; z += aDz; w += aDw; }




  bool operator==(const Sub& aPoint) const {
    return x == aPoint.x && y == aPoint.y &&
           z == aPoint.z && w == aPoint.w;
  }
  bool operator!=(const Sub& aPoint) const {
    return x != aPoint.x || y != aPoint.y ||
           z != aPoint.z || w != aPoint.w;
  }

  Sub operator+(const Sub& aPoint) const {
    return Sub(x + aPoint.x, y + aPoint.y, z + aPoint.z, w + aPoint.w);
  }
  Sub operator-(const Sub& aPoint) const {
    return Sub(x - aPoint.x, y - aPoint.y, z - aPoint.z, w - aPoint.w);
  }
  Sub& operator+=(const Sub& aPoint) {
    x += aPoint.x;
    y += aPoint.y;
    z += aPoint.z;
    w += aPoint.w;
    return *static_cast<Sub*>(this);
  }
  Sub& operator-=(const Sub& aPoint) {
    x -= aPoint.x;
    y -= aPoint.y;
    z -= aPoint.z;
    w -= aPoint.w;
    return *static_cast<Sub*>(this);
  }

  Sub operator*(T aScale) const {
    return Sub(x * aScale, y * aScale, z * aScale, w * aScale);
  }
  Sub operator/(T aScale) const {
    return Sub(x / aScale, y / aScale, z / aScale, w / aScale);
  }

  Sub& operator*=(T aScale) {
    x *= aScale;
    y *= aScale;
    z *= aScale;
    w *= aScale;
    return *static_cast<Sub*>(this);
  }

  Sub& operator/=(T aScale) {
    x /= aScale;
    y /= aScale;
    z /= aScale;
    w /= aScale;
    return *static_cast<Sub*>(this);
  }

  Sub operator-() const {
    return Sub(-x, -y, -z, -w);
  }

  T& operator[](int aIndex) {
    do { } while (0);
    return *((&x)+aIndex);
  }

  const T& operator[](int aIndex) const {
    do { } while (0);
    return *((&x)+aIndex);
  }

  T DotProduct(const Sub& aPoint) const {
    return x * aPoint.x + y * aPoint.y + z * aPoint.z + w * aPoint.w;
  }


  Sub CrossProduct(const Sub& aPoint) const {
      return Sub(y * aPoint.z - aPoint.y * z,
          z * aPoint.x - aPoint.z * x,
          x * aPoint.y - aPoint.x * y,
          0);
  }

  T Length() const {
    return sqrt(x*x + y*y + z*z + w*w);
  }

  void Normalize() {
    *this /= Length();
  }

  bool HasPositiveWCoord() { return w > 0; }
};

}
}




namespace mozilla {

template <typename> struct IsPixel;

namespace gfx {


struct UnknownUnits {};

}

template<> struct IsPixel<gfx::UnknownUnits> : TrueType {};

namespace gfx {






template<typename T>
struct IntParam {
  constexpr IntParam(char val) : value(val) {}
  constexpr IntParam(unsigned char val) : value(val) {}
  constexpr IntParam(short val) : value(val) {}
  constexpr IntParam(unsigned short val) : value(val) {}
  constexpr IntParam(int val) : value(val) {}
  constexpr IntParam(unsigned int val) : value(val) {}
  constexpr IntParam(long val) : value(val) {}
  constexpr IntParam(unsigned long val) : value(val) {}
  constexpr IntParam(long long val) : value(val) {}
  constexpr IntParam(unsigned long long val) : value(val) {}
  template<typename Unit>
  constexpr IntParam(IntCoordTyped<Unit> val) : value(val) {}


               IntParam(float val) = delete;
               IntParam(double val) = delete;

  T value;
};

template<class units, class> struct PointTyped;
template<class units, class> struct SizeTyped;

template<class units>
struct IntPointTyped :
  public BasePoint< int32_t, IntPointTyped<units>, IntCoordTyped<units> >,
  public units {
  static_assert(IsPixel<units>::value,
                "'units' must be a coordinate system tag");

  typedef IntParam<int32_t> ToInt;
  typedef IntCoordTyped<units> Coord;
  typedef BasePoint< int32_t, IntPointTyped<units>, IntCoordTyped<units> > Super;

  constexpr IntPointTyped() : Super() {}
  constexpr IntPointTyped(ToInt aX, ToInt aY) : Super(Coord(aX.value), Coord(aY.value)) {}

  static IntPointTyped<units> Round(float aX, float aY) {
    return IntPointTyped(int32_t(floorf(aX + 0.5)), int32_t(floorf(aY + 0.5)));
  }

  static IntPointTyped<units> Ceil(float aX, float aY) {
    return IntPointTyped(int32_t(ceil(aX)), int32_t(ceil(aY)));
  }

  static IntPointTyped<units> Floor(float aX, float aY) {
    return IntPointTyped(int32_t(floorf(aX)), int32_t(floorf(aY)));
  }

  static IntPointTyped<units> Truncate(float aX, float aY) {
    return IntPointTyped(int32_t(aX), int32_t(aY));
  }

  static IntPointTyped<units> Round(const PointTyped<units, float>& aPoint);
  static IntPointTyped<units> Ceil(const PointTyped<units, float>& aPoint);
  static IntPointTyped<units> Floor(const PointTyped<units, float>& aPoint);
  static IntPointTyped<units> Truncate(const PointTyped<units, float>& aPoint);




  static IntPointTyped<units> FromUnknownPoint(const IntPointTyped<UnknownUnits>& aPoint) {
    return IntPointTyped<units>(aPoint.x, aPoint.y);
  }

  IntPointTyped<UnknownUnits> ToUnknownPoint() const {
    return IntPointTyped<UnknownUnits>(this->x, this->y);
  }
};
typedef IntPointTyped<UnknownUnits> IntPoint;

template<class units, class F = Float>
struct PointTyped :
  public BasePoint< F, PointTyped<units, F>, CoordTyped<units, F> >,
  public units {
  static_assert(IsPixel<units>::value,
                "'units' must be a coordinate system tag");

  typedef CoordTyped<units, F> Coord;
  typedef BasePoint< F, PointTyped<units, F>, CoordTyped<units, F> > Super;

  constexpr PointTyped() : Super() {}
  constexpr PointTyped(F aX, F aY) : Super(Coord(aX), Coord(aY)) {}


  constexpr PointTyped(F aX, Coord aY) : Super(Coord(aX), aY) {}
  constexpr PointTyped(Coord aX, F aY) : Super(aX, Coord(aY)) {}
  constexpr PointTyped(Coord aX, Coord aY) : Super(aX.value, aY.value) {}
  constexpr PointTyped(const IntPointTyped<units>& point) : Super(F(point.x), F(point.y)) {}




  static PointTyped<units, F> FromUnknownPoint(const PointTyped<UnknownUnits, F>& aPoint) {
    return PointTyped<units, F>(aPoint.x, aPoint.y);
  }

  PointTyped<UnknownUnits, F> ToUnknownPoint() const {
    return PointTyped<UnknownUnits, F>(this->x, this->y);
  }
};
typedef PointTyped<UnknownUnits> Point;
typedef PointTyped<UnknownUnits, double> PointDouble;

template<class units>
IntPointTyped<units> RoundedToInt(const PointTyped<units>& aPoint) {
  return IntPointTyped<units>::Round(aPoint.x, aPoint.y);
}

template<class units>
IntPointTyped<units> TruncatedToInt(const PointTyped<units>& aPoint) {
  return IntPointTyped<units>::Truncate(aPoint.x, aPoint.y);
}

template<class units, class F = Float>
struct Point3DTyped :
  public BasePoint3D< F, Point3DTyped<units, F> > {
  static_assert(IsPixel<units>::value,
                "'units' must be a coordinate system tag");

  typedef BasePoint3D< F, Point3DTyped<units, F> > Super;

  Point3DTyped() : Super() {}
  Point3DTyped(F aX, F aY, F aZ) : Super(aX, aY, aZ) {}




  static Point3DTyped<units, F> FromUnknownPoint(const Point3DTyped<UnknownUnits, F>& aPoint) {
    return Point3DTyped<units, F>(aPoint.x, aPoint.y, aPoint.z);
  }

  Point3DTyped<UnknownUnits, F> ToUnknownPoint() const {
    return Point3DTyped<UnknownUnits, F>(this->x, this->y, this->z);
  }
};
typedef Point3DTyped<UnknownUnits> Point3D;
typedef Point3DTyped<UnknownUnits, double> PointDouble3D;

template<typename units>
IntPointTyped<units>
IntPointTyped<units>::Round(const PointTyped<units, float>& aPoint)
{
  return IntPointTyped::Round(aPoint.x, aPoint.y);
}

template<typename units>
IntPointTyped<units>
IntPointTyped<units>::Ceil(const PointTyped<units, float>& aPoint)
{
  return IntPointTyped::Ceil(aPoint.x, aPoint.y);
}

template<typename units>
IntPointTyped<units>
IntPointTyped<units>::Floor(const PointTyped<units, float>& aPoint)
{
  return IntPointTyped::Floor(aPoint.x, aPoint.y);
}

template<typename units>
IntPointTyped<units>
IntPointTyped<units>::Truncate(const PointTyped<units, float>& aPoint)
{
  return IntPointTyped::Truncate(aPoint.x, aPoint.y);
}

template<class units, class F = Float>
struct Point4DTyped :
  public BasePoint4D< F, Point4DTyped<units, F> > {
  static_assert(IsPixel<units>::value,
                "'units' must be a coordinate system tag");

  typedef BasePoint4D< F, Point4DTyped<units, F> > Super;

  Point4DTyped() : Super() {}
  Point4DTyped(F aX, F aY, F aZ, F aW) : Super(aX, aY, aZ, aW) {}

  explicit Point4DTyped(const Point3DTyped<units, F>& aPoint)
    : Super(aPoint.x, aPoint.y, aPoint.z, 1) {}




  static Point4DTyped<units, F> FromUnknownPoint(const Point4DTyped<UnknownUnits, F>& aPoint) {
    return Point4DTyped<units, F>(aPoint.x, aPoint.y, aPoint.z, aPoint.w);
  }

  Point4DTyped<UnknownUnits, F> ToUnknownPoint() const {
    return Point4DTyped<UnknownUnits, F>(this->x, this->y, this->z, this->w);
  }

  PointTyped<units, F> As2DPoint() const {
    return PointTyped<units, F>(this->x / this->w,
                                this->y / this->w);
  }

  Point3DTyped<units, F> As3DPoint() const {
    return Point3DTyped<units, F>(this->x / this->w,
                                  this->y / this->w,
                                  this->z / this->w);
  }
};
typedef Point4DTyped<UnknownUnits> Point4D;
typedef Point4DTyped<UnknownUnits, double> PointDouble4D;

template<class units>
struct IntSizeTyped :
  public BaseSize< int32_t, IntSizeTyped<units> >,
  public units {
  static_assert(IsPixel<units>::value,
                "'units' must be a coordinate system tag");

  typedef IntParam<int32_t> ToInt;
  typedef BaseSize< int32_t, IntSizeTyped<units> > Super;

  constexpr IntSizeTyped() : Super() {}
  constexpr IntSizeTyped(ToInt aWidth, ToInt aHeight) : Super(aWidth.value, aHeight.value) {}

  static IntSizeTyped<units> Round(float aWidth, float aHeight) {
    return IntSizeTyped(int32_t(floorf(aWidth + 0.5)), int32_t(floorf(aHeight + 0.5)));
  }

  static IntSizeTyped<units> Truncate(float aWidth, float aHeight) {
    return IntSizeTyped(int32_t(aWidth), int32_t(aHeight));
  }

  static IntSizeTyped<units> Ceil(float aWidth, float aHeight) {
    return IntSizeTyped(int32_t(ceil(aWidth)), int32_t(ceil(aHeight)));
  }

  static IntSizeTyped<units> Floor(float aWidth, float aHeight) {
    return IntSizeTyped(int32_t(floorf(aWidth)), int32_t(floorf(aHeight)));
  }

  static IntSizeTyped<units> Round(const SizeTyped<units, float>& aSize);
  static IntSizeTyped<units> Ceil(const SizeTyped<units, float>& aSize);
  static IntSizeTyped<units> Floor(const SizeTyped<units, float>& aSize);
  static IntSizeTyped<units> Truncate(const SizeTyped<units, float>& aSize);




  static IntSizeTyped<units> FromUnknownSize(const IntSizeTyped<UnknownUnits>& aSize) {
    return IntSizeTyped<units>(aSize.width, aSize.height);
  }

  IntSizeTyped<UnknownUnits> ToUnknownSize() const {
    return IntSizeTyped<UnknownUnits>(this->width, this->height);
  }
};
typedef IntSizeTyped<UnknownUnits> IntSize;

template<class units, class F = Float>
struct SizeTyped :
  public BaseSize< F, SizeTyped<units, F> >,
  public units {
  static_assert(IsPixel<units>::value,
                "'units' must be a coordinate system tag");

  typedef BaseSize< F, SizeTyped<units, F> > Super;

  constexpr SizeTyped() : Super() {}
  constexpr SizeTyped(F aWidth, F aHeight) : Super(aWidth, aHeight) {}
  explicit SizeTyped(const IntSizeTyped<units>& size) :
    Super(F(size.width), F(size.height)) {}




  static SizeTyped<units, F> FromUnknownSize(const SizeTyped<UnknownUnits, F>& aSize) {
    return SizeTyped<units, F>(aSize.width, aSize.height);
  }

  SizeTyped<UnknownUnits, F> ToUnknownSize() const {
    return SizeTyped<UnknownUnits, F>(this->width, this->height);
  }
};
typedef SizeTyped<UnknownUnits> Size;
typedef SizeTyped<UnknownUnits, double> SizeDouble;

template<class units>
IntSizeTyped<units> RoundedToInt(const SizeTyped<units>& aSize) {
  return IntSizeTyped<units>(int32_t(floorf(aSize.width + 0.5f)),
                             int32_t(floorf(aSize.height + 0.5f)));
}

template<typename units> IntSizeTyped<units>
IntSizeTyped<units>::Round(const SizeTyped<units, float>& aSize) {
  return IntSizeTyped::Round(aSize.width, aSize.height);
}

template<typename units> IntSizeTyped<units>
IntSizeTyped<units>::Ceil(const SizeTyped<units, float>& aSize) {
  return IntSizeTyped::Ceil(aSize.width, aSize.height);
}

template<typename units> IntSizeTyped<units>
IntSizeTyped<units>::Floor(const SizeTyped<units, float>& aSize) {
  return IntSizeTyped::Floor(aSize.width, aSize.height);
}

template<typename units> IntSizeTyped<units>
IntSizeTyped<units>::Truncate(const SizeTyped<units, float>& aSize) {
  return IntSizeTyped::Truncate(aSize.width, aSize.height);
}

}
}




typedef mozilla::gfx::IntSize nsIntSize;

struct nsSize : public mozilla::gfx::BaseSize<nscoord, nsSize> {
  typedef mozilla::gfx::BaseSize<nscoord, nsSize> Super;

  nsSize() : Super() {}
  nsSize(nscoord aWidth, nscoord aHeight) : Super(aWidth, aHeight) {}

  inline mozilla::gfx::IntSize ScaleToNearestPixels(float aXScale, float aYScale,
                                        nscoord aAppUnitsPerPixel) const;
  inline mozilla::gfx::IntSize ToNearestPixels(nscoord aAppUnitsPerPixel) const;






  __attribute__ ((warn_unused_result)) inline nsSize
    ScaleToOtherAppUnits(int32_t aFromAPP, int32_t aToAPP) const;
};

inline mozilla::gfx::IntSize
nsSize::ScaleToNearestPixels(float aXScale, float aYScale,
                             nscoord aAppUnitsPerPixel) const
{
  return mozilla::gfx::IntSize(
      NSToIntRoundUp(NSAppUnitsToDoublePixels(width, aAppUnitsPerPixel) * aXScale),
      NSToIntRoundUp(NSAppUnitsToDoublePixels(height, aAppUnitsPerPixel) * aYScale));
}

inline mozilla::gfx::IntSize
nsSize::ToNearestPixels(nscoord aAppUnitsPerPixel) const
{
  return ScaleToNearestPixels(1.0f, 1.0f, aAppUnitsPerPixel);
}

inline nsSize
nsSize::ScaleToOtherAppUnits(int32_t aFromAPP, int32_t aToAPP) const {
  if (aFromAPP != aToAPP) {
    nsSize size;
    size.width = NSToCoordRound(NSCoordScale(width, aFromAPP, aToAPP));
    size.height = NSToCoordRound(NSCoordScale(height, aFromAPP, aToAPP));
    return size;
  }
  return *this;
}

inline nsSize
IntSizeToAppUnits(mozilla::gfx::IntSize aSize, nscoord aAppUnitsPerPixel)
{
  return nsSize(NSIntPixelsToAppUnits(aSize.width, aAppUnitsPerPixel),
                NSIntPixelsToAppUnits(aSize.height, aAppUnitsPerPixel));
}





typedef mozilla::gfx::IntPoint nsIntPoint;



struct nsPoint : public mozilla::gfx::BasePoint<nscoord, nsPoint> {
  typedef mozilla::gfx::BasePoint<nscoord, nsPoint> Super;

  nsPoint() : Super() {}
  nsPoint(const nsPoint& aPoint) : Super(aPoint) {}
  nsPoint(nscoord aX, nscoord aY) : Super(aX, aY) {}

  inline nsIntPoint ScaleToNearestPixels(float aXScale, float aYScale,
                                         nscoord aAppUnitsPerPixel) const;
  inline nsIntPoint ToNearestPixels(nscoord aAppUnitsPerPixel) const;






  __attribute__ ((warn_unused_result)) inline nsPoint
    ScaleToOtherAppUnits(int32_t aFromAPP, int32_t aToAPP) const;

  __attribute__ ((warn_unused_result)) inline nsPoint
    RemoveResolution(const float resolution) const;
  __attribute__ ((warn_unused_result)) inline nsPoint
    ApplyResolution(const float resolution) const;
};

inline nsPoint ToAppUnits(const nsIntPoint& aPoint, nscoord aAppUnitsPerPixel);

inline nsIntPoint
nsPoint::ScaleToNearestPixels(float aXScale, float aYScale,
                              nscoord aAppUnitsPerPixel) const
{
  return nsIntPoint(
      NSToIntRoundUp(NSAppUnitsToDoublePixels(x, aAppUnitsPerPixel) * aXScale),
      NSToIntRoundUp(NSAppUnitsToDoublePixels(y, aAppUnitsPerPixel) * aYScale));
}

inline nsIntPoint
nsPoint::ToNearestPixels(nscoord aAppUnitsPerPixel) const
{
  return ScaleToNearestPixels(1.0f, 1.0f, aAppUnitsPerPixel);
}

inline nsPoint
nsPoint::ScaleToOtherAppUnits(int32_t aFromAPP, int32_t aToAPP) const
{
  if (aFromAPP != aToAPP) {
    nsPoint point;
    point.x = NSToCoordRound(NSCoordScale(x, aFromAPP, aToAPP));
    point.y = NSToCoordRound(NSCoordScale(y, aFromAPP, aToAPP));
    return point;
  }
  return *this;
}

inline nsPoint
nsPoint::RemoveResolution(const float resolution) const {
  if (resolution != 1.0f) {
    nsPoint point;
    point.x = NSToCoordRound(NSCoordToFloat(x) / resolution);
    point.y = NSToCoordRound(NSCoordToFloat(y) / resolution);
    return point;
  }
  return *this;
}

inline nsPoint
nsPoint::ApplyResolution(const float resolution) const {
  if (resolution != 1.0f) {
    nsPoint point;
    point.x = NSToCoordRound(NSCoordToFloat(x) * resolution);
    point.y = NSToCoordRound(NSCoordToFloat(y) * resolution);
    return point;
  }
  return *this;
}


inline nsPoint
ToAppUnits(const nsIntPoint& aPoint, nscoord aAppUnitsPerPixel)
{
  return nsPoint(NSIntPixelsToAppUnits(aPoint.x, aAppUnitsPerPixel),
                 NSIntPixelsToAppUnits(aPoint.y, aAppUnitsPerPixel));
}
namespace mozilla {




struct Sides final {
  Sides() : mBits(0) {}
  explicit Sides(SideBits aSideBits)
  {
    do { } while (0);
    mBits = aSideBits;
  }
  bool IsEmpty() const { return mBits == 0; }
  bool Top() const { return (mBits & eSideBitsTop) != 0; }
  bool Right() const { return (mBits & eSideBitsRight) != 0; }
  bool Bottom() const { return (mBits & eSideBitsBottom) != 0; }
  bool Left() const { return (mBits & eSideBitsLeft) != 0; }
  bool Contains(SideBits aSideBits) const
  {
    do { } while (0);
    return (mBits & aSideBits) == aSideBits;
  }
  Sides operator|(Sides aOther) const
  {
    return Sides(SideBits(mBits | aOther.mBits));
  }
  Sides operator|(SideBits aSideBits) const
  {
    return *this | Sides(aSideBits);
  }
  Sides& operator|=(Sides aOther)
  {
    mBits |= aOther.mBits;
    return *this;
  }
  Sides& operator|=(SideBits aSideBits)
  {
    return *this |= Sides(aSideBits);
  }
  bool operator==(Sides aOther) const
  {
    return mBits == aOther.mBits;
  }
  bool operator!=(Sides aOther) const
  {
    return !(*this == aOther);
  }

private:
  uint8_t mBits;
};

namespace gfx {





template <class T, class Sub>
struct BaseMargin {
  typedef mozilla::Side SideT;



  T top, right, bottom, left;


  BaseMargin() : top(0), right(0), bottom(0), left(0) {}
  BaseMargin(T aTop, T aRight, T aBottom, T aLeft) :
      top(aTop), right(aRight), bottom(aBottom), left(aLeft) {}

  void SizeTo(T aTop, T aRight, T aBottom, T aLeft)
  {
    top = aTop; right = aRight; bottom = aBottom; left = aLeft;
  }

  T LeftRight() const { return left + right; }
  T TopBottom() const { return top + bottom; }

  T& Side(SideT aSide) {

    return *(&top + int(aSide));
  }
  T Side(SideT aSide) const {

    return *(&top + int(aSide));
  }

  void ApplySkipSides(Sides aSkipSides)
  {
    if (aSkipSides.Top()) {
      top = 0;
    }
    if (aSkipSides.Right()) {
      right = 0;
    }
    if (aSkipSides.Bottom()) {
      bottom = 0;
    }
    if (aSkipSides.Left()) {
      left = 0;
    }
  }



  bool operator==(const Sub& aMargin) const {
    return top == aMargin.top && right == aMargin.right &&
           bottom == aMargin.bottom && left == aMargin.left;
  }
  bool operator!=(const Sub& aMargin) const {
    return !(*this == aMargin);
  }
  Sub operator+(const Sub& aMargin) const {
    return Sub(top + aMargin.top, right + aMargin.right,
               bottom + aMargin.bottom, left + aMargin.left);
  }
  Sub operator-(const Sub& aMargin) const {
    return Sub(top - aMargin.top, right - aMargin.right,
               bottom - aMargin.bottom, left - aMargin.left);
  }
  Sub& operator+=(const Sub& aMargin) {
    top += aMargin.top;
    right += aMargin.right;
    bottom += aMargin.bottom;
    left += aMargin.left;
    return *static_cast<Sub*>(this);
  }

  friend std::ostream& operator<<(std::ostream& aStream,
      const BaseMargin& aMargin) {
    return aStream << '(' << aMargin.top << ',' << aMargin.right << ','
                  << aMargin.bottom << ',' << aMargin.left << ')';
  }
};

}
}















namespace mozilla {
namespace gfx {
template <class T, class Sub, class Point, class SizeT, class MarginT>
struct BaseRect {
  T x, y, width, height;


  BaseRect() : x(0), y(0), width(0), height(0) {}
  BaseRect(const Point& aOrigin, const SizeT &aSize) :
      x(aOrigin.x), y(aOrigin.y), width(aSize.width), height(aSize.height)
  {
  }
  BaseRect(T aX, T aY, T aWidth, T aHeight) :
      x(aX), y(aY), width(aWidth), height(aHeight)
  {
  }



  bool IsEmpty() const { return height <= 0 || width <= 0; }
  void SetEmpty() { width = height = 0; }


  bool IsFinite() const
  {
    typedef typename mozilla::Conditional<mozilla::IsSame<T, float>::value, float, double>::Type FloatType;
    return (mozilla::IsFinite(FloatType(x)) &&
            mozilla::IsFinite(FloatType(y)) &&
            mozilla::IsFinite(FloatType(width)) &&
            mozilla::IsFinite(FloatType(height)));
  }




  bool Contains(const Sub& aRect) const
  {
    return aRect.IsEmpty() ||
           (x <= aRect.x && aRect.XMost() <= XMost() &&
            y <= aRect.y && aRect.YMost() <= YMost());
  }



  bool Contains(T aX, T aY) const
  {
    return x <= aX && aX < XMost() &&
           y <= aY && aY < YMost();
  }



  bool Contains(const Point& aPoint) const { return Contains(aPoint.x, aPoint.y); }




  bool Intersects(const Sub& aRect) const
  {
    return !IsEmpty() && !aRect.IsEmpty() &&
           x < aRect.XMost() && aRect.x < XMost() &&
           y < aRect.YMost() && aRect.y < YMost();
  }




  __attribute__ ((warn_unused_result)) Sub Intersect(const Sub& aRect) const
  {
    Sub result;
    result.x = std::max<T>(x, aRect.x);
    result.y = std::max<T>(y, aRect.y);
    result.width = std::min<T>(x - result.x + width, aRect.x - result.x + aRect.width);
    result.height = std::min<T>(y - result.y + height, aRect.y - result.y + aRect.height);
    if (result.width < 0 || result.height < 0) {
      result.SizeTo(0, 0);
    }
    return result;
  }






  bool IntersectRect(const Sub& aRect1, const Sub& aRect2)
  {
    *static_cast<Sub*>(this) = aRect1.Intersect(aRect2);
    return !IsEmpty();
  }







  __attribute__ ((warn_unused_result)) Sub Union(const Sub& aRect) const
  {
    if (IsEmpty()) {
      return aRect;
    } else if (aRect.IsEmpty()) {
      return *static_cast<const Sub*>(this);
    } else {
      return UnionEdges(aRect);
    }
  }





  __attribute__ ((warn_unused_result)) Sub UnionEdges(const Sub& aRect) const
  {
    Sub result;
    result.x = std::min(x, aRect.x);
    result.y = std::min(y, aRect.y);
    result.width = std::max(XMost(), aRect.XMost()) - result.x;
    result.height = std::max(YMost(), aRect.YMost()) - result.y;
    return result;
  }






  void UnionRect(const Sub& aRect1, const Sub& aRect2)
  {
    *static_cast<Sub*>(this) = aRect1.Union(aRect2);
  }






  void UnionRectEdges(const Sub& aRect1, const Sub& aRect2)
  {
    *static_cast<Sub*>(this) = aRect1.UnionEdges(aRect2);
  }


  void ExpandToEnclose(const Point& aPoint)
  {
    if (aPoint.x < x) {
      width = XMost() - aPoint.x;
      x = aPoint.x;
    } else if (aPoint.x > XMost()) {
      width = aPoint.x - x;
    }
    if (aPoint.y < y) {
      height = YMost() - aPoint.y;
      y = aPoint.y;
    } else if (aPoint.y > YMost()) {
      height = aPoint.y - y;
    }
  }

  void SetRect(T aX, T aY, T aWidth, T aHeight)
  {
    x = aX; y = aY; width = aWidth; height = aHeight;
  }
  void SetRect(const Point& aPt, const SizeT& aSize)
  {
    SetRect(aPt.x, aPt.y, aSize.width, aSize.height);
  }
  void MoveTo(T aX, T aY) { x = aX; y = aY; }
  void MoveTo(const Point& aPoint) { x = aPoint.x; y = aPoint.y; }
  void MoveBy(T aDx, T aDy) { x += aDx; y += aDy; }
  void MoveBy(const Point& aPoint) { x += aPoint.x; y += aPoint.y; }
  void SizeTo(T aWidth, T aHeight) { width = aWidth; height = aHeight; }
  void SizeTo(const SizeT& aSize) { width = aSize.width; height = aSize.height; }

  void Inflate(T aD) { Inflate(aD, aD); }
  void Inflate(T aDx, T aDy)
  {
    x -= aDx;
    y -= aDy;
    width += 2 * aDx;
    height += 2 * aDy;
  }
  void Inflate(const MarginT& aMargin)
  {
    x -= aMargin.left;
    y -= aMargin.top;
    width += aMargin.LeftRight();
    height += aMargin.TopBottom();
  }
  void Inflate(const SizeT& aSize) { Inflate(aSize.width, aSize.height); }

  void Deflate(T aD) { Deflate(aD, aD); }
  void Deflate(T aDx, T aDy)
  {
    x += aDx;
    y += aDy;
    width = std::max(T(0), width - 2 * aDx);
    height = std::max(T(0), height - 2 * aDy);
  }
  void Deflate(const MarginT& aMargin)
  {
    x += aMargin.left;
    y += aMargin.top;
    width = std::max(T(0), width - aMargin.LeftRight());
    height = std::max(T(0), height - aMargin.TopBottom());
  }
  void Deflate(const SizeT& aSize) { Deflate(aSize.width, aSize.height); }





  bool IsEqualEdges(const Sub& aRect) const
  {
    return x == aRect.x && y == aRect.y &&
           width == aRect.width && height == aRect.height;
  }


  bool IsEqualInterior(const Sub& aRect) const
  {
    return IsEqualEdges(aRect) || (IsEmpty() && aRect.IsEmpty());
  }

  friend Sub operator+(Sub aSub, const Point& aPoint)
  {
    aSub += aPoint;
    return aSub;
  }
  friend Sub operator-(Sub aSub, const Point& aPoint)
  {
    aSub -= aPoint;
    return aSub;
  }
  friend Sub operator+(Sub aSub, const SizeT& aSize)
  {
    aSub += aSize;
    return aSub;
  }
  friend Sub operator-(Sub aSub, const SizeT& aSize)
  {
    aSub -= aSize;
    return aSub;
  }
  Sub& operator+=(const Point& aPoint)
  {
    MoveBy(aPoint);
    return *static_cast<Sub*>(this);
  }
  Sub& operator-=(const Point& aPoint)
  {
    MoveBy(-aPoint);
    return *static_cast<Sub*>(this);
  }
  Sub& operator+=(const SizeT& aSize)
  {
    width += aSize.width;
    height += aSize.height;
    return *static_cast<Sub*>(this);
  }
  Sub& operator-=(const SizeT& aSize)
  {
    width -= aSize.width;
    height -= aSize.height;
    return *static_cast<Sub*>(this);
  }

  MarginT operator-(const Sub& aRect) const
  {
    return MarginT(aRect.y - y,
                   XMost() - aRect.XMost(),
                   YMost() - aRect.YMost(),
                   aRect.x - x);
  }


  Point TopLeft() const { return Point(x, y); }
  Point TopRight() const { return Point(XMost(), y); }
  Point BottomLeft() const { return Point(x, YMost()); }
  Point BottomRight() const { return Point(XMost(), YMost()); }
  Point AtCorner(Corner aCorner) const {
    switch (aCorner) {
      case eCornerTopLeft: return TopLeft();
      case eCornerTopRight: return TopRight();
      case eCornerBottomRight: return BottomRight();
      case eCornerBottomLeft: return BottomLeft();
    }
    do { AnnotateMozCrashReason("MOZ_CRASH(" "GFX: Incomplete switch" ")"); do { *((volatile int*) __null) = 329; ::abort(); } while (0); } while (0);
  }
  Point CCWCorner(mozilla::Side side) const {
    switch (side) {
      case eSideTop: return TopLeft();
      case eSideRight: return TopRight();
      case eSideBottom: return BottomRight();
      case eSideLeft: return BottomLeft();
    }
    do { AnnotateMozCrashReason("MOZ_CRASH(" "GFX: Incomplete switch" ")"); do { *((volatile int*) __null) = 338; ::abort(); } while (0); } while (0);
  }
  Point CWCorner(mozilla::Side side) const {
    switch (side) {
      case eSideTop: return TopRight();
      case eSideRight: return BottomRight();
      case eSideBottom: return BottomLeft();
      case eSideLeft: return TopLeft();
    }
    do { AnnotateMozCrashReason("MOZ_CRASH(" "GFX: Incomplete switch" ")"); do { *((volatile int*) __null) = 347; ::abort(); } while (0); } while (0);
  }
  Point Center() const { return Point(x, y) + Point(width, height)/2; }
  SizeT Size() const { return SizeT(width, height); }

  T Area() const { return width * height; }


  T X() const { return x; }
  T Y() const { return y; }
  T Width() const { return width; }
  T Height() const { return height; }
  T XMost() const { return x + width; }
  T YMost() const { return y + height; }


  T Edge(mozilla::Side aSide) const
  {
    switch (aSide) {
      case eSideTop: return Y();
      case eSideRight: return XMost();
      case eSideBottom: return YMost();
      case eSideLeft: return X();
    }
    do { AnnotateMozCrashReason("MOZ_CRASH(" "GFX: Incomplete switch" ")"); do { *((volatile int*) __null) = 371; ::abort(); } while (0); } while (0);
  }


  void SetLeftEdge(T aX) {
    do { } while (0);
    width = XMost() - aX;
    x = aX;
  }
  void SetRightEdge(T aXMost) {
    do { } while (0);
    width = aXMost - x;
  }
  void SetTopEdge(T aY) {
    do { } while (0);
    height = YMost() - aY;
    y = aY;
  }
  void SetBottomEdge(T aYMost) {
    do { } while (0);
    height = aYMost - y;
  }
  void Round()
  {
    T x0 = static_cast<T>(floor(T(X()) + 0.5));
    T y0 = static_cast<T>(floor(T(Y()) + 0.5));
    T x1 = static_cast<T>(floor(T(XMost()) + 0.5));
    T y1 = static_cast<T>(floor(T(YMost()) + 0.5));

    x = x0;
    y = y0;

    width = x1 - x0;
    height = y1 - y0;
  }



  void RoundIn()
  {
    T x0 = static_cast<T>(ceil(T(X())));
    T y0 = static_cast<T>(ceil(T(Y())));
    T x1 = static_cast<T>(floor(T(XMost())));
    T y1 = static_cast<T>(floor(T(YMost())));

    x = x0;
    y = y0;

    width = x1 - x0;
    height = y1 - y0;
  }



  void RoundOut()
  {
    T x0 = static_cast<T>(floor(T(X())));
    T y0 = static_cast<T>(floor(T(Y())));
    T x1 = static_cast<T>(ceil(T(XMost())));
    T y1 = static_cast<T>(ceil(T(YMost())));

    x = x0;
    y = y0;

    width = x1 - x0;
    height = y1 - y0;
  }


  void Scale(T aScale) { Scale(aScale, aScale); }

  void Scale(T aXScale, T aYScale)
  {
    T right = XMost() * aXScale;
    T bottom = YMost() * aYScale;
    x = x * aXScale;
    y = y * aYScale;
    width = right - x;
    height = bottom - y;
  }



  void ScaleRoundOut(double aScale) { ScaleRoundOut(aScale, aScale); }




  void ScaleRoundOut(double aXScale, double aYScale)
  {
    T right = static_cast<T>(ceil(double(XMost()) * aXScale));
    T bottom = static_cast<T>(ceil(double(YMost()) * aYScale));
    x = static_cast<T>(floor(double(x) * aXScale));
    y = static_cast<T>(floor(double(y) * aYScale));
    width = right - x;
    height = bottom - y;
  }


  void ScaleRoundIn(double aScale) { ScaleRoundIn(aScale, aScale); }



  void ScaleRoundIn(double aXScale, double aYScale)
  {
    T right = static_cast<T>(floor(double(XMost()) * aXScale));
    T bottom = static_cast<T>(floor(double(YMost()) * aYScale));
    x = static_cast<T>(ceil(double(x) * aXScale));
    y = static_cast<T>(ceil(double(y) * aYScale));
    width = std::max<T>(0, right - x);
    height = std::max<T>(0, bottom - y);
  }



  void ScaleInverseRoundOut(double aScale) { ScaleInverseRoundOut(aScale, aScale); }




  void ScaleInverseRoundOut(double aXScale, double aYScale)
  {
    T right = static_cast<T>(ceil(double(XMost()) / aXScale));
    T bottom = static_cast<T>(ceil(double(YMost()) / aYScale));
    x = static_cast<T>(floor(double(x) / aXScale));
    y = static_cast<T>(floor(double(y) / aYScale));
    width = right - x;
    height = bottom - y;
  }


  void ScaleInverseRoundIn(double aScale) { ScaleInverseRoundIn(aScale, aScale); }



  void ScaleInverseRoundIn(double aXScale, double aYScale)
  {
    T right = static_cast<T>(floor(double(XMost()) / aXScale));
    T bottom = static_cast<T>(floor(double(YMost()) / aYScale));
    x = static_cast<T>(ceil(double(x) / aXScale));
    y = static_cast<T>(ceil(double(y) / aYScale));
    width = std::max<T>(0, right - x);
    height = std::max<T>(0, bottom - y);
  }





  __attribute__ ((warn_unused_result)) Point ClampPoint(const Point& aPoint) const
  {
    return Point(std::max(x, std::min(XMost(), aPoint.x)),
                 std::max(y, std::min(YMost(), aPoint.y)));
  }






  __attribute__ ((warn_unused_result)) Sub MoveInsideAndClamp(const Sub& aRect) const
  {
    Sub rect(std::max(aRect.x, x),
             std::max(aRect.y, y),
             std::min(aRect.width, width),
             std::min(aRect.height, height));
    rect.x = std::min(rect.XMost(), aRect.XMost()) - rect.width;
    rect.y = std::min(rect.YMost(), aRect.YMost()) - rect.height;
    return rect;
  }







  static Sub MaxIntRect()
  {
    return Sub(
      static_cast<T>(-std::numeric_limits<int32_t>::max() * 0.5),
      static_cast<T>(-std::numeric_limits<int32_t>::max() * 0.5),
      static_cast<T>(std::numeric_limits<int32_t>::max()),
      static_cast<T>(std::numeric_limits<int32_t>::max())
    );
  };

  friend std::ostream& operator<<(std::ostream& stream,
      const BaseRect<T, Sub, Point, SizeT, MarginT>& aRect) {
    return stream << '(' << aRect.x << ',' << aRect.y << ','
                  << aRect.width << ',' << aRect.height << ')';
  }

private:


  bool operator==(const Sub& aRect) const { return false; }
  bool operator!=(const Sub& aRect) const { return false; }
};

}
}









namespace mozilla {






inline int32_t
RoundDownToMultiple(int32_t x, int32_t aMultiplier)
{


  int mod = x % aMultiplier;
  if (x > 0) {
    return x - mod;
  }
  return mod ? x - aMultiplier - mod : x;
}




inline int32_t
RoundUpToMultiple(int32_t x, int32_t aMultiplier)
{
  int mod = x % aMultiplier;
  if (x > 0) {
    return mod ? x + aMultiplier - mod : x;
  }
  return x - mod;
}

}









namespace mozilla {

template<typename T> class CheckedInt;

namespace detail {
struct UnsupportedType {};

template<typename IntegerType>
struct IsSupportedPass2
{
  static const bool value = false;
};

template<typename IntegerType>
struct IsSupported
{
  static const bool value = IsSupportedPass2<IntegerType>::value;
};

template<>
struct IsSupported<int8_t>
{ static const bool value = true; };

template<>
struct IsSupported<uint8_t>
{ static const bool value = true; };

template<>
struct IsSupported<int16_t>
{ static const bool value = true; };

template<>
struct IsSupported<uint16_t>
{ static const bool value = true; };

template<>
struct IsSupported<int32_t>
{ static const bool value = true; };

template<>
struct IsSupported<uint32_t>
{ static const bool value = true; };

template<>
struct IsSupported<int64_t>
{ static const bool value = true; };

template<>
struct IsSupported<uint64_t>
{ static const bool value = true; };


template<>
struct IsSupportedPass2<char>
{ static const bool value = true; };

template<>
struct IsSupportedPass2<signed char>
{ static const bool value = true; };

template<>
struct IsSupportedPass2<unsigned char>
{ static const bool value = true; };

template<>
struct IsSupportedPass2<short>
{ static const bool value = true; };

template<>
struct IsSupportedPass2<unsigned short>
{ static const bool value = true; };

template<>
struct IsSupportedPass2<int>
{ static const bool value = true; };

template<>
struct IsSupportedPass2<unsigned int>
{ static const bool value = true; };

template<>
struct IsSupportedPass2<long>
{ static const bool value = true; };

template<>
struct IsSupportedPass2<unsigned long>
{ static const bool value = true; };

template<>
struct IsSupportedPass2<long long>
{ static const bool value = true; };

template<>
struct IsSupportedPass2<unsigned long long>
{ static const bool value = true; };







template<typename IntegerType, size_t Size = sizeof(IntegerType)>
struct TwiceBiggerType
{
  typedef typename detail::StdintTypeForSizeAndSignedness<
                     sizeof(IntegerType) * 2,
                     IsSigned<IntegerType>::value
                   >::Type Type;
};

template<typename IntegerType>
struct TwiceBiggerType<IntegerType, 8>
{
  typedef UnsupportedType Type;
};

template<typename T>
inline bool
HasSignBit(T aX)
{




  return bool(typename MakeUnsigned<T>::Type(aX) >>
              PositionOfSignBit<T>::value);
}



template<typename T>
inline T
BinaryComplement(T aX)
{
  return ~aX;
}

template<typename T,
         typename U,
         bool IsTSigned = IsSigned<T>::value,
         bool IsUSigned = IsSigned<U>::value>
struct DoesRangeContainRange
{
};

template<typename T, typename U, bool Signedness>
struct DoesRangeContainRange<T, U, Signedness, Signedness>
{
  static const bool value = sizeof(T) >= sizeof(U);
};

template<typename T, typename U>
struct DoesRangeContainRange<T, U, true, false>
{
  static const bool value = sizeof(T) > sizeof(U);
};

template<typename T, typename U>
struct DoesRangeContainRange<T, U, false, true>
{
  static const bool value = false;
};

template<typename T,
         typename U,
         bool IsTSigned = IsSigned<T>::value,
         bool IsUSigned = IsSigned<U>::value,
         bool DoesTRangeContainURange = DoesRangeContainRange<T, U>::value>
struct IsInRangeImpl {};

template<typename T, typename U, bool IsTSigned, bool IsUSigned>
struct IsInRangeImpl<T, U, IsTSigned, IsUSigned, true>
{
  static bool constexpr run(U)
  {
    return true;
  }
};

template<typename T, typename U>
struct IsInRangeImpl<T, U, true, true, false>
{
  static bool constexpr run(U aX)
  {
    return aX <= MaxValue<T>::value && aX >= MinValue<T>::value;
  }
};

template<typename T, typename U>
struct IsInRangeImpl<T, U, false, false, false>
{
  static bool constexpr run(U aX)
  {
    return aX <= MaxValue<T>::value;
  }
};

template<typename T, typename U>
struct IsInRangeImpl<T, U, true, false, false>
{
  static bool constexpr run(U aX)
  {
    return sizeof(T) > sizeof(U) || aX <= U(MaxValue<T>::value);
  }
};

template<typename T, typename U>
struct IsInRangeImpl<T, U, false, true, false>
{
  static bool constexpr run(U aX)
  {
    return sizeof(T) >= sizeof(U)
           ? aX >= 0
           : aX >= 0 && aX <= U(MaxValue<T>::value);
  }
};

template<typename T, typename U>
inline constexpr bool
IsInRange(U aX)
{
  return IsInRangeImpl<T, U>::run(aX);
}

template<typename T>
inline bool
IsAddValid(T aX, T aY)
{






  typename MakeUnsigned<T>::Type ux = aX;
  typename MakeUnsigned<T>::Type uy = aY;
  typename MakeUnsigned<T>::Type result = ux + uy;
  return IsSigned<T>::value
         ? HasSignBit(BinaryComplement(T((result ^ aX) & (result ^ aY))))
         : BinaryComplement(aX) >= aY;
}

template<typename T>
inline bool
IsSubValid(T aX, T aY)
{



  typename MakeUnsigned<T>::Type ux = aX;
  typename MakeUnsigned<T>::Type uy = aY;
  typename MakeUnsigned<T>::Type result = ux - uy;

  return IsSigned<T>::value
         ? HasSignBit(BinaryComplement(T((result ^ aX) & (aX ^ aY))))
         : aX >= aY;
}

template<typename T,
         bool IsTSigned = IsSigned<T>::value,
         bool TwiceBiggerTypeIsSupported =
           IsSupported<typename TwiceBiggerType<T>::Type>::value>
struct IsMulValidImpl {};

template<typename T, bool IsTSigned>
struct IsMulValidImpl<T, IsTSigned, true>
{
  static bool run(T aX, T aY)
  {
    typedef typename TwiceBiggerType<T>::Type TwiceBiggerType;
    TwiceBiggerType product = TwiceBiggerType(aX) * TwiceBiggerType(aY);
    return IsInRange<T>(product);
  }
};

template<typename T>
struct IsMulValidImpl<T, true, false>
{
  static bool run(T aX, T aY)
  {
    const T max = MaxValue<T>::value;
    const T min = MinValue<T>::value;

    if (aX == 0 || aY == 0) {
      return true;
    }
    if (aX > 0) {
      return aY > 0
             ? aX <= max / aY
             : aY >= min / aX;
    }


    return aY > 0
           ? aX >= min / aY
           : aY >= max / aX;
  }
};

template<typename T>
struct IsMulValidImpl<T, false, false>
{
  static bool run(T aX, T aY)
  {
    return aY == 0 || aX <= MaxValue<T>::value / aY;
  }
};

template<typename T>
inline bool
IsMulValid(T aX, T aY)
{
  return IsMulValidImpl<T>::run(aX, aY);
}

template<typename T>
inline bool
IsDivValid(T aX, T aY)
{


  return aY != 0 &&
         !(IsSigned<T>::value && aX == MinValue<T>::value && aY == T(-1));
}

template<typename T, bool IsTSigned = IsSigned<T>::value>
struct IsModValidImpl;

template<typename T>
inline bool
IsModValid(T aX, T aY)
{
  return IsModValidImpl<T>::run(aX, aY);
}
template<typename T>
struct IsModValidImpl<T, false>
{
  static inline bool run(T aX, T aY)
  {
    return aY >= 1;
  }
};

template<typename T>
struct IsModValidImpl<T, true>
{
  static inline bool run(T aX, T aY)
  {
    if (aX < 0) {
      return false;
    }
    return aY >= 1;
  }
};

template<typename T, bool IsSigned = IsSigned<T>::value>
struct NegateImpl;

template<typename T>
struct NegateImpl<T, false>
{
  static CheckedInt<T> negate(const CheckedInt<T>& aVal)
  {


    return CheckedInt<T>(0, aVal.isValid() && aVal.mValue == 0);
  }
};

template<typename T>
struct NegateImpl<T, true>
{
  static CheckedInt<T> negate(const CheckedInt<T>& aVal)
  {


    if (!aVal.isValid() || aVal.mValue == MinValue<T>::value) {
      return CheckedInt<T>(aVal.mValue, false);
    }
    return CheckedInt<T>(-aVal.mValue, true);
  }
};

}
template<typename T>
class CheckedInt
{
protected:
  T mValue;
  bool mIsValid;

  template<typename U>
  CheckedInt(U aValue, bool aIsValid) : mValue(aValue), mIsValid(aIsValid)
  {
    static_assert(detail::IsSupported<T>::value &&
                  detail::IsSupported<U>::value,
                  "This type is not supported by CheckedInt");
  }

  friend struct detail::NegateImpl<T>;

public:
  template<typename U>
               constexpr CheckedInt(U aValue)
    : mValue(T(aValue)),
      mIsValid(detail::IsInRange<T>(aValue))
  {
    static_assert(detail::IsSupported<T>::value &&
                  detail::IsSupported<U>::value,
                  "This type is not supported by CheckedInt");
  }

  template<typename U>
  friend class CheckedInt;

  template<typename U>
  CheckedInt<U> toChecked() const
  {
    CheckedInt<U> ret(mValue);
    ret.mIsValid = ret.mIsValid && mIsValid;
    return ret;
  }


  constexpr CheckedInt() : mValue(0), mIsValid(true)
  {
    static_assert(detail::IsSupported<T>::value,
                  "This type is not supported by CheckedInt");
  }


  T value() const
  {
    do { } while (0);
    return mValue;
  }






  bool isValid() const
  {
    return mIsValid;
  }

  template<typename U>
  friend CheckedInt<U> operator +(const CheckedInt<U>& aLhs,
                                  const CheckedInt<U>& aRhs);
  template<typename U>
  CheckedInt& operator +=(U aRhs);
  CheckedInt& operator +=(const CheckedInt<T>& aRhs);

  template<typename U>
  friend CheckedInt<U> operator -(const CheckedInt<U>& aLhs,
                                  const CheckedInt<U>& aRhs);
  template<typename U>
  CheckedInt& operator -=(U aRhs);
  CheckedInt& operator -=(const CheckedInt<T>& aRhs);

  template<typename U>
  friend CheckedInt<U> operator *(const CheckedInt<U>& aLhs,
                                  const CheckedInt<U>& aRhs);
  template<typename U>
  CheckedInt& operator *=(U aRhs);
  CheckedInt& operator *=(const CheckedInt<T>& aRhs);

  template<typename U>
  friend CheckedInt<U> operator /(const CheckedInt<U>& aLhs,
                                  const CheckedInt<U>& aRhs);
  template<typename U>
  CheckedInt& operator /=(U aRhs);
  CheckedInt& operator /=(const CheckedInt<T>& aRhs);

  template<typename U>
  friend CheckedInt<U> operator %(const CheckedInt<U>& aLhs,
                                  const CheckedInt<U>& aRhs);
  template<typename U>
  CheckedInt& operator %=(U aRhs);
  CheckedInt& operator %=(const CheckedInt<T>& aRhs);

  CheckedInt operator -() const
  {
    return detail::NegateImpl<T>::negate(*this);
  }
  bool operator ==(const CheckedInt& aOther) const
  {
    return mIsValid && aOther.mIsValid && mValue == aOther.mValue;
  }


  CheckedInt& operator++()
  {
    *this += 1;
    return *this;
  }


  CheckedInt operator++(int)
  {
    CheckedInt tmp = *this;
    *this += 1;
    return tmp;
  }


  CheckedInt& operator--()
  {
    *this -= 1;
    return *this;
  }


  CheckedInt operator--(int)
  {
    CheckedInt tmp = *this;
    *this -= 1;
    return tmp;
  }

private:




  template<typename U> bool operator !=(U aOther) const = delete;
  template<typename U> bool operator < (U aOther) const = delete;
  template<typename U> bool operator <=(U aOther) const = delete;
  template<typename U> bool operator > (U aOther) const = delete;
  template<typename U> bool operator >=(U aOther) const = delete;
};
template<typename T> inline CheckedInt<T> operator +(const CheckedInt<T>& aLhs, const CheckedInt<T>& aRhs) { if (!detail::IsAddValid(aLhs.mValue, aRhs.mValue)) { return CheckedInt<T>(0, false); } return CheckedInt<T>(aLhs.mValue + aRhs.mValue, aLhs.mIsValid && aRhs.mIsValid); }
template<typename T> inline CheckedInt<T> operator -(const CheckedInt<T>& aLhs, const CheckedInt<T>& aRhs) { if (!detail::IsSubValid(aLhs.mValue, aRhs.mValue)) { return CheckedInt<T>(0, false); } return CheckedInt<T>(aLhs.mValue - aRhs.mValue, aLhs.mIsValid && aRhs.mIsValid); }
template<typename T> inline CheckedInt<T> operator *(const CheckedInt<T>& aLhs, const CheckedInt<T>& aRhs) { if (!detail::IsMulValid(aLhs.mValue, aRhs.mValue)) { return CheckedInt<T>(0, false); } return CheckedInt<T>(aLhs.mValue * aRhs.mValue, aLhs.mIsValid && aRhs.mIsValid); }
template<typename T> inline CheckedInt<T> operator /(const CheckedInt<T>& aLhs, const CheckedInt<T>& aRhs) { if (!detail::IsDivValid(aLhs.mValue, aRhs.mValue)) { return CheckedInt<T>(0, false); } return CheckedInt<T>(aLhs.mValue / aRhs.mValue, aLhs.mIsValid && aRhs.mIsValid); }
template<typename T> inline CheckedInt<T> operator %(const CheckedInt<T>& aLhs, const CheckedInt<T>& aRhs) { if (!detail::IsModValid(aLhs.mValue, aRhs.mValue)) { return CheckedInt<T>(0, false); } return CheckedInt<T>(aLhs.mValue % aRhs.mValue, aLhs.mIsValid && aRhs.mIsValid); }
namespace detail {

template<typename T, typename U>
struct CastToCheckedIntImpl
{
  typedef CheckedInt<T> ReturnType;
  static CheckedInt<T> run(U aU) { return aU; }
};

template<typename T>
struct CastToCheckedIntImpl<T, CheckedInt<T> >
{
  typedef const CheckedInt<T>& ReturnType;
  static const CheckedInt<T>& run(const CheckedInt<T>& aU) { return aU; }
};

}

template<typename T, typename U>
inline typename detail::CastToCheckedIntImpl<T, U>::ReturnType
castToCheckedInt(U aU)
{
  static_assert(detail::IsSupported<T>::value &&
                detail::IsSupported<U>::value,
                "This type is not supported by CheckedInt");
  return detail::CastToCheckedIntImpl<T, U>::run(aU);
}
template<typename T> template<typename U> CheckedInt<T>& CheckedInt<T>::operator +=(U aRhs) { *this = *this + castToCheckedInt<T>(aRhs); return *this; } template<typename T> CheckedInt<T>& CheckedInt<T>::operator +=(const CheckedInt<T>& aRhs) { *this = *this + aRhs; return *this; } template<typename T, typename U> inline CheckedInt<T> operator +(const CheckedInt<T>& aLhs, U aRhs) { return aLhs + castToCheckedInt<T>(aRhs); } template<typename T, typename U> inline CheckedInt<T> operator +(U aLhs, const CheckedInt<T>& aRhs) { return castToCheckedInt<T>(aLhs) + aRhs; }
template<typename T> template<typename U> CheckedInt<T>& CheckedInt<T>::operator *=(U aRhs) { *this = *this * castToCheckedInt<T>(aRhs); return *this; } template<typename T> CheckedInt<T>& CheckedInt<T>::operator *=(const CheckedInt<T>& aRhs) { *this = *this * aRhs; return *this; } template<typename T, typename U> inline CheckedInt<T> operator *(const CheckedInt<T>& aLhs, U aRhs) { return aLhs * castToCheckedInt<T>(aRhs); } template<typename T, typename U> inline CheckedInt<T> operator *(U aLhs, const CheckedInt<T>& aRhs) { return castToCheckedInt<T>(aLhs) * aRhs; }
template<typename T> template<typename U> CheckedInt<T>& CheckedInt<T>::operator -=(U aRhs) { *this = *this - castToCheckedInt<T>(aRhs); return *this; } template<typename T> CheckedInt<T>& CheckedInt<T>::operator -=(const CheckedInt<T>& aRhs) { *this = *this - aRhs; return *this; } template<typename T, typename U> inline CheckedInt<T> operator -(const CheckedInt<T>& aLhs, U aRhs) { return aLhs - castToCheckedInt<T>(aRhs); } template<typename T, typename U> inline CheckedInt<T> operator -(U aLhs, const CheckedInt<T>& aRhs) { return castToCheckedInt<T>(aLhs) - aRhs; }
template<typename T> template<typename U> CheckedInt<T>& CheckedInt<T>::operator /=(U aRhs) { *this = *this / castToCheckedInt<T>(aRhs); return *this; } template<typename T> CheckedInt<T>& CheckedInt<T>::operator /=(const CheckedInt<T>& aRhs) { *this = *this / aRhs; return *this; } template<typename T, typename U> inline CheckedInt<T> operator /(const CheckedInt<T>& aLhs, U aRhs) { return aLhs / castToCheckedInt<T>(aRhs); } template<typename T, typename U> inline CheckedInt<T> operator /(U aLhs, const CheckedInt<T>& aRhs) { return castToCheckedInt<T>(aLhs) / aRhs; }
template<typename T> template<typename U> CheckedInt<T>& CheckedInt<T>::operator %=(U aRhs) { *this = *this % castToCheckedInt<T>(aRhs); return *this; } template<typename T> CheckedInt<T>& CheckedInt<T>::operator %=(const CheckedInt<T>& aRhs) { *this = *this % aRhs; return *this; } template<typename T, typename U> inline CheckedInt<T> operator %(const CheckedInt<T>& aLhs, U aRhs) { return aLhs % castToCheckedInt<T>(aRhs); } template<typename T, typename U> inline CheckedInt<T> operator %(U aLhs, const CheckedInt<T>& aRhs) { return castToCheckedInt<T>(aLhs) % aRhs; }



template<typename T, typename U>
inline bool
operator ==(const CheckedInt<T>& aLhs, U aRhs)
{
  return aLhs == castToCheckedInt<T>(aRhs);
}

template<typename T, typename U>
inline bool
operator ==(U aLhs, const CheckedInt<T>& aRhs)
{
  return castToCheckedInt<T>(aLhs) == aRhs;
}


typedef CheckedInt<int8_t> CheckedInt8;
typedef CheckedInt<uint8_t> CheckedUint8;
typedef CheckedInt<int16_t> CheckedInt16;
typedef CheckedInt<uint16_t> CheckedUint16;
typedef CheckedInt<int32_t> CheckedInt32;
typedef CheckedInt<uint32_t> CheckedUint32;
typedef CheckedInt<int64_t> CheckedInt64;
typedef CheckedInt<uint64_t> CheckedUint64;

}





namespace mozilla {
namespace gfx {

static inline bool
IsOperatorBoundByMask(CompositionOp aOp) {
  switch (aOp) {
  case CompositionOp::OP_IN:
  case CompositionOp::OP_OUT:
  case CompositionOp::OP_DEST_IN:
  case CompositionOp::OP_DEST_ATOP:
  case CompositionOp::OP_SOURCE:
    return false;
  default:
    return true;
  }
}

template <class T>
struct ClassStorage
{
  char bytes[sizeof(T)];

  const T *addr() const { return (const T *)bytes; }
  T *addr() { return (T *)(void *)bytes; }
};

static inline bool
FuzzyEqual(Float aA, Float aB, Float aErr)
{
  if ((aA + aErr >= aB) && (aA - aErr <= aB)) {
    return true;
  }
  return false;
}

static inline void
NudgeToInteger(float *aVal)
{
  float r = floorf(*aVal + 0.5f);





  if (FuzzyEqual(r, *aVal, r == 0.0f ? 1e-6f : fabs(r*1e-6f))) {
    *aVal = r;
  }
}

static inline void
NudgeToInteger(float *aVal, float aErr)
{
  float r = floorf(*aVal + 0.5f);
  if (FuzzyEqual(r, *aVal, aErr)) {
    *aVal = r;
  }
}

static inline Float
Distance(Point aA, Point aB)
{
  return hypotf(aB.x - aA.x, aB.y - aA.y);
}

static inline int
BytesPerPixel(SurfaceFormat aFormat)
{
  switch (aFormat) {
  case SurfaceFormat::A8:
    return 1;
  case SurfaceFormat::R5G6B5_UINT16:
    return 2;
  case SurfaceFormat::R8G8B8:
  case SurfaceFormat::B8G8R8:
    return 3;
  case SurfaceFormat::HSV:
  case SurfaceFormat::Lab:
    return 3 * sizeof(float);
  case SurfaceFormat::Depth:
    return sizeof(uint16_t);
  default:
    return 4;
  }
}

static inline bool
IsOpaqueFormat(SurfaceFormat aFormat) {
  switch (aFormat) {
    case SurfaceFormat::B8G8R8X8:
    case SurfaceFormat::R8G8B8X8:
    case SurfaceFormat::X8R8G8B8:
    case SurfaceFormat::YUV:
    case SurfaceFormat::NV12:
    case SurfaceFormat::YUV422:
    case SurfaceFormat::R5G6B5_UINT16:
      return true;
    default:
      return false;
  }
}

template<typename T, int alignment = 16>
struct AlignedArray
{
  typedef T value_type;

  AlignedArray()
    : mPtr(nullptr)
    , mStorage(nullptr)
  {
  }

  explicit __attribute__((always_inline)) inline AlignedArray(size_t aCount, bool aZero = false)
    : mStorage(nullptr)
    , mCount(0)
  {
    Realloc(aCount, aZero);
  }

  __attribute__((always_inline)) inline ~AlignedArray()
  {
    Dealloc();
  }

  void Dealloc()
  {




    static_assert(mozilla::IsPod<T>::value,
                  "Destructors must be invoked for this type");
    free(mStorage);
    mStorage = nullptr;
    mPtr = nullptr;
  }

  __attribute__((always_inline)) inline void Realloc(size_t aCount, bool aZero = false)
  {
    free(mStorage);
    CheckedInt32 storageByteCount =
      CheckedInt32(sizeof(T)) * aCount + (alignment - 1);
    if (!storageByteCount.isValid()) {
      mStorage = nullptr;
      mPtr = nullptr;
      mCount = 0;
      return;
    }


    if (aZero) {


      mStorage = static_cast<uint8_t *>(calloc(1, storageByteCount.value()));
    } else {
      mStorage = static_cast<uint8_t *>(malloc(storageByteCount.value()));
    }
    if (!mStorage) {
      mStorage = nullptr;
      mPtr = nullptr;
      mCount = 0;
      return;
    }
    if (uintptr_t(mStorage) % alignment) {

      mPtr = (T*)(uintptr_t(mStorage) + alignment - (uintptr_t(mStorage) % alignment));
    } else {
      mPtr = (T*)(mStorage);
    }




    mPtr = new (mPtr) T[aCount];
    mCount = aCount;
  }

  void Swap(AlignedArray<T, alignment>& aOther)
  {
    mozilla::Swap(mPtr, aOther.mPtr);
    mozilla::Swap(mStorage, aOther.mStorage);
    mozilla::Swap(mCount, aOther.mCount);
  }

  __attribute__((always_inline)) inline operator T*()
  {
    return mPtr;
  }

  T *mPtr;

private:
  uint8_t *mStorage;
  size_t mCount;
};
template<int alignment>
int32_t GetAlignedStride(int32_t aWidth, int32_t aBytesPerPixel)
{
  static_assert(alignment > 0 && (alignment & (alignment-1)) == 0,
                "This implementation currently require power-of-two alignment");
  const int32_t mask = alignment - 1;
  CheckedInt32 stride = CheckedInt32(aWidth) * CheckedInt32(aBytesPerPixel) + CheckedInt32(mask);
  if (stride.isValid()) {
    return stride.value() & ~mask;
  }
  return 0;
}

}
}
namespace mozilla {

struct Nothing { };
template<class T>
class Maybe
{
  alignas(T) unsigned char mStorage[sizeof(T)];
  char mIsSome;



  void* data() { return mStorage; }
  const void* data() const { return mStorage; }

public:
  using ValueType = T;

  Maybe() : mIsSome(false) { }
  ~Maybe() { reset(); }

               Maybe(Nothing) : mIsSome(false) { }

  Maybe(const Maybe& aOther)
    : mIsSome(false)
  {
    if (aOther.mIsSome) {
      emplace(*aOther);
    }
  }




  template<typename U,
           typename =
             typename std::enable_if<std::is_convertible<U, T>::value>::type>

  Maybe(const Maybe<U>& aOther)
    : mIsSome(false)
  {
    if (aOther.isSome()) {
      emplace(*aOther);
    }
  }

  Maybe(Maybe&& aOther)
    : mIsSome(false)
  {
    if (aOther.mIsSome) {
      emplace(Move(*aOther));
      aOther.reset();
    }
  }




  template<typename U,
           typename =
             typename std::enable_if<std::is_convertible<U, T>::value>::type>

  Maybe(Maybe<U>&& aOther)
    : mIsSome(false)
  {
    if (aOther.isSome()) {
      emplace(Move(*aOther));
      aOther.reset();
    }
  }

  Maybe& operator=(const Maybe& aOther)
  {
    if (&aOther != this) {
      if (aOther.mIsSome) {
        if (mIsSome) {
          ref() = aOther.ref();
        } else {
          emplace(*aOther);
        }
      } else {
        reset();
      }
    }
    return *this;
  }

  template<typename U,
           typename =
             typename std::enable_if<std::is_convertible<U, T>::value>::type>
  Maybe& operator=(const Maybe<U>& aOther)
  {
    if (aOther.isSome()) {
      if (mIsSome) {
        ref() = aOther.ref();
      } else {
        emplace(*aOther);
      }
    } else {
      reset();
    }
    return *this;
  }

  Maybe& operator=(Maybe&& aOther)
  {
    do { } while (0);

    if (aOther.mIsSome) {
      if (mIsSome) {
        ref() = Move(aOther.ref());
      } else {
        emplace(Move(*aOther));
      }
      aOther.reset();
    } else {
      reset();
    }

    return *this;
  }

  template<typename U,
           typename =
             typename std::enable_if<std::is_convertible<U, T>::value>::type>
  Maybe& operator=(Maybe<U>&& aOther)
  {
    if (aOther.isSome()) {
      if (mIsSome) {
        ref() = Move(aOther.ref());
      } else {
        emplace(Move(*aOther));
      }
      aOther.reset();
    } else {
      reset();
    }

    return *this;
  }


  explicit operator bool() const { return isSome(); }
  bool isSome() const { return mIsSome; }
  bool isNothing() const { return !mIsSome; }


  T value() const
  {
    do { } while (0);
    return ref();
  }





  template<typename V>
  T valueOr(V&& aDefault) const
  {
    if (isSome()) {
      return ref();
    }
    return Forward<V>(aDefault);
  }





  template<typename F>
  T valueOrFrom(F&& aFunc) const
  {
    if (isSome()) {
      return ref();
    }
    return aFunc();
  }


  T* ptr()
  {
    do { } while (0);
    return &ref();
  }

  const T* ptr() const
  {
    do { } while (0);
    return &ref();
  }





  T* ptrOr(T* aDefault)
  {
    if (isSome()) {
      return ptr();
    }
    return aDefault;
  }

  const T* ptrOr(const T* aDefault) const
  {
    if (isSome()) {
      return ptr();
    }
    return aDefault;
  }





  template<typename F>
  T* ptrOrFrom(F&& aFunc)
  {
    if (isSome()) {
      return ptr();
    }
    return aFunc();
  }

  template<typename F>
  const T* ptrOrFrom(F&& aFunc) const
  {
    if (isSome()) {
      return ptr();
    }
    return aFunc();
  }

  T* operator->()
  {
    do { } while (0);
    return ptr();
  }

  const T* operator->() const
  {
    do { } while (0);
    return ptr();
  }


  T& ref()
  {
    do { } while (0);
    return *static_cast<T*>(data());
  }

  const T& ref() const
  {
    do { } while (0);
    return *static_cast<const T*>(data());
  }





  T& refOr(T& aDefault)
  {
    if (isSome()) {
      return ref();
    }
    return aDefault;
  }

  const T& refOr(const T& aDefault) const
  {
    if (isSome()) {
      return ref();
    }
    return aDefault;
  }





  template<typename F>
  T& refOrFrom(F&& aFunc)
  {
    if (isSome()) {
      return ref();
    }
    return aFunc();
  }

  template<typename F>
  const T& refOrFrom(F&& aFunc) const
  {
    if (isSome()) {
      return ref();
    }
    return aFunc();
  }

  T& operator*()
  {
    do { } while (0);
    return ref();
  }

  const T& operator*() const
  {
    do { } while (0);
    return ref();
  }



  template<typename Func>
  Maybe& apply(Func aFunc)
  {
    if (isSome()) {
      aFunc(ref());
    }
    return *this;
  }

  template<typename Func>
  const Maybe& apply(Func aFunc) const
  {
    if (isSome()) {
      aFunc(ref());
    }
    return *this;
  }





  template<typename Func>
  auto map(Func aFunc) -> Maybe<decltype(aFunc(DeclVal<Maybe<T>>().ref()))>
  {
    using ReturnType = decltype(aFunc(ref()));
    if (isSome()) {
      Maybe<ReturnType> val;
      val.emplace(aFunc(ref()));
      return val;
    }
    return Maybe<ReturnType>();
  }

  template<typename Func>
  auto map(Func aFunc) const -> Maybe<decltype(aFunc(DeclVal<Maybe<T>>().ref()))>
  {
    using ReturnType = decltype(aFunc(ref()));
    if (isSome()) {
      Maybe<ReturnType> val;
      val.emplace(aFunc(ref()));
      return val;
    }
    return Maybe<ReturnType>();
  }


  void reset()
  {
    if (isSome()) {
      ref().T::~T();
      mIsSome = false;
    }
  }





  template<typename... Args>
  void emplace(Args&&... aArgs)
  {
    do { } while (0);
    ::new (KnownNotNull, data()) T(Forward<Args>(aArgs)...);
    mIsSome = true;
  }

  friend std::ostream&
  operator<<(std::ostream& aStream, const Maybe<T>& aMaybe)
  {
    if (aMaybe) {
      aStream << aMaybe.ref();
    } else {
      aStream << "<Nothing>";
    }
    return aStream;
  }
};
template<typename T,
         typename U = typename std::remove_cv<
           typename std::remove_reference<T>::type>::type>
Maybe<U>
Some(T&& aValue)
{
  Maybe<U> value;
  value.emplace(Forward<T>(aValue));
  return value;
}

template<typename T>
Maybe<typename RemoveCV<typename RemoveReference<T>::Type>::Type>
ToMaybe(T* aPtr)
{
  if (aPtr) {
    return Some(*aPtr);
  }
  return Nothing();
}






template<typename T> bool
operator==(const Maybe<T>& aLHS, const Maybe<T>& aRHS)
{
  if (aLHS.isNothing() != aRHS.isNothing()) {
    return false;
  }
  return aLHS.isNothing() || *aLHS == *aRHS;
}

template<typename T> bool
operator!=(const Maybe<T>& aLHS, const Maybe<T>& aRHS)
{
  return !(aLHS == aRHS);
}





template<typename T> bool
operator==(const Maybe<T>& aLHS, const Nothing& aRHS)
{
  return aLHS.isNothing();
}

template<typename T> bool
operator!=(const Maybe<T>& aLHS, const Nothing& aRHS)
{
  return !(aLHS == aRHS);
}

template<typename T> bool
operator==(const Nothing& aLHS, const Maybe<T>& aRHS)
{
  return aRHS.isNothing();
}

template<typename T> bool
operator!=(const Nothing& aLHS, const Maybe<T>& aRHS)
{
  return !(aLHS == aRHS);
}





template<typename T> bool
operator<(const Maybe<T>& aLHS, const Maybe<T>& aRHS)
{
  if (aLHS.isNothing()) {
    return aRHS.isSome();
  }
  if (aRHS.isNothing()) {
    return false;
  }
  return *aLHS < *aRHS;
}

template<typename T> bool
operator>(const Maybe<T>& aLHS, const Maybe<T>& aRHS)
{
  return !(aLHS < aRHS || aLHS == aRHS);
}

template<typename T> bool
operator<=(const Maybe<T>& aLHS, const Maybe<T>& aRHS)
{
  return aLHS < aRHS || aLHS == aRHS;
}

template<typename T> bool
operator>=(const Maybe<T>& aLHS, const Maybe<T>& aRHS)
{
  return !(aLHS < aRHS);
}

}


namespace mozilla {

template <typename> struct IsPixel;

namespace gfx {

template<class units, class F> struct RectTyped;

template<class units>
struct IntMarginTyped:
    public BaseMargin<int32_t, IntMarginTyped<units> >,
    public units {
    static_assert(IsPixel<units>::value,
                  "'units' must be a coordinate system tag");

    typedef BaseMargin<int32_t, IntMarginTyped<units> > Super;

    IntMarginTyped() : Super() {}
    IntMarginTyped(int32_t aTop, int32_t aRight, int32_t aBottom, int32_t aLeft) :
        Super(aTop, aRight, aBottom, aLeft) {}




    static IntMarginTyped<units> FromUnknownMargin(const IntMarginTyped<UnknownUnits>& aMargin) {
        return IntMarginTyped<units>(aMargin.top, aMargin.right,
                                     aMargin.bottom, aMargin.left);
    }

    IntMarginTyped<UnknownUnits> ToUnknownMargin() const {
        return IntMarginTyped<UnknownUnits>(this->top, this->right,
                                            this->bottom, this->left);
    }
};
typedef IntMarginTyped<UnknownUnits> IntMargin;

template<class units, class F = Float>
struct MarginTyped:
    public BaseMargin<F, MarginTyped<units> >,
    public units {
    static_assert(IsPixel<units>::value,
                  "'units' must be a coordinate system tag");

    typedef BaseMargin<F, MarginTyped<units, F> > Super;

    MarginTyped() : Super() {}
    MarginTyped(F aTop, F aRight, F aBottom, F aLeft) :
        Super(aTop, aRight, aBottom, aLeft) {}
    explicit MarginTyped(const IntMarginTyped<units>& aMargin) :
        Super(F(aMargin.top), F(aMargin.right),
              F(aMargin.bottom), F(aMargin.left)) {}
};
typedef MarginTyped<UnknownUnits> Margin;
typedef MarginTyped<UnknownUnits, double> MarginDouble;

template<class units>
IntMarginTyped<units> RoundedToInt(const MarginTyped<units>& aMargin)
{
  return IntMarginTyped<units>(int32_t(floorf(aMargin.top + 0.5f)),
                               int32_t(floorf(aMargin.right + 0.5f)),
                               int32_t(floorf(aMargin.bottom + 0.5f)),
                               int32_t(floorf(aMargin.left + 0.5f)));
}

template<class units>
struct IntRectTyped :
    public BaseRect<int32_t, IntRectTyped<units>, IntPointTyped<units>, IntSizeTyped<units>, IntMarginTyped<units> >,
    public units {
    static_assert(IsPixel<units>::value,
                  "'units' must be a coordinate system tag");

    typedef BaseRect<int32_t, IntRectTyped<units>, IntPointTyped<units>, IntSizeTyped<units>, IntMarginTyped<units> > Super;
    typedef IntRectTyped<units> Self;
    typedef IntParam<int32_t> ToInt;

    IntRectTyped() : Super() {}
    IntRectTyped(const IntPointTyped<units>& aPos, const IntSizeTyped<units>& aSize) :
        Super(aPos, aSize) {}

    IntRectTyped(ToInt aX, ToInt aY, ToInt aWidth, ToInt aHeight) :
        Super(aX.value, aY.value, aWidth.value, aHeight.value) {}

    static IntRectTyped<units> RoundIn(float aX, float aY, float aW, float aH) {
      return IntRectTyped<units>::RoundIn(RectTyped<units, float>(aX, aY, aW, aH));
    }

    static IntRectTyped<units> RoundOut(float aX, float aY, float aW, float aH) {
      return IntRectTyped<units>::RoundOut(RectTyped<units, float>(aX, aY, aW, aH));
    }

    static IntRectTyped<units> Round(float aX, float aY, float aW, float aH) {
      return IntRectTyped<units>::Round(RectTyped<units, float>(aX, aY, aW, aH));
    }

    static IntRectTyped<units> Truncate(float aX, float aY, float aW, float aH) {
      return IntRectTyped<units>(IntPointTyped<units>::Truncate(aX, aY),
                                 IntSizeTyped<units>::Truncate(aW, aH));
    }

    static IntRectTyped<units> RoundIn(const RectTyped<units, float>& aRect) {
      auto tmp(aRect);
      tmp.RoundIn();
      return IntRectTyped(int32_t(tmp.x), int32_t(tmp.y),
                          int32_t(tmp.width), int32_t(tmp.height));
    }

    static IntRectTyped<units> RoundOut(const RectTyped<units, float>& aRect) {
      auto tmp(aRect);
      tmp.RoundOut();
      return IntRectTyped(int32_t(tmp.x), int32_t(tmp.y),
                          int32_t(tmp.width), int32_t(tmp.height));
    }

    static IntRectTyped<units> Round(const RectTyped<units, float>& aRect) {
      auto tmp(aRect);
      tmp.Round();
      return IntRectTyped(int32_t(tmp.x), int32_t(tmp.y),
                          int32_t(tmp.width), int32_t(tmp.height));
    }

    static IntRectTyped<units> Truncate(const RectTyped<units, float>& aRect) {
      return IntRectTyped::Truncate(aRect.x, aRect.y, aRect.width, aRect.height);
    }


    void Round() {}
    void RoundIn() {}
    void RoundOut() {}




    static IntRectTyped<units> FromUnknownRect(const IntRectTyped<UnknownUnits>& rect) {
        return IntRectTyped<units>(rect.x, rect.y, rect.width, rect.height);
    }

    IntRectTyped<UnknownUnits> ToUnknownRect() const {
        return IntRectTyped<UnknownUnits>(this->x, this->y, this->width, this->height);
    }

    bool Overflows() const {
      CheckedInt<int32_t> xMost = this->x;
      xMost += this->width;
      CheckedInt<int32_t> yMost = this->y;
      yMost += this->height;
      return !xMost.isValid() || !yMost.isValid();
    }




    __attribute__ ((warn_unused_result)) Maybe<Self> SafeUnion(const Self& aRect) const
    {
      if (this->IsEmpty()) {
        return aRect.Overflows() ? Nothing() : Some(aRect);
      } else if (aRect.IsEmpty()) {
        return Some(*static_cast<const Self*>(this));
      } else {
        return this->SafeUnionEdges(aRect);
      }
    }



    __attribute__ ((warn_unused_result)) Maybe<Self> SafeUnionEdges(const Self& aRect) const
    {
      if (this->Overflows() || aRect.Overflows()) {
        return Nothing();
      }


      CheckedInt<int32_t> newX = std::min(this->x, aRect.x);
      CheckedInt<int32_t> newY = std::min(this->y, aRect.y);
      CheckedInt<int32_t> newXMost = std::max(this->XMost(), aRect.XMost());
      CheckedInt<int32_t> newYMost = std::max(this->YMost(), aRect.YMost());
      CheckedInt<int32_t> newW = newXMost - newX;
      CheckedInt<int32_t> newH = newYMost - newY;
      if (!newW.isValid() || !newH.isValid()) {
        return Nothing();
      }
      return Some(Self(newX.value(), newY.value(), newW.value(), newH.value()));
    }


    bool operator==(const IntRectTyped<units>& aRect) const
    {
      return IntRectTyped<units>::IsEqualEdges(aRect);
    }

    void InflateToMultiple(const IntSizeTyped<units>& aTileSize)
    {
      if (this->IsEmpty()) {
        return;
      }

      int32_t yMost = this->YMost();
      int32_t xMost = this->XMost();

      this->x = mozilla::RoundDownToMultiple(this->x, aTileSize.width);
      this->y = mozilla::RoundDownToMultiple(this->y, aTileSize.height);
      xMost = mozilla::RoundUpToMultiple(xMost, aTileSize.width);
      yMost = mozilla::RoundUpToMultiple(yMost, aTileSize.height);

      this->width = xMost - this->x;
      this->height = yMost - this->y;
    }

};
typedef IntRectTyped<UnknownUnits> IntRect;

template<class units, class F = Float>
struct RectTyped :
    public BaseRect<F, RectTyped<units, F>, PointTyped<units, F>, SizeTyped<units, F>, MarginTyped<units, F> >,
    public units {
    static_assert(IsPixel<units>::value,
                  "'units' must be a coordinate system tag");

    typedef BaseRect<F, RectTyped<units, F>, PointTyped<units, F>, SizeTyped<units, F>, MarginTyped<units, F> > Super;

    RectTyped() : Super() {}
    RectTyped(const PointTyped<units, F>& aPos, const SizeTyped<units, F>& aSize) :
        Super(aPos, aSize) {}
    RectTyped(F _x, F _y, F _width, F _height) :
        Super(_x, _y, _width, _height) {}
    explicit RectTyped(const IntRectTyped<units>& rect) :
        Super(F(rect.x), F(rect.y),
              F(rect.width), F(rect.height)) {}

    void NudgeToIntegers()
    {
      NudgeToInteger(&(this->x));
      NudgeToInteger(&(this->y));
      NudgeToInteger(&(this->width));
      NudgeToInteger(&(this->height));
    }

    bool ToIntRect(IntRectTyped<units> *aOut) const
    {
      *aOut = IntRectTyped<units>(int32_t(this->X()), int32_t(this->Y()),
                                  int32_t(this->Width()), int32_t(this->Height()));
      return RectTyped<units, F>(F(aOut->x), F(aOut->y),
                                 F(aOut->width), F(aOut->height))
             .IsEqualEdges(*this);
    }




    static RectTyped<units, F> FromUnknownRect(const RectTyped<UnknownUnits, F>& rect) {
        return RectTyped<units, F>(rect.x, rect.y, rect.width, rect.height);
    }

    RectTyped<UnknownUnits, F> ToUnknownRect() const {
        return RectTyped<UnknownUnits, F>(this->x, this->y, this->width, this->height);
    }


    bool operator==(const RectTyped<units, F>& aRect) const
    {
      return RectTyped<units, F>::IsEqualEdges(aRect);
    }
};
typedef RectTyped<UnknownUnits> Rect;
typedef RectTyped<UnknownUnits, double> RectDouble;

template<class units>
IntRectTyped<units> RoundedToInt(const RectTyped<units>& aRect)
{
  RectTyped<units> copy(aRect);
  copy.Round();
  return IntRectTyped<units>(int32_t(copy.x),
                             int32_t(copy.y),
                             int32_t(copy.width),
                             int32_t(copy.height));
}

template<class units>
IntRectTyped<units> RoundedIn(const RectTyped<units>& aRect)
{
  return IntRectTyped<units>::RoundIn(aRect);
}

template<class units>
IntRectTyped<units> RoundedOut(const RectTyped<units>& aRect)
{
  return IntRectTyped<units>::RoundOut(aRect);
}

template<class units>
IntRectTyped<units> TruncatedToInt(const RectTyped<units>& aRect) {
  return IntRectTyped<units>::Truncate(aRect);
}

template<class units>
RectTyped<units> IntRectToRect(const IntRectTyped<units>& aRect)
{
  return RectTyped<units>(aRect.x, aRect.y, aRect.width, aRect.height);
}


template <typename T>
Maybe<T>
IntersectMaybeRects(const Maybe<T>& a, const Maybe<T>& b)
{
  if (!a) {
    return b;
  } else if (!b) {
    return a;
  } else {
    return Some(a->Intersect(*b));
  }
}

}
}

struct nsMargin : public mozilla::gfx::BaseMargin<nscoord, nsMargin> {
  typedef mozilla::gfx::BaseMargin<nscoord, nsMargin> Super;


  nsMargin() : Super() {}
  nsMargin(const nsMargin& aMargin) : Super(aMargin) {}
  nsMargin(nscoord aTop, nscoord aRight, nscoord aBottom, nscoord aLeft)
    : Super(aTop, aRight, aBottom, aLeft) {}
};

typedef mozilla::gfx::IntMargin nsIntMargin;

class nsSVGAngle;
class nsSVGIntegerPair;
class nsSVGLength2;
class nsSVGNumberPair;
class nsSVGViewBox;

namespace mozilla {
class SVGLengthList;
class SVGNumberList;
class SVGPathData;
class SVGPointList;
class SVGAnimatedPreserveAspectRatio;
class SVGStringList;
class SVGTransformList;
}

namespace mozilla {

class SVGAttrValueWrapper
{
public:
  static void ToString(const nsSVGAngle* aAngle, nsAString& aResult);
  static void ToString(const nsSVGIntegerPair* aIntegerPair,
                       nsAString& aResult);
  static void ToString(const nsSVGLength2* aLength, nsAString& aResult);
  static void ToString(const mozilla::SVGLengthList* aLengthList,
                       nsAString& aResult);
  static void ToString(const mozilla::SVGNumberList* aNumberList,
                       nsAString& aResult);
  static void ToString(const nsSVGNumberPair* aNumberPair, nsAString& aResult);
  static void ToString(const mozilla::SVGPathData* aPathData,
                       nsAString& aResult);
  static void ToString(const mozilla::SVGPointList* aPointList,
                       nsAString& aResult);
  static void ToString(
    const mozilla::SVGAnimatedPreserveAspectRatio* aPreserveAspectRatio,
    nsAString& aResult);
  static void ToString(const mozilla::SVGStringList* aStringList,
                       nsAString& aResult);
  static void ToString(const mozilla::SVGTransformList* aTransformList,
                       nsAString& aResult);
  static void ToString(const nsSVGViewBox* aViewBox, nsAString& aResult);
};

}



namespace JS { class Value; }
enum JSValueType
{
    JSVAL_TYPE_DOUBLE = 0x00,
    JSVAL_TYPE_INT32 = 0x01,
    JSVAL_TYPE_UNDEFINED = 0x02,
    JSVAL_TYPE_NULL = 0x03,
    JSVAL_TYPE_BOOLEAN = 0x04,
    JSVAL_TYPE_MAGIC = 0x05,
    JSVAL_TYPE_STRING = 0x06,
    JSVAL_TYPE_SYMBOL = 0x07,
    JSVAL_TYPE_PRIVATE_GCTHING = 0x08,
    JSVAL_TYPE_OBJECT = 0x0c,


    JSVAL_TYPE_UNKNOWN = 0x20,
    JSVAL_TYPE_MISSING = 0x21
} __attribute__((packed));

static_assert(sizeof(JSValueType) == 1,
              "compiler typed enum support is apparently buggy");
enum JSValueTag
{
    JSVAL_TAG_MAX_DOUBLE = 0x1FFF0,
    JSVAL_TAG_INT32 = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_INT32,
    JSVAL_TAG_UNDEFINED = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_UNDEFINED,
    JSVAL_TAG_NULL = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_NULL,
    JSVAL_TAG_BOOLEAN = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_BOOLEAN,
    JSVAL_TAG_MAGIC = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_MAGIC,
    JSVAL_TAG_STRING = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_STRING,
    JSVAL_TAG_SYMBOL = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_SYMBOL,
    JSVAL_TAG_PRIVATE_GCTHING = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_PRIVATE_GCTHING,
    JSVAL_TAG_OBJECT = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_OBJECT
} __attribute__((packed));

static_assert(sizeof(JSValueTag) == sizeof(uint32_t),
              "compiler typed enum support is apparently buggy");

enum JSValueShiftedTag
{
    JSVAL_SHIFTED_TAG_MAX_DOUBLE = ((((uint64_t)JSVAL_TAG_MAX_DOUBLE) << 47) | 0xFFFFFFFF),
    JSVAL_SHIFTED_TAG_INT32 = (((uint64_t)JSVAL_TAG_INT32) << 47),
    JSVAL_SHIFTED_TAG_UNDEFINED = (((uint64_t)JSVAL_TAG_UNDEFINED) << 47),
    JSVAL_SHIFTED_TAG_NULL = (((uint64_t)JSVAL_TAG_NULL) << 47),
    JSVAL_SHIFTED_TAG_BOOLEAN = (((uint64_t)JSVAL_TAG_BOOLEAN) << 47),
    JSVAL_SHIFTED_TAG_MAGIC = (((uint64_t)JSVAL_TAG_MAGIC) << 47),
    JSVAL_SHIFTED_TAG_STRING = (((uint64_t)JSVAL_TAG_STRING) << 47),
    JSVAL_SHIFTED_TAG_SYMBOL = (((uint64_t)JSVAL_TAG_SYMBOL) << 47),
    JSVAL_SHIFTED_TAG_PRIVATE_GCTHING = (((uint64_t)JSVAL_TAG_PRIVATE_GCTHING) << 47),
    JSVAL_SHIFTED_TAG_OBJECT = (((uint64_t)JSVAL_TAG_OBJECT) << 47)
} __attribute__((packed));

static_assert(sizeof(JSValueShiftedTag) == sizeof(uint64_t),
              "compiler typed enum support is apparently buggy");
typedef enum JSWhyMagic
{

    JS_ELEMENTS_HOLE,


    JS_NO_ITER_VALUE,


    JS_GENERATOR_CLOSING,


    JS_NO_CONSTANT,


    JS_THIS_POISON,


    JS_ARG_POISON,


    JS_SERIALIZE_NO_NODE,


    JS_LAZY_ARGUMENTS,


    JS_OPTIMIZED_ARGUMENTS,


    JS_IS_CONSTRUCTING,


    JS_BLOCK_NEEDS_CLONE,


    JS_HASH_KEY_EMPTY,


    JS_ION_ERROR,


    JS_ION_BAILOUT,


    JS_OPTIMIZED_OUT,


    JS_UNINITIALIZED_LEXICAL,


    JS_GENERIC_MAGIC,

    JS_WHY_MAGIC_COUNT
} JSWhyMagic;

namespace JS {

static inline constexpr JS::Value UndefinedValue();
static inline JS::Value PoisonedObjectValue(JSObject* obj);

namespace detail {

constexpr int CanonicalizedNaNSignBit = 0;
constexpr uint64_t CanonicalizedNaNSignificand = 0x8000000000000ULL;

constexpr uint64_t CanonicalizedNaNBits =
    mozilla::SpecificNaNBits<double,
                             detail::CanonicalizedNaNSignBit,
                             detail::CanonicalizedNaNSignificand>::value;

}







static __attribute__((always_inline)) inline double
GenericNaN()
{
  return mozilla::SpecificNaN<double>(detail::CanonicalizedNaNSignBit,
                                      detail::CanonicalizedNaNSignificand);
}





static inline double
CanonicalizeNaN(double d)
{
    if ((__builtin_expect(!!(mozilla::IsNaN(d)), 0)))
        return GenericNaN();
    return d;
}
class alignas(8) Value
{
  public:



    using PayloadType = uint64_t;






    Value() = default;
    Value(const Value& v) = default;





    template <typename T>
    static bool isNumberRepresentable(const T t) {
        return T(double(t)) == t;
    }



    void setNull() {
        data.asBits = bitsFromTagAndPayload(JSVAL_TAG_NULL, 0);
    }

    void setUndefined() {
        data.asBits = bitsFromTagAndPayload(JSVAL_TAG_UNDEFINED, 0);
    }

    void setInt32(int32_t i) {
        data.asBits = bitsFromTagAndPayload(JSVAL_TAG_INT32, uint32_t(i));
    }

    int32_t& getInt32Ref() {
        do { } while (0);
        return data.s.payload.i32;
    }

    void setDouble(double d) {


        data = layout(d);
        do { } while (0);
    }

    void setNaN() {
        setDouble(GenericNaN());
    }

    double& getDoubleRef() {
        do { } while (0);
        return data.asDouble;
    }

    void setString(JSString* str) {
        do { } while (0);
        data.asBits = bitsFromTagAndPayload(JSVAL_TAG_STRING, PayloadType(str));
    }

    void setSymbol(JS::Symbol* sym) {
        do { } while (0);
        data.asBits = bitsFromTagAndPayload(JSVAL_TAG_SYMBOL, PayloadType(sym));
    }

    void setObject(JSObject& obj) {
        do { } while (0);





        do { } while (0);

        setObjectNoCheck(&obj);
    }

  private:
    void setObjectNoCheck(JSObject* obj) {
        data.asBits = bitsFromTagAndPayload(JSVAL_TAG_OBJECT, PayloadType(obj));
    }

    friend inline Value PoisonedObjectValue(JSObject* obj);

  public:
    void setBoolean(bool b) {
        data.asBits = bitsFromTagAndPayload(JSVAL_TAG_BOOLEAN, uint32_t(b));
    }

    void setMagic(JSWhyMagic why) {
        data.asBits = bitsFromTagAndPayload(JSVAL_TAG_MAGIC, uint32_t(why));
    }

    void setMagicUint32(uint32_t payload) {
        data.asBits = bitsFromTagAndPayload(JSVAL_TAG_MAGIC, payload);
    }

    bool setNumber(uint32_t ui) {
        if (ui > ((int32_t)0x7fffffff)) {
            setDouble((double)ui);
            return false;
        } else {
            setInt32((int32_t)ui);
            return true;
        }
    }

    bool setNumber(double d) {
        int32_t i;
        if (mozilla::NumberIsInt32(d, &i)) {
            setInt32(i);
            return true;
        }

        setDouble(d);
        return false;
    }

    void setObjectOrNull(JSObject* arg) {
        if (arg)
            setObject(*arg);
        else
            setNull();
    }

    void swap(Value& rhs) {
        uint64_t tmp = rhs.data.asBits;
        rhs.data.asBits = data.asBits;
        data.asBits = tmp;
    }

  private:
    JSValueTag toTag() const {



        return JSValueTag(data.asBits >> 47);

    }

  public:
    const void* bitsAsPunboxPointer() const {
        return reinterpret_cast<void*>(data.asBits);
    }
    bool isUndefined() const {



        return data.asBits == JSVAL_SHIFTED_TAG_UNDEFINED;

    }

    bool isNull() const {



        return data.asBits == JSVAL_SHIFTED_TAG_NULL;

    }

    bool isNullOrUndefined() const {
        return isNull() || isUndefined();
    }

    bool isInt32() const {
        return toTag() == JSVAL_TAG_INT32;
    }

    bool isInt32(int32_t i32) const {
        return data.asBits == bitsFromTagAndPayload(JSVAL_TAG_INT32, uint32_t(i32));
    }

    bool isDouble() const {



        return (data.asBits | mozilla::DoubleTypeTraits::kSignBit) <= JSVAL_SHIFTED_TAG_MAX_DOUBLE;

    }

    bool isNumber() const {




        return data.asBits < JSVAL_SHIFTED_TAG_UNDEFINED;

    }

    bool isString() const {
        return toTag() == JSVAL_TAG_STRING;
    }

    bool isSymbol() const {
        return toTag() == JSVAL_TAG_SYMBOL;
    }

    bool isObject() const {



        do { } while (0);
        return data.asBits >= JSVAL_SHIFTED_TAG_OBJECT;

    }

    bool isPrimitive() const {



        return data.asBits < JSVAL_SHIFTED_TAG_OBJECT;

    }

    bool isObjectOrNull() const {
        return isObject() || isNull();
    }

    bool isGCThing() const {




        return data.asBits >= JSVAL_SHIFTED_TAG_STRING;

    }

    bool isBoolean() const {
        return toTag() == JSVAL_TAG_BOOLEAN;
    }

    bool isTrue() const {
        return data.asBits == bitsFromTagAndPayload(JSVAL_TAG_BOOLEAN, uint32_t(true));
    }

    bool isFalse() const {
        return data.asBits == bitsFromTagAndPayload(JSVAL_TAG_BOOLEAN, uint32_t(false));
    }

    bool isMagic() const {
        return toTag() == JSVAL_TAG_MAGIC;
    }

    bool isMagic(JSWhyMagic why) const {
        do { } while (0);
        return isMagic();
    }

    JS::TraceKind traceKind() const {
        do { } while (0);
        static_assert((JSVAL_TAG_STRING & 0x03) == size_t(JS::TraceKind::String),
                      "Value type tags must correspond with JS::TraceKinds.");
        static_assert((JSVAL_TAG_SYMBOL & 0x03) == size_t(JS::TraceKind::Symbol),
                      "Value type tags must correspond with JS::TraceKinds.");
        static_assert((JSVAL_TAG_OBJECT & 0x03) == size_t(JS::TraceKind::Object),
                      "Value type tags must correspond with JS::TraceKinds.");
        if ((__builtin_expect(!!(isPrivateGCThing()), 0)))
            return JS::GCThingTraceKind(toGCThing());
        return JS::TraceKind(toTag() & 0x03);
    }

    JSWhyMagic whyMagic() const {
        do { } while (0);
        return data.s.payload.why;
    }

    uint32_t magicUint32() const {
        do { } while (0);
        return data.s.payload.u32;
    }



    bool operator==(const Value& rhs) const {
        return data.asBits == rhs.data.asBits;
    }

    bool operator!=(const Value& rhs) const {
        return data.asBits != rhs.data.asBits;
    }

    friend inline bool SameType(const Value& lhs, const Value& rhs);



    int32_t toInt32() const {
        do { } while (0);



        return int32_t(data.asBits);

    }

    double toDouble() const {
        do { } while (0);
        return data.asDouble;
    }

    double toNumber() const {
        do { } while (0);
        return isDouble() ? toDouble() : double(toInt32());
    }

    JSString* toString() const {
        do { } while (0);



        return reinterpret_cast<JSString*>(data.asBits & 0x00007FFFFFFFFFFFLL);

    }

    JS::Symbol* toSymbol() const {
        do { } while (0);



        return reinterpret_cast<JS::Symbol*>(data.asBits & 0x00007FFFFFFFFFFFLL);

    }

    JSObject& toObject() const {
        do { } while (0);



        return *toObjectOrNull();

    }

    JSObject* toObjectOrNull() const {
        do { } while (0);



        uint64_t ptrBits = data.asBits & 0x00007FFFFFFFFFFFLL;
        do { } while (0);
        return reinterpret_cast<JSObject*>(ptrBits);

    }

    js::gc::Cell* toGCThing() const {
        do { } while (0);



        uint64_t ptrBits = data.asBits & 0x00007FFFFFFFFFFFLL;
        do { } while (0);
        return reinterpret_cast<js::gc::Cell*>(ptrBits);

    }

    GCCellPtr toGCCellPtr() const {
        return GCCellPtr(toGCThing(), traceKind());
    }

    bool toBoolean() const {
        do { } while (0);



        return bool(data.asBits & 0x00007FFFFFFFFFFFLL);

    }

    uint32_t payloadAsRawUint32() const {
        do { } while (0);
        return data.s.payload.u32;
    }

    uint64_t asRawBits() const {
        return data.asBits;
    }

    JSValueType extractNonDoubleType() const {
        uint32_t type = toTag() & 0xF;
        do { } while (0);
        return JSValueType(type);
    }
    void setPrivate(void* ptr) {
        do { } while (0);




        data.asBits = uintptr_t(ptr) >> 1;

        do { } while (0);
    }

    void* toPrivate() const {
        do { } while (0);



        do { } while (0);
        return reinterpret_cast<void*>(data.asBits << 1);

    }

    void setPrivateUint32(uint32_t ui) {
        do { } while (0);
        setInt32(int32_t(ui));
    }

    uint32_t toPrivateUint32() const {
        return uint32_t(toInt32());
    }
    void setPrivateGCThing(js::gc::Cell* cell) {
        do { } while (0);

        do { } while (0);

        do { } while (0);


        do { } while (0);





        do { } while (0);

        data.asBits = bitsFromTagAndPayload(JSVAL_TAG_PRIVATE_GCTHING, PayloadType(cell));
    }

    bool isPrivateGCThing() const {
        return toTag() == JSVAL_TAG_PRIVATE_GCTHING;
    }

    const size_t* payloadWord() const {



        return &data.asWord;

    }

    const uintptr_t* payloadUIntPtr() const {



        return &data.asUIntPtr;

    }





  private:
    union layout {
        uint64_t asBits;


        struct {
            uint64_t payload47 : 47;
            JSValueTag tag : 17;
        } debugView;

        struct {
            union {
                int32_t i32;
                uint32_t u32;
                JSWhyMagic why;
            } payload;
        } s;
        double asDouble;
        void* asPtr;
        size_t asWord;
        uintptr_t asUIntPtr;

        layout() = default;
        explicit constexpr layout(uint64_t bits) : asBits(bits) {}
        explicit constexpr layout(double d) : asDouble(d) {}
    } data;
  private:
    explicit constexpr Value(uint64_t asBits) : data(asBits) {}
    explicit constexpr Value(double d) : data(d) {}

    void staticAssertions() {
        static_assert(sizeof(JSValueType) == 1, "JS_STATIC_ASSERT");
        static_assert(sizeof(JSValueTag) == 4, "JS_STATIC_ASSERT");
        static_assert(sizeof(JSWhyMagic) <= 4, "JS_STATIC_ASSERT");
        static_assert(sizeof(Value) == 8, "JS_STATIC_ASSERT");
    }

    friend constexpr Value JS::UndefinedValue();

  public:
    static constexpr uint64_t
    bitsFromTagAndPayload(JSValueTag tag, PayloadType payload)
    {



        return (uint64_t(uint32_t(tag)) << 47) | payload;

    }

    static constexpr Value
    fromTagAndPayload(JSValueTag tag, PayloadType payload)
    {
        return fromRawBits(bitsFromTagAndPayload(tag, payload));
    }

    static constexpr Value
    fromRawBits(uint64_t asBits) {
        return Value(asBits);
    }

    static constexpr Value
    fromInt32(int32_t i) {
        return fromTagAndPayload(JSVAL_TAG_INT32, uint32_t(i));
    }

    static constexpr Value
    fromDouble(double d) {
        return Value(d);
    }
} ;

static_assert(sizeof(Value) == 8, "Value size must leave three tag bits, be a binary power, and is ubiquitously depended upon everywhere");

inline bool
IsOptimizedPlaceholderMagicValue(const Value& v)
{
    if (v.isMagic()) {
        do { } while (0);
        return true;
    }
    return false;
}

static __attribute__((always_inline)) inline void
ExposeValueToActiveJS(const Value& v)
{
    if (v.isGCThing())
        js::gc::ExposeGCThingToActiveJS(GCCellPtr(v));
}



static inline Value
NullValue()
{
    Value v;
    v.setNull();
    return v;
}

static inline constexpr Value
UndefinedValue()
{
    return Value::fromTagAndPayload(JSVAL_TAG_UNDEFINED, 0);
}

static inline constexpr Value
Int32Value(int32_t i32)
{
    return Value::fromInt32(i32);
}

static inline Value
DoubleValue(double dbl)
{
    Value v;
    v.setDouble(dbl);
    return v;
}

static inline Value
CanonicalizedDoubleValue(double d)
{
    return (__builtin_expect(!!(mozilla::IsNaN(d)), 0))
           ? Value::fromRawBits(detail::CanonicalizedNaNBits)
           : Value::fromDouble(d);
}

static inline bool
IsCanonicalized(double d)
{
  if (mozilla::IsInfinite(d) || mozilla::IsFinite(d))
      return true;

  uint64_t bits;
  mozilla::BitwiseCast<uint64_t>(d, &bits);
  return (bits & ~mozilla::DoubleTypeTraits::kSignBit) == detail::CanonicalizedNaNBits;
}

static inline Value
DoubleNaNValue()
{
    Value v;
    v.setNaN();
    return v;
}

static inline Value
Float32Value(float f)
{
    Value v;
    v.setDouble(f);
    return v;
}

static inline Value
StringValue(JSString* str)
{
    Value v;
    v.setString(str);
    return v;
}

static inline Value
SymbolValue(JS::Symbol* sym)
{
    Value v;
    v.setSymbol(sym);
    return v;
}

static inline Value
BooleanValue(bool boo)
{
    Value v;
    v.setBoolean(boo);
    return v;
}

static inline Value
TrueValue()
{
    Value v;
    v.setBoolean(true);
    return v;
}

static inline Value
FalseValue()
{
    Value v;
    v.setBoolean(false);
    return v;
}

static inline Value
ObjectValue(JSObject& obj)
{
    Value v;
    v.setObject(obj);
    return v;
}

static inline Value
ObjectValueCrashOnTouch()
{
    Value v;
    v.setObject(*reinterpret_cast<JSObject*>(0x48));
    return v;
}

static inline Value
MagicValue(JSWhyMagic why)
{
    Value v;
    v.setMagic(why);
    return v;
}

static inline Value
MagicValueUint32(uint32_t payload)
{
    Value v;
    v.setMagicUint32(payload);
    return v;
}

static inline Value
NumberValue(float f)
{
    Value v;
    v.setNumber(f);
    return v;
}

static inline Value
NumberValue(double dbl)
{
    Value v;
    v.setNumber(dbl);
    return v;
}

static inline Value
NumberValue(int8_t i)
{
    return Int32Value(i);
}

static inline Value
NumberValue(uint8_t i)
{
    return Int32Value(i);
}

static inline Value
NumberValue(int16_t i)
{
    return Int32Value(i);
}

static inline Value
NumberValue(uint16_t i)
{
    return Int32Value(i);
}

static inline Value
NumberValue(int32_t i)
{
    return Int32Value(i);
}

static inline constexpr Value
NumberValue(uint32_t i)
{
    return i <= ((int32_t)0x7fffffff)
           ? Int32Value(int32_t(i))
           : Value::fromDouble(double(i));
}

namespace detail {

template <bool Signed>
class MakeNumberValue
{
  public:
    template<typename T>
    static inline Value create(const T t)
    {
        Value v;
        if (((int32_t)0x80000000) <= t && t <= ((int32_t)0x7fffffff))
            v.setInt32(int32_t(t));
        else
            v.setDouble(double(t));
        return v;
    }
};

template <>
class MakeNumberValue<false>
{
  public:
    template<typename T>
    static inline Value create(const T t)
    {
        Value v;
        if (t <= ((int32_t)0x7fffffff))
            v.setInt32(int32_t(t));
        else
            v.setDouble(double(t));
        return v;
    }
};

}

template <typename T>
static inline Value
NumberValue(const T t)
{
    do { } while (0);
    return detail::MakeNumberValue<std::numeric_limits<T>::is_signed>::create(t);
}

static inline Value
ObjectOrNullValue(JSObject* obj)
{
    Value v;
    v.setObjectOrNull(obj);
    return v;
}

static inline Value
PrivateValue(void* ptr)
{
    Value v;
    v.setPrivate(ptr);
    return v;
}

static inline Value
PrivateUint32Value(uint32_t ui)
{
    Value v;
    v.setPrivateUint32(ui);
    return v;
}

static inline Value
PrivateGCThingValue(js::gc::Cell* cell)
{
    Value v;
    v.setPrivateGCThing(cell);
    return v;
}

static inline Value
PoisonedObjectValue(JSObject* obj)
{
    Value v;
    v.setObjectNoCheck(obj);
    return v;
}

inline bool
SameType(const Value& lhs, const Value& rhs)
{




    return (lhs.isDouble() && rhs.isDouble()) ||
           (((lhs.data.asBits ^ rhs.data.asBits) & 0xFFFF800000000000ULL) == 0);

}

}



namespace JS {
void HeapValuePostBarrier(Value* valuep, const Value& prev, const Value& next);

template <>
struct GCPolicy<JS::Value>
{
    static Value initial() { return UndefinedValue(); }
    static void trace(JSTracer* trc, Value* v, const char* name) {
        js::UnsafeTraceManuallyBarrieredEdge(trc, v, name);
    }
    static bool isTenured(const Value& thing) {
        return !thing.isGCThing() || !IsInsideNursery(thing.toGCThing());
    }
};

}

namespace js {

template <>
struct BarrierMethods<JS::Value>
{
    static gc::Cell* asGCThingOrNull(const JS::Value& v) {
        return v.isGCThing() ? v.toGCThing() : nullptr;
    }
    static void postBarrier(JS::Value* v, const JS::Value& prev, const JS::Value& next) {
        JS::HeapValuePostBarrier(v, prev, next);
    }
    static void exposeToJS(const JS::Value& v) {
        JS::ExposeValueToActiveJS(v);
    }
};

template <class Wrapper> class MutableValueOperations;







template <class Wrapper>
class WrappedPtrOperations<JS::Value, Wrapper>
{
    const JS::Value& value() const { return static_cast<const Wrapper*>(this)->get(); }

  public:
    bool isUndefined() const { return value().isUndefined(); }
    bool isNull() const { return value().isNull(); }
    bool isBoolean() const { return value().isBoolean(); }
    bool isTrue() const { return value().isTrue(); }
    bool isFalse() const { return value().isFalse(); }
    bool isNumber() const { return value().isNumber(); }
    bool isInt32() const { return value().isInt32(); }
    bool isInt32(int32_t i32) const { return value().isInt32(i32); }
    bool isDouble() const { return value().isDouble(); }
    bool isString() const { return value().isString(); }
    bool isSymbol() const { return value().isSymbol(); }
    bool isObject() const { return value().isObject(); }
    bool isMagic() const { return value().isMagic(); }
    bool isMagic(JSWhyMagic why) const { return value().isMagic(why); }
    bool isGCThing() const { return value().isGCThing(); }
    bool isPrimitive() const { return value().isPrimitive(); }

    bool isNullOrUndefined() const { return value().isNullOrUndefined(); }
    bool isObjectOrNull() const { return value().isObjectOrNull(); }

    bool toBoolean() const { return value().toBoolean(); }
    double toNumber() const { return value().toNumber(); }
    int32_t toInt32() const { return value().toInt32(); }
    double toDouble() const { return value().toDouble(); }
    JSString* toString() const { return value().toString(); }
    JS::Symbol* toSymbol() const { return value().toSymbol(); }
    JSObject& toObject() const { return value().toObject(); }
    JSObject* toObjectOrNull() const { return value().toObjectOrNull(); }
    gc::Cell* toGCThing() const { return value().toGCThing(); }
    JS::TraceKind traceKind() const { return value().traceKind(); }
    void* toPrivate() const { return value().toPrivate(); }
    uint32_t toPrivateUint32() const { return value().toPrivateUint32(); }

    uint64_t asRawBits() const { return value().asRawBits(); }
    JSValueType extractNonDoubleType() const { return value().extractNonDoubleType(); }

    JSWhyMagic whyMagic() const { return value().whyMagic(); }
    uint32_t magicUint32() const { return value().magicUint32(); }
};







template <class Wrapper>
class MutableWrappedPtrOperations<JS::Value, Wrapper> : public WrappedPtrOperations<JS::Value, Wrapper>
{
    JS::Value& value() { return static_cast<Wrapper*>(this)->get(); }

  public:
    void setNull() { value().setNull(); }
    void setUndefined() { value().setUndefined(); }
    void setInt32(int32_t i) { value().setInt32(i); }
    void setDouble(double d) { value().setDouble(d); }
    void setNaN() { setDouble(JS::GenericNaN()); }
    void setBoolean(bool b) { value().setBoolean(b); }
    void setMagic(JSWhyMagic why) { value().setMagic(why); }
    bool setNumber(uint32_t ui) { return value().setNumber(ui); }
    bool setNumber(double d) { return value().setNumber(d); }
    void setString(JSString* str) { this->value().setString(str); }
    void setSymbol(JS::Symbol* sym) { this->value().setSymbol(sym); }
    void setObject(JSObject& obj) { this->value().setObject(obj); }
    void setObjectOrNull(JSObject* arg) { this->value().setObjectOrNull(arg); }
    void setPrivate(void* ptr) { this->value().setPrivate(ptr); }
    void setPrivateUint32(uint32_t ui) { this->value().setPrivateUint32(ui); }
    void setPrivateGCThing(js::gc::Cell* cell) { this->value().setPrivateGCThing(cell); }
};





template <typename Wrapper>
class HeapBase<JS::Value, Wrapper> : public WrappedPtrOperations<JS::Value, Wrapper>
{
    void setBarriered(const JS::Value& v) {
        *static_cast<JS::Heap<JS::Value>*>(this) = v;
    }

  public:
    void setNull() { setBarriered(JS::NullValue()); }
    void setUndefined() { setBarriered(JS::UndefinedValue()); }
    void setInt32(int32_t i) { setBarriered(JS::Int32Value(i)); }
    void setDouble(double d) { setBarriered(JS::DoubleValue(d)); }
    void setNaN() { setDouble(JS::GenericNaN()); }
    void setBoolean(bool b) { setBarriered(JS::BooleanValue(b)); }
    void setMagic(JSWhyMagic why) { setBarriered(JS::MagicValue(why)); }
    void setString(JSString* str) { setBarriered(JS::StringValue(str)); }
    void setSymbol(JS::Symbol* sym) { setBarriered(JS::SymbolValue(sym)); }
    void setObject(JSObject& obj) { setBarriered(JS::ObjectValue(obj)); }
    void setPrivateGCThing(js::gc::Cell* cell) { setBarriered(JS::PrivateGCThingValue(cell)); }

    bool setNumber(uint32_t ui) {
        if (ui > ((int32_t)0x7fffffff)) {
            setDouble((double)ui);
            return false;
        } else {
            setInt32((int32_t)ui);
            return true;
        }
    }

    bool setNumber(double d) {
        int32_t i;
        if (mozilla::NumberIsInt32(d, &i)) {
            setInt32(i);
            return true;
        }

        setDouble(d);
        return false;
    }

    void setObjectOrNull(JSObject* arg) {
        if (arg)
            setObject(*arg);
        else
            setNull();
    }
};





template <typename F, typename... Args>
auto
DispatchTyped(F f, const JS::Value& val, Args&&... args)
  -> decltype(f(static_cast<JSObject*>(nullptr), mozilla::Forward<Args>(args)...))
{
    if (val.isString())
        return f(val.toString(), mozilla::Forward<Args>(args)...);
    if (val.isObject())
        return f(&val.toObject(), mozilla::Forward<Args>(args)...);
    if (val.isSymbol())
        return f(val.toSymbol(), mozilla::Forward<Args>(args)...);
    if ((__builtin_expect(!!(val.isPrivateGCThing()), 0)))
        return DispatchTyped(f, val.toGCCellPtr(), mozilla::Forward<Args>(args)...);
    do { } while (0);
    return F::defaultValue(val);
}

template <class S> struct VoidDefaultAdaptor { static void defaultValue(const S&) {} };
template <class S> struct IdentityDefaultAdaptor { static S defaultValue(const S& v) {return v;} };
template <class S, bool v> struct BoolDefaultAdaptor { static bool defaultValue(const S&) { return v; } };

}
namespace JS {

extern const HandleValue NullHandleValue;
extern const HandleValue UndefinedHandleValue;
extern const HandleValue TrueHandleValue;
extern const HandleValue FalseHandleValue;

}


template <class T>
class nsAutoPtr
{
private:
  static_assert(!mozilla::IsScalar<T>::value, "If you are using "
                "nsAutoPtr to hold an array, use UniquePtr<T[]> instead");

  void**
  begin_assignment()
  {
    assign(0);
    return reinterpret_cast<void**>(&mRawPtr);
  }

  void
  assign(T* aNewPtr)
  {
    T* oldPtr = mRawPtr;

    if (aNewPtr && aNewPtr == oldPtr) {
      do { AnnotateMozCrashReason("MOZ_CRASH(" "Logic flaw in the caller" ")"); do { *((volatile int*) __null) = 41; ::abort(); } while (0); } while (0);
    }

    mRawPtr = aNewPtr;
    delete oldPtr;
  }






  class Ptr
  {
  public:
                 Ptr(T* aPtr)
      : mPtr(aPtr)
    {
    }

    operator T*() const
    {
      return mPtr;
    }

  private:
    T* mPtr;
  };

private:
  T* mRawPtr;

public:
  typedef T element_type;

  ~nsAutoPtr()
  {
    delete mRawPtr;
  }



  nsAutoPtr()
    : mRawPtr(0)

  {
  }

               nsAutoPtr(Ptr aRawPtr)
    : mRawPtr(aRawPtr)

  {
  }



  nsAutoPtr(nsAutoPtr<T>& aSmartPtr)
    : mRawPtr(aSmartPtr.forget())

  {
  }

  template <typename I>
               nsAutoPtr(nsAutoPtr<I>& aSmartPtr)
    : mRawPtr(aSmartPtr.forget())

  {
  }

  nsAutoPtr(nsAutoPtr<T>&& aSmartPtr)
    : mRawPtr(aSmartPtr.forget())

  {
  }

  template <typename I>
               nsAutoPtr(nsAutoPtr<I>&& aSmartPtr)
    : mRawPtr(aSmartPtr.forget())

  {
  }



  nsAutoPtr<T>&
  operator=(T* aRhs)

  {
    assign(aRhs);
    return *this;
  }

  nsAutoPtr<T>& operator=(nsAutoPtr<T>& aRhs)

  {
    assign(aRhs.forget());
    return *this;
  }

  template <typename I>
  nsAutoPtr<T>& operator=(nsAutoPtr<I>& aRhs)

  {
    assign(aRhs.forget());
    return *this;
  }

  nsAutoPtr<T>& operator=(nsAutoPtr<T>&& aRhs)
  {
    assign(aRhs.forget());
    return *this;
  }

  template <typename I>
  nsAutoPtr<T>& operator=(nsAutoPtr<I>&& aRhs)
  {
    assign(aRhs.forget());
    return *this;
  }



  T*
  get() const





  {
    return mRawPtr;
  }

  operator T*() const
  {
    return get();
  }

  T*
  forget()
  {
    T* temp = mRawPtr;
    mRawPtr = 0;
    return temp;
  }

  T*
  operator->() const
  {
    do { } while(0);

    return get();
  }

  template <typename R, typename... Args>
  class Proxy
  {
    typedef R (T::*member_function)(Args...);
    T* mRawPtr;
    member_function mFunction;
  public:
    Proxy(T* aRawPtr, member_function aFunction)
      : mRawPtr(aRawPtr),
        mFunction(aFunction)
    {
    }
    template<typename... ActualArgs>
    R operator()(ActualArgs&&... aArgs)
    {
      return ((*mRawPtr).*mFunction)(mozilla::Forward<ActualArgs>(aArgs)...);
    }
  };

  template <typename R, typename C, typename... Args>
  Proxy<R, Args...> operator->*(R (C::*aFptr)(Args...)) const
  {
    do { } while(0);

    return Proxy<R, Args...>(get(), aFptr);
  }

  nsAutoPtr<T>*
  get_address()


  {
    return this;
  }

  const nsAutoPtr<T>*
  get_address() const


  {
    return this;
  }

public:
  T&
  operator*() const
  {
    do { } while(0);

    return *get();
  }

  T**
  StartAssignment()
  {

    return reinterpret_cast<T**>(begin_assignment());




  }
};

template <class T>
inline nsAutoPtr<T>*
address_of(nsAutoPtr<T>& aPtr)
{
  return aPtr.get_address();
}

template <class T>
inline const nsAutoPtr<T>*
address_of(const nsAutoPtr<T>& aPtr)
{
  return aPtr.get_address();
}

template <class T>
class nsAutoPtrGetterTransfers
{
public:
  explicit
  nsAutoPtrGetterTransfers(nsAutoPtr<T>& aSmartPtr)
    : mTargetSmartPtr(aSmartPtr)
  {

  }

  operator void**()
  {
    return reinterpret_cast<void**>(mTargetSmartPtr.StartAssignment());
  }

  operator T**()
  {
    return mTargetSmartPtr.StartAssignment();
  }

  T*&
  operator*()
  {
    return *(mTargetSmartPtr.StartAssignment());
  }

private:
  nsAutoPtr<T>& mTargetSmartPtr;
};

template <class T>
inline nsAutoPtrGetterTransfers<T>
getter_Transfers(nsAutoPtr<T>& aSmartPtr)




{
  return nsAutoPtrGetterTransfers<T>(aSmartPtr);
}





template <class T, class U>
inline bool
operator==(const nsAutoPtr<T>& aLhs, const nsAutoPtr<U>& aRhs)
{
  return static_cast<const T*>(aLhs.get()) == static_cast<const U*>(aRhs.get());
}


template <class T, class U>
inline bool
operator!=(const nsAutoPtr<T>& aLhs, const nsAutoPtr<U>& aRhs)
{
  return static_cast<const T*>(aLhs.get()) != static_cast<const U*>(aRhs.get());
}




template <class T, class U>
inline bool
operator==(const nsAutoPtr<T>& aLhs, const U* aRhs)
{
  return static_cast<const T*>(aLhs.get()) == static_cast<const U*>(aRhs);
}

template <class T, class U>
inline bool
operator==(const U* aLhs, const nsAutoPtr<T>& aRhs)
{
  return static_cast<const U*>(aLhs) == static_cast<const T*>(aRhs.get());
}

template <class T, class U>
inline bool
operator!=(const nsAutoPtr<T>& aLhs, const U* aRhs)
{
  return static_cast<const T*>(aLhs.get()) != static_cast<const U*>(aRhs);
}

template <class T, class U>
inline bool
operator!=(const U* aLhs, const nsAutoPtr<T>& aRhs)
{
  return static_cast<const U*>(aLhs) != static_cast<const T*>(aRhs.get());
}

template <class T, class U>
inline bool
operator==(const nsAutoPtr<T>& aLhs, U* aRhs)
{
  return static_cast<const T*>(aLhs.get()) == const_cast<const U*>(aRhs);
}

template <class T, class U>
inline bool
operator==(U* aLhs, const nsAutoPtr<T>& aRhs)
{
  return const_cast<const U*>(aLhs) == static_cast<const T*>(aRhs.get());
}

template <class T, class U>
inline bool
operator!=(const nsAutoPtr<T>& aLhs, U* aRhs)
{
  return static_cast<const T*>(aLhs.get()) != const_cast<const U*>(aRhs);
}

template <class T, class U>
inline bool
operator!=(U* aLhs, const nsAutoPtr<T>& aRhs)
{
  return const_cast<const U*>(aLhs) != static_cast<const T*>(aRhs.get());
}





template <class T>
inline bool
operator==(const nsAutoPtr<T>& aLhs, decltype(nullptr))
{
  return aLhs.get() == nullptr;
}

template <class T>
inline bool
operator==(decltype(nullptr), const nsAutoPtr<T>& aRhs)
{
  return nullptr == aRhs.get();
}

template <class T>
inline bool
operator!=(const nsAutoPtr<T>& aLhs, decltype(nullptr))
{
  return aLhs.get() != nullptr;
}

template <class T>
inline bool
operator!=(decltype(nullptr), const nsAutoPtr<T>& aRhs)
{
  return nullptr != aRhs.get();
}


namespace mozilla {

template<class T>
class OwningNonNull
{
public:
  OwningNonNull() {}

               OwningNonNull(T& aValue)
  {
    init(&aValue);
  }

  template<class U>
               OwningNonNull(already_AddRefed<U>&& aValue)
  {
    init(aValue);
  }

  template<class U>
               OwningNonNull(const OwningNonNull<U>& aValue)
  {
    init(aValue);
  }


  operator T&() const
  {
    do { } while (0);
    do { } while (0);
    return *mPtr;
  }

  operator T*() const
  {
    do { } while (0);
    do { } while (0);
    return mPtr;
  }


  explicit operator bool() const = delete;

  T*
  operator->() const
  {
    do { } while (0);
    do { } while (0);
    return mPtr;
  }

  OwningNonNull<T>&
  operator=(T* aValue)
  {
    init(aValue);
    return *this;
  }

  OwningNonNull<T>&
  operator=(T& aValue)
  {
    init(&aValue);
    return *this;
  }

  template<class U>
  OwningNonNull<T>&
  operator=(already_AddRefed<U>&& aValue)
  {
    init(aValue);
    return *this;
  }

  template<class U>
  OwningNonNull<T>&
  operator=(const OwningNonNull<U>& aValue)
  {
    init(aValue);
    return *this;
  }


  void operator=(decltype(nullptr)) = delete;

  already_AddRefed<T> forget()
  {



    return mPtr.forget();
  }

  template<class U>
  void
  forget(U** aOther)
  {



    mPtr.forget(aOther);
  }


  T* get() const
  {
    do { } while (0);
    do { } while (0);
    return mPtr;
  }

  template<typename U>
  void swap(U& aOther)
  {
    mPtr.swap(aOther);



  }




  bool isInitialized() const
  {
    do { } while (0);
    return mPtr;
  }

protected:
  template<typename U>
  void init(U&& aValue)
  {
    mPtr = aValue;
    do { } while (0);



  }

  RefPtr<T> mPtr;



};

template <typename T>
inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            OwningNonNull<T>& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  CycleCollectionNoteChild(aCallback, aField.get(), aName, aFlags);
}

}


template<class T> template<class U>
nsCOMPtr<T>::nsCOMPtr(const mozilla::OwningNonNull<U>& aOther)
  : nsCOMPtr(aOther.get())
{}

template<class T> template<class U>
nsCOMPtr<T>&
nsCOMPtr<T>::operator=(const mozilla::OwningNonNull<U>& aOther)
{
  return operator=(aOther.get());
}


template<class T> template<class U>
RefPtr<T>::RefPtr(const mozilla::OwningNonNull<U>& aOther)
  : RefPtr(aOther.get())
{}

template<class T> template<class U>
RefPtr<T>&
RefPtr<T>::operator=(const mozilla::OwningNonNull<U>& aOther)
{
  return operator=(aOther.get());
}



namespace JS {
template<typename T>
struct GCPolicy<mozilla::OwningNonNull<T>>
{
  typedef mozilla::OwningNonNull<T> SmartPtrType;

  static SmartPtrType initial()
  {
    return SmartPtrType();
  }

  static void trace(JSTracer* trc, SmartPtrType* tp,
                    const char* name)
  {
    if ((*tp).isInitialized()) {
      (*tp)->Trace(trc);
    }
  }
};
}

namespace js {
template<typename T, typename Wrapper>
struct WrappedPtrOperations<mozilla::OwningNonNull<T>, Wrapper>
{
  operator T& () const
  {
    return static_cast<const Wrapper*>(this)->get();
  }
};
}
namespace JS {
template<typename T>
struct GCPolicy<RefPtr<T>>
{
  static RefPtr<T> initial() {
    return RefPtr<T>();
  }

  static void trace(JSTracer* trc, RefPtr<T>* tp, const char* name)
  {
    if (*tp) {
      (*tp)->Trace(trc);
    }
  }
};
}

namespace js {
template<typename T, typename Wrapper>
struct WrappedPtrOperations<RefPtr<T>, Wrapper>
{
  operator T*() const
  {
    return static_cast<const Wrapper*>(this)->get();
  }
};
}

namespace mozilla {
namespace dom {
class DOMString {
public:
  DOMString()
    : mStringBuffer(nullptr)
    , mLength(0)
    , mIsNull(false)
    , mStringBufferOwned(false)
  {}
  ~DOMString()
  {
    do { } while (0);

    if (mStringBufferOwned) {
      do { } while (0);
      mStringBuffer->Release();
    }
  }

  operator nsString&()
  {
    return AsAString();
  }



  operator const nsString&() = delete;
  operator const nsAString&() = delete;

  nsString& AsAString()
  {
    do { } while (0);
    do { } while (0);
    if (!mString) {
      mString.emplace();
    }
    return *mString;
  }

  bool HasStringBuffer() const
  {
    do { } while (0);

    do { } while (0);
    return !mString;
  }






  nsStringBuffer* StringBuffer() const
  {
    do { } while (0);
    do { } while (0);

    do { } while (0);
    do { } while (0);

    return mStringBuffer;
  }



  uint32_t StringBufferLength() const
  {
    do { } while (0);
    return mLength;
  }



  void RelinquishBufferOwnership()
  {
    do { } while (0);
    if (mStringBufferOwned) {

      mStringBufferOwned = false;
    } else {

      mStringBuffer->AddRef();
    }
  }




  void SetStringBuffer(nsStringBuffer* aStringBuffer, uint32_t aLength)
  {
    do { } while (0);
    do { } while (0);
    do { } while (0);
    do { } while (0);
    mStringBuffer = aStringBuffer;
    mLength = aLength;
  }


  void SetEphemeralStringBuffer(nsStringBuffer* aStringBuffer, uint32_t aLength)
  {

    SetStringBuffer(aStringBuffer, aLength);
    aStringBuffer->AddRef();
    mStringBufferOwned = true;
  }

  void SetOwnedString(const nsAString& aString)
  {
    do { } while (0);
    do { } while (0);
    do { } while (0);
    nsStringBuffer* buf = nsStringBuffer::FromString(aString);
    if (buf) {
      SetStringBuffer(buf, aString.Length());
    } else if (aString.IsVoid()) {
      SetNull();
    } else if (!aString.IsEmpty()) {
      AsAString() = aString;
    }
  }

  enum NullHandling
  {
    eTreatNullAsNull,
    eTreatNullAsEmpty,
    eNullNotExpected
  };

  void SetOwnedAtom(nsIAtom* aAtom, NullHandling aNullHandling)
  {
    do { } while (0);
    do { } while (0);
    do { } while (0);
    do { } while (0);
    if (aNullHandling == eNullNotExpected || aAtom) {
      SetStringBuffer(aAtom->GetStringBuffer(), aAtom->GetLength());
    } else if (aNullHandling == eTreatNullAsNull) {
      SetNull();
    }
  }

  void SetNull()
  {
    do { } while (0);
    do { } while (0);
    mIsNull = true;
  }

  bool IsNull() const
  {
    do { } while (0);

    return mIsNull || (mString && mString->IsVoid());
  }

  void ToString(nsAString& aString)
  {
    if (IsNull()) {
      SetDOMStringToNull(aString);
    } else if (HasStringBuffer()) {
      if (StringBufferLength() == 0) {
        aString.Truncate();
      } else {


        nsStringBuffer* buf = StringBuffer();
        uint32_t len = StringBufferLength();
        auto chars = static_cast<char16_t*>(buf->Data());
        if (chars[len] == '\0') {

          buf->ToString(len, aString);
        } else {

          aString.Assign(chars, len);
        }
      }
    } else {
      aString = AsAString();
    }
  }

private:

  Maybe<nsAutoString> mString;



  nsStringBuffer* mStringBuffer;


  uint32_t mLength;
  bool mIsNull;
  bool mStringBufferOwned;
};

}
}





class nsIPrincipal;
class nsWrapperCache;

namespace mozilla {
namespace dom {



struct DictionaryBase
{
protected:
  bool ParseJSON(JSContext* aCx, const nsAString& aJSON,
                 JS::MutableHandle<JS::Value> aVal);

  bool StringifyToJSON(JSContext* aCx,
                       JS::Handle<JSObject*> aObj,
                       nsAString& aJSON) const;





  struct FastDictionaryInitializer {
  };

  bool mIsAnyMemberPresent = false;

private:


  static bool AppendJSONToString(const char16_t* aJSONData,
                                 uint32_t aDataLength, void* aString);

public:
  bool IsAnyMemberPresent() const
  {
    return mIsAnyMemberPresent;
  }
};




struct AllTypedArraysBase {
};




struct AllOwningUnionBase {
};


struct EnumEntry {
  const char* value;
  size_t length;
};

enum class CallerType : uint32_t;

class GlobalObject
{
public:
  GlobalObject(JSContext* aCx, JSObject* aObject);

  JSObject* Get() const
  {
    return mGlobalJSObject;
  }

  nsISupports* GetAsSupports() const;




  JSContext* Context() const
  {
    return mCx;
  }

  bool Failed() const
  {
    return !Get();
  }



  nsIPrincipal* GetSubjectPrincipal() const;



  dom::CallerType CallerType() const;

protected:
  JS::Rooted<JSObject*> mGlobalJSObject;
  JSContext* mCx;
  mutable nsISupports* mGlobalObject;



};


template<typename T, typename InternalType>
class Optional_base
{
public:
  Optional_base()
  {}

  explicit Optional_base(const T& aValue)
  {
    mImpl.emplace(aValue);
  }

  bool operator==(const Optional_base<T, InternalType>& aOther) const
  {
    return mImpl == aOther.mImpl;
  }

  template<typename T1, typename T2>
  explicit Optional_base(const T1& aValue1, const T2& aValue2)
  {
    mImpl.emplace(aValue1, aValue2);
  }

  bool WasPassed() const
  {
    return mImpl.isSome();
  }


  template<typename... Args>
  InternalType& Construct(Args&&... aArgs)
  {
    mImpl.emplace(Forward<Args>(aArgs)...);
    return *mImpl;
  }

  void Reset()
  {
    mImpl.reset();
  }

  const T& Value() const
  {
    return *mImpl;
  }


  InternalType& Value()
  {
    return *mImpl;
  }


  const InternalType& InternalValue() const
  {
    return *mImpl;
  }





private:

  Optional_base(const Optional_base& other) = delete;
  const Optional_base &operator=(const Optional_base &other) = delete;

protected:
  Maybe<InternalType> mImpl;
};

template<typename T>
class Optional : public Optional_base<T, T>
{
public:
  Optional() :
    Optional_base<T, T>()
  {}

  explicit Optional(const T& aValue) :
    Optional_base<T, T>(aValue)
  {}
};

template<typename T>
class Optional<JS::Handle<T> > :
  public Optional_base<JS::Handle<T>, JS::Rooted<T> >
{
public:
  Optional() :
    Optional_base<JS::Handle<T>, JS::Rooted<T> >()
  {}

  explicit Optional(JSContext* cx) :
    Optional_base<JS::Handle<T>, JS::Rooted<T> >()
  {
    this->Construct(cx);
  }

  Optional(JSContext* cx, const T& aValue) :
    Optional_base<JS::Handle<T>, JS::Rooted<T> >(cx, aValue)
  {}



  JS::Handle<T> Value() const
  {
    return *this->mImpl;
  }



  JS::Rooted<T>& Value()
  {
    return *this->mImpl;
  }
};




template<>
class Optional<JSObject*> : public Optional_base<JSObject*, JSObject*>
{
public:
  Optional() :
    Optional_base<JSObject*, JSObject*>()
  {}

  explicit Optional(JSObject* aValue) :
    Optional_base<JSObject*, JSObject*>(aValue)
  {}


  JSObject*& Construct()
  {


    return Optional_base<JSObject*, JSObject*>::Construct(
      static_cast<JSObject*>(nullptr));
  }

  template <class T1>
  JSObject*& Construct(const T1& t1)
  {
    return Optional_base<JSObject*, JSObject*>::Construct(t1);
  }
};


template<>
class Optional<JS::Value>
{
private:
  Optional() = delete;

  explicit Optional(const JS::Value& aValue) = delete;
};


template<typename U> class NonNull;
template<typename T>
class Optional<NonNull<T> > : public Optional_base<T, NonNull<T> >
{
public:



  T& Value() const
  {
    return *this->mImpl->get();
  }



  NonNull<T>& Value()
  {
    return *this->mImpl;
  }
};



template<typename T>
class Optional<OwningNonNull<T> > : public Optional_base<T, OwningNonNull<T> >
{
public:



  T& Value() const
  {
    return *this->mImpl->get();
  }



  OwningNonNull<T>& Value()
  {
    return *this->mImpl;
  }
};






namespace binding_detail {
struct FakeString;
}

template<>
class Optional<nsAString>
{
public:
  Optional() : mPassed(false) {}

  bool WasPassed() const
  {
    return mPassed;
  }

  void operator=(const nsAString* str)
  {
    do { } while (0);
    mStr = str;
    mPassed = true;
  }



  void operator=(const binding_detail::FakeString* str)
  {
    do { } while (0);
    mStr = reinterpret_cast<const nsString*>(str);
    mPassed = true;
  }

  const nsAString& Value() const
  {
    do { } while (0);
    return *mStr;
  }

private:

  Optional(const Optional& other) = delete;
  const Optional &operator=(const Optional &other) = delete;

  bool mPassed;
  const nsAString* mStr;
};

template<class T>
class NonNull
{
public:
  NonNull()



  {}


  operator T&() const {
    do { } while (0);
    do { } while (0);
    return *ptr;
  }

  operator T*() const {
    do { } while (0);
    do { } while (0);
    return ptr;
  }

  void operator=(T* t) {
    ptr = t;
    do { } while (0);



  }

  template<typename U>
  void operator=(U* t) {
    ptr = t->ToAStringPtr();
    do { } while (0);



  }

  T** Slot() {



    return &ptr;
  }

  T* Ptr() {
    do { } while (0);
    do { } while (0);
    return ptr;
  }


  T* get() const {
    do { } while (0);
    do { } while (0);
    return ptr;
  }

protected:
  T* ptr;



};





template<typename T>
class Sequence : public FallibleTArray<T>
{
public:
  Sequence() : FallibleTArray<T>()
  {}
};

inline nsWrapperCache*
GetWrapperCache(nsWrapperCache* cache)
{
  return cache;
}

inline nsWrapperCache*
GetWrapperCache(void* p)
{
  return nullptr;
}



template <template <typename> class SmartPtr, typename T>
inline nsWrapperCache*
GetWrapperCache(const SmartPtr<T>& aObject)
{
  return GetWrapperCache(aObject.get());
}

struct ParentObject {
  template<class T>
               ParentObject(T* aObject) :
    mObject(aObject),
    mWrapperCache(GetWrapperCache(aObject)),
    mUseXBLScope(false)
  {}

  template<class T, template<typename> class SmartPtr>
               ParentObject(const SmartPtr<T>& aObject) :
    mObject(aObject.get()),
    mWrapperCache(GetWrapperCache(aObject.get())),
    mUseXBLScope(false)
  {}

  ParentObject(nsISupports* aObject, nsWrapperCache* aCache) :
    mObject(aObject),
    mWrapperCache(aCache),
    mUseXBLScope(false)
  {}



  nsISupports* const mObject;
  nsWrapperCache* const mWrapperCache;
  bool mUseXBLScope;
};

namespace binding_detail {


template<typename T>
class AutoSequence : public AutoTArray<T, 16>
{
public:
  AutoSequence() : AutoTArray<T, 16>()
  {}


  operator const Sequence<T>&() const {
    return *reinterpret_cast<const Sequence<T>*>(this);
  }
};

}


enum class CallerType : uint32_t {
  System,
  NonSystem
};




class SystemCallerGuarantee {
public:
  operator CallerType() const { return CallerType::System; }
};

}
}
namespace mozilla {

namespace detail {

template<size_t EnumSize, bool EnumSigned, size_t StorageSize, bool StorageSigned>
struct EnumFitsWithinHelper;


template<size_t EnumSize, size_t StorageSize>
struct EnumFitsWithinHelper<EnumSize, true, StorageSize, true>
  : public std::integral_constant<bool, (EnumSize <= StorageSize)>
{};


template<size_t EnumSize, size_t StorageSize>
struct EnumFitsWithinHelper<EnumSize, true, StorageSize, false>
  : public std::integral_constant<bool, false>
{};


template<size_t EnumSize, size_t StorageSize>
struct EnumFitsWithinHelper<EnumSize, false, StorageSize, true>
  : public std::integral_constant<bool, (EnumSize * 2 <= StorageSize)>
{};


template<size_t EnumSize, size_t StorageSize>
struct EnumFitsWithinHelper<EnumSize, false, StorageSize, false>
  : public std::integral_constant<bool, (EnumSize <= StorageSize)>
{};

}
template<typename T, typename Storage>
struct EnumTypeFitsWithin
  : public detail::EnumFitsWithinHelper<
      sizeof(T),
      std::is_signed<typename std::underlying_type<T>::type>::value,
      sizeof(Storage),
      std::is_signed<Storage>::value
    >
{
  static_assert(std::is_enum<T>::value, "must provide an enum type");
  static_assert(std::is_integral<Storage>::value, "must provide an integral type");
};

}




class nsAString;
class nsIDocument;
class nsStyledElement;
struct MiscContainer;

namespace mozilla {
class DeclarationBlock;
namespace css {
struct URLValue;
struct ImageValue;
}
}
class nsCheapString : public nsString {
public:
  explicit nsCheapString(nsStringBuffer* aBuf)
  {
    if (aBuf)
      aBuf->ToString(aBuf->StorageSize()/sizeof(char16_t) - 1, *this);
  }
};

class nsAttrValue {
  friend struct MiscContainer;
public:
  typedef nsTArray< nsCOMPtr<nsIAtom> > AtomArray;


  enum ValueType {
    eString = 0x00,

    eAtom = 0x02,
    eInteger = 0x03,
    eColor = 0x07,
    eEnum = 0x0B,
    ePercent = 0x0F,


    eCSSDeclaration = 0x10,
    eURL,
    eImage,
    eAtomArray,
    eDoubleValue,
    eIntMarginValue,
    eSVGAngle,
    eSVGTypesBegin = eSVGAngle,
    eSVGIntegerPair,
    eSVGLength,
    eSVGLengthList,
    eSVGNumberList,
    eSVGNumberPair,
    eSVGPathData,
    eSVGPointList,
    eSVGPreserveAspectRatio,
    eSVGStringList,
    eSVGTransformList,
    eSVGViewBox,
    eSVGTypesEnd = eSVGViewBox,
  };

  nsAttrValue();
  nsAttrValue(const nsAttrValue& aOther);
  explicit nsAttrValue(const nsAString& aValue);
  explicit nsAttrValue(nsIAtom* aValue);
  nsAttrValue(already_AddRefed<mozilla::DeclarationBlock> aValue,
              const nsAString* aSerialized);
  explicit nsAttrValue(const nsIntMargin& aValue);
  ~nsAttrValue();

  inline const nsAttrValue& operator=(const nsAttrValue& aOther);

  static nsresult Init();
  static void Shutdown();

  ValueType Type() const;





  inline bool StoresOwnData() const;

  void Reset();

  void SetTo(const nsAttrValue& aOther);
  void SetTo(const nsAString& aValue);
  void SetTo(nsIAtom* aValue);
  void SetTo(int16_t aInt);
  void SetTo(int32_t aInt, const nsAString* aSerialized);
  void SetTo(double aValue, const nsAString* aSerialized);
  void SetTo(already_AddRefed<mozilla::DeclarationBlock> aValue,
             const nsAString* aSerialized);
  void SetTo(mozilla::css::URLValue* aValue, const nsAString* aSerialized);
  void SetTo(const nsIntMargin& aValue);
  void SetTo(const nsSVGAngle& aValue, const nsAString* aSerialized);
  void SetTo(const nsSVGIntegerPair& aValue, const nsAString* aSerialized);
  void SetTo(const nsSVGLength2& aValue, const nsAString* aSerialized);
  void SetTo(const mozilla::SVGLengthList& aValue,
             const nsAString* aSerialized);
  void SetTo(const mozilla::SVGNumberList& aValue,
             const nsAString* aSerialized);
  void SetTo(const nsSVGNumberPair& aValue, const nsAString* aSerialized);
  void SetTo(const mozilla::SVGPathData& aValue, const nsAString* aSerialized);
  void SetTo(const mozilla::SVGPointList& aValue, const nsAString* aSerialized);
  void SetTo(const mozilla::SVGAnimatedPreserveAspectRatio& aValue,
             const nsAString* aSerialized);
  void SetTo(const mozilla::SVGStringList& aValue,
             const nsAString* aSerialized);
  void SetTo(const mozilla::SVGTransformList& aValue,
             const nsAString* aSerialized);
  void SetTo(const nsSVGViewBox& aValue, const nsAString* aSerialized);
  void SetToSerialized(const nsAttrValue& aValue);

  void SwapValueWith(nsAttrValue& aOther);

  void ToString(nsAString& aResult) const;
  inline void ToString(mozilla::dom::DOMString& aResult) const;





  already_AddRefed<nsIAtom> GetAsAtom() const;



  inline bool IsEmptyString() const;
  const nsCheapString GetStringValue() const;
  inline nsIAtom* GetAtomValue() const;
  inline int32_t GetIntegerValue() const;
  bool GetColorValue(nscolor& aColor) const;
  inline int16_t GetEnumValue() const;
  inline float GetPercentValue() const;
  inline AtomArray* GetAtomArrayValue() const;
  inline mozilla::DeclarationBlock* GetCSSDeclarationValue() const;
  inline mozilla::css::URLValue* GetURLValue() const;
  inline mozilla::css::ImageValue* GetImageValue() const;
  inline double GetDoubleValue() const;
  bool GetIntMarginValue(nsIntMargin& aMargin) const;







  void GetEnumString(nsAString& aResult, bool aRealTag) const;




  uint32_t GetAtomCount() const;


  nsIAtom* AtomAt(int32_t aIndex) const;

  uint32_t HashValue() const;
  bool Equals(const nsAttrValue& aOther) const;

  bool Equals(const nsAString& aValue, nsCaseTreatment aCaseSensitive) const;
  bool Equals(nsIAtom* aValue, nsCaseTreatment aCaseSensitive) const;
  bool EqualsAsStrings(const nsAttrValue& aOther) const;





  bool Contains(nsIAtom* aValue, nsCaseTreatment aCaseSensitive) const;





  bool Contains(const nsAString& aValue) const;

  void ParseAtom(const nsAString& aValue);
  void ParseAtomArray(const nsAString& aValue);
  void ParseStringOrAtom(const nsAString& aValue);
  struct EnumTable {



    constexpr EnumTable(const char* aTag, int16_t aValue)
      : tag(aTag)
      , value(aValue)
    {
    }

    template<typename T,
             typename = typename std::enable_if<std::is_enum<T>::value>::type>
    constexpr EnumTable(const char* aTag, T aValue)
      : tag(aTag)
      , value(static_cast<int16_t>(aValue))
    {
      static_assert(mozilla::EnumTypeFitsWithin<T, int16_t>::value,
                    "aValue must be an enum that fits within int16_t");
    }


    const char* tag;

    int16_t value;
  };
  bool ParseEnumValue(const nsAString& aValue,
                        const EnumTable* aTable,
                        bool aCaseSensitive,
                        const EnumTable* aDefaultValue = nullptr);
  bool ParseSpecialIntValue(const nsAString& aString);
  bool ParseIntValue(const nsAString& aString) {
    return ParseIntWithBounds(aString, (-2147483647-1), (2147483647));
  }
  bool ParseIntWithBounds(const nsAString& aString, int32_t aMin,
                            int32_t aMax = (2147483647));
  void ParseIntWithFallback(const nsAString& aString, int32_t aDefault,
                            int32_t aMax = (2147483647));
  bool ParseNonNegativeIntValue(const nsAString& aString);
  bool ParsePositiveIntValue(const nsAString& aString);
  bool ParseColor(const nsAString& aString);







  bool ParseDoubleValue(const nsAString& aString);





  bool ParseLazyURIValue(const nsAString& aString);
  bool ParseIntMarginValue(const nsAString& aString);






  void LoadImage(nsIDocument* aDocument);







  bool ParseStyleAttribute(const nsAString& aString,
                           nsStyledElement* aElement);

  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

private:

  enum ValueBaseType {
    eStringBase = eString,
    eOtherBase = 0x01,
    eAtomBase = eAtom,
    eIntegerBase = 0x03
  };

  inline ValueBaseType BaseType() const;
  inline bool IsSVGType(ValueType aType) const;
  int16_t GetEnumTableIndex(const EnumTable* aTable);

  inline void SetPtrValueAndType(void* aValue, ValueBaseType aType);
  void SetIntValueAndType(int32_t aValue, ValueType aType,
                          const nsAString* aStringValue);
  void SetColorValue(nscolor aColor, const nsAString& aString);
  void SetMiscAtomOrString(const nsAString* aValue);
  void ResetMiscAtomOrString();
  void SetSVGType(ValueType aType, const void* aValue,
                  const nsAString* aSerialized);
  inline void ResetIfSet();

  inline void* GetPtr() const;
  inline MiscContainer* GetMiscContainer() const;
  inline int32_t GetIntInternal() const;



  MiscContainer* ClearMiscContainer();


  MiscContainer* EnsureEmptyMiscContainer();
  bool EnsureEmptyAtomArray();
  already_AddRefed<nsStringBuffer>
    GetStringBuffer(const nsAString& aValue) const;


  int32_t EnumTableEntryToValue(const EnumTable* aEnumTable,
                                const EnumTable* aTableEntry);

  static nsTArray<const EnumTable*>* sEnumTableArray;

  uintptr_t mBits;
};

inline const nsAttrValue&
nsAttrValue::operator=(const nsAttrValue& aOther)
{
  SetTo(aOther);
  return *this;
}

inline nsIAtom*
nsAttrValue::GetAtomValue() const
{
  do { } while(0);
  return reinterpret_cast<nsIAtom*>(GetPtr());
}

inline nsAttrValue::ValueBaseType
nsAttrValue::BaseType() const
{
  return static_cast<ValueBaseType>(mBits & (uintptr_t(3)));
}

inline void*
nsAttrValue::GetPtr() const
{
  do { } while(0);

  return reinterpret_cast<void*>(mBits & (~(uintptr_t(3))));
}

inline bool
nsAttrValue::IsEmptyString() const
{
  return !mBits;
}

inline void
nsAttrValue::ToString(mozilla::dom::DOMString& aResult) const
{
  switch (Type()) {
    case eString:
    {
      nsStringBuffer* str = static_cast<nsStringBuffer*>(GetPtr());
      if (str) {
        aResult.SetStringBuffer(str, str->StorageSize()/sizeof(char16_t) - 1);
      }

      return;
    }
    case eAtom:
    {
      nsIAtom *atom = static_cast<nsIAtom*>(GetPtr());
      aResult.SetStringBuffer(atom->GetStringBuffer(), atom->GetLength());
      break;
    }
    default:
    {
      ToString(aResult.AsAString());
    }
  }
}
struct nsCSSSelector;



enum nsChangeHint {
  nsChangeHint_Empty = 0,




  nsChangeHint_RepaintFrame = 1 << 0,



  nsChangeHint_NeedReflow = 1 << 1,



  nsChangeHint_ClearAncestorIntrinsics = 1 << 2,




  nsChangeHint_ClearDescendantIntrinsics = 1 << 3,




  nsChangeHint_NeedDirtyReflow = 1 << 4,



  nsChangeHint_SyncFrameView = 1 << 5,


  nsChangeHint_UpdateCursor = 1 << 6,
  nsChangeHint_UpdateEffects = 1 << 7,






  nsChangeHint_UpdateOpacityLayer = 1 << 8,




  nsChangeHint_UpdateTransformLayer = 1 << 9,
  nsChangeHint_ReconstructFrame = 1 << 10,





  nsChangeHint_UpdateOverflow = 1 << 11,





  nsChangeHint_UpdateSubtreeOverflow = 1 << 12,
  nsChangeHint_UpdatePostTransformOverflow = 1 << 13,







  nsChangeHint_UpdateParentOverflow = 1 << 14,





  nsChangeHint_ChildrenOnlyTransform = 1 << 15,
  nsChangeHint_RecomputePosition = 1 << 16,
  nsChangeHint_UpdateContainingBlock = 1 << 17,







  nsChangeHint_BorderStyleNoneChange = 1 << 18,





  nsChangeHint_UpdateTextPath = 1 << 19,





  nsChangeHint_SchedulePaint = 1 << 20,
  nsChangeHint_NeutralChange = 1 << 21,




  nsChangeHint_InvalidateRenderingObservers = 1 << 22,







  nsChangeHint_ReflowChangesSizeOrPosition = 1 << 23,





  nsChangeHint_UpdateComputedBSize = 1 << 24,
  nsChangeHint_UpdateUsesOpacity = 1 << 25,
  nsChangeHint_UpdateBackgroundPosition = 1 << 26,





  nsChangeHint_AddOrRemoveTransform = 1 << 27,
  nsChangeHint_AllHints = (1 << 28) - 1,
};




inline void operator<(nsChangeHint s1, nsChangeHint s2) {}
inline void operator>(nsChangeHint s1, nsChangeHint s2) {}
inline void operator!=(nsChangeHint s1, nsChangeHint s2) {}
inline void operator==(nsChangeHint s1, nsChangeHint s2) {}
inline void operator<=(nsChangeHint s1, nsChangeHint s2) {}
inline void operator>=(nsChangeHint s1, nsChangeHint s2) {}




inline bool NS_IsHintSubset(nsChangeHint aSubset, nsChangeHint aSuperSet) {
  return (aSubset & aSuperSet) == aSubset;
}



typedef decltype(nsChangeHint(0) + nsChangeHint(0)) nsChangeHint_size_t;

inline nsChangeHint constexpr
operator|(nsChangeHint aLeft, nsChangeHint aRight)
{
  return nsChangeHint(nsChangeHint_size_t(aLeft) | nsChangeHint_size_t(aRight));
}

inline nsChangeHint constexpr
operator&(nsChangeHint aLeft, nsChangeHint aRight)
{
  return nsChangeHint(nsChangeHint_size_t(aLeft) & nsChangeHint_size_t(aRight));
}

inline nsChangeHint& operator|=(nsChangeHint& aLeft, nsChangeHint aRight)
{
  return aLeft = aLeft | aRight;
}

inline nsChangeHint& operator&=(nsChangeHint& aLeft, nsChangeHint aRight)
{
  return aLeft = aLeft & aRight;
}

inline nsChangeHint constexpr
operator~(nsChangeHint aArg)
{
  return nsChangeHint(~nsChangeHint_size_t(aArg));
}

inline nsChangeHint constexpr
operator^(nsChangeHint aLeft, nsChangeHint aRight)
{
  return nsChangeHint(nsChangeHint_size_t(aLeft) ^ nsChangeHint_size_t(aRight));
}

inline nsChangeHint operator^=(nsChangeHint& aLeft, nsChangeHint aRight)
{
  return aLeft = aLeft ^ aRight;
}
static_assert(!(( nsChangeHint_ClearDescendantIntrinsics | nsChangeHint_NeedDirtyReflow | nsChangeHint_NeutralChange | nsChangeHint_ReconstructFrame | nsChangeHint_RepaintFrame | nsChangeHint_SchedulePaint | nsChangeHint_SyncFrameView | nsChangeHint_UpdateCursor | nsChangeHint_UpdateSubtreeOverflow | nsChangeHint_UpdateTextPath ) &
                ( nsChangeHint_BorderStyleNoneChange | nsChangeHint_ChildrenOnlyTransform | nsChangeHint_InvalidateRenderingObservers | nsChangeHint_RecomputePosition | nsChangeHint_UpdateBackgroundPosition | nsChangeHint_UpdateComputedBSize | nsChangeHint_UpdateContainingBlock | nsChangeHint_UpdateEffects | nsChangeHint_UpdateOpacityLayer | nsChangeHint_UpdateOverflow | nsChangeHint_UpdateParentOverflow | nsChangeHint_UpdatePostTransformOverflow | nsChangeHint_UpdateTransformLayer | nsChangeHint_UpdateUsesOpacity | nsChangeHint_AddOrRemoveTransform )) &&
              !(( nsChangeHint_ClearDescendantIntrinsics | nsChangeHint_NeedDirtyReflow | nsChangeHint_NeutralChange | nsChangeHint_ReconstructFrame | nsChangeHint_RepaintFrame | nsChangeHint_SchedulePaint | nsChangeHint_SyncFrameView | nsChangeHint_UpdateCursor | nsChangeHint_UpdateSubtreeOverflow | nsChangeHint_UpdateTextPath ) &
                ( nsChangeHint_ClearAncestorIntrinsics | nsChangeHint_NeedReflow | nsChangeHint_ReflowChangesSizeOrPosition )) &&
              !(( nsChangeHint_BorderStyleNoneChange | nsChangeHint_ChildrenOnlyTransform | nsChangeHint_InvalidateRenderingObservers | nsChangeHint_RecomputePosition | nsChangeHint_UpdateBackgroundPosition | nsChangeHint_UpdateComputedBSize | nsChangeHint_UpdateContainingBlock | nsChangeHint_UpdateEffects | nsChangeHint_UpdateOpacityLayer | nsChangeHint_UpdateOverflow | nsChangeHint_UpdateParentOverflow | nsChangeHint_UpdatePostTransformOverflow | nsChangeHint_UpdateTransformLayer | nsChangeHint_UpdateUsesOpacity | nsChangeHint_AddOrRemoveTransform ) &
                ( nsChangeHint_ClearAncestorIntrinsics | nsChangeHint_NeedReflow | nsChangeHint_ReflowChangesSizeOrPosition )) &&
              !(nsChangeHint_AllHints ^
                ( nsChangeHint_ClearDescendantIntrinsics | nsChangeHint_NeedDirtyReflow | nsChangeHint_NeutralChange | nsChangeHint_ReconstructFrame | nsChangeHint_RepaintFrame | nsChangeHint_SchedulePaint | nsChangeHint_SyncFrameView | nsChangeHint_UpdateCursor | nsChangeHint_UpdateSubtreeOverflow | nsChangeHint_UpdateTextPath ) ^
                ( nsChangeHint_BorderStyleNoneChange | nsChangeHint_ChildrenOnlyTransform | nsChangeHint_InvalidateRenderingObservers | nsChangeHint_RecomputePosition | nsChangeHint_UpdateBackgroundPosition | nsChangeHint_UpdateComputedBSize | nsChangeHint_UpdateContainingBlock | nsChangeHint_UpdateEffects | nsChangeHint_UpdateOpacityLayer | nsChangeHint_UpdateOverflow | nsChangeHint_UpdateParentOverflow | nsChangeHint_UpdatePostTransformOverflow | nsChangeHint_UpdateTransformLayer | nsChangeHint_UpdateUsesOpacity | nsChangeHint_AddOrRemoveTransform ) ^
                ( nsChangeHint_ClearAncestorIntrinsics | nsChangeHint_NeedReflow | nsChangeHint_ReflowChangesSizeOrPosition )),
              "change hints must be present in exactly one of "
              "nsChangeHint_Hints_{Always,Never,Sometimes}"
              "HandledForDescendants");
inline nsChangeHint NS_HintsNotHandledForDescendantsIn(nsChangeHint aChangeHint) {
  nsChangeHint result =
    aChangeHint & ( nsChangeHint_BorderStyleNoneChange | nsChangeHint_ChildrenOnlyTransform | nsChangeHint_InvalidateRenderingObservers | nsChangeHint_RecomputePosition | nsChangeHint_UpdateBackgroundPosition | nsChangeHint_UpdateComputedBSize | nsChangeHint_UpdateContainingBlock | nsChangeHint_UpdateEffects | nsChangeHint_UpdateOpacityLayer | nsChangeHint_UpdateOverflow | nsChangeHint_UpdateParentOverflow | nsChangeHint_UpdatePostTransformOverflow | nsChangeHint_UpdateTransformLayer | nsChangeHint_UpdateUsesOpacity | nsChangeHint_AddOrRemoveTransform );

  if (!NS_IsHintSubset(nsChangeHint_NeedDirtyReflow, aChangeHint)) {
    if (NS_IsHintSubset(nsChangeHint_NeedReflow, aChangeHint)) {


      result |= nsChangeHint_NeedReflow;
    }

    if (NS_IsHintSubset(nsChangeHint_ReflowChangesSizeOrPosition,
                        aChangeHint)) {


      result |= nsChangeHint_ReflowChangesSizeOrPosition;
    }
  }

  if (!NS_IsHintSubset(nsChangeHint_ClearDescendantIntrinsics, aChangeHint) &&
      NS_IsHintSubset(nsChangeHint_ClearAncestorIntrinsics, aChangeHint)) {


    result |= nsChangeHint_ClearAncestorIntrinsics;
  }

  do { } while (0);



  return result;
}

inline nsChangeHint
NS_HintsHandledForDescendantsIn(nsChangeHint aChangeHint)
{
  return aChangeHint & ~NS_HintsNotHandledForDescendantsIn(aChangeHint);
}



inline nsChangeHint
NS_RemoveSubsumedHints(nsChangeHint aOurChange, nsChangeHint aHintsHandled)
{
  nsChangeHint result =
    aOurChange & ~NS_HintsHandledForDescendantsIn(aHintsHandled);

  if (result & (nsChangeHint_ClearAncestorIntrinsics |
                nsChangeHint_ClearDescendantIntrinsics |
                nsChangeHint_NeedDirtyReflow |
                nsChangeHint_ReflowChangesSizeOrPosition |
                nsChangeHint_UpdateComputedBSize)) {
    result |= nsChangeHint_NeedReflow;
  }

  if (result & (nsChangeHint_ClearDescendantIntrinsics)) {
    do { } while (0);
    result |=
              nsChangeHint_NeedDirtyReflow;
  }

  return result;
}
enum nsRestyleHint {




  eRestyle_Self = 1 << 0,



  eRestyle_SomeDescendants = 1 << 1,





  eRestyle_Subtree = 1 << 2,



  eRestyle_LaterSiblings = 1 << 3,






  eRestyle_CSSTransitions = 1 << 4,






  eRestyle_CSSAnimations = 1 << 5,
  eRestyle_StyleAttribute = 1 << 6,



  eRestyle_StyleAttribute_Animations = 1 << 7,



  eRestyle_Force = 1 << 8,






  eRestyle_ForceDescendants = 1 << 9,


  eRestyle_AllHintsWithAnimations = eRestyle_CSSTransitions |
                                    eRestyle_CSSAnimations |
                                    eRestyle_StyleAttribute_Animations,
};



typedef decltype(nsRestyleHint(0) + nsRestyleHint(0)) nsRestyleHint_size_t;

inline constexpr nsRestyleHint operator|(nsRestyleHint aLeft,
                                             nsRestyleHint aRight)
{
  return nsRestyleHint(nsRestyleHint_size_t(aLeft) |
                       nsRestyleHint_size_t(aRight));
}

inline constexpr nsRestyleHint operator&(nsRestyleHint aLeft,
                                             nsRestyleHint aRight)
{
  return nsRestyleHint(nsRestyleHint_size_t(aLeft) &
                       nsRestyleHint_size_t(aRight));
}

inline nsRestyleHint& operator|=(nsRestyleHint& aLeft, nsRestyleHint aRight)
{
  return aLeft = aLeft | aRight;
}

inline nsRestyleHint& operator&=(nsRestyleHint& aLeft, nsRestyleHint aRight)
{
  return aLeft = aLeft & aRight;
}

inline constexpr nsRestyleHint operator~(nsRestyleHint aArg)
{
  return nsRestyleHint(~nsRestyleHint_size_t(aArg));
}

inline constexpr nsRestyleHint operator^(nsRestyleHint aLeft,
                                             nsRestyleHint aRight)
{
  return nsRestyleHint(nsRestyleHint_size_t(aLeft) ^
                       nsRestyleHint_size_t(aRight));
}

inline nsRestyleHint operator^=(nsRestyleHint& aLeft, nsRestyleHint aRight)
{
  return aLeft = aLeft ^ aRight;
}

namespace mozilla {





struct RestyleHintData
{


  nsTArray<nsCSSSelector*> mSelectorsForDescendants;
};

}


namespace mozilla {

namespace dom {
class Element;
}






struct ServoAttrSnapshot
{
  nsAttrName mName;
  nsAttrValue mValue;

  ServoAttrSnapshot(const nsAttrName& aName, const nsAttrValue& aValue)
    : mName(aName)
    , mValue(aValue)
  {
  }
};





enum class ServoElementSnapshotFlags : uint8_t
{
  State = 1 << 0,
  Attributes = 1 << 1,
  All = State | Attributes
};

inline constexpr mozilla::CastableTypedEnumResult<ServoElementSnapshotFlags> operator |(ServoElementSnapshotFlags a, ServoElementSnapshotFlags b) { typedef mozilla::CastableTypedEnumResult<ServoElementSnapshotFlags> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<ServoElementSnapshotFlags>::Type U; return Result(ServoElementSnapshotFlags(U(a) | U(b))); } inline ServoElementSnapshotFlags& operator |=(ServoElementSnapshotFlags& a, ServoElementSnapshotFlags b) { return a = a | b; } inline constexpr mozilla::CastableTypedEnumResult<ServoElementSnapshotFlags> operator &(ServoElementSnapshotFlags a, ServoElementSnapshotFlags b) { typedef mozilla::CastableTypedEnumResult<ServoElementSnapshotFlags> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<ServoElementSnapshotFlags>::Type U; return Result(ServoElementSnapshotFlags(U(a) & U(b))); } inline ServoElementSnapshotFlags& operator &=(ServoElementSnapshotFlags& a, ServoElementSnapshotFlags b) { return a = a & b; } inline constexpr mozilla::CastableTypedEnumResult<ServoElementSnapshotFlags> operator ^(ServoElementSnapshotFlags a, ServoElementSnapshotFlags b) { typedef mozilla::CastableTypedEnumResult<ServoElementSnapshotFlags> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<ServoElementSnapshotFlags>::Type U; return Result(ServoElementSnapshotFlags(U(a) ^ U(b))); } inline ServoElementSnapshotFlags& operator ^=(ServoElementSnapshotFlags& a, ServoElementSnapshotFlags b) { return a = a ^ b; } inline constexpr mozilla::CastableTypedEnumResult<ServoElementSnapshotFlags> operator~(ServoElementSnapshotFlags a) { typedef mozilla::CastableTypedEnumResult<ServoElementSnapshotFlags> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<ServoElementSnapshotFlags>::Type U; return Result(ServoElementSnapshotFlags(~(U(a)))); }
class ServoElementSnapshot
{
  typedef dom::BorrowedAttrInfo BorrowedAttrInfo;
  typedef dom::Element Element;
  typedef EventStates::ServoType ServoStateType;

public:
  typedef ServoElementSnapshotFlags Flags;

  explicit ServoElementSnapshot(const Element* aElement);
  ~ServoElementSnapshot();

  bool HasAttrs() { return HasAny(Flags::Attributes); }

  bool HasState() { return HasAny(Flags::State); }




  void AddState(EventStates aState)
  {
    if (!HasAny(Flags::State)) {
      mState = aState.ServoValue();
      mContains |= Flags::State;
    }
  }




  void AddAttrs(Element* aElement);




  BorrowedAttrInfo GetAttrInfoAt(uint32_t aIndex) const
  {
    if (aIndex >= mAttrs.Length()) {
      return BorrowedAttrInfo(nullptr, nullptr);
    }
    return BorrowedAttrInfo(&mAttrs[aIndex].mName, &mAttrs[aIndex].mValue);
  }

  const nsAttrValue* GetParsedAttr(nsIAtom* aLocalName) const
  {
    return GetParsedAttr(aLocalName, kNameSpaceID_None);
  }

  const nsAttrValue* GetParsedAttr(nsIAtom* aLocalName,
                                   int32_t aNamespaceID) const
  {
    uint32_t i, len = mAttrs.Length();
    if (aNamespaceID == kNameSpaceID_None) {

      for (i = 0; i < len; ++i) {
        if (mAttrs[i].mName.Equals(aLocalName)) {
          return &mAttrs[i].mValue;
        }
      }

      return nullptr;
    }

    for (i = 0; i < len; ++i) {
      if (mAttrs[i].mName.Equals(aLocalName, aNamespaceID)) {
        return &mAttrs[i].mValue;
      }
    }

    return nullptr;
  }

  bool IsInChromeDocument() const
  {
    return mIsInChromeDocument;
  }

  bool HasAny(Flags aFlags) { return bool(mContains & aFlags); }

private:




  Flags mContains;
  nsTArray<ServoAttrSnapshot> mAttrs;
  ServoStateType mState;
  bool mIsHTMLElementInHTMLDocument;
  bool mIsInChromeDocument;
};

}
namespace mozilla {
namespace css {
enum SheetParsingMode {
  eAuthorSheetFeatures = 0,
  eUserSheetFeatures,
  eAgentSheetFeatures
};

}
}
class nsINode;
class nsIContent;
class nsMappedAttributes;
class nsHTMLStyleSheet;
class nsRuleWalker;
class nsMappedAttributeElement;
class nsAttrAndChildArray
{
  typedef mozilla::dom::BorrowedAttrInfo BorrowedAttrInfo;
public:
  nsAttrAndChildArray();
  ~nsAttrAndChildArray();

  uint32_t ChildCount() const
  {
    return mImpl ? (mImpl->mAttrAndChildCount >> 10) : 0;
  }
  nsIContent* ChildAt(uint32_t aPos) const
  {
    do { } while(0);
    return reinterpret_cast<nsIContent*>(mImpl->mBuffer[AttrSlotsSize() + aPos]);
  }
  nsIContent* GetSafeChildAt(uint32_t aPos) const;
  nsIContent * const * GetChildArray(uint32_t* aChildCount) const;
  nsresult AppendChild(nsIContent* aChild)
  {
    return InsertChildAt(aChild, ChildCount());
  }
  nsresult InsertChildAt(nsIContent* aChild, uint32_t aPos);
  void RemoveChildAt(uint32_t aPos);


  already_AddRefed<nsIContent> TakeChildAt(uint32_t aPos);
  int32_t IndexOfChild(const nsINode* aPossibleChild) const;

  bool HasAttrs() const
  {
    return MappedAttrCount() || (AttrSlotCount() && AttrSlotIsTaken(0));
  }

  uint32_t AttrCount() const;
  const nsAttrValue* GetAttr(nsIAtom* aLocalName,
                             int32_t aNamespaceID = kNameSpaceID_None) const;


  const nsAttrValue* GetAttr(const nsAString& aName) const;


  const nsAttrValue* GetAttr(const nsAString& aName,
                             nsCaseTreatment aCaseSensitive) const;
  const nsAttrValue* AttrAt(uint32_t aPos) const;

  nsresult SetAndSwapAttr(nsIAtom* aLocalName, nsAttrValue& aValue);
  nsresult SetAndSwapAttr(mozilla::dom::NodeInfo* aName, nsAttrValue& aValue);



  nsresult RemoveAttrAt(uint32_t aPos, nsAttrValue& aValue);


  const nsAttrName* AttrNameAt(uint32_t aPos) const;


  BorrowedAttrInfo AttrInfoAt(uint32_t aPos) const;


  const nsAttrName* GetSafeAttrNameAt(uint32_t aPos) const;

  const nsAttrName* GetExistingAttrNameFromQName(const nsAString& aName) const;
  int32_t IndexOfAttr(nsIAtom* aLocalName, int32_t aNamespaceID = kNameSpaceID_None) const;

  nsresult SetAndTakeMappedAttr(nsIAtom* aLocalName, nsAttrValue& aValue,
                                nsMappedAttributeElement* aContent,
                                nsHTMLStyleSheet* aSheet);
  nsresult SetMappedAttrStyleSheet(nsHTMLStyleSheet* aSheet) {
    if (!mImpl || !mImpl->mMappedAttrs) {
      return NS_OK;
    }
    return DoSetMappedAttrStyleSheet(aSheet);
  }
  void WalkMappedAttributeStyleRules(nsRuleWalker* aRuleWalker);

  void Compact();

  bool CanFitMoreAttrs() const
  {
    return AttrSlotCount() < ((1 << 10) - 1) ||
           !AttrSlotIsTaken(((1 << 10) - 1) - 1);
  }

  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;
  bool HasMappedAttrs() const
  {
    return MappedAttrCount();
  }
  const nsMappedAttributes* GetMapped() const;


  nsresult ForceMapped(nsMappedAttributeElement* aContent, nsIDocument* aDocument);



  void ClearMappedServoStyle();

private:
  nsAttrAndChildArray(const nsAttrAndChildArray& aOther) = delete;
  nsAttrAndChildArray& operator=(const nsAttrAndChildArray& aOther) = delete;

  void Clear();

  uint32_t NonMappedAttrCount() const;
  uint32_t MappedAttrCount() const;


  nsMappedAttributes*
  GetModifiableMapped(nsMappedAttributeElement* aContent,
                      nsHTMLStyleSheet* aSheet,
                      bool aWillAddAttr,
                      int32_t aAttrCount = 1);
  nsresult MakeMappedUnique(nsMappedAttributes* aAttributes);

  uint32_t AttrSlotsSize() const
  {
    return AttrSlotCount() * (sizeof(InternalAttr) / sizeof(void*));
  }

  uint32_t AttrSlotCount() const
  {
    return mImpl ? mImpl->mAttrAndChildCount & ((1 << 10) - 1) : 0;
  }

  bool AttrSlotIsTaken(uint32_t aSlot) const
  {
    do { } while(0);
    return mImpl->mBuffer[aSlot * (sizeof(InternalAttr) / sizeof(void*))];
  }

  void SetChildCount(uint32_t aCount)
  {
    mImpl->mAttrAndChildCount =
        (mImpl->mAttrAndChildCount & ((1 << 10) - 1)) |
        (aCount << 10);
  }

  void SetAttrSlotCount(uint32_t aCount)
  {
    mImpl->mAttrAndChildCount =
        (mImpl->mAttrAndChildCount & ~((1 << 10) - 1)) |
        aCount;
  }

  void SetAttrSlotAndChildCount(uint32_t aSlotCount, uint32_t aChildCount)
  {
    mImpl->mAttrAndChildCount = aSlotCount |
      (aChildCount << 10);
  }

  bool GrowBy(uint32_t aGrowSize);
  bool AddAttrSlot();






  inline void SetChildAtPos(void** aPos, nsIContent* aChild, uint32_t aIndex,
                            uint32_t aChildCount);




  nsresult DoSetMappedAttrStyleSheet(nsHTMLStyleSheet* aSheet);

  struct InternalAttr
  {
    nsAttrName mName;
    nsAttrValue mValue;
  };

  struct Impl {
    uint32_t mAttrAndChildCount;
    uint32_t mBufferSize;
    nsMappedAttributes* mMappedAttrs;
    void* mBuffer[1];
  };

  Impl* mImpl;
};

class nsIAtom;

class nsGkAtoms {
public:

  static void AddRefAtoms();
static nsIAtom* _empty;
static nsIAtom* moz;
static nsIAtom* mozframetype;
static nsIAtom* _moz_abspos;
static nsIAtom* _moz_activated;
static nsIAtom* _moz_anonclass;
static nsIAtom* _moz_resizing;
static nsIAtom* mozallowfullscreen;
static nsIAtom* moztype;
static nsIAtom* mozdirty;
static nsIAtom* mozdisallowselectionprint;
static nsIAtom* mozdonotsend;
static nsIAtom* mozeditorbogusnode;
static nsIAtom* mozgeneratedcontentbefore;
static nsIAtom* mozgeneratedcontentafter;
static nsIAtom* mozgeneratedcontentimage;
static nsIAtom* mozquote;
static nsIAtom* mozsignature;
static nsIAtom* _moz_is_glyph;
static nsIAtom* _moz_original_size;
static nsIAtom* _moz_target;
static nsIAtom* menuactive;
static nsIAtom* _poundDefault;
static nsIAtom* _asterisk;
static nsIAtom* a;
static nsIAtom* abbr;
static nsIAtom* abort;
static nsIAtom* above;
static nsIAtom* acceltext;
static nsIAtom* accept;
static nsIAtom* acceptcharset;
static nsIAtom* accesskey;
static nsIAtom* acronym;
static nsIAtom* action;
static nsIAtom* active;
static nsIAtom* activetitlebarcolor;
static nsIAtom* activateontab;
static nsIAtom* actuate;
static nsIAtom* address;
static nsIAtom* after;
static nsIAtom* after_end;
static nsIAtom* after_start;
static nsIAtom* align;
static nsIAtom* alink;
static nsIAtom* all;
static nsIAtom* allowdirs;
static nsIAtom* allowevents;
static nsIAtom* allownegativeassertions;
static nsIAtom* allowforms;
static nsIAtom* allowfullscreen;
static nsIAtom* allowmodals;
static nsIAtom* alloworientationlock;
static nsIAtom* allowpointerlock;
static nsIAtom* allowpopupstoescapesandbox;
static nsIAtom* allowpopups;
static nsIAtom* allowpresentation;
static nsIAtom* allowsameorigin;
static nsIAtom* allowscripts;
static nsIAtom* allowtopnavigation;
static nsIAtom* allowuntrusted;
static nsIAtom* alt;
static nsIAtom* alternate;
static nsIAtom* always;
static nsIAtom* ancestor;
static nsIAtom* ancestorOrSelf;
static nsIAtom* anchor;
static nsIAtom* _and;
static nsIAtom* animations;
static nsIAtom* anonid;
static nsIAtom* anonlocation;
static nsIAtom* any;
static nsIAtom* applet;
static nsIAtom* applyImports;
static nsIAtom* applyTemplates;
static nsIAtom* mozapptype;
static nsIAtom* archive;
static nsIAtom* area;
static nsIAtom* arrow;
static nsIAtom* article;
static nsIAtom* ascending;
static nsIAtom* aside;
static nsIAtom* aspectRatio;
static nsIAtom* assign;
static nsIAtom* async;
static nsIAtom* attribute;
static nsIAtom* attributes;
static nsIAtom* attributeSet;
static nsIAtom* aural;
static nsIAtom* _auto;
static nsIAtom* autocheck;
static nsIAtom* autocomplete;
static nsIAtom* autofocus;
static nsIAtom* autoplay;
static nsIAtom* autorepeatbutton;
static nsIAtom* axis;
static nsIAtom* b;
static nsIAtom* backdropFrame;
static nsIAtom* background;
static nsIAtom* base;
static nsIAtom* basefont;
static nsIAtom* baseline;
static nsIAtom* bdi;
static nsIAtom* bdo;
static nsIAtom* before;
static nsIAtom* before_end;
static nsIAtom* before_start;
static nsIAtom* below;
static nsIAtom* bgcolor;
static nsIAtom* bgsound;
static nsIAtom* big;
static nsIAtom* binding;
static nsIAtom* bindings;
static nsIAtom* bindToUntrustedContent;
static nsIAtom* blankrow;
static nsIAtom* block;
static nsIAtom* blockquote;
static nsIAtom* blur;
static nsIAtom* body;
static nsIAtom* boolean;
static nsIAtom* border;
static nsIAtom* bordercolor;
static nsIAtom* both;
static nsIAtom* bottom;
static nsIAtom* bottomend;
static nsIAtom* bottomstart;
static nsIAtom* bottomleft;
static nsIAtom* bottommargin;
static nsIAtom* bottompadding;
static nsIAtom* bottomright;
static nsIAtom* box;
static nsIAtom* br;
static nsIAtom* braille;
static nsIAtom* broadcast;
static nsIAtom* broadcaster;
static nsIAtom* broadcasterset;
static nsIAtom* browser;
static nsIAtom* mozbrowser;
static nsIAtom* bulletinboard;
static nsIAtom* button;
static nsIAtom* brighttitlebarforeground;
static nsIAtom* callTemplate;
static nsIAtom* cancel;
static nsIAtom* canvas;
static nsIAtom* caption;
static nsIAtom* capture;
static nsIAtom* caseOrder;
static nsIAtom* cdataSectionElements;
static nsIAtom* ceiling;
static nsIAtom* cell;
static nsIAtom* cellpadding;
static nsIAtom* cellspacing;
static nsIAtom* center;
static nsIAtom* ch;
static nsIAtom* change;
static nsIAtom* _char;
static nsIAtom* characterData;
static nsIAtom* charcode;
static nsIAtom* charoff;
static nsIAtom* charset;
static nsIAtom* checkbox;
static nsIAtom* checked;
static nsIAtom* child;
static nsIAtom* children;
static nsIAtom* childList;
static nsIAtom* choose;
static nsIAtom* chromemargin;
static nsIAtom* chromeOnlyContent;
static nsIAtom* exposeToUntrustedContent;
static nsIAtom* circ;
static nsIAtom* circle;
static nsIAtom* cite;
static nsIAtom* _class;
static nsIAtom* classid;
static nsIAtom* clear;
static nsIAtom* click;
static nsIAtom* clickcount;
static nsIAtom* clickthrough;
static nsIAtom* movetoclick;
static nsIAtom* clip;
static nsIAtom* close;
static nsIAtom* closed;
static nsIAtom* closemenu;
static nsIAtom* coalesceduplicatearcs;
static nsIAtom* code;
static nsIAtom* codebase;
static nsIAtom* codetype;
static nsIAtom* col;
static nsIAtom* colgroup;
static nsIAtom* collapse;
static nsIAtom* collapsed;
static nsIAtom* color;
static nsIAtom* colorIndex;
static nsIAtom* cols;
static nsIAtom* colspan;
static nsIAtom* column;
static nsIAtom* columns;
static nsIAtom* combobox;
static nsIAtom* command;
static nsIAtom* commands;
static nsIAtom* commandset;
static nsIAtom* commandupdate;
static nsIAtom* commandupdater;
static nsIAtom* comment;
static nsIAtom* compact;
static nsIAtom* concat;
static nsIAtom* conditions;
static nsIAtom* constructor;
static nsIAtom* consumeoutsideclicks;
static nsIAtom* container;
static nsIAtom* containment;
static nsIAtom* contains;
static nsIAtom* content;
static nsIAtom* contenteditable;
static nsIAtom* headerContentDisposition;
static nsIAtom* headerContentLanguage;
static nsIAtom* contentLocation;
static nsIAtom* headerContentScriptType;
static nsIAtom* headerContentStyleType;
static nsIAtom* headerContentType;
static nsIAtom* consumeanchor;
static nsIAtom* context;
static nsIAtom* contextmenu;
static nsIAtom* control;
static nsIAtom* controls;
static nsIAtom* coords;
static nsIAtom* copy;
static nsIAtom* copyOf;
static nsIAtom* count;
static nsIAtom* crop;
static nsIAtom* crossorigin;
static nsIAtom* curpos;
static nsIAtom* current;
static nsIAtom* cutoutregion;
static nsIAtom* cycler;
static nsIAtom* data;
static nsIAtom* datalist;
static nsIAtom* dataType;
static nsIAtom* dateTime;
static nsIAtom* datasources;
static nsIAtom* datetime;
static nsIAtom* datetimebox;
static nsIAtom* dblclick;
static nsIAtom* dd;
static nsIAtom* debug;
static nsIAtom* decimalFormat;
static nsIAtom* decimalSeparator;
static nsIAtom* deck;
static nsIAtom* declare;
static nsIAtom* decoderDoctor;
static nsIAtom* decrement;
static nsIAtom* _default;
static nsIAtom* headerDefaultStyle;
static nsIAtom* defaultAction;
static nsIAtom* defaultchecked;
static nsIAtom* defaultLabel;
static nsIAtom* defaultselected;
static nsIAtom* defaultvalue;
static nsIAtom* defaultplaybackrate;
static nsIAtom* defer;
static nsIAtom* del;
static nsIAtom* descendant;
static nsIAtom* descendantOrSelf;
static nsIAtom* descending;
static nsIAtom* description;
static nsIAtom* destructor;
static nsIAtom* details;
static nsIAtom* deviceAspectRatio;
static nsIAtom* deviceHeight;
static nsIAtom* devicePixelRatio;
static nsIAtom* deviceWidth;
static nsIAtom* dfn;
static nsIAtom* dialog;
static nsIAtom* difference;
static nsIAtom* digit;
static nsIAtom* dir;
static nsIAtom* dirAutoSetBy;
static nsIAtom* directionality;
static nsIAtom* directory;
static nsIAtom* disableOutputEscaping;
static nsIAtom* disabled;
static nsIAtom* disableglobalhistory;
static nsIAtom* disablehistory;
static nsIAtom* disablefullscreen;
static nsIAtom* display;
static nsIAtom* displayMode;
static nsIAtom* distinct;
static nsIAtom* div;
static nsIAtom* dl;
static nsIAtom* doctypePublic;
static nsIAtom* doctypeSystem;
static nsIAtom* document;
static nsIAtom* download;
static nsIAtom* DOMAttrModified;
static nsIAtom* DOMCharacterDataModified;
static nsIAtom* DOMNodeInserted;
static nsIAtom* DOMNodeInsertedIntoDocument;
static nsIAtom* DOMNodeRemoved;
static nsIAtom* DOMNodeRemovedFromDocument;
static nsIAtom* DOMSubtreeModified;
static nsIAtom* double_;
static nsIAtom* drag;
static nsIAtom* dragend;
static nsIAtom* dragenter;
static nsIAtom* dragevent;
static nsIAtom* dragexit;
static nsIAtom* draggable;
static nsIAtom* dragging;
static nsIAtom* dragleave;
static nsIAtom* dragover;
static nsIAtom* dragSession;
static nsIAtom* dragstart;
static nsIAtom* drawintitlebar;
static nsIAtom* drawtitle;
static nsIAtom* drop;
static nsIAtom* dropAfter;
static nsIAtom* dropBefore;
static nsIAtom* dropOn;
static nsIAtom* dropMarker;
static nsIAtom* dt;
static nsIAtom* editable;
static nsIAtom* editing;
static nsIAtom* editor;
static nsIAtom* editorDisplayList;
static nsIAtom* element;
static nsIAtom* elementAvailable;
static nsIAtom* elements;
static nsIAtom* em;
static nsIAtom* embed;
static nsIAtom* embossed;
static nsIAtom* empty;
static nsIAtom* encoding;
static nsIAtom* enctype;
static nsIAtom* end;
static nsIAtom* endEvent;
static nsIAtom* end_after;
static nsIAtom* end_before;
static nsIAtom* equalsize;
static nsIAtom* error;
static nsIAtom* even;
static nsIAtom* event;
static nsIAtom* events;
static nsIAtom* excludeResultPrefixes;
static nsIAtom* excludes;
static nsIAtom* expr;
static nsIAtom* extends;
static nsIAtom* extensionElementPrefixes;
static nsIAtom* face;
static nsIAtom* fallback;
static nsIAtom* _false;
static nsIAtom* farthest;
static nsIAtom* field;
static nsIAtom* fieldset;
static nsIAtom* figcaption;
static nsIAtom* figure;
static nsIAtom* fixed;
static nsIAtom* flags;
static nsIAtom* flex;
static nsIAtom* flexgroup;
static nsIAtom* flip;
static nsIAtom* floating;
static nsIAtom* floor;
static nsIAtom* flowlength;
static nsIAtom* focus;
static nsIAtom* focused;
static nsIAtom* followanchor;
static nsIAtom* following;
static nsIAtom* followingSibling;
static nsIAtom* font;
static nsIAtom* fontWeight;
static nsIAtom* fontpicker;
static nsIAtom* footer;
static nsIAtom* _for;
static nsIAtom* forEach;
static nsIAtom* forceOwnRefreshDriver;
static nsIAtom* form;
static nsIAtom* formaction;
static nsIAtom* format;
static nsIAtom* formatNumber;
static nsIAtom* formenctype;
static nsIAtom* formmethod;
static nsIAtom* formnovalidate;
static nsIAtom* formtarget;
static nsIAtom* frame;
static nsIAtom* frameborder;
static nsIAtom* frameset;
static nsIAtom* from;
static nsIAtom* fullscreenchange;
static nsIAtom* fullscreenerror;
static nsIAtom* functionAvailable;
static nsIAtom* freshProcess;
static nsIAtom* generateId;
static nsIAtom* getter;
static nsIAtom* glyphchar;
static nsIAtom* glyphid;
static nsIAtom* grid;
static nsIAtom* grippy;
static nsIAtom* group;
static nsIAtom* groupingSeparator;
static nsIAtom* groupingSize;
static nsIAtom* grow;
static nsIAtom* gutter;
static nsIAtom* h1;
static nsIAtom* h2;
static nsIAtom* h3;
static nsIAtom* h4;
static nsIAtom* h5;
static nsIAtom* h6;
static nsIAtom* handheld;
static nsIAtom* handheldFriendly;
static nsIAtom* handler;
static nsIAtom* handlers;
static nsIAtom* HARD;
static nsIAtom* hasSameNode;
static nsIAtom* hbox;
static nsIAtom* head;
static nsIAtom* header;
static nsIAtom* headers;
static nsIAtom* height;
static nsIAtom* hgroup;
static nsIAtom* hidden;
static nsIAtom* hidechrome;
static nsIAtom* hidecolumnpicker;
static nsIAtom* high;
static nsIAtom* highest;
static nsIAtom* horizontal;
static nsIAtom* hover;
static nsIAtom* hr;
static nsIAtom* href;
static nsIAtom* hreflang;
static nsIAtom* hspace;
static nsIAtom* html;
static nsIAtom* httpEquiv;
static nsIAtom* i;
static nsIAtom* icon;
static nsIAtom* id;
static nsIAtom* _if;
static nsIAtom* iframe;
static nsIAtom* ignorecase;
static nsIAtom* ignorekeys;
static nsIAtom* ignoreuserfocus;
static nsIAtom* ilayer;
static nsIAtom* image;
static nsIAtom* imageClickedPoint;
static nsIAtom* img;
static nsIAtom* implementation;
static nsIAtom* implements;
static nsIAtom* import;
static nsIAtom* inactivetitlebarcolor;
static nsIAtom* include;
static nsIAtom* includes;
static nsIAtom* increment;
static nsIAtom* indent;
static nsIAtom* indeterminate;
static nsIAtom* index;
static nsIAtom* infer;
static nsIAtom* infinity;
static nsIAtom* inherit;
static nsIAtom* inherits;
static nsIAtom* inheritstyle;
static nsIAtom* initial_scale;
static nsIAtom* input;
static nsIAtom* inputmode;
static nsIAtom* ins;
static nsIAtom* insertafter;
static nsIAtom* insertbefore;
static nsIAtom* install;
static nsIAtom* instanceOf;
static nsIAtom* int32;
static nsIAtom* int64;
static nsIAtom* integer;
static nsIAtom* integrity;
static nsIAtom* intersection;
static nsIAtom* is;
static nsIAtom* iscontainer;
static nsIAtom* isempty;
static nsIAtom* ismap;
static nsIAtom* itemid;
static nsIAtom* itemprop;
static nsIAtom* itemref;
static nsIAtom* itemscope;
static nsIAtom* itemtype;
static nsIAtom* kbd;
static nsIAtom* keepcurrentinview;
static nsIAtom* keepobjectsalive;
static nsIAtom* key;
static nsIAtom* keycode;
static nsIAtom* keystatuseschange;
static nsIAtom* keydown;
static nsIAtom* keygen;
static nsIAtom* keypress;
static nsIAtom* keyset;
static nsIAtom* keysystem;
static nsIAtom* keytext;
static nsIAtom* keyup;
static nsIAtom* kind;
static nsIAtom* label;
static nsIAtom* lang;
static nsIAtom* language;
static nsIAtom* last;
static nsIAtom* layer;
static nsIAtom* LayerActivity;
static nsIAtom* layout;
static nsIAtom* leading;
static nsIAtom* leaf;
static nsIAtom* left;
static nsIAtom* leftmargin;
static nsIAtom* leftpadding;
static nsIAtom* legend;
static nsIAtom* length;
static nsIAtom* letterValue;
static nsIAtom* level;
static nsIAtom* li;
static nsIAtom* line;
static nsIAtom* link;
static nsIAtom* list;
static nsIAtom* listbox;
static nsIAtom* listboxbody;
static nsIAtom* listcell;
static nsIAtom* listcol;
static nsIAtom* listcols;
static nsIAtom* listener;
static nsIAtom* listhead;
static nsIAtom* listheader;
static nsIAtom* listing;
static nsIAtom* listitem;
static nsIAtom* listrows;
static nsIAtom* load;
static nsIAtom* loadingprincipal;
static nsIAtom* localedir;
static nsIAtom* localName;
static nsIAtom* longdesc;
static nsIAtom* loop;
static nsIAtom* low;
static nsIAtom* lowerFirst;
static nsIAtom* lowest;
static nsIAtom* lowsrc;
static nsIAtom* ltr;
static nsIAtom* lwtheme;
static nsIAtom* lwthemetextcolor;
static nsIAtom* main;
static nsIAtom* map;
static nsIAtom* manifest;
static nsIAtom* marginBottom;
static nsIAtom* marginLeft;
static nsIAtom* marginRight;
static nsIAtom* marginTop;
static nsIAtom* marginheight;
static nsIAtom* marginwidth;
static nsIAtom* mark;
static nsIAtom* marquee;
static nsIAtom* match;
static nsIAtom* max;
static nsIAtom* maxheight;
static nsIAtom* maximum_scale;
static nsIAtom* maxlength;
static nsIAtom* maxpos;
static nsIAtom* maxwidth;
static nsIAtom* mayscript;
static nsIAtom* media;
static nsIAtom* mediaType;
static nsIAtom* member;
static nsIAtom* menu;
static nsIAtom* menubar;
static nsIAtom* menubutton;
static nsIAtom* menuButton;
static nsIAtom* menugroup;
static nsIAtom* menuitem;
static nsIAtom* menulist;
static nsIAtom* menupopup;
static nsIAtom* menuseparator;
static nsIAtom* message;
static nsIAtom* meta;
static nsIAtom* referrer;
static nsIAtom* referrerpolicy;
static nsIAtom* headerReferrerPolicy;
static nsIAtom* meter;
static nsIAtom* method;
static nsIAtom* middle;
static nsIAtom* min;
static nsIAtom* minheight;
static nsIAtom* minimum_scale;
static nsIAtom* minlength;
static nsIAtom* minpos;
static nsIAtom* minusSign;
static nsIAtom* minwidth;
static nsIAtom* _mixed;
static nsIAtom* messagemanagergroup;
static nsIAtom* mod;
static nsIAtom* mode;
static nsIAtom* modifiers;
static nsIAtom* monochrome;
static nsIAtom* mousedown;
static nsIAtom* mousemove;
static nsIAtom* mouseout;
static nsIAtom* mouseover;
static nsIAtom* mousethrough;
static nsIAtom* mouseup;
static nsIAtom* mozaudiochannel;
static nsIAtom* mozfullscreenchange;
static nsIAtom* mozfullscreenerror;
static nsIAtom* mozpointerlockchange;
static nsIAtom* mozpointerlockerror;
static nsIAtom* mozprivatebrowsing;
static nsIAtom* moz_opaque;
static nsIAtom* moz_action_hint;
static nsIAtom* x_moz_errormessage;
static nsIAtom* msthemecompatible;
static nsIAtom* multicol;
static nsIAtom* multiple;
static nsIAtom* muted;
static nsIAtom* name;
static nsIAtom* _namespace;
static nsIAtom* namespaceAlias;
static nsIAtom* namespaceUri;
static nsIAtom* NaN;
static nsIAtom* nativeAnonymousChildList;
static nsIAtom* nav;
static nsIAtom* negate;
static nsIAtom* never;
static nsIAtom* _new;
static nsIAtom* newline;
static nsIAtom* nextBidi;
static nsIAtom* no;
static nsIAtom* noautofocus;
static nsIAtom* noautohide;
static nsIAtom* norolluponanchor;
static nsIAtom* nobr;
static nsIAtom* node;
static nsIAtom* nodefaultsrc;
static nsIAtom* nodeSet;
static nsIAtom* noembed;
static nsIAtom* noframes;
static nsIAtom* nohref;
static nsIAtom* noisolation;
static nsIAtom* nonce;
static nsIAtom* none;
static nsIAtom* noresize;
static nsIAtom* normal;
static nsIAtom* normalizeSpace;
static nsIAtom* noscript;
static nsIAtom* noshade;
static nsIAtom* novalidate;
static nsIAtom* _not;
static nsIAtom* nowrap;
static nsIAtom* number;
static nsIAtom* null;
static nsIAtom* object;
static nsIAtom* objectType;
static nsIAtom* observer;
static nsIAtom* observes;
static nsIAtom* odd;
static nsIAtom* OFF;
static nsIAtom* ol;
static nsIAtom* omitXmlDeclaration;
static nsIAtom* ona2dpstatuschanged;
static nsIAtom* onabort;
static nsIAtom* onmozaccesskeynotfound;
static nsIAtom* onactivate;
static nsIAtom* onadapteradded;
static nsIAtom* onadapterremoved;
static nsIAtom* onafterprint;
static nsIAtom* onafterscriptexecute;
static nsIAtom* onalerting;
static nsIAtom* onanimationcancel;
static nsIAtom* onanimationend;
static nsIAtom* onanimationiteration;
static nsIAtom* onanimationstart;
static nsIAtom* onantennaavailablechange;
static nsIAtom* onAppCommand;
static nsIAtom* onappinstalled;
static nsIAtom* onattributechanged;
static nsIAtom* onattributereadreq;
static nsIAtom* onattributewritereq;
static nsIAtom* onaudioprocess;
static nsIAtom* onauxclick;
static nsIAtom* onbeforecopy;
static nsIAtom* onbeforecut;
static nsIAtom* onbeforepaste;
static nsIAtom* onbeforeevicted;
static nsIAtom* onbeforeprint;
static nsIAtom* onbeforescriptexecute;
static nsIAtom* onbeforeunload;
static nsIAtom* onblocked;
static nsIAtom* onblur;
static nsIAtom* onbroadcast;
static nsIAtom* onbusy;
static nsIAtom* onbufferedamountlow;
static nsIAtom* oncached;
static nsIAtom* oncallschanged;
static nsIAtom* oncancel;
static nsIAtom* oncardstatechange;
static nsIAtom* oncfstatechange;
static nsIAtom* onchange;
static nsIAtom* oncharacteristicchanged;
static nsIAtom* onchargingchange;
static nsIAtom* onchargingtimechange;
static nsIAtom* onchecking;
static nsIAtom* onclick;
static nsIAtom* onclirmodechange;
static nsIAtom* onclose;
static nsIAtom* oncommand;
static nsIAtom* oncommandupdate;
static nsIAtom* oncomplete;
static nsIAtom* oncompositionend;
static nsIAtom* oncompositionstart;
static nsIAtom* oncompositionupdate;
static nsIAtom* onconnect;
static nsIAtom* onconnected;
static nsIAtom* onconnecting;
static nsIAtom* onconnectionavailable;
static nsIAtom* onconnectionstatechanged;
static nsIAtom* oncontextmenu;
static nsIAtom* oncopy;
static nsIAtom* oncurrentchannelchanged;
static nsIAtom* oncurrentsourcechanged;
static nsIAtom* oncut;
static nsIAtom* ondatachange;
static nsIAtom* ondataerror;
static nsIAtom* ondblclick;
static nsIAtom* ondeleted;
static nsIAtom* ondeliverysuccess;
static nsIAtom* ondeliveryerror;
static nsIAtom* ondevicefound;
static nsIAtom* ondevicepaired;
static nsIAtom* ondeviceunpaired;
static nsIAtom* ondialing;
static nsIAtom* ondisabled;
static nsIAtom* ondischargingtimechange;
static nsIAtom* ondisconnect;
static nsIAtom* ondisconnected;
static nsIAtom* ondisconnecting;
static nsIAtom* ondisplaypasskeyreq;
static nsIAtom* ondownloading;
static nsIAtom* onDOMActivate;
static nsIAtom* onDOMAttrModified;
static nsIAtom* onDOMCharacterDataModified;
static nsIAtom* onDOMFocusIn;
static nsIAtom* onDOMFocusOut;
static nsIAtom* onDOMMouseScroll;
static nsIAtom* onDOMNodeInserted;
static nsIAtom* onDOMNodeInsertedIntoDocument;
static nsIAtom* onDOMNodeRemoved;
static nsIAtom* onDOMNodeRemovedFromDocument;
static nsIAtom* onDOMSubtreeModified;
static nsIAtom* ondata;
static nsIAtom* ondrag;
static nsIAtom* ondragdrop;
static nsIAtom* ondragend;
static nsIAtom* ondragenter;
static nsIAtom* ondragexit;
static nsIAtom* ondraggesture;
static nsIAtom* ondragleave;
static nsIAtom* ondragover;
static nsIAtom* ondragstart;
static nsIAtom* ondrain;
static nsIAtom* ondrop;
static nsIAtom* oneitbroadcasted;
static nsIAtom* onenabled;
static nsIAtom* onenterpincodereq;
static nsIAtom* onemergencycbmodechange;
static nsIAtom* onerror;
static nsIAtom* onevicted;
static nsIAtom* onfailed;
static nsIAtom* onfetch;
static nsIAtom* onfinish;
static nsIAtom* onfocus;
static nsIAtom* onfocusin;
static nsIAtom* onfocusout;
static nsIAtom* onfrequencychange;
static nsIAtom* onfullscreenchange;
static nsIAtom* onfullscreenerror;
static nsIAtom* onspeakerforcedchange;
static nsIAtom* onget;
static nsIAtom* ongroupchange;
static nsIAtom* onhashchange;
static nsIAtom* onheadphoneschange;
static nsIAtom* onheld;
static nsIAtom* onhfpstatuschanged;
static nsIAtom* onhidstatuschanged;
static nsIAtom* onholding;
static nsIAtom* oniccchange;
static nsIAtom* oniccdetected;
static nsIAtom* oniccinfochange;
static nsIAtom* oniccundetected;
static nsIAtom* onincoming;
static nsIAtom* oninput;
static nsIAtom* oninstall;
static nsIAtom* oninvalid;
static nsIAtom* onkeydown;
static nsIAtom* onkeypress;
static nsIAtom* onkeyup;
static nsIAtom* onlanguagechange;
static nsIAtom* onlevelchange;
static nsIAtom* onLoad;
static nsIAtom* onload;
static nsIAtom* onloading;
static nsIAtom* onloadingdone;
static nsIAtom* onloadingerror;
static nsIAtom* onpopstate;
static nsIAtom* only;
static nsIAtom* onmessage;
static nsIAtom* onmousedown;
static nsIAtom* onmouseenter;
static nsIAtom* onmouseleave;
static nsIAtom* onmouselongtap;
static nsIAtom* onmousemove;
static nsIAtom* onmouseout;
static nsIAtom* onmouseover;
static nsIAtom* onMozMouseHittest;
static nsIAtom* onmouseup;
static nsIAtom* onMozAfterPaint;
static nsIAtom* onmozfullscreenchange;
static nsIAtom* onmozfullscreenerror;
static nsIAtom* onmozkeydownonplugin;
static nsIAtom* onmozkeyuponplugin;
static nsIAtom* onmozpointerlockchange;
static nsIAtom* onmozpointerlockerror;
static nsIAtom* onmoztimechange;
static nsIAtom* onMozMousePixelScroll;
static nsIAtom* onMozScrolledAreaChanged;
static nsIAtom* onmoznetworkupload;
static nsIAtom* onmoznetworkdownload;
static nsIAtom* onmapfolderlistingreq;
static nsIAtom* onmapmessageslistingreq;
static nsIAtom* onmapgetmessagereq;
static nsIAtom* onmapsetmessagestatusreq;
static nsIAtom* onmapsendmessagereq;
static nsIAtom* onmapmessageupdatereq;
static nsIAtom* onnewrdsgroup;
static nsIAtom* onnotificationclick;
static nsIAtom* onnotificationclose;
static nsIAtom* onnoupdate;
static nsIAtom* onobexpasswordreq;
static nsIAtom* onobsolete;
static nsIAtom* ononline;
static nsIAtom* onoffline;
static nsIAtom* onopen;
static nsIAtom* onorientationchange;
static nsIAtom* onotastatuschange;
static nsIAtom* onoverflow;
static nsIAtom* onoverflowchanged;
static nsIAtom* onpagehide;
static nsIAtom* onpageshow;
static nsIAtom* onpaint;
static nsIAtom* onpairingaborted;
static nsIAtom* onpairingconfirmationreq;
static nsIAtom* onpairingconsentreq;
static nsIAtom* onpaste;
static nsIAtom* onpendingchange;
static nsIAtom* onpichange;
static nsIAtom* onpointerlockchange;
static nsIAtom* onpointerlockerror;
static nsIAtom* onpopuphidden;
static nsIAtom* onpopuphiding;
static nsIAtom* onpopuppositioned;
static nsIAtom* onpopupshowing;
static nsIAtom* onpopupshown;
static nsIAtom* onpullphonebookreq;
static nsIAtom* onpullvcardentryreq;
static nsIAtom* onpullvcardlistingreq;
static nsIAtom* onpush;
static nsIAtom* onpushsubscriptionchange;
static nsIAtom* onpschange;
static nsIAtom* onptychange;
static nsIAtom* onradiostatechange;
static nsIAtom* onrdsdisabled;
static nsIAtom* onrdsenabled;
static nsIAtom* onreaderror;
static nsIAtom* onreadsuccess;
static nsIAtom* onready;
static nsIAtom* onreadystatechange;
static nsIAtom* onreceived;
static nsIAtom* onremoteheld;
static nsIAtom* onremoteresumed;
static nsIAtom* onrequestprogress;
static nsIAtom* onresourcetimingbufferfull;
static nsIAtom* onresponseprogress;
static nsIAtom* onretrieving;
static nsIAtom* onRequest;
static nsIAtom* onrequestmediaplaystatus;
static nsIAtom* onreset;
static nsIAtom* onresuming;
static nsIAtom* onresize;
static nsIAtom* onrtchange;
static nsIAtom* onscanningstatechanged;
static nsIAtom* onscostatuschanged;
static nsIAtom* onscroll;
static nsIAtom* onselect;
static nsIAtom* onselectionchange;
static nsIAtom* onselectstart;
static nsIAtom* onsending;
static nsIAtom* onsent;
static nsIAtom* onset;
static nsIAtom* onshow;
static nsIAtom* onstatechange;
static nsIAtom* onstatuschanged;
static nsIAtom* onstkcommand;
static nsIAtom* onstksessionend;
static nsIAtom* onstorage;
static nsIAtom* onstorageareachanged;
static nsIAtom* onsubmit;
static nsIAtom* onsuccess;
static nsIAtom* ontypechange;
static nsIAtom* onterminate;
static nsIAtom* ontext;
static nsIAtom* ontoggle;
static nsIAtom* ontouchstart;
static nsIAtom* ontouchend;
static nsIAtom* ontouchmove;
static nsIAtom* ontouchcancel;
static nsIAtom* ontransitioncancel;
static nsIAtom* ontransitionend;
static nsIAtom* ontransitionrun;
static nsIAtom* ontransitionstart;
static nsIAtom* onunderflow;
static nsIAtom* onunload;
static nsIAtom* onupdatefound;
static nsIAtom* onupdateready;
static nsIAtom* onupgradeneeded;
static nsIAtom* onussdreceived;
static nsIAtom* onversionchange;
static nsIAtom* onvoicechange;
static nsIAtom* onvoiceschanged;
static nsIAtom* onvrdisplayactivate;
static nsIAtom* onvrdisplayconnect;
static nsIAtom* onvrdisplaydeactivate;
static nsIAtom* onvrdisplaydisconnect;
static nsIAtom* onvrdisplaypresentchange;
static nsIAtom* onwebkitAnimationEnd;
static nsIAtom* onwebkitAnimationIteration;
static nsIAtom* onwebkitAnimationStart;
static nsIAtom* onwebkitTransitionEnd;
static nsIAtom* onwebkitanimationend;
static nsIAtom* onwebkitanimationiteration;
static nsIAtom* onwebkitanimationstart;
static nsIAtom* onwebkittransitionend;
static nsIAtom* onwebsocket;
static nsIAtom* onwheel;
static nsIAtom* open;
static nsIAtom* optgroup;
static nsIAtom* optimum;
static nsIAtom* option;
static nsIAtom* _or;
static nsIAtom* order;
static nsIAtom* ordinal;
static nsIAtom* orient;
static nsIAtom* orientation;
static nsIAtom* otherwise;
static nsIAtom* output;
static nsIAtom* overflow;
static nsIAtom* overflowchanged;
static nsIAtom* overlay;
static nsIAtom* overlap;
static nsIAtom* p;
static nsIAtom* pack;
static nsIAtom* page;
static nsIAtom* pageincrement;
static nsIAtom* pagex;
static nsIAtom* pagey;
static nsIAtom* paint_order;
static nsIAtom* palettename;
static nsIAtom* panel;
static nsIAtom* param;
static nsIAtom* parameter;
static nsIAtom* parent;
static nsIAtom* parentfocused;
static nsIAtom* parsetype;
static nsIAtom* password;
static nsIAtom* pattern;
static nsIAtom* patternSeparator;
static nsIAtom* perMille;
static nsIAtom* percent;
static nsIAtom* persist;
static nsIAtom* phase;
static nsIAtom* picture;
static nsIAtom* ping;
static nsIAtom* pinned;
static nsIAtom* placeholder;
static nsIAtom* plaintext;
static nsIAtom* playbackrate;
static nsIAtom* pointSize;
static nsIAtom* pointerlockchange;
static nsIAtom* pointerlockerror;
static nsIAtom* poly;
static nsIAtom* polygon;
static nsIAtom* popup;
static nsIAtom* popupalign;
static nsIAtom* popupanchor;
static nsIAtom* popupgroup;
static nsIAtom* popuphidden;
static nsIAtom* popuphiding;
static nsIAtom* popupset;
static nsIAtom* popupshowing;
static nsIAtom* popupshown;
static nsIAtom* popupsinherittooltip;
static nsIAtom* position;
static nsIAtom* poster;
static nsIAtom* pre;
static nsIAtom* preceding;
static nsIAtom* precedingSibling;
static nsIAtom* predicate;
static nsIAtom* prefix;
static nsIAtom* preload;
static nsIAtom* prerendered;
static nsIAtom* mozpresentation;
static nsIAtom* preserve;
static nsIAtom* preserveSpace;
static nsIAtom* preventdefault;
static nsIAtom* primary;
static nsIAtom* print;
static nsIAtom* priority;
static nsIAtom* processingInstruction;
static nsIAtom* profile;
static nsIAtom* progress;
static nsIAtom* progressmeter;
static nsIAtom* progressNormal;
static nsIAtom* progressUndetermined;
static nsIAtom* projection;
static nsIAtom* prompt;
static nsIAtom* propagate;
static nsIAtom* properties;
static nsIAtom* property;
static nsIAtom* pubdate;
static nsIAtom* q;
static nsIAtom* query;
static nsIAtom* queryset;
static nsIAtom* querytype;
static nsIAtom* radio;
static nsIAtom* radiogroup;
static nsIAtom* range;
static nsIAtom* readonly;
static nsIAtom* rect;
static nsIAtom* rectangle;
static nsIAtom* ref;
static nsIAtom* refresh;
static nsIAtom* rel;
static nsIAtom* onreloadpage;
static nsIAtom* rem;
static nsIAtom* removeelement;
static nsIAtom* renderingobserverlist;
static nsIAtom* repeat;
static nsIAtom* replace;
static nsIAtom* required;
static nsIAtom* reserved;
static nsIAtom* reset;
static nsIAtom* resizeafter;
static nsIAtom* resizebefore;
static nsIAtom* resizer;
static nsIAtom* resolution;
static nsIAtom* resource;
static nsIAtom* resources;
static nsIAtom* result;
static nsIAtom* resultPrefix;
static nsIAtom* retargetdocumentfocus;
static nsIAtom* rev;
static nsIAtom* reverse;
static nsIAtom* reversed;
static nsIAtom* richlistbox;
static nsIAtom* richlistitem;
static nsIAtom* right;
static nsIAtom* rightmargin;
static nsIAtom* rightpadding;
static nsIAtom* role;
static nsIAtom* rolluponmousewheel;
static nsIAtom* round;
static nsIAtom* row;
static nsIAtom* rows;
static nsIAtom* rowspan;
static nsIAtom* rb;
static nsIAtom* rp;
static nsIAtom* rt;
static nsIAtom* rtc;
static nsIAtom* rtl;
static nsIAtom* ruby;
static nsIAtom* rubyBase;
static nsIAtom* rubyBaseContainer;
static nsIAtom* rubyText;
static nsIAtom* rubyTextContainer;
static nsIAtom* rule;
static nsIAtom* rules;
static nsIAtom* s;
static nsIAtom* samp;
static nsIAtom* sandbox;
static nsIAtom* sbattr;
static nsIAtom* scale;
static nsIAtom* scan;
static nsIAtom* scheme;
static nsIAtom* scope;
static nsIAtom* scoped;
static nsIAtom* screen;
static nsIAtom* screenX;
static nsIAtom* screenY;
static nsIAtom* script;
static nsIAtom* scriptEnabledBeforePrintOrPreview;
static nsIAtom* scrollbar;
static nsIAtom* scrollbarbutton;
static nsIAtom* scrollbarDownBottom;
static nsIAtom* scrollbarDownTop;
static nsIAtom* scrollbarUpBottom;
static nsIAtom* scrollbarUpTop;
static nsIAtom* scrollbox;
static nsIAtom* scrollcorner;
static nsIAtom* scrolling;
static nsIAtom* scrollPosition;
static nsIAtom* section;
static nsIAtom* select;
static nsIAtom* selectable;
static nsIAtom* selected;
static nsIAtom* selectedIndex;
static nsIAtom* selectedindex;
static nsIAtom* self;
static nsIAtom* seltype;
static nsIAtom* setcookie;
static nsIAtom* setter;
static nsIAtom* shape;
static nsIAtom* show;
static nsIAtom* showcaret;
static nsIAtom* showresizer;
static nsIAtom* simple;
static nsIAtom* single;
static nsIAtom* size;
static nsIAtom* sizes;
static nsIAtom* sizemode;
static nsIAtom* sizetopopup;
static nsIAtom* slider;
static nsIAtom* small;
static nsIAtom* smooth;
static nsIAtom* snap;
static nsIAtom* sort;
static nsIAtom* sortActive;
static nsIAtom* sortDirection;
static nsIAtom* sorted;
static nsIAtom* sorthints;
static nsIAtom* sortLocked;
static nsIAtom* sortResource;
static nsIAtom* sortResource2;
static nsIAtom* sortSeparators;
static nsIAtom* sortStaticsLast;
static nsIAtom* source;
static nsIAtom* space;
static nsIAtom* spacer;
static nsIAtom* span;
static nsIAtom* spellcheck;
static nsIAtom* spinner;
static nsIAtom* split;
static nsIAtom* splitter;
static nsIAtom* spring;
static nsIAtom* src;
static nsIAtom* srcdoc;
static nsIAtom* srclang;
static nsIAtom* srcset;
static nsIAtom* stack;
static nsIAtom* standalone;
static nsIAtom* standby;
static nsIAtom* start;
static nsIAtom* start_after;
static nsIAtom* start_before;
static nsIAtom* startsWith;
static nsIAtom* state;
static nsIAtom* statedatasource;
static nsIAtom* staticHint;
static nsIAtom* statusbar;
static nsIAtom* statustext;
static nsIAtom* step;
static nsIAtom* stop;
static nsIAtom* stretch;
static nsIAtom* strike;
static nsIAtom* string;
static nsIAtom* stringLength;
static nsIAtom* stripSpace;
static nsIAtom* strong;
static nsIAtom* style;
static nsIAtom* stylesheet;
static nsIAtom* stylesheetPrefix;
static nsIAtom* subject;
static nsIAtom* submit;
static nsIAtom* substate;
static nsIAtom* substring;
static nsIAtom* substringAfter;
static nsIAtom* substringBefore;
static nsIAtom* sub;
static nsIAtom* sum;
static nsIAtom* sup;
static nsIAtom* summary;
static nsIAtom* systemProperty;
static nsIAtom* tab;
static nsIAtom* tabbox;
static nsIAtom* tabindex;
static nsIAtom* table;
static nsIAtom* tabpanel;
static nsIAtom* tabpanels;
static nsIAtom* tag;
static nsIAtom* target;
static nsIAtom* targets;
static nsIAtom* tbody;
static nsIAtom* td;
static nsIAtom* _template;
static nsIAtom* text_decoration;
static nsIAtom* terminate;
static nsIAtom* test;
static nsIAtom* text;
static nsIAtom* textAlign;
static nsIAtom* textarea;
static nsIAtom* textbox;
static nsIAtom* textnode;
static nsIAtom* textNodeDirectionalityMap;
static nsIAtom* tfoot;
static nsIAtom* th;
static nsIAtom* thead;
static nsIAtom* thumb;
static nsIAtom* time;
static nsIAtom* title;
static nsIAtom* titlebar;
static nsIAtom* titletip;
static nsIAtom* toggled;
static nsIAtom* token;
static nsIAtom* tokenize;
static nsIAtom* toolbar;
static nsIAtom* toolbarbutton;
static nsIAtom* toolbaritem;
static nsIAtom* toolbox;
static nsIAtom* tooltip;
static nsIAtom* tooltiptext;
static nsIAtom* top;
static nsIAtom* topleft;
static nsIAtom* topmargin;
static nsIAtom* toppadding;
static nsIAtom* topright;
static nsIAtom* tr;
static nsIAtom* track;
static nsIAtom* trailing;
static nsIAtom* transform;
static nsIAtom* transform_3d;
static nsIAtom* transformiix;
static nsIAtom* translate;
static nsIAtom* transparent;
static nsIAtom* tree;
static nsIAtom* treecell;
static nsIAtom* treechildren;
static nsIAtom* treecol;
static nsIAtom* treecolpicker;
static nsIAtom* treecols;
static nsIAtom* treeitem;
static nsIAtom* treerow;
static nsIAtom* treeseparator;
static nsIAtom* triple;
static nsIAtom* _true;
static nsIAtom* tt;
static nsIAtom* tty;
static nsIAtom* tv;
static nsIAtom* type;
static nsIAtom* typemustmatch;
static nsIAtom* u;
static nsIAtom* ul;
static nsIAtom* underflow;
static nsIAtom* undetermined;
static nsIAtom* unload;
static nsIAtom* unparsedEntityUri;
static nsIAtom* upperFirst;
static nsIAtom* uri;
static nsIAtom* use;
static nsIAtom* useAttributeSets;
static nsIAtom* usemap;
static nsIAtom* user_scalable;
static nsIAtom* userInput;
static nsIAtom* validate;
static nsIAtom* valign;
static nsIAtom* value;
static nsIAtom* values;
static nsIAtom* valueOf;
static nsIAtom* valuetype;
static nsIAtom* var;
static nsIAtom* variable;
static nsIAtom* vbox;
static nsIAtom* vcard_name;
static nsIAtom* vendor;
static nsIAtom* vendorUrl;
static nsIAtom* version;
static nsIAtom* vert;
static nsIAtom* vertical;
static nsIAtom* audio;
static nsIAtom* video;
static nsIAtom* videocontrols;
static nsIAtom* viewport;
static nsIAtom* viewport_height;
static nsIAtom* viewport_initial_scale;
static nsIAtom* viewport_maximum_scale;
static nsIAtom* viewport_minimum_scale;
static nsIAtom* viewport_user_scalable;
static nsIAtom* viewport_width;
static nsIAtom* visibility;
static nsIAtom* visuallyselected;
static nsIAtom* vlink;
static nsIAtom* vspace;
static nsIAtom* wbr;
static nsIAtom* webkitdirectory;
static nsIAtom* when;
static nsIAtom* where;
static nsIAtom* widget;
static nsIAtom* width;
static nsIAtom* willChange;
static nsIAtom* window;
static nsIAtom* headerWindowTarget;
static nsIAtom* windowtype;
static nsIAtom* withParam;
static nsIAtom* wizard;
static nsIAtom* wrap;
static nsIAtom* headerDNSPrefetchControl;
static nsIAtom* headerCSP;
static nsIAtom* headerCSPReportOnly;
static nsIAtom* headerXFO;
static nsIAtom* x_western;
static nsIAtom* xml;
static nsIAtom* xml_stylesheet;
static nsIAtom* xmlns;
static nsIAtom* xmp;
static nsIAtom* xulcontentsgenerated;
static nsIAtom* yes;
static nsIAtom* z_index;
static nsIAtom* zeroDigit;


static nsIAtom* percentage;
static nsIAtom* A;
static nsIAtom* alignment_baseline;
static nsIAtom* amplitude;
static nsIAtom* animate;
static nsIAtom* animateColor;
static nsIAtom* animateMotion;
static nsIAtom* animateTransform;
static nsIAtom* arithmetic;
static nsIAtom* atop;
static nsIAtom* azimuth;
static nsIAtom* B;
static nsIAtom* backgroundColor;
static nsIAtom* background_image;
static nsIAtom* baseFrequency;
static nsIAtom* baseline_shift;
static nsIAtom* bias;
static nsIAtom* caption_side;
static nsIAtom* clip_path;
static nsIAtom* clip_rule;
static nsIAtom* clipPath;
static nsIAtom* clipPathUnits;
static nsIAtom* cm;
static nsIAtom* colorBurn;
static nsIAtom* colorDodge;
static nsIAtom* colorInterpolation;
static nsIAtom* colorInterpolationFilters;
static nsIAtom* colorProfile;
static nsIAtom* cursor;
static nsIAtom* cx;
static nsIAtom* cy;
static nsIAtom* d;
static nsIAtom* darken;
static nsIAtom* defs;
static nsIAtom* deg;
static nsIAtom* desc;
static nsIAtom* diffuseConstant;
static nsIAtom* dilate;
static nsIAtom* direction;
static nsIAtom* disable;
static nsIAtom* discrete;
static nsIAtom* divisor;
static nsIAtom* dominant_baseline;
static nsIAtom* duplicate;
static nsIAtom* dx;
static nsIAtom* dy;
static nsIAtom* edgeMode;
static nsIAtom* ellipse;
static nsIAtom* elevation;
static nsIAtom* erode;
static nsIAtom* ex;
static nsIAtom* exact;
static nsIAtom* exclusion;
static nsIAtom* exponent;
static nsIAtom* feBlend;
static nsIAtom* feColorMatrix;
static nsIAtom* feComponentTransfer;
static nsIAtom* feComposite;
static nsIAtom* feConvolveMatrix;
static nsIAtom* feDiffuseLighting;
static nsIAtom* feDisplacementMap;
static nsIAtom* feDistantLight;
static nsIAtom* feDropShadow;
static nsIAtom* feFlood;
static nsIAtom* feFuncA;
static nsIAtom* feFuncB;
static nsIAtom* feFuncG;
static nsIAtom* feFuncR;
static nsIAtom* feGaussianBlur;
static nsIAtom* feImage;
static nsIAtom* feMerge;
static nsIAtom* feMergeNode;
static nsIAtom* feMorphology;
static nsIAtom* feOffset;
static nsIAtom* fePointLight;
static nsIAtom* feSpecularLighting;
static nsIAtom* feSpotLight;
static nsIAtom* feTile;
static nsIAtom* feTurbulence;
static nsIAtom* fill;
static nsIAtom* fill_opacity;
static nsIAtom* fill_rule;
static nsIAtom* filter;
static nsIAtom* filterUnits;
static nsIAtom* _float;
static nsIAtom* flood_color;
static nsIAtom* flood_opacity;
static nsIAtom* font_face;
static nsIAtom* font_face_format;
static nsIAtom* font_face_name;
static nsIAtom* font_face_src;
static nsIAtom* font_face_uri;
static nsIAtom* font_family;
static nsIAtom* font_size;
static nsIAtom* font_size_adjust;
static nsIAtom* font_stretch;
static nsIAtom* font_style;
static nsIAtom* font_variant;
static nsIAtom* foreignObject;
static nsIAtom* fractalNoise;
static nsIAtom* fx;
static nsIAtom* fy;
static nsIAtom* G;
static nsIAtom* g;
static nsIAtom* gamma;

static nsIAtom* generic_;
static nsIAtom* glyphRef;
static nsIAtom* grad;
static nsIAtom* gradientTransform;
static nsIAtom* gradientUnits;
static nsIAtom* hardLight;
static nsIAtom* hue;
static nsIAtom* hueRotate;
static nsIAtom* identity;
static nsIAtom* image_rendering;
static nsIAtom* in;
static nsIAtom* in2;
static nsIAtom* intercept;
static nsIAtom* k1;
static nsIAtom* k2;
static nsIAtom* k3;
static nsIAtom* k4;
static nsIAtom* kernelMatrix;
static nsIAtom* kernelUnitLength;
static nsIAtom* lengthAdjust;
static nsIAtom* letter_spacing;
static nsIAtom* lighten;
static nsIAtom* lighting_color;
static nsIAtom* limitingConeAngle;
static nsIAtom* linear;
static nsIAtom* linearGradient;
static nsIAtom* linearRGB;
static nsIAtom* list_style_type;
static nsIAtom* luminanceToAlpha;
static nsIAtom* luminosity;
static nsIAtom* magnify;
static nsIAtom* marker;
static nsIAtom* marker_end;
static nsIAtom* marker_mid;
static nsIAtom* marker_start;
static nsIAtom* markerHeight;
static nsIAtom* markerUnits;
static nsIAtom* markerWidth;
static nsIAtom* mask;
static nsIAtom* maskContentUnits;
static nsIAtom* mask_type;
static nsIAtom* maskUnits;
static nsIAtom* matrix;
static nsIAtom* metadata;
static nsIAtom* missingGlyph;
static nsIAtom* mm;
static nsIAtom* mpath;
static nsIAtom* noStitch;
static nsIAtom* numOctaves;
static nsIAtom* multiply;
static nsIAtom* objectBoundingBox;
static nsIAtom* offset;
static nsIAtom* onSVGLoad;
static nsIAtom* onSVGResize;
static nsIAtom* onSVGScroll;
static nsIAtom* onSVGUnload;
static nsIAtom* onSVGZoom;
static nsIAtom* onzoom;
static nsIAtom* opacity;
static nsIAtom* _operator;
static nsIAtom* out;
static nsIAtom* over;
static nsIAtom* overridePreserveAspectRatio;
static nsIAtom* pad;
static nsIAtom* path;
static nsIAtom* pathLength;
static nsIAtom* patternContentUnits;
static nsIAtom* patternTransform;
static nsIAtom* patternUnits;
static nsIAtom* pc;
static nsIAtom* pointer_events;
static nsIAtom* points;
static nsIAtom* pointsAtX;
static nsIAtom* pointsAtY;
static nsIAtom* pointsAtZ;
static nsIAtom* polyline;
static nsIAtom* preserveAlpha;
static nsIAtom* preserveAspectRatio;
static nsIAtom* primitiveUnits;
static nsIAtom* pt;
static nsIAtom* px;
static nsIAtom* R;
static nsIAtom* r;
static nsIAtom* rad;
static nsIAtom* radialGradient;
static nsIAtom* radius;
static nsIAtom* reflect;
static nsIAtom* refX;
static nsIAtom* refY;
static nsIAtom* requiredExtensions;
static nsIAtom* requiredFeatures;
static nsIAtom* rotate;
static nsIAtom* rx;
static nsIAtom* ry;
static nsIAtom* saturate;
static nsIAtom* saturation;
static nsIAtom* set;
static nsIAtom* seed;
static nsIAtom* shadow;
static nsIAtom* shape_rendering;
static nsIAtom* skewX;
static nsIAtom* skewY;
static nsIAtom* slope;
static nsIAtom* softLight;
static nsIAtom* spacing;
static nsIAtom* spacingAndGlyphs;
static nsIAtom* specularConstant;
static nsIAtom* specularExponent;
static nsIAtom* spreadMethod;
static nsIAtom* sRGB;
static nsIAtom* startOffset;
static nsIAtom* stdDeviation;
static nsIAtom* stitch;
static nsIAtom* stitchTiles;
static nsIAtom* stop_color;
static nsIAtom* stop_opacity;
static nsIAtom* stroke;
static nsIAtom* stroke_dasharray;
static nsIAtom* stroke_dashoffset;
static nsIAtom* stroke_linecap;
static nsIAtom* stroke_linejoin;
static nsIAtom* stroke_miterlimit;
static nsIAtom* stroke_opacity;
static nsIAtom* stroke_width;
static nsIAtom* strokeWidth;
static nsIAtom* surfaceScale;
static nsIAtom* svg;
static nsIAtom* svgContextPaint;
static nsIAtom* svgSwitch;
static nsIAtom* symbol;
static nsIAtom* systemLanguage;
static nsIAtom* tableValues;
static nsIAtom* targetX;
static nsIAtom* targetY;
static nsIAtom* text_anchor;
static nsIAtom* text_rendering;
static nsIAtom* textLength;
static nsIAtom* textPath;
static nsIAtom* tref;
static nsIAtom* tspan;
static nsIAtom* turbulence;
static nsIAtom* unicode_bidi;
static nsIAtom* userSpaceOnUse;
static nsIAtom* view;
static nsIAtom* viewBox;
static nsIAtom* viewTarget;
static nsIAtom* white_space;
static nsIAtom* word_spacing;
static nsIAtom* writing_mode;
static nsIAtom* x;
static nsIAtom* x1;
static nsIAtom* x2;
static nsIAtom* xChannelSelector;
static nsIAtom* xor_;
static nsIAtom* y;
static nsIAtom* y1;
static nsIAtom* y2;
static nsIAtom* yChannelSelector;
static nsIAtom* z;
static nsIAtom* zoomAndPan;
static nsIAtom* vector_effect;
static nsIAtom* vertical_align;

static nsIAtom* accumulate;
static nsIAtom* additive;
static nsIAtom* attributeName;
static nsIAtom* attributeType;
static nsIAtom* auto_reverse;
static nsIAtom* begin;
static nsIAtom* beginEvent;
static nsIAtom* by;
static nsIAtom* calcMode;
static nsIAtom* css;
static nsIAtom* dur;
static nsIAtom* keyPoints;
static nsIAtom* keySplines;
static nsIAtom* keyTimes;
static nsIAtom* mozAnimateMotionDummyAttr;
static nsIAtom* onbegin;
static nsIAtom* onbeginEvent;
static nsIAtom* onend;
static nsIAtom* onendEvent;
static nsIAtom* onrepeat;
static nsIAtom* onrepeatEvent;
static nsIAtom* repeatCount;
static nsIAtom* repeatDur;
static nsIAtom* repeatEvent;
static nsIAtom* restart;
static nsIAtom* to;
static nsIAtom* XML;

static nsIAtom* abs_;
static nsIAtom* accent_;
static nsIAtom* accentunder_;
static nsIAtom* actiontype_;
static nsIAtom* alignmentscope_;
static nsIAtom* altimg_;
static nsIAtom* altimg_height_;
static nsIAtom* altimg_valign_;
static nsIAtom* altimg_width_;
static nsIAtom* annotation_;
static nsIAtom* annotation_xml_;
static nsIAtom* apply_;
static nsIAtom* approx_;
static nsIAtom* arccos_;
static nsIAtom* arccosh_;
static nsIAtom* arccot_;
static nsIAtom* arccoth_;
static nsIAtom* arccsc_;
static nsIAtom* arccsch_;
static nsIAtom* arcsec_;
static nsIAtom* arcsech_;
static nsIAtom* arcsin_;
static nsIAtom* arcsinh_;
static nsIAtom* arctan_;
static nsIAtom* arctanh_;
static nsIAtom* arg_;
static nsIAtom* bevelled_;
static nsIAtom* bind_;
static nsIAtom* bvar_;
static nsIAtom* card_;
static nsIAtom* cartesianproduct_;
static nsIAtom* cbytes_;
static nsIAtom* cd_;
static nsIAtom* cdgroup_;
static nsIAtom* cerror_;
static nsIAtom* charalign_;
static nsIAtom* ci_;
static nsIAtom* closure_;
static nsIAtom* cn_;
static nsIAtom* codomain_;
static nsIAtom* columnalign_;
static nsIAtom* columnalignment_;
static nsIAtom* columnlines_;
static nsIAtom* columnspacing_;
static nsIAtom* columnspan_;
static nsIAtom* columnwidth_;
static nsIAtom* complexes_;
static nsIAtom* compose_;
static nsIAtom* condition_;
static nsIAtom* conjugate_;
static nsIAtom* cos_;
static nsIAtom* cosh_;
static nsIAtom* cot_;
static nsIAtom* coth_;
static nsIAtom* crossout_;
static nsIAtom* csc_;
static nsIAtom* csch_;
static nsIAtom* cs_;
static nsIAtom* csymbol_;
static nsIAtom* curl_;
static nsIAtom* decimalpoint_;
static nsIAtom* definitionURL_;
static nsIAtom* degree_;
static nsIAtom* denomalign_;
static nsIAtom* depth_;
static nsIAtom* determinant_;
static nsIAtom* diff_;
static nsIAtom* displaystyle_;
static nsIAtom* divergence_;
static nsIAtom* divide_;
static nsIAtom* domain_;
static nsIAtom* domainofapplication_;
static nsIAtom* edge_;
static nsIAtom* el_;
static nsIAtom* emptyset_;
static nsIAtom* eq_;
static nsIAtom* equalcolumns_;
static nsIAtom* equalrows_;
static nsIAtom* equivalent_;
static nsIAtom* eulergamma_;
static nsIAtom* exists_;
static nsIAtom* exp_;
static nsIAtom* exponentiale_;
static nsIAtom* factorial_;
static nsIAtom* factorof_;
static nsIAtom* fence_;
static nsIAtom* fn_;
static nsIAtom* fontfamily_;
static nsIAtom* fontsize_;
static nsIAtom* fontstyle_;
static nsIAtom* fontweight_;
static nsIAtom* forall_;
static nsIAtom* framespacing_;
static nsIAtom* gcd_;
static nsIAtom* geq_;
static nsIAtom* groupalign_;
static nsIAtom* gt_;
static nsIAtom* ident_;
static nsIAtom* imaginaryi_;
static nsIAtom* imaginary_;
static nsIAtom* implies_;
static nsIAtom* indentalignfirst_;
static nsIAtom* indentalign_;
static nsIAtom* indentalignlast_;
static nsIAtom* indentshiftfirst_;
static nsIAtom* indentshift_;
static nsIAtom* indenttarget_;
static nsIAtom* integers_;
static nsIAtom* intersect_;
static nsIAtom* interval_;
static nsIAtom* int_;
static nsIAtom* inverse_;
static nsIAtom* lambda_;
static nsIAtom* laplacian_;
static nsIAtom* largeop_;
static nsIAtom* lcm_;
static nsIAtom* leq_;
static nsIAtom* limit_;
static nsIAtom* linebreak_;
static nsIAtom* linebreakmultchar_;
static nsIAtom* linebreakstyle_;
static nsIAtom* linethickness_;
static nsIAtom* list_;
static nsIAtom* ln_;
static nsIAtom* location_;
static nsIAtom* logbase_;
static nsIAtom* log_;
static nsIAtom* longdivstyle_;
static nsIAtom* lowlimit_;
static nsIAtom* lquote_;
static nsIAtom* lspace_;
static nsIAtom* lt_;
static nsIAtom* maction_;
static nsIAtom* maligngroup_;
static nsIAtom* malignmark_;
static nsIAtom* mathbackground_;
static nsIAtom* mathcolor_;
static nsIAtom* mathsize_;
static nsIAtom* mathvariant_;
static nsIAtom* matrixrow_;
static nsIAtom* maxsize_;
static nsIAtom* mean_;
static nsIAtom* median_;
static nsIAtom* menclose_;
static nsIAtom* merror_;
static nsIAtom* mfenced_;
static nsIAtom* mfrac_;
static nsIAtom* mglyph_;
static nsIAtom* mi_;
static nsIAtom* minlabelspacing_;
static nsIAtom* minsize_;
static nsIAtom* minus_;
static nsIAtom* mlabeledtr_;
static nsIAtom* mlongdiv_;
static nsIAtom* mmultiscripts_;
static nsIAtom* mn_;
static nsIAtom* momentabout_;
static nsIAtom* moment_;
static nsIAtom* mo_;
static nsIAtom* movablelimits_;
static nsIAtom* mover_;
static nsIAtom* mpadded_;
static nsIAtom* mphantom_;
static nsIAtom* mprescripts_;
static nsIAtom* mroot_;
static nsIAtom* mrow_;
static nsIAtom* mscarries_;
static nsIAtom* mscarry_;
static nsIAtom* msgroup_;
static nsIAtom* msline_;
static nsIAtom* ms_;
static nsIAtom* mspace_;
static nsIAtom* msqrt_;
static nsIAtom* msrow_;
static nsIAtom* mstack_;
static nsIAtom* mstyle_;
static nsIAtom* msub_;
static nsIAtom* msubsup_;
static nsIAtom* msup_;
static nsIAtom* mtable_;
static nsIAtom* mtd_;
static nsIAtom* mtext_;
static nsIAtom* mtr_;
static nsIAtom* munder_;
static nsIAtom* munderover_;
static nsIAtom* naturalnumbers_;
static nsIAtom* neq_;
static nsIAtom* notanumber_;
static nsIAtom* notation_;
static nsIAtom* note_;
static nsIAtom* notin_;
static nsIAtom* notprsubset_;
static nsIAtom* notsubset_;
static nsIAtom* numalign_;
static nsIAtom* other_;
static nsIAtom* outerproduct_;
static nsIAtom* partialdiff_;
static nsIAtom* piece_;
static nsIAtom* piecewise_;
static nsIAtom* pi_;
static nsIAtom* plus_;
static nsIAtom* power_;
static nsIAtom* primes_;
static nsIAtom* product_;
static nsIAtom* prsubset_;
static nsIAtom* quotient_;
static nsIAtom* rationals_;
static nsIAtom* real_;
static nsIAtom* reals_;
static nsIAtom* reln_;
static nsIAtom* root_;
static nsIAtom* rowalign_;
static nsIAtom* rowlines_;
static nsIAtom* rowspacing_;
static nsIAtom* rquote_;
static nsIAtom* rspace_;
static nsIAtom* scalarproduct_;
static nsIAtom* schemaLocation_;
static nsIAtom* scriptlevel_;
static nsIAtom* scriptminsize_;
static nsIAtom* scriptsizemultiplier_;
static nsIAtom* scriptsize_;
static nsIAtom* sdev_;
static nsIAtom* sech_;
static nsIAtom* sec_;
static nsIAtom* selection_;
static nsIAtom* selector_;
static nsIAtom* semantics_;
static nsIAtom* separator_;
static nsIAtom* separators_;
static nsIAtom* sep_;
static nsIAtom* setdiff_;
static nsIAtom* set_;
static nsIAtom* share_;
static nsIAtom* shift_;
static nsIAtom* side_;
static nsIAtom* sinh_;
static nsIAtom* sin_;
static nsIAtom* stackalign_;
static nsIAtom* stretchy_;
static nsIAtom* subscriptshift_;
static nsIAtom* subset_;
static nsIAtom* superscriptshift_;
static nsIAtom* symmetric_;
static nsIAtom* tanh_;
static nsIAtom* tan_;
static nsIAtom* tendsto_;
static nsIAtom* times_;
static nsIAtom* transpose_;
static nsIAtom* union_;
static nsIAtom* uplimit_;
static nsIAtom* variance_;
static nsIAtom* vectorproduct_;
static nsIAtom* vector_;
static nsIAtom* voffset_;
static nsIAtom* xref_;
static nsIAtom* math;
static nsIAtom* avg;
static nsIAtom* booleanFromString;
static nsIAtom* countNonEmpty;
static nsIAtom* daysFromDate;
static nsIAtom* init;
static nsIAtom* instance;
static nsIAtom* months;
static nsIAtom* now;
static nsIAtom* seconds;
static nsIAtom* secondsFromDateTime;


static nsIAtom* onMozSwipeGestureMayStart;
static nsIAtom* onMozSwipeGestureStart;
static nsIAtom* onMozSwipeGestureUpdate;
static nsIAtom* onMozSwipeGestureEnd;
static nsIAtom* onMozSwipeGesture;
static nsIAtom* onMozMagnifyGestureStart;
static nsIAtom* onMozMagnifyGestureUpdate;
static nsIAtom* onMozMagnifyGesture;
static nsIAtom* onMozRotateGestureStart;
static nsIAtom* onMozRotateGestureUpdate;
static nsIAtom* onMozRotateGesture;
static nsIAtom* onMozTapGesture;
static nsIAtom* onMozPressTapGesture;
static nsIAtom* onMozEdgeUIStarted;
static nsIAtom* onMozEdgeUICanceled;
static nsIAtom* onMozEdgeUICompleted;


static nsIAtom* onpointerdown;
static nsIAtom* onpointermove;
static nsIAtom* onpointerup;
static nsIAtom* onpointercancel;
static nsIAtom* onpointerover;
static nsIAtom* onpointerout;
static nsIAtom* onpointerenter;
static nsIAtom* onpointerleave;
static nsIAtom* ongotpointercapture;
static nsIAtom* onlostpointercapture;


static nsIAtom* ondevicemotion;
static nsIAtom* ondeviceorientation;
static nsIAtom* onabsolutedeviceorientation;
static nsIAtom* ondeviceproximity;
static nsIAtom* onmozorientationchange;
static nsIAtom* onuserproximity;


static nsIAtom* ondevicelight;


static nsIAtom* onmozinterruptbegin;
static nsIAtom* onmozinterruptend;


static nsIAtom* ondevicechange;


static nsIAtom* mozinputrangeignorepreventdefault;






static nsIAtom* cdataTagName;
static nsIAtom* commentTagName;
static nsIAtom* documentNodeName;
static nsIAtom* documentFragmentNodeName;
static nsIAtom* documentTypeNodeName;
static nsIAtom* processingInstructionTagName;
static nsIAtom* textTagName;


static nsIAtom* bcTableCellFrame;
static nsIAtom* blockFrame;
static nsIAtom* boxFrame;
static nsIAtom* brFrame;
static nsIAtom* bulletFrame;
static nsIAtom* colorControlFrame;
static nsIAtom* columnSetFrame;
static nsIAtom* comboboxControlFrame;
static nsIAtom* comboboxDisplayFrame;
static nsIAtom* dateTimeControlFrame;
static nsIAtom* deckFrame;
static nsIAtom* detailsFrame;
static nsIAtom* fieldSetFrame;
static nsIAtom* flexContainerFrame;
static nsIAtom* formControlFrame;
static nsIAtom* frameSetFrame;
static nsIAtom* gfxButtonControlFrame;
static nsIAtom* gridContainerFrame;
static nsIAtom* HTMLButtonControlFrame;
static nsIAtom* HTMLCanvasFrame;
static nsIAtom* subDocumentFrame;
static nsIAtom* imageBoxFrame;
static nsIAtom* imageFrame;
static nsIAtom* imageControlFrame;
static nsIAtom* inlineFrame;
static nsIAtom* leafBoxFrame;
static nsIAtom* legendFrame;
static nsIAtom* letterFrame;
static nsIAtom* lineFrame;
static nsIAtom* listControlFrame;
static nsIAtom* menuFrame;
static nsIAtom* meterFrame;
static nsIAtom* menuPopupFrame;
static nsIAtom* numberControlFrame;
static nsIAtom* objectFrame;
static nsIAtom* pageFrame;
static nsIAtom* pageBreakFrame;
static nsIAtom* pageContentFrame;
static nsIAtom* placeholderFrame;
static nsIAtom* popupSetFrame;
static nsIAtom* progressFrame;
static nsIAtom* canvasFrame;
static nsIAtom* rangeFrame;
static nsIAtom* rootFrame;
static nsIAtom* rubyBaseContainerFrame;
static nsIAtom* rubyBaseFrame;
static nsIAtom* rubyFrame;
static nsIAtom* rubyTextContainerFrame;
static nsIAtom* rubyTextFrame;
static nsIAtom* scrollFrame;
static nsIAtom* scrollbarFrame;
static nsIAtom* sequenceFrame;
static nsIAtom* sliderFrame;
static nsIAtom* tableCellFrame;
static nsIAtom* tableColFrame;
static nsIAtom* tableColGroupFrame;
static nsIAtom* tableFrame;
static nsIAtom* tableWrapperFrame;
static nsIAtom* tableRowGroupFrame;
static nsIAtom* tableRowFrame;
static nsIAtom* textInputFrame;
static nsIAtom* textFrame;
static nsIAtom* viewportFrame;

static nsIAtom* XULLabelFrame;

static nsIAtom* svgAFrame;
static nsIAtom* svgClipPathFrame;
static nsIAtom* svgDefsFrame;
static nsIAtom* svgFEContainerFrame;
static nsIAtom* svgFEImageFrame;
static nsIAtom* svgFELeafFrame;
static nsIAtom* svgFEUnstyledLeafFrame;
static nsIAtom* svgFilterFrame;
static nsIAtom* svgForeignObjectFrame;
static nsIAtom* svgGenericContainerFrame;
static nsIAtom* svgGeometryFrame;
static nsIAtom* svgGFrame;
static nsIAtom* svgGradientFrame;
static nsIAtom* svgImageFrame;
static nsIAtom* svgInnerSVGFrame;
static nsIAtom* svgLinearGradientFrame;
static nsIAtom* svgMarkerFrame;
static nsIAtom* svgMarkerAnonChildFrame;
static nsIAtom* svgMaskFrame;
static nsIAtom* svgOuterSVGFrame;
static nsIAtom* svgOuterSVGAnonChildFrame;
static nsIAtom* svgPatternFrame;
static nsIAtom* svgRadialGradientFrame;
static nsIAtom* svgStopFrame;
static nsIAtom* svgSwitchFrame;
static nsIAtom* svgTextFrame;
static nsIAtom* svgUseFrame;
static nsIAtom* svgViewFrame;
static nsIAtom* HTMLVideoFrame;
static nsIAtom* onloadend;
static nsIAtom* onloadstart;
static nsIAtom* onprogress;
static nsIAtom* onsuspend;
static nsIAtom* onemptied;
static nsIAtom* onstalled;
static nsIAtom* onplay;
static nsIAtom* onpause;
static nsIAtom* onloadedmetadata;
static nsIAtom* onloadeddata;
static nsIAtom* onwaiting;
static nsIAtom* onplaying;
static nsIAtom* oncanplay;
static nsIAtom* oncanplaythrough;
static nsIAtom* onseeking;
static nsIAtom* onseeked;
static nsIAtom* ontimeout;
static nsIAtom* ontimeupdate;
static nsIAtom* onended;
static nsIAtom* onratechange;
static nsIAtom* ondurationchange;
static nsIAtom* onvolumechange;
static nsIAtom* onaddtrack;
static nsIAtom* oncontrollerchange;
static nsIAtom* oncuechange;
static nsIAtom* onenter;
static nsIAtom* onexit;
static nsIAtom* onencrypted;
static nsIAtom* encrypted;
static nsIAtom* onwaitingforkey;
static nsIAtom* onkeystatuseschange;
static nsIAtom* onremovetrack;
static nsIAtom* loadstart;
static nsIAtom* suspend;
static nsIAtom* emptied;
static nsIAtom* stalled;
static nsIAtom* play;
static nsIAtom* pause;
static nsIAtom* loadedmetadata;
static nsIAtom* loadeddata;
static nsIAtom* waiting;
static nsIAtom* playing;
static nsIAtom* seeking;
static nsIAtom* seeked;
static nsIAtom* timeupdate;
static nsIAtom* ended;
static nsIAtom* canplay;
static nsIAtom* canplaythrough;
static nsIAtom* ratechange;
static nsIAtom* durationchange;
static nsIAtom* volumechange;
static nsIAtom* ondataavailable;
static nsIAtom* onwarning;
static nsIAtom* onstart;
static nsIAtom* onstop;
static nsIAtom* onphoto;
static nsIAtom* onactivestatechanged;
static nsIAtom* ongamepadbuttondown;
static nsIAtom* ongamepadbuttonup;
static nsIAtom* ongamepadaxismove;
static nsIAtom* ongamepadconnected;
static nsIAtom* ongamepaddisconnected;


static nsIAtom* animationsProperty;
static nsIAtom* animationsOfBeforeProperty;
static nsIAtom* animationsOfAfterProperty;
static nsIAtom* animationEffectsProperty;
static nsIAtom* animationEffectsForBeforeProperty;
static nsIAtom* animationEffectsForAfterProperty;
static nsIAtom* cssPseudoElementBeforeProperty;
static nsIAtom* cssPseudoElementAfterProperty;
static nsIAtom* transitionsProperty;
static nsIAtom* transitionsOfBeforeProperty;
static nsIAtom* transitionsOfAfterProperty;
static nsIAtom* genConInitializerProperty;
static nsIAtom* labelMouseDownPtProperty;
static nsIAtom* lockedStyleStates;
static nsIAtom* apzCallbackTransform;
static nsIAtom* restylableAnonymousNode;
static nsIAtom* paintRequestTime;
static nsIAtom* pseudoProperty;


static nsIAtom* Japanese;
static nsIAtom* Chinese;
static nsIAtom* Taiwanese;
static nsIAtom* HongKongChinese;
static nsIAtom* Unicode;


static nsIAtom* ko;
static nsIAtom* zh_cn;
static nsIAtom* zh_hk;
static nsIAtom* zh_tw;


static nsIAtom* x_cyrillic;
static nsIAtom* he;
static nsIAtom* ar;
static nsIAtom* x_devanagari;
static nsIAtom* x_tamil;
static nsIAtom* x_armn;
static nsIAtom* x_beng;
static nsIAtom* x_cans;
static nsIAtom* x_ethi;
static nsIAtom* x_geor;
static nsIAtom* x_gujr;
static nsIAtom* x_guru;
static nsIAtom* x_khmr;
static nsIAtom* x_knda;
static nsIAtom* x_mlym;
static nsIAtom* x_orya;
static nsIAtom* x_sinh;
static nsIAtom* x_telu;
static nsIAtom* x_tibt;


static nsIAtom* az;
static nsIAtom* ba;
static nsIAtom* crh;
static nsIAtom* el;
static nsIAtom* ga;
static nsIAtom* nl;


static nsIAtom* x_math;


static nsIAtom* TypingTxnName;
static nsIAtom* IMETxnName;
static nsIAtom* DeleteTxnName;


static nsIAtom* serif;
static nsIAtom* sans_serif;
static nsIAtom* cursive;
static nsIAtom* fantasy;
static nsIAtom* monospace;
static nsIAtom* mozfixed;


static nsIAtom* Remote;
static nsIAtom* RemoteId;
static nsIAtom* RemoteType;
static nsIAtom* DisplayPort;
static nsIAtom* DisplayPortMargins;
static nsIAtom* DisplayPortBase;
static nsIAtom* AsyncScrollLayerCreationFailed;
static nsIAtom* forcemessagemanager;


static nsIAtom* color_picker_available;
static nsIAtom* scrollbar_start_backward;
static nsIAtom* scrollbar_start_forward;
static nsIAtom* scrollbar_end_backward;
static nsIAtom* scrollbar_end_forward;
static nsIAtom* scrollbar_thumb_proportional;
static nsIAtom* overlay_scrollbars;
static nsIAtom* windows_default_theme;
static nsIAtom* mac_graphite_theme;
static nsIAtom* mac_yosemite_theme;
static nsIAtom* windows_compositor;
static nsIAtom* windows_glass;
static nsIAtom* touch_enabled;
static nsIAtom* menubar_drag;
static nsIAtom* swipe_animation_enabled;
static nsIAtom* physical_home_button;


static nsIAtom* windows_classic;
static nsIAtom* windows_theme_aero;
static nsIAtom* windows_theme_aero_lite;
static nsIAtom* windows_theme_luna_blue;
static nsIAtom* windows_theme_luna_olive;
static nsIAtom* windows_theme_luna_silver;
static nsIAtom* windows_theme_royale;
static nsIAtom* windows_theme_zune;
static nsIAtom* windows_theme_generic;


static nsIAtom* _moz_color_picker_available;
static nsIAtom* _moz_scrollbar_start_backward;
static nsIAtom* _moz_scrollbar_start_forward;
static nsIAtom* _moz_scrollbar_end_backward;
static nsIAtom* _moz_scrollbar_end_forward;
static nsIAtom* _moz_scrollbar_thumb_proportional;
static nsIAtom* _moz_overlay_scrollbars;
static nsIAtom* _moz_windows_default_theme;
static nsIAtom* _moz_mac_graphite_theme;
static nsIAtom* _moz_mac_yosemite_theme;
static nsIAtom* _moz_windows_compositor;
static nsIAtom* _moz_windows_classic;
static nsIAtom* _moz_windows_glass;
static nsIAtom* _moz_windows_theme;
static nsIAtom* _moz_os_version;
static nsIAtom* _moz_touch_enabled;
static nsIAtom* _moz_menubar_drag;
static nsIAtom* _moz_device_pixel_ratio;
static nsIAtom* _moz_device_orientation;
static nsIAtom* _moz_is_resource_document;
static nsIAtom* _moz_swipe_animation_enabled;
static nsIAtom* _moz_physical_home_button;


static nsIAtom* Back;
static nsIAtom* Forward;
static nsIAtom* Reload;
static nsIAtom* Stop;
static nsIAtom* Search;
static nsIAtom* Bookmarks;
static nsIAtom* Home;
static nsIAtom* Clear;
static nsIAtom* VolumeUp;
static nsIAtom* VolumeDown;
static nsIAtom* NextTrack;
static nsIAtom* PreviousTrack;
static nsIAtom* MediaStop;
static nsIAtom* PlayPause;
static nsIAtom* Menu;
static nsIAtom* New;
static nsIAtom* Open;
static nsIAtom* Close;
static nsIAtom* Save;
static nsIAtom* Find;
static nsIAtom* Help;
static nsIAtom* Print;
static nsIAtom* SendMail;
static nsIAtom* ForwardMail;
static nsIAtom* ReplyToMail;






static nsIAtom* mouseWheel;
static nsIAtom* pixels;
static nsIAtom* lines;
static nsIAtom* pages;
static nsIAtom* scrollbars;
static nsIAtom* other;

static nsIAtom* apz;
static nsIAtom* restore;


static nsIAtom* alert;
static nsIAtom* alertdialog;
static nsIAtom* application;
static nsIAtom* aria_activedescendant;
static nsIAtom* aria_atomic;
static nsIAtom* aria_autocomplete;
static nsIAtom* aria_busy;
static nsIAtom* aria_checked;
static nsIAtom* aria_colcount;
static nsIAtom* aria_colindex;
static nsIAtom* aria_controls;
static nsIAtom* aria_describedby;
static nsIAtom* aria_details;
static nsIAtom* aria_disabled;
static nsIAtom* aria_dropeffect;
static nsIAtom* aria_errormessage;
static nsIAtom* aria_expanded;
static nsIAtom* aria_flowto;
static nsIAtom* aria_grabbed;
static nsIAtom* aria_haspopup;
static nsIAtom* aria_hidden;
static nsIAtom* aria_invalid;
static nsIAtom* aria_label;
static nsIAtom* aria_labelledby;
static nsIAtom* aria_level;
static nsIAtom* aria_live;
static nsIAtom* aria_modal;
static nsIAtom* aria_multiline;
static nsIAtom* aria_multiselectable;
static nsIAtom* aria_orientation;
static nsIAtom* aria_owns;
static nsIAtom* aria_posinset;
static nsIAtom* aria_pressed;
static nsIAtom* aria_readonly;
static nsIAtom* aria_relevant;
static nsIAtom* aria_required;
static nsIAtom* aria_rowcount;
static nsIAtom* aria_rowindex;
static nsIAtom* aria_selected;
static nsIAtom* aria_setsize;
static nsIAtom* aria_sort;
static nsIAtom* aria_valuenow;
static nsIAtom* aria_valuemin;
static nsIAtom* aria_valuemax;
static nsIAtom* aria_valuetext;
static nsIAtom* AreaFrame;
static nsIAtom* auto_generated;
static nsIAtom* banner;
static nsIAtom* checkable;
static nsIAtom* choices;
static nsIAtom* columnheader;
static nsIAtom* complementary;
static nsIAtom* containerAtomic;
static nsIAtom* containerBusy;
static nsIAtom* containerLive;
static nsIAtom* containerLiveRole;
static nsIAtom* containerRelevant;
static nsIAtom* contentinfo;
static nsIAtom* cycles;
static nsIAtom* datatable;
static nsIAtom* eventFromInput;
static nsIAtom* feed;
static nsIAtom* grammar;
static nsIAtom* gridcell;
static nsIAtom* heading;
static nsIAtom* hitregion;
static nsIAtom* InlineBlockFrame;
static nsIAtom* inlinevalue;
static nsIAtom* invalid;
static nsIAtom* item;
static nsIAtom* itemset;
static nsIAtom* lineNumber;
static nsIAtom* linkedPanel;
static nsIAtom* live;
static nsIAtom* menuitemcheckbox;
static nsIAtom* menuitemradio;
static nsIAtom* mixed;
static nsIAtom* multiline;
static nsIAtom* navigation;
static nsIAtom* polite;
static nsIAtom* posinset;
static nsIAtom* presentation;
static nsIAtom* progressbar;
static nsIAtom* region;
static nsIAtom* rowgroup;
static nsIAtom* rowheader;
static nsIAtom* search;
static nsIAtom* searchbox;
static nsIAtom* select1;
static nsIAtom* setsize;
static nsIAtom* spelling;
static nsIAtom* spinbutton;
static nsIAtom* status;
static nsIAtom* _switch;
static nsIAtom* tableCellIndex;
static nsIAtom* tablist;
static nsIAtom* textIndent;
static nsIAtom* textInputType;
static nsIAtom* textLineThroughColor;
static nsIAtom* textLineThroughStyle;
static nsIAtom* textPosition;
static nsIAtom* textUnderlineColor;
static nsIAtom* textUnderlineStyle;
static nsIAtom* timer;
static nsIAtom* toolbarname;
static nsIAtom* toolbarseparator;
static nsIAtom* toolbarspacer;
static nsIAtom* toolbarspring;
static nsIAtom* treegrid;
static nsIAtom* _undefined;
static nsIAtom* xmlroles;


static nsIAtom* close_fence;
static nsIAtom* denominator;
static nsIAtom* numerator;
static nsIAtom* open_fence;
static nsIAtom* overscript;
static nsIAtom* presubscript;
static nsIAtom* presuperscript;
static nsIAtom* root_index;
static nsIAtom* subscript;
static nsIAtom* superscript;
static nsIAtom* underscript;



static nsIAtom* onaudiostart;
static nsIAtom* onaudioend;
static nsIAtom* onsoundstart;
static nsIAtom* onsoundend;
static nsIAtom* onspeechstart;
static nsIAtom* onspeechend;
static nsIAtom* onresult;
static nsIAtom* onnomatch;
static nsIAtom* onresume;
static nsIAtom* onmark;
static nsIAtom* onboundary;



static nsIAtom* usercontextid;


static nsIAtom* nsuri_xmlns;
static nsIAtom* nsuri_xml;
static nsIAtom* nsuri_xhtml;
static nsIAtom* nsuri_xlink;
static nsIAtom* nsuri_xslt;
static nsIAtom* nsuri_xbl;
static nsIAtom* nsuri_mathml;
static nsIAtom* nsuri_rdf;
static nsIAtom* nsuri_xul;
static nsIAtom* nsuri_svg;


static nsIAtom* onsourceopen;
static nsIAtom* onsourceended;
static nsIAtom* onsourceclosed;
static nsIAtom* onupdatestart;
static nsIAtom* onupdate;
static nsIAtom* onupdateend;
static nsIAtom* onaddsourcebuffer;
static nsIAtom* onremovesourcebuffer;

};
class nsWrapperCache;
typedef uint64_t DOMTimeStamp;

typedef double DOMHighResTimeStamp;

class nsIDOMAttr;

class nsIDOMCDATASection;

class nsIDOMCharacterData;

class nsIDOMComment;

class nsIDOMDOMImplementation;

class nsIDOMDocument;

class nsIDOMDocumentFragment;

class nsIDOMDocumentType;

class nsIDOMElement;

class nsIDOMNode;

class nsIDOMNodeList;

class nsIDOMProcessingInstruction;

class nsIDOMText;

class nsIDOMClientRect;

class nsIDOMClientRectList;

class DOMException;

class nsIDOMStyleSheetList;

class nsIDOMStyleSheet;

class nsIDOMMediaList;

class nsIDOMWindow;

class nsIDOMWindowCollection;

class nsIDOMNavigator;

class nsIDOMScreen;

class nsIDOMEvent;

class nsIDOMEventTarget;

class nsIDOMEventListener;

class nsIDOMHTMLElement;

class nsIDOMHTMLFormElement;

class nsIDOMHTMLCollection;

class nsIDOMHTMLHeadElement;

class nsIDOMCSSValue;

class nsIDOMCSSPrimitiveValue;

class nsIDOMCSSRule;

class nsIDOMCSSRuleList;

class nsIDOMCSSKeyframeRule;

class nsIDOMCSSFontFeatureValuesRule;

class nsIDOMCSSStyleSheet;

class nsIDOMCSSStyleDeclaration;

class nsIDOMCounter;

class nsIDOMRect;

class nsIDOMCSSStyleRule;

class nsIDOMCSSStyleRuleCollection;

class nsIDOMRange;

class nsIDOMCrypto;

class nsIDOMFontFace;

class nsIDOMFontFaceList;






class nsIVariant;
class nsIDOMNode : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    ELEMENT_NODE = 1U,
    ATTRIBUTE_NODE = 2U,
    TEXT_NODE = 3U,
    CDATA_SECTION_NODE = 4U,
    ENTITY_REFERENCE_NODE = 5U,
    ENTITY_NODE = 6U,
    PROCESSING_INSTRUCTION_NODE = 7U,
    COMMENT_NODE = 8U,
    DOCUMENT_NODE = 9U,
    DOCUMENT_TYPE_NODE = 10U,
    DOCUMENT_FRAGMENT_NODE = 11U,
    NOTATION_NODE = 12U
  };


  virtual nsresult GetNodeName(nsAString & aNodeName) = 0;


  virtual nsresult GetNodeValue(nsAString & aNodeValue) = 0;
  virtual nsresult SetNodeValue(const nsAString & aNodeValue) = 0;


  virtual nsresult GetNodeType(uint16_t *aNodeType) = 0;


  virtual nsresult GetParentNode(nsIDOMNode * *aParentNode) = 0;


  virtual nsresult GetChildNodes(nsIDOMNodeList * *aChildNodes) = 0;


  virtual nsresult GetFirstChild(nsIDOMNode * *aFirstChild) = 0;


  virtual nsresult GetLastChild(nsIDOMNode * *aLastChild) = 0;


  virtual nsresult GetPreviousSibling(nsIDOMNode * *aPreviousSibling) = 0;


  virtual nsresult GetNextSibling(nsIDOMNode * *aNextSibling) = 0;


  virtual nsresult GetOwnerDocument(nsIDOMDocument * *aOwnerDocument) = 0;


  virtual nsresult RemoveChild(nsIDOMNode *oldChild, nsIDOMNode * *_retval) = 0;


  virtual nsresult HasChildNodes(bool *_retval) = 0;


  virtual nsresult CloneNode(bool deep, uint8_t _argc, nsIDOMNode * *_retval) = 0;


  virtual nsresult GetNamespaceURI(nsAString & aNamespaceURI) = 0;


  virtual nsresult GetPrefix(nsAString & aPrefix) = 0;


  virtual nsresult GetLocalName(nsAString & aLocalName) = 0;

  enum {
    DOCUMENT_POSITION_DISCONNECTED = 1U,
    DOCUMENT_POSITION_PRECEDING = 2U,
    DOCUMENT_POSITION_FOLLOWING = 4U,
    DOCUMENT_POSITION_CONTAINS = 8U,
    DOCUMENT_POSITION_CONTAINED_BY = 16U,
    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32U
  };


  virtual nsresult GetTextContent(nsAString & aTextContent) = 0;
  virtual nsresult SetTextContent(const nsAString & aTextContent) = 0;

};

  template<typename T> struct nsIDOMNode::COMTypeInfo<nsIDOMNode, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMNode::COMTypeInfo<nsIDOMNode, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xcc35b412, 0x009b, 0x46a3, { 0x9b, 0xe0, 0x76, 0x44, 0x8f, 0x12, 0x54, 0x8d }};

class nsIDataType : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    VTYPE_INT8 = 0U,
    VTYPE_INT16 = 1U,
    VTYPE_INT32 = 2U,
    VTYPE_INT64 = 3U,
    VTYPE_UINT8 = 4U,
    VTYPE_UINT16 = 5U,
    VTYPE_UINT32 = 6U,
    VTYPE_UINT64 = 7U,
    VTYPE_FLOAT = 8U,
    VTYPE_DOUBLE = 9U,
    VTYPE_BOOL = 10U,
    VTYPE_CHAR = 11U,
    VTYPE_WCHAR = 12U,
    VTYPE_VOID = 13U,
    VTYPE_ID = 14U,
    VTYPE_DOMSTRING = 15U,
    VTYPE_CHAR_STR = 16U,
    VTYPE_WCHAR_STR = 17U,
    VTYPE_INTERFACE = 18U,
    VTYPE_INTERFACE_IS = 19U,
    VTYPE_ARRAY = 20U,
    VTYPE_STRING_SIZE_IS = 21U,
    VTYPE_WSTRING_SIZE_IS = 22U,
    VTYPE_UTF8STRING = 23U,
    VTYPE_CSTRING = 24U,
    VTYPE_ASTRING = 25U,
    VTYPE_EMPTY_ARRAY = 254U,
    VTYPE_EMPTY = 255U
  };

};

  template<typename T> struct nsIDataType::COMTypeInfo<nsIDataType, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDataType::COMTypeInfo<nsIDataType, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x4d12e540, 0x83d7, 0x11d5, { 0x90, 0xed, 0x00, 0x10, 0xa4, 0xe7, 0x3d, 0x9a }};
class nsIVariant : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetDataType(uint16_t *aDataType) = 0;


  virtual nsresult GetAsInt8(uint8_t *_retval) = 0;


  virtual nsresult GetAsInt16(int16_t *_retval) = 0;


  virtual nsresult GetAsInt32(int32_t *_retval) = 0;


  virtual nsresult GetAsInt64(int64_t *_retval) = 0;


  virtual nsresult GetAsUint8(uint8_t *_retval) = 0;


  virtual nsresult GetAsUint16(uint16_t *_retval) = 0;


  virtual nsresult GetAsUint32(uint32_t *_retval) = 0;


  virtual nsresult GetAsUint64(uint64_t *_retval) = 0;


  virtual nsresult GetAsFloat(float *_retval) = 0;


  virtual nsresult GetAsDouble(double *_retval) = 0;


  virtual nsresult GetAsBool(bool *_retval) = 0;


  virtual nsresult GetAsChar(char *_retval) = 0;


  virtual nsresult GetAsWChar(char16_t *_retval) = 0;


  virtual nsresult GetAsID(nsID *retval) = 0;


  virtual nsresult GetAsAString(nsAString & _retval) = 0;


  virtual nsresult GetAsDOMString(nsAString & _retval) = 0;


  virtual nsresult GetAsACString(nsACString & _retval) = 0;


  virtual nsresult GetAsAUTF8String(nsACString & _retval) = 0;


  virtual nsresult GetAsString(char * *_retval) = 0;


  virtual nsresult GetAsWString(char16_t * *_retval) = 0;


  virtual nsresult GetAsISupports(nsISupports * *_retval) = 0;


  virtual nsresult GetAsJSVal(JS::MutableHandleValue _retval) = 0;


  virtual nsresult GetAsInterface(nsIID **iid, void **iface) = 0;


  virtual nsresult GetAsArray(uint16_t *type, nsIID *iid, uint32_t *count, void **ptr) = 0;


  virtual nsresult GetAsStringWithSize(uint32_t *size, char * *str) = 0;


  virtual nsresult GetAsWStringWithSize(uint32_t *size, char16_t * *str) = 0;

};

  template<typename T> struct nsIVariant::COMTypeInfo<nsIVariant, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIVariant::COMTypeInfo<nsIVariant, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x81e4c2de, 0xacac, 0x4ad6, { 0x90, 0x1a, 0xb5, 0xfb, 0x1b, 0x85, 0x1a, 0x0d }};
class nsIWritableVariant : public nsIVariant {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetWritable(bool *aWritable) = 0;
  virtual nsresult SetWritable(bool aWritable) = 0;


  virtual nsresult SetAsInt8(uint8_t aValue) = 0;


  virtual nsresult SetAsInt16(int16_t aValue) = 0;


  virtual nsresult SetAsInt32(int32_t aValue) = 0;


  virtual nsresult SetAsInt64(int64_t aValue) = 0;


  virtual nsresult SetAsUint8(uint8_t aValue) = 0;


  virtual nsresult SetAsUint16(uint16_t aValue) = 0;


  virtual nsresult SetAsUint32(uint32_t aValue) = 0;


  virtual nsresult SetAsUint64(uint64_t aValue) = 0;


  virtual nsresult SetAsFloat(float aValue) = 0;


  virtual nsresult SetAsDouble(double aValue) = 0;


  virtual nsresult SetAsBool(bool aValue) = 0;


  virtual nsresult SetAsChar(char aValue) = 0;


  virtual nsresult SetAsWChar(char16_t aValue) = 0;


  virtual nsresult SetAsID(const nsID & aValue) = 0;


  virtual nsresult SetAsAString(const nsAString & aValue) = 0;


  virtual nsresult SetAsDOMString(const nsAString & aValue) = 0;


  virtual nsresult SetAsACString(const nsACString & aValue) = 0;


  virtual nsresult SetAsAUTF8String(const nsACString & aValue) = 0;


  virtual nsresult SetAsString(const char * aValue) = 0;


  virtual nsresult SetAsWString(const char16_t * aValue) = 0;


  virtual nsresult SetAsISupports(nsISupports *aValue) = 0;


  virtual nsresult SetAsInterface(const nsIID & iid, void *iface) = 0;


  virtual nsresult SetAsArray(uint16_t type, const nsIID *iid, uint32_t count, void *ptr) = 0;


  virtual nsresult SetAsStringWithSize(uint32_t size, const char * str) = 0;


  virtual nsresult SetAsWStringWithSize(uint32_t size, const char16_t * str) = 0;


  virtual nsresult SetAsVoid(void) = 0;


  virtual nsresult SetAsEmpty(void) = 0;


  virtual nsresult SetAsEmptyArray(void) = 0;


  virtual nsresult SetFromVariant(nsIVariant *aValue) = 0;

};

  template<typename T> struct nsIWritableVariant::COMTypeInfo<nsIWritableVariant, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIWritableVariant::COMTypeInfo<nsIWritableVariant, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x5586a590, 0x8c82, 0x11d5, { 0x90, 0xf3, 0x00, 0x10, 0xa4, 0xe7, 0x3d, 0x9a }};
class nsAString;
class nsBindingManager;
class nsIAtom;
class nsIDocument;
class nsIDOMDocumentType;
class nsIPrincipal;
struct PLHashEntry;
struct PLHashTable;
template<class T> struct already_AddRefed;

namespace mozilla {
namespace dom {
class NodeInfo;
}
}



class nsNodeInfoManager final
{
private:
  ~nsNodeInfoManager();

public:
  nsNodeInfoManager();

  void DeleteCycleCollectable(void) { delete this; } class cycleCollection : public nsCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = true) : nsCycleCollectionParticipant(true) {} private: public: virtual void Root(void *n) override; virtual void Unlink(void *n) override; virtual void Unroot(void *n) override; virtual nsresult TraverseNative(void *n, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "nsNodeInfoManager"; }; virtual void DeleteCycleCollectable(void *n) override { DowncastCCParticipant<nsNodeInfoManager>(n)->DeleteCycleCollectable(); } static nsNodeInfoManager* Downcast(void* s) { return DowncastCCParticipant<nsNodeInfoManager>(s); } static void* Upcast(nsNodeInfoManager *p) { return static_cast<void*>(p); } virtual bool CanSkipReal(void *p, bool aRemovingAllowed) override; virtual bool CanSkipInCCReal(void *p) override; virtual bool CanSkipThisReal(void *p) override; static nsCycleCollectionParticipant* GetParticipant() { return &nsNodeInfoManager::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsNodeInfoManager>::value, "Reference-counted class " "nsNodeInfoManager" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); nsrefcnt count = mRefCnt.incr(static_cast<void*>(this), nsNodeInfoManager::cycleCollection::GetParticipant()); ; return count; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); nsrefcnt count = mRefCnt.decr(static_cast<void*>(this), nsNodeInfoManager::cycleCollection::GetParticipant()); ; return count; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:




  nsresult Init(nsIDocument *aDocument);





  void DropDocumentReference();




  already_AddRefed<mozilla::dom::NodeInfo>
  GetNodeInfo(nsIAtom *aName, nsIAtom *aPrefix, int32_t aNamespaceID,
              uint16_t aNodeType, nsIAtom* aExtraName = nullptr);
  nsresult GetNodeInfo(const nsAString& aName, nsIAtom *aPrefix,
                       int32_t aNamespaceID, uint16_t aNodeType,
                       mozilla::dom::NodeInfo** aNodeInfo);
  nsresult GetNodeInfo(const nsAString& aName, nsIAtom *aPrefix,
                       const nsAString& aNamespaceURI, uint16_t aNodeType,
                       mozilla::dom::NodeInfo** aNodeInfo);




  already_AddRefed<mozilla::dom::NodeInfo> GetTextNodeInfo();




  already_AddRefed<mozilla::dom::NodeInfo> GetCommentNodeInfo();




  already_AddRefed<mozilla::dom::NodeInfo> GetDocumentNodeInfo();





  nsIDocument* GetDocument() const
  {
    return mDocument;
  }




  nsIPrincipal *DocumentPrincipal() const {
    do { } while(0);
    return mPrincipal;
  }

  void RemoveNodeInfo(mozilla::dom::NodeInfo *aNodeInfo);

  nsBindingManager* GetBindingManager() const
  {
    return mBindingManager;
  }

protected:
  friend class nsDocument;
  friend class nsXULPrototypeDocument;
  friend nsresult NS_NewDOMDocumentType(nsIDOMDocumentType** ,
                                        nsNodeInfoManager *,
                                        nsIAtom *,
                                        const nsAString& ,
                                        const nsAString& ,
                                        const nsAString& );




  void SetDocumentPrincipal(nsIPrincipal *aPrincipal);

private:
  static int NodeInfoInnerKeyCompare(const void *key1, const void *key2);
  static PLHashNumber GetNodeInfoInnerHashValue(const void *key);
  static int DropNodeInfoDocument(PLHashEntry *he, int hashIndex,
                                     void *arg);

  PLHashTable *mNodeInfoHash;
  nsIDocument * mDocument;
  uint32_t mNonDocumentNodeInfos;
  nsCOMPtr<nsIPrincipal> mPrincipal;
  nsCOMPtr<nsIPrincipal> mDefaultPrincipal;
  mozilla::dom::NodeInfo * mTextNodeInfo;
  mozilla::dom::NodeInfo * mCommentNodeInfo;
  mozilla::dom::NodeInfo * mDocumentNodeInfo;
  RefPtr<nsBindingManager> mBindingManager;
  mozilla::dom::NodeInfo* mRecentlyUsedNodeInfos[31];
};
class nsIAtom;

typedef void
(*NSPropertyFunc)(void *aObject,
                  nsIAtom *aPropertyName,
                  void *aPropertyValue,
                  void *aData);







typedef NSPropertyFunc NSPropertyDtorFunc;
class nsINode;
class nsIFrame;

class nsPropertyOwner
{
public:
  nsPropertyOwner(const nsPropertyOwner& aOther) : mObject(aOther.mObject) {}




               nsPropertyOwner(const nsINode* aObject) : mObject(aObject) {}
               nsPropertyOwner(const nsIFrame* aObject) : mObject(aObject) {}

  operator const void*() { return mObject; }
  const void* get() { return mObject; }

private:
  const void* mObject;
};

class nsPropertyTable
{
 public:




  void* GetProperty(const nsPropertyOwner& aObject,
                    nsIAtom *aPropertyName,
                    nsresult *aResult = nullptr)
  {
    return GetPropertyInternal(aObject, aPropertyName, false, aResult);
  }
  nsresult SetProperty(const nsPropertyOwner& aObject,
                                   nsIAtom *aPropertyName,
                                   void *aPropertyValue,
                                   NSPropertyDtorFunc aDtor,
                                   void *aDtorData,
                                   bool aTransfer = false,
                                   void **aOldValue = nullptr)
  {
    return SetPropertyInternal(aObject, aPropertyName, aPropertyValue,
                               aDtor, aDtorData, aTransfer, aOldValue);
  }





  nsresult DeleteProperty(nsPropertyOwner aObject,
                                      nsIAtom *aPropertyName);






  void* UnsetProperty(const nsPropertyOwner& aObject,
                      nsIAtom *aPropertyName,
                      nsresult *aStatus = nullptr)
  {
    return GetPropertyInternal(aObject, aPropertyName, true, aStatus);
  }





  void DeleteAllPropertiesFor(nsPropertyOwner aObject);
  nsresult
    TransferOrDeleteAllPropertiesFor(nsPropertyOwner aObject,
                                     nsPropertyTable *aOtherTable);






  void Enumerate(nsPropertyOwner aObject,
                             NSPropertyFunc aCallback, void *aData);






  void EnumerateAll(NSPropertyFunc aCallback, void *aData);





  void DeleteAllProperties();

  nsPropertyTable() : mPropertyList(nullptr) {}
  ~nsPropertyTable() {
    DeleteAllProperties();
  }






  static void SupportsDtorFunc(void *aObject, nsIAtom *aPropertyName,
                               void *aPropertyValue, void *aData);

  class PropertyList;

  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;
  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

 private:
  void DestroyPropertyList();
  PropertyList* GetPropertyListFor(nsIAtom *aPropertyName) const;
  void* GetPropertyInternal(nsPropertyOwner aObject,
                                        nsIAtom *aPropertyName,
                                        bool aRemove,
                                        nsresult *aStatus);
  nsresult SetPropertyInternal(nsPropertyOwner aObject,
                                           nsIAtom *aPropertyName,
                                           void *aPropertyValue,
                                           NSPropertyDtorFunc aDtor,
                                           void *aDtorData,
                                           bool aTransfer,
                                           void **aOldValue);

  PropertyList *mPropertyList;
};
class nsTObserverArray_base
{
public:
  typedef size_t index_type;
  typedef size_t size_type;
  typedef ptrdiff_t diff_type;

protected:
  class Iterator_base
  {
  protected:
    friend class nsTObserverArray_base;

    Iterator_base(index_type aPosition, Iterator_base* aNext)
      : mPosition(aPosition)
      , mNext(aNext)
    {
    }



    index_type mPosition;


    Iterator_base* mNext;
  };

  nsTObserverArray_base() : mIterators(nullptr) {}

  ~nsTObserverArray_base()
  {
    do { } while(0);
  }
  void AdjustIterators(index_type aModPos, diff_type aAdjustment);




  void ClearIterators();

  mutable Iterator_base* mIterators;
};

template<class T, size_t N>
class nsAutoTObserverArray : protected nsTObserverArray_base
{
public:
  typedef T elem_type;
  typedef nsTArray<T> array_type;

  nsAutoTObserverArray() {}






  size_type Length() const { return mArray.Length(); }


  bool IsEmpty() const { return mArray.IsEmpty(); }






  elem_type& ElementAt(index_type aIndex)
  {
    return mArray.ElementAt(aIndex);
  }


  const elem_type& ElementAt(index_type aIndex) const
  {
    return mArray.ElementAt(aIndex);
  }






  elem_type& SafeElementAt(index_type aIndex, elem_type& aDef)
  {
    return mArray.SafeElementAt(aIndex, aDef);
  }


  const elem_type& SafeElementAt(index_type aIndex, const elem_type& aDef) const
  {
    return mArray.SafeElementAt(aIndex, aDef);
  }
  template<class Item>
  bool Contains(const Item& aItem) const
  {
    return IndexOf(aItem) != array_type::NoIndex;
  }







  template<class Item>
  index_type IndexOf(const Item& aItem, index_type aStart = 0) const
  {
    return mArray.IndexOf(aItem, aStart);
  }
  template<class Item>
  elem_type* InsertElementAt(index_type aIndex, const Item& aItem)
  {
    elem_type* item = mArray.InsertElementAt(aIndex, aItem);
    AdjustIterators(aIndex, 1);
    return item;
  }



  elem_type* InsertElementAt(index_type aIndex)
  {
    elem_type* item = mArray.InsertElementAt(aIndex);
    AdjustIterators(aIndex, 1);
    return item;
  }





  template<class Item>
  bool PrependElementUnlessExists(const Item& aItem)
  {
    if (Contains(aItem)) {
      return true;
    }

    bool inserted = mArray.InsertElementAt(0, aItem) != nullptr;
    AdjustIterators(0, 1);
    return inserted;
  }




  template<class Item>
  elem_type* AppendElement(const Item& aItem)
  {
    return mArray.AppendElement(aItem);
  }



  elem_type* AppendElement()
  {
    return mArray.AppendElement();
  }





  template<class Item>
  bool AppendElementUnlessExists(const Item& aItem)
  {
    return Contains(aItem) || AppendElement(aItem) != nullptr;
  }



  void RemoveElementAt(index_type aIndex)
  {
    do { } while(0);
    mArray.RemoveElementAt(aIndex);
    AdjustIterators(aIndex, -1);
  }






  template<class Item>
  bool RemoveElement(const Item& aItem)
  {
    index_type index = mArray.IndexOf(aItem, 0);
    if (index == array_type::NoIndex) {
      return false;
    }

    mArray.RemoveElementAt(index);
    AdjustIterators(index, -1);
    return true;
  }


  void RemoveElementsBy(std::function<bool(const elem_type&)> aPredicate)
  {
    index_type i = 0;
    mArray.RemoveElementsBy([&](const elem_type& aItem) {
      if (aPredicate(aItem)) {

        AdjustIterators(i, -1);
        return true;
      }
      ++i;
      return false;
    });
  }




  void Clear()
  {
    mArray.Clear();
    ClearIterators();
  }


  void Compact() { mArray.Compact(); }





  size_t ShallowSizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return mArray.ShallowSizeOfExcludingThis(aMallocSizeOf);
  }






  class Iterator : public Iterator_base
  {
  protected:
    friend class nsAutoTObserverArray;
    typedef nsAutoTObserverArray<T, N> array_type;

    Iterator(index_type aPosition, const array_type& aArray)
      : Iterator_base(aPosition, aArray.mIterators)
      , mArray(const_cast<array_type&>(aArray))
    {
      aArray.mIterators = this;
    }

    ~Iterator()
    {
      do { } while(0);



      mArray.mIterators = mNext;
    }


    array_type& mArray;
  };
  class ForwardIterator : protected Iterator
  {
  public:
    typedef nsAutoTObserverArray<T, N> array_type;
    typedef Iterator base_type;

    explicit ForwardIterator(const array_type& aArray)
      : Iterator(0, aArray)
    {
    }

    ForwardIterator(const array_type& aArray, index_type aPos)
      : Iterator(aPos, aArray)
    {
    }

    bool operator<(const ForwardIterator& aOther) const
    {
      do { } while(0);

      return base_type::mPosition < aOther.mPosition;
    }




    bool HasMore() const
    {
      return base_type::mPosition < base_type::mArray.Length();
    }




    elem_type& GetNext()
    {
      do { } while(0);
      return base_type::mArray.ElementAt(base_type::mPosition++);
    }
  };



  class EndLimitedIterator : protected ForwardIterator
  {
  public:
    typedef nsAutoTObserverArray<T, N> array_type;
    typedef Iterator base_type;

    explicit EndLimitedIterator(const array_type& aArray)
      : ForwardIterator(aArray)
      , mEnd(aArray, aArray.Length())
    {
    }




    bool HasMore() const { return *this < mEnd; }




    elem_type& GetNext()
    {
      do { } while(0);
      return base_type::mArray.ElementAt(base_type::mPosition++);
    }

  private:
    ForwardIterator mEnd;
  };
  class BackwardIterator : protected Iterator
  {
  public:
    typedef nsAutoTObserverArray<T, N> array_type;
    typedef Iterator base_type;

    explicit BackwardIterator(const array_type& aArray)
      : Iterator(aArray.Length(), aArray)
    {
    }




    bool HasMore() const { return base_type::mPosition > 0; }




    elem_type& GetNext()
    {
      do { } while(0);
      return base_type::mArray.ElementAt(--base_type::mPosition);
    }




    void Remove()
    {
      return base_type::mArray.RemoveElementAt(base_type::mPosition);
    }
  };

protected:
  AutoTArray<T, N> mArray;
};

template<class T>
class nsTObserverArray : public nsAutoTObserverArray<T, 0>
{
public:
  typedef nsAutoTObserverArray<T, 0> base_type;
  typedef nsTObserverArray_base::size_type size_type;





  nsTObserverArray() {}


  explicit nsTObserverArray(size_type aCapacity)
  {
    base_type::mArray.SetCapacity(aCapacity);
  }
};

template<typename T, size_t N>
inline void
ImplCycleCollectionUnlink(nsAutoTObserverArray<T, N>& aField)
{
  aField.Clear();
}

template<typename T, size_t N>
inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            nsAutoTObserverArray<T, N>& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  aFlags |= CycleCollectionEdgeNameArrayFlag;
  size_t length = aField.Length();
  for (size_t i = 0; i < length; ++i) {
    ImplCycleCollectionTraverse(aCallback, aField.ElementAt(i), aName, aFlags);
  }
}
namespace IPC {
class Message;
template <typename> struct ParamTraits;
}
class PickleIterator;

namespace mozilla {

namespace dom {

enum ErrNum {



MSG_INVALID_ENUM_VALUE,
MSG_MISSING_ARGUMENTS,
MSG_NOT_OBJECT,
MSG_NOT_CALLABLE,
MSG_NOT_CONSTRUCTOR,
MSG_DOES_NOT_IMPLEMENT_INTERFACE,
MSG_METHOD_THIS_DOES_NOT_IMPLEMENT_INTERFACE,
MSG_METHOD_THIS_UNWRAPPING_DENIED,
MSG_THIS_DOES_NOT_IMPLEMENT_INTERFACE,
MSG_NOT_IN_UNION,
MSG_ILLEGAL_CONSTRUCTOR,
MSG_CONSTRUCTOR_WITHOUT_NEW,
MSG_ENFORCE_RANGE_NON_FINITE,
MSG_ENFORCE_RANGE_OUT_OF_RANGE,
MSG_NOT_SEQUENCE,
MSG_NOT_DICTIONARY,
MSG_OVERLOAD_RESOLUTION_FAILED,
MSG_GLOBAL_NOT_NATIVE,
MSG_ENCODING_NOT_SUPPORTED,
MSG_DOM_ENCODING_NOT_UTF,
MSG_DOM_DECODING_FAILED,
MSG_NOT_FINITE,
MSG_INVALID_VERSION,
MSG_INVALID_BYTESTRING,

MSG_NOT_DATE,
MSG_INVALID_ADVANCE_COUNT,
MSG_DEFINEPROPERTY_ON_GSP,
MSG_INVALID_URL,
MSG_URL_HAS_CREDENTIALS,
MSG_METADATA_NOT_CONFIGURED,
MSG_INVALID_READ_SIZE,
MSG_HEADERS_IMMUTABLE,
MSG_INVALID_HEADER_NAME,
MSG_INVALID_HEADER_VALUE,
MSG_INVALID_HEADER_SEQUENCE,
MSG_PERMISSION_DENIED_TO_PASS_ARG,
MSG_MISSING_REQUIRED_DICTIONARY_MEMBER,
MSG_REQUEST_INTEGRITY_METADATA_NOT_EMPTY,
MSG_INVALID_REQUEST_METHOD,
MSG_INVALID_REQUEST_MODE,
MSG_INVALID_REFERRER_URL,
MSG_CROSS_ORIGIN_REFERRER_URL,
MSG_FETCH_BODY_CONSUMED_ERROR,
MSG_RESPONSE_INVALID_STATUSTEXT_ERROR,
MSG_FETCH_FAILED,
MSG_NO_BODY_ALLOWED_FOR_GET_AND_HEAD,
MSG_RESPONSE_NULL_STATUS_WITH_BODY,
MSG_DEFINE_NON_CONFIGURABLE_PROP_ON_WINDOW,
MSG_INVALID_ZOOMANDPAN_VALUE_ERROR,
MSG_INVALID_TRANSFORM_ANGLE_ERROR,
MSG_INVALID_RESPONSE_STATUSCODE_ERROR,
MSG_INVALID_REDIRECT_STATUSCODE_ERROR,
MSG_INVALID_URL_SCHEME,
MSG_RESPONSE_URL_IS_NULL,
MSG_RESPONSE_HAS_VARY_STAR,
MSG_BAD_FORMDATA,
MSG_NO_ACTIVE_WORKER,
MSG_NOTIFICATION_PERMISSION_DENIED,
MSG_NOTIFICATION_NO_CONSTRUCTOR_IN_SERVICEWORKER,
MSG_INVALID_SCOPE,
MSG_INVALID_KEYFRAME_OFFSETS,
MSG_IS_NOT_PROMISE,
MSG_SW_INSTALL_ERROR,
MSG_SW_SCRIPT_THREW,
MSG_TYPEDARRAY_IS_SHARED,
MSG_TYPEDARRAY_IS_DETACHED,
MSG_CACHE_ADD_FAILED_RESPONSE,
MSG_SW_UPDATE_BAD_REGISTRATION,
MSG_INVALID_DURATION_ERROR,
MSG_INVALID_EASING_ERROR,
MSG_INVALID_SPACING_MODE_ERROR,
MSG_USELESS_SETTIMEOUT,
MSG_TOKENLIST_NO_SUPPORTED_TOKENS,
MSG_CACHE_STREAM_CLOSED,
MSG_TIME_VALUE_OUT_OF_RANGE,
MSG_ONLY_IF_CACHED_WITHOUT_SAME_ORIGIN,
MSG_THRESHOLD_RANGE_ERROR,
MSG_WORKER_THREAD_SHUTTING_DOWN,
MSG_CACHE_OPEN_FAILED,

  Err_Limit
};
uint16_t
GetErrorArgCount(const ErrNum aErrorNumber);

namespace binding_detail {
void ThrowErrorMessage(JSContext* aCx, const unsigned aErrorNumber, ...);
}

template<typename... Ts>
inline bool
ThrowErrorMessage(JSContext* aCx, const ErrNum aErrorNumber, Ts&&... aArgs)
{
  binding_detail::ThrowErrorMessage(aCx, static_cast<const unsigned>(aErrorNumber),
                                    mozilla::Forward<Ts>(aArgs)...);
  return false;
}

struct StringArrayAppender
{
  static void Append(nsTArray<nsString>& aArgs, uint16_t aCount)
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(aCount == 0)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(aCount == 0))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "aCount == 0" ") (" "Must give at least as many string arguments as are required by the ErrNum." ")"); do { *((volatile int*) __null) = 87; ::abort(); } while (0); } } while (0);
  }

  template<typename... Ts>
  static void Append(nsTArray<nsString>& aArgs, uint16_t aCount, const nsAString& aFirst, Ts&&... aOtherArgs)
  {
    if (aCount == 0) {
      do { } while (0);
      return;
    }
    aArgs.AppendElement(aFirst);
    Append(aArgs, aCount - 1, Forward<Ts>(aOtherArgs)...);
  }
};

}

class ErrorResult;
class OOMReporter;

namespace binding_danger {
template<typename CleanupPolicy>
class TErrorResult {
public:
  TErrorResult()
    : mResult(NS_OK)




  {
  }

  ~TErrorResult() {
    AssertInOwningThread();

    if (CleanupPolicy::assertHandled) {


      AssertReportedOrSuppressed();
    }

    if (CleanupPolicy::suppress) {
      SuppressException();
    }


    AssertReportedOrSuppressed();
  }

  TErrorResult(TErrorResult&& aRHS)



    : TErrorResult()
  {
    *this = Move(aRHS);
  }
  TErrorResult& operator=(TErrorResult&& aRHS);

  explicit TErrorResult(nsresult aRv)
    : TErrorResult()
  {
    AssignErrorCode(aRv);
  }

  operator ErrorResult&();
  operator OOMReporter&();

  void Throw(nsresult rv) {
    do { } while (0);
    AssignErrorCode(rv);
  }
  void ThrowWithCustomCleanup(nsresult rv) {
    Throw(rv);
  }




  void CloneTo(TErrorResult& aRv) const;




  void SuppressException();




  nsresult StealNSResult() {
    nsresult rv = ErrorCode();
    SuppressException();

    if (rv == NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR ||
        rv == NS_ERROR_INTERNAL_ERRORRESULT_RANGEERROR ||
        rv == NS_ERROR_INTERNAL_ERRORRESULT_JS_EXCEPTION ||
        rv == NS_ERROR_INTERNAL_ERRORRESULT_DOMEXCEPTION) {

      return NS_ERROR_DOM_INVALID_STATE_ERR;
    }

    return rv;
  }
  bool MaybeSetPendingException(JSContext* cx)
  {
    WouldReportJSException();
    if (!Failed()) {
      return false;
    }

    SetPendingException(cx);
    return true;
  }
  void StealExceptionFromJSContext(JSContext* cx);

  template<dom::ErrNum errorNumber, typename... Ts>
  void ThrowTypeError(Ts&&... messageArgs)
  {
    ThrowErrorWithMessage<errorNumber>(NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR,
                                       Forward<Ts>(messageArgs)...);
  }

  template<dom::ErrNum errorNumber, typename... Ts>
  void ThrowRangeError(Ts&&... messageArgs)
  {
    ThrowErrorWithMessage<errorNumber>(NS_ERROR_INTERNAL_ERRORRESULT_RANGEERROR,
                                       Forward<Ts>(messageArgs)...);
  }

  bool IsErrorWithMessage() const
  {
    return ErrorCode() == NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR ||
           ErrorCode() == NS_ERROR_INTERNAL_ERRORRESULT_RANGEERROR;
  }
  void ThrowJSException(JSContext* cx, JS::Handle<JS::Value> exn);
  bool IsJSException() const
  {
    return ErrorCode() == NS_ERROR_INTERNAL_ERRORRESULT_JS_EXCEPTION;
  }






  void ThrowDOMException(nsresult rv, const nsACString& message = EmptyCString());
  bool IsDOMException() const
  {
    return ErrorCode() == NS_ERROR_INTERNAL_ERRORRESULT_DOMEXCEPTION;
  }




  void NoteJSContextException(JSContext* aCx);



  bool IsJSContextException() {
    return ErrorCode() == NS_ERROR_INTERNAL_ERRORRESULT_EXCEPTION_ON_JSCONTEXT;
  }


  void ThrowUncatchableException() {
    Throw(NS_ERROR_UNCATCHABLE_EXCEPTION);
  }
  bool IsUncatchableException() const {
    return ErrorCode() == NS_ERROR_UNCATCHABLE_EXCEPTION;
  }

  void __attribute__((always_inline)) inline MightThrowJSException()
  {



  }
  void __attribute__((always_inline)) inline WouldReportJSException()
  {



  }
  void operator=(nsresult rv) {
    AssignErrorCode(rv);
  }

  bool Failed() const {
    return ((bool)(__builtin_expect(!!(NS_FAILED_impl(mResult)), 0)));
  }

  bool ErrorCodeIs(nsresult rv) const {
    return mResult == rv;
  }


  uint32_t ErrorCodeAsInt() const {
    return static_cast<uint32_t>(ErrorCode());
  }

protected:
  nsresult ErrorCode() const {
    return mResult;
  }

private:
  friend struct IPC::ParamTraits<TErrorResult>;
  friend struct IPC::ParamTraits<ErrorResult>;
  void SerializeMessage(IPC::Message* aMsg) const;
  bool DeserializeMessage(const IPC::Message* aMsg, PickleIterator* aIter);

  void SerializeDOMExceptionInfo(IPC::Message* aMsg) const;
  bool DeserializeDOMExceptionInfo(const IPC::Message* aMsg, PickleIterator* aIter);



  nsTArray<nsString>& CreateErrorMessageHelper(const dom::ErrNum errorNumber, nsresult errorType);

  template<dom::ErrNum errorNumber, typename... Ts>
  void ThrowErrorWithMessage(nsresult errorType, Ts&&... messageArgs)
  {





    ClearUnionData();

    nsTArray<nsString>& messageArgsArray = CreateErrorMessageHelper(errorNumber, errorType);
    uint16_t argCount = dom::GetErrorArgCount(errorNumber);
    dom::StringArrayAppender::Append(messageArgsArray, argCount,
                                     Forward<Ts>(messageArgs)...);



  }

  __attribute__((always_inline)) inline void AssertInOwningThread() const {



  }

  void AssignErrorCode(nsresult aRv) {
    do { } while (0);

    do { } while (0);

    do { } while (0);
    do { } while (0);

    do { } while (0);
    do { } while (0);

    do { } while (0);
    do { } while (0);
    do { } while (0);

    mResult = aRv;
  }

  void ClearMessage();
  void ClearDOMExceptionInfo();







  void ClearUnionData();



  void SetPendingException(JSContext* cx);


  void SetPendingExceptionWithMessage(JSContext* cx);
  void SetPendingJSException(JSContext* cx);
  void SetPendingDOMException(JSContext* cx);
  void SetPendingGenericErrorException(JSContext* cx);

  __attribute__((always_inline)) inline void AssertReportedOrSuppressed()
  {
    do { } while (0);
    do { } while (0);
    do { } while (0);
  }
  nsresult mResult;

  struct Message;
  struct DOMExceptionInfo;






  union {
    Message* mMessage;
    JS::Value mJSException;
    DOMExceptionInfo* mDOMExceptionInfo;
  };
  TErrorResult(const TErrorResult&) = delete;
  void operator=(const TErrorResult&) = delete;
};

struct JustAssertCleanupPolicy {
  static const bool assertHandled = true;
  static const bool suppress = false;
};

struct AssertAndSuppressCleanupPolicy {
  static const bool assertHandled = true;
  static const bool suppress = true;
};

struct JustSuppressCleanupPolicy {
  static const bool assertHandled = false;
  static const bool suppress = true;
};

}



class ErrorResult :
    public binding_danger::TErrorResult<binding_danger::AssertAndSuppressCleanupPolicy>
{
  typedef binding_danger::TErrorResult<binding_danger::AssertAndSuppressCleanupPolicy> BaseErrorResult;

public:
  ErrorResult()
    : BaseErrorResult()
  {}

  ErrorResult(ErrorResult&& aRHS)
    : BaseErrorResult(Move(aRHS))
  {}

  explicit ErrorResult(nsresult aRv)
    : BaseErrorResult(aRv)
  {}

  void operator=(nsresult rv)
  {
    BaseErrorResult::operator=(rv);
  }

  ErrorResult& operator=(ErrorResult&& aRHS)
  {
    BaseErrorResult::operator=(Move(aRHS));
    return *this;
  }

private:


  ErrorResult(const ErrorResult&) = delete;
  void operator=(const ErrorResult&) = delete;
};

template<typename CleanupPolicy>
binding_danger::TErrorResult<CleanupPolicy>::operator ErrorResult&()
{
  return *static_cast<ErrorResult*>(
     reinterpret_cast<TErrorResult<AssertAndSuppressCleanupPolicy>*>(this));
}




class IgnoredErrorResult :
    public binding_danger::TErrorResult<binding_danger::JustSuppressCleanupPolicy>
{
};

namespace dom {
namespace binding_detail {
class FastErrorResult :
    public mozilla::binding_danger::TErrorResult<
      mozilla::binding_danger::JustAssertCleanupPolicy>
{
};
}
}
namespace binding_danger {
class OOMReporterInstantiator;
}

class OOMReporter : private dom::binding_detail::FastErrorResult
{
public:
  void ReportOOM()
  {
    Throw(NS_ERROR_OUT_OF_MEMORY);
  }

private:


  friend class binding_danger::OOMReporterInstantiator;


  template<typename CleanupPolicy>
  friend class binding_danger::TErrorResult;

  OOMReporter()
    : dom::binding_detail::FastErrorResult()
  {
  }
};

namespace binding_danger {
class OOMReporterInstantiator : public OOMReporter
{
public:
  OOMReporterInstantiator()
    : OOMReporter()
  {
  }




  bool MaybeSetPendingException(JSContext* cx)
  {
    return OOMReporter::MaybeSetPendingException(cx);
  }
};
}

template<typename CleanupPolicy>
binding_danger::TErrorResult<CleanupPolicy>::operator OOMReporter&()
{
  return *static_cast<OOMReporter*>(
     reinterpret_cast<TErrorResult<JustAssertCleanupPolicy>*>(this));
}
}

class nsCString;
enum nsEventStatus
{

  nsEventStatus_eIgnore,

  nsEventStatus_eConsumeNoDefault,

  nsEventStatus_eConsumeDoDefault,

  nsEventStatus_eSentinel
};

namespace mozilla {





typedef uint16_t EventMessageType;

enum EventMessage : EventMessageType
{






eVoidEvent,



eAllEvents,


eWindowClose,

eKeyPress,
eKeyUp,
eKeyDown,





eKeyDownOnPlugin,
eKeyUpOnPlugin,





eAccessKeyNotFound,

eResize,
eScroll,


eInstall,
eAppInstalled,





ePluginActivate,
ePluginFocus,

eOffline,
eOnline,

eLanguageChange,

eMouseMove,
eMouseUp,
eMouseDown,
eMouseEnterIntoWidget,
eMouseExitFromWidget,
eMouseDoubleClick,
eMouseClick,
eMouseAuxClick,

eMouseActivate,
eMouseOver,
eMouseOut,
eMouseHitTest,
eMouseEnter,
eMouseLeave,
eMouseTouchDrag,
eMouseLongTap,
eMouseEventFirst = eMouseMove, eMouseEventLast = eMouseLongTap,


ePointerMove,
ePointerUp,
ePointerDown,
ePointerOver,
ePointerOut,
ePointerEnter,
ePointerLeave,
ePointerCancel,
ePointerGotCapture,
ePointerLostCapture,
ePointerEventFirst = ePointerMove, ePointerEventLast = ePointerLostCapture,

eContextMenu,

eLoad,
eUnload,
eHashChange,
eImageAbort,
eLoadError,
eLoadEnd,
ePopState,
eStorage,
eBeforeUnload,
eReadyStateChange,

eFormSubmit,
eFormReset,
eFormChange,
eFormSelect,
eFormInvalid,


eFocus,
eBlur,
eFocusIn,
eFocusOut,

eDragEnter,
eDragOver,
eDragExit,
eDrag,
eDragEnd,
eDragStart,
eDrop,
eDragLeave,
eDragDropEventFirst = eDragEnter, eDragDropEventLast = eDragLeave,


eXULPopupShowing,
eXULPopupShown,
eXULPopupPositioned,
eXULPopupHiding,
eXULPopupHidden,
eXULBroadcast,
eXULCommandUpdate,


eLegacyMouseLineOrPageScroll,
eLegacyMousePixelScroll,

eScrollPortUnderflow,
eScrollPortOverflow,

eLegacySubtreeModified,
eLegacyNodeInserted,
eLegacyNodeRemoved,
eLegacyNodeRemovedFromDocument,
eLegacyNodeInsertedIntoDocument,
eLegacyAttrModified,
eLegacyCharacterDataModified,
eLegacyMutationEventFirst = eLegacySubtreeModified, eLegacyMutationEventLast = eLegacyCharacterDataModified,


eUnidentifiedEvent,


eCompositionStart,



eCompositionEnd,




eCompositionUpdate,




eCompositionChange,






eCompositionCommitAsIs,





eCompositionCommit,




eLegacyDOMActivate,

eLegacyDOMFocusIn,

eLegacyDOMFocusOut,


ePageShow,
ePageHide,


eSVGLoad,
eSVGUnload,
eSVGResize,
eSVGScroll,


eSVGZoom,


eXULCommand,


eCopy,
eCut,
ePaste,
ePasteNoFormatting,



eQuerySelectedText,



eQueryTextContent,


eQueryCaretRect,



eQueryTextRect,


eQueryTextRectArray,


eQueryEditorRect,


eQueryContentState,

eQuerySelectionAsTransferable,



eQueryCharacterAtPoint,


eQueryDOMWidgetHittest,


eLoadStart,
eProgress,
eSuspend,
eEmptied,
eStalled,
ePlay,
ePause,
eLoadedMetaData,
eLoadedData,
eWaiting,
ePlaying,
eCanPlay,
eCanPlayThrough,
eSeeking,
eSeeked,
eTimeUpdate,
eEnded,
eRateChange,
eDurationChange,
eVolumeChange,


eAfterPaint,


eSwipeGestureMayStart,
eSwipeGestureStart,
eSwipeGestureUpdate,
eSwipeGestureEnd,
eSwipeGesture,
eMagnifyGestureStart,
eMagnifyGestureUpdate,
eMagnifyGesture,
eRotateGestureStart,
eRotateGestureUpdate,
eRotateGesture,
eTapGesture,
ePressTapGesture,
eEdgeUIStarted,
eEdgeUICanceled,
eEdgeUICompleted,


ePluginInputEvent,



eSetSelection,


eContentCommandCut,
eContentCommandCopy,
eContentCommandPaste,
eContentCommandDelete,
eContentCommandUndo,
eContentCommandRedo,
eContentCommandPasteTransferable,
eContentCommandLookUpDictionary,






eContentCommandScroll,


eGestureNotify,

eScrolledAreaChanged,


eTransitionStart,
eTransitionRun,
eTransitionEnd,
eTransitionCancel,
eAnimationStart,
eAnimationEnd,
eAnimationIteration,
eAnimationCancel,


eWebkitTransitionEnd,
eWebkitAnimationStart,
eWebkitAnimationEnd,
eWebkitAnimationIteration,

eSMILBeginEvent,
eSMILEndEvent,
eSMILRepeatEvent,

eAudioProcess,
eAudioComplete,


eBeforeScriptExecute,
eAfterScriptExecute,

eBeforePrint,
eAfterPrint,

eMessage,


eOpen,


eDeviceOrientation,
eAbsoluteDeviceOrientation,
eDeviceMotion,
eDeviceProximity,
eUserProximity,
eDeviceLight,





eVRDisplayActivate,
eVRDisplayDeactivate,
eVRDisplayConnect,
eVRDisplayDisconnect,
eVRDisplayPresentChange,

eShow,


eFullscreenChange,
eFullscreenError,
eMozFullscreenChange,
eMozFullscreenError,

eTouchStart,
eTouchMove,
eTouchEnd,
eTouchCancel,
eTouchPointerCancel,


ePointerLockChange,
ePointerLockError,
eMozPointerLockChange,
eMozPointerLockError,


eWheel,



eWheelOperationStart,



eWheelOperationEnd,


eTimeChange,


eNetworkUpload,
eNetworkDownload,


eMediaRecorderDataAvailable,
eMediaRecorderWarning,
eMediaRecorderStop,


eGamepadButtonDown,
eGamepadButtonUp,
eGamepadAxisMove,
eGamepadConnected,
eGamepadDisconnected,
eGamepadEventFirst = eGamepadButtonDown, eGamepadEventLast = eGamepadDisconnected,



eEditorInput,


eSelectStart,
eSelectionChange,


eToggle,


eClose,





  eEventMessage_MaxValue
};

const char* ToChar(EventMessage aEventMessage);





typedef uint8_t EventClassIDType;

enum EventClassID : EventClassIDType
{







eBasicEventClass
, eGUIEventClass
, eInputEventClass
, eUIEventClass


, eKeyboardEventClass
, eCompositionEventClass
, eQueryContentEventClass
, eSelectionEventClass
, eEditorInputEventClass


, eMouseEventBaseClass
, eMouseEventClass
, eDragEventClass
, eMouseScrollEventClass
, eWheelEventClass
, ePointerEventClass


, eGestureNotifyEventClass
, eSimpleGestureEventClass
, eTouchEventClass


, eScrollPortEventClass
, eScrollAreaEventClass
, eFormEventClass
, eClipboardEventClass
, eFocusEventClass
, eTransitionEventClass
, eAnimationEventClass
, eSMILTimeEventClass


, eCommandEventClass
, eContentCommandEventClass
, ePluginEventClass


, eMutationEventClass



};

const char* ToChar(EventClassID aEventClassID);

typedef uint16_t Modifiers;




typedef uint16_t KeyNameIndexType;
enum KeyNameIndex : KeyNameIndexType
{

KEY_NAME_INDEX_Unidentified,




KEY_NAME_INDEX_PrintableKey,
KEY_NAME_INDEX_SoftLeft,
KEY_NAME_INDEX_SoftRight,
KEY_NAME_INDEX_Alt,
KEY_NAME_INDEX_AltGraph,
KEY_NAME_INDEX_CapsLock,
KEY_NAME_INDEX_Control,
KEY_NAME_INDEX_Fn,
KEY_NAME_INDEX_FnLock,
KEY_NAME_INDEX_Hyper,
KEY_NAME_INDEX_Meta,
KEY_NAME_INDEX_NumLock,
KEY_NAME_INDEX_OS,
KEY_NAME_INDEX_ScrollLock,
KEY_NAME_INDEX_Shift,
KEY_NAME_INDEX_Super,
KEY_NAME_INDEX_Symbol,
KEY_NAME_INDEX_SymbolLock,




KEY_NAME_INDEX_Enter,
KEY_NAME_INDEX_Tab,




KEY_NAME_INDEX_ArrowDown,
KEY_NAME_INDEX_ArrowLeft,
KEY_NAME_INDEX_ArrowRight,
KEY_NAME_INDEX_ArrowUp,
KEY_NAME_INDEX_End,
KEY_NAME_INDEX_Home,
KEY_NAME_INDEX_PageDown,
KEY_NAME_INDEX_PageUp,




KEY_NAME_INDEX_Backspace,
KEY_NAME_INDEX_Clear,
KEY_NAME_INDEX_Copy,
KEY_NAME_INDEX_CrSel,
KEY_NAME_INDEX_Cut,
KEY_NAME_INDEX_Delete,
KEY_NAME_INDEX_EraseEof,
KEY_NAME_INDEX_ExSel,
KEY_NAME_INDEX_Insert,
KEY_NAME_INDEX_Paste,
KEY_NAME_INDEX_Redo,
KEY_NAME_INDEX_Undo,




KEY_NAME_INDEX_Accept,
KEY_NAME_INDEX_Again,
KEY_NAME_INDEX_Attn,
KEY_NAME_INDEX_Cancel,
KEY_NAME_INDEX_ContextMenu,
KEY_NAME_INDEX_Escape,
KEY_NAME_INDEX_Execute,
KEY_NAME_INDEX_Find,
KEY_NAME_INDEX_Help,
KEY_NAME_INDEX_Pause,
KEY_NAME_INDEX_Play,
KEY_NAME_INDEX_Props,
KEY_NAME_INDEX_Select,
KEY_NAME_INDEX_ZoomIn,
KEY_NAME_INDEX_ZoomOut,




KEY_NAME_INDEX_BrightnessDown,
KEY_NAME_INDEX_BrightnessUp,
KEY_NAME_INDEX_Eject,
KEY_NAME_INDEX_LogOff,
KEY_NAME_INDEX_Power,
KEY_NAME_INDEX_PowerOff,
KEY_NAME_INDEX_PrintScreen,
KEY_NAME_INDEX_Hibernate,
KEY_NAME_INDEX_Standby,
KEY_NAME_INDEX_WakeUp,




KEY_NAME_INDEX_AllCandidates,
KEY_NAME_INDEX_Alphanumeric,
KEY_NAME_INDEX_CodeInput,
KEY_NAME_INDEX_Compose,
KEY_NAME_INDEX_Convert,
KEY_NAME_INDEX_Dead,
KEY_NAME_INDEX_FinalMode,
KEY_NAME_INDEX_GroupFirst,
KEY_NAME_INDEX_GroupLast,
KEY_NAME_INDEX_GroupNext,
KEY_NAME_INDEX_GroupPrevious,
KEY_NAME_INDEX_ModeChange,
KEY_NAME_INDEX_NextCandidate,
KEY_NAME_INDEX_NonConvert,
KEY_NAME_INDEX_PreviousCandidate,
KEY_NAME_INDEX_Process,
KEY_NAME_INDEX_SingleCandidate,




KEY_NAME_INDEX_HangulMode,
KEY_NAME_INDEX_HanjaMode,
KEY_NAME_INDEX_JunjaMode,




KEY_NAME_INDEX_Eisu,
KEY_NAME_INDEX_Hankaku,
KEY_NAME_INDEX_Hiragana,
KEY_NAME_INDEX_HiraganaKatakana,
KEY_NAME_INDEX_KanaMode,
KEY_NAME_INDEX_KanjiMode,
KEY_NAME_INDEX_Katakana,
KEY_NAME_INDEX_Romaji,
KEY_NAME_INDEX_Zenkaku,
KEY_NAME_INDEX_ZenkakuHankaku,




KEY_NAME_INDEX_F1,
KEY_NAME_INDEX_F2,
KEY_NAME_INDEX_F3,
KEY_NAME_INDEX_F4,
KEY_NAME_INDEX_F5,
KEY_NAME_INDEX_F6,
KEY_NAME_INDEX_F7,
KEY_NAME_INDEX_F8,
KEY_NAME_INDEX_F9,
KEY_NAME_INDEX_F10,
KEY_NAME_INDEX_F11,
KEY_NAME_INDEX_F12,
KEY_NAME_INDEX_F13,
KEY_NAME_INDEX_F14,
KEY_NAME_INDEX_F15,
KEY_NAME_INDEX_F16,
KEY_NAME_INDEX_F17,
KEY_NAME_INDEX_F18,
KEY_NAME_INDEX_F19,
KEY_NAME_INDEX_F20,
KEY_NAME_INDEX_F21,
KEY_NAME_INDEX_F22,
KEY_NAME_INDEX_F23,
KEY_NAME_INDEX_F24,
KEY_NAME_INDEX_F25,
KEY_NAME_INDEX_F26,
KEY_NAME_INDEX_F27,
KEY_NAME_INDEX_F28,
KEY_NAME_INDEX_F29,
KEY_NAME_INDEX_F30,
KEY_NAME_INDEX_F31,
KEY_NAME_INDEX_F32,
KEY_NAME_INDEX_F33,
KEY_NAME_INDEX_F34,
KEY_NAME_INDEX_F35,
KEY_NAME_INDEX_Soft1,
KEY_NAME_INDEX_Soft2,
KEY_NAME_INDEX_Soft3,
KEY_NAME_INDEX_Soft4,




KEY_NAME_INDEX_ChannelDown,
KEY_NAME_INDEX_ChannelUp,
KEY_NAME_INDEX_Close,
KEY_NAME_INDEX_MailForward,
KEY_NAME_INDEX_MailReply,
KEY_NAME_INDEX_MailSend,
KEY_NAME_INDEX_MediaFastForward,
KEY_NAME_INDEX_MediaPause,
KEY_NAME_INDEX_MediaPlay,
KEY_NAME_INDEX_MediaPlayPause,
KEY_NAME_INDEX_MediaRecord,
KEY_NAME_INDEX_MediaRewind,
KEY_NAME_INDEX_MediaStop,
KEY_NAME_INDEX_MediaTrackNext,
KEY_NAME_INDEX_MediaTrackPrevious,
KEY_NAME_INDEX_New,
KEY_NAME_INDEX_Open,
KEY_NAME_INDEX_Print,
KEY_NAME_INDEX_Save,
KEY_NAME_INDEX_SpellCheck,




KEY_NAME_INDEX_Key11,
KEY_NAME_INDEX_Key12,




KEY_NAME_INDEX_AudioBalanceLeft,
KEY_NAME_INDEX_AudioBalanceRight,
KEY_NAME_INDEX_AudioBassBoostDown,
KEY_NAME_INDEX_AudioBassBoostToggle,
KEY_NAME_INDEX_AudioBassBoostUp,
KEY_NAME_INDEX_AudioFaderFront,
KEY_NAME_INDEX_AudioFaderRear,
KEY_NAME_INDEX_AudioSurroundModeNext,
KEY_NAME_INDEX_AudioTrebleDown,
KEY_NAME_INDEX_AudioTrebleUp,
KEY_NAME_INDEX_AudioVolumeDown,
KEY_NAME_INDEX_AudioVolumeUp,
KEY_NAME_INDEX_AudioVolumeMute,

KEY_NAME_INDEX_MicrophoneToggle,
KEY_NAME_INDEX_MicrophoneVolumeDown,
KEY_NAME_INDEX_MicrophoneVolumeUp,
KEY_NAME_INDEX_MicrophoneVolumeMute,




KEY_NAME_INDEX_SpeechCorrectionList,
KEY_NAME_INDEX_SpeechInputToggle,




KEY_NAME_INDEX_LaunchCalculator,
KEY_NAME_INDEX_LaunchCalendar,
KEY_NAME_INDEX_LaunchContacts,
KEY_NAME_INDEX_LaunchMail,
KEY_NAME_INDEX_LaunchMediaPlayer,
KEY_NAME_INDEX_LaunchMusicPlayer,
KEY_NAME_INDEX_LaunchMyComputer,
KEY_NAME_INDEX_LaunchPhone,
KEY_NAME_INDEX_LaunchScreenSaver,
KEY_NAME_INDEX_LaunchSpreadsheet,
KEY_NAME_INDEX_LaunchWebBrowser,
KEY_NAME_INDEX_LaunchWebCam,
KEY_NAME_INDEX_LaunchWordProcessor,

KEY_NAME_INDEX_LaunchApplication1,
KEY_NAME_INDEX_LaunchApplication2,
KEY_NAME_INDEX_LaunchApplication3,
KEY_NAME_INDEX_LaunchApplication4,
KEY_NAME_INDEX_LaunchApplication5,
KEY_NAME_INDEX_LaunchApplication6,
KEY_NAME_INDEX_LaunchApplication7,
KEY_NAME_INDEX_LaunchApplication8,
KEY_NAME_INDEX_LaunchApplication9,
KEY_NAME_INDEX_LaunchApplication10,
KEY_NAME_INDEX_LaunchApplication11,
KEY_NAME_INDEX_LaunchApplication12,
KEY_NAME_INDEX_LaunchApplication13,
KEY_NAME_INDEX_LaunchApplication14,
KEY_NAME_INDEX_LaunchApplication15,
KEY_NAME_INDEX_LaunchApplication16,
KEY_NAME_INDEX_LaunchApplication17,
KEY_NAME_INDEX_LaunchApplication18,




KEY_NAME_INDEX_BrowserBack,
KEY_NAME_INDEX_BrowserFavorites,
KEY_NAME_INDEX_BrowserForward,
KEY_NAME_INDEX_BrowserHome,
KEY_NAME_INDEX_BrowserRefresh,
KEY_NAME_INDEX_BrowserSearch,
KEY_NAME_INDEX_BrowserStop,




KEY_NAME_INDEX_AppSwitch,
KEY_NAME_INDEX_Call,
KEY_NAME_INDEX_Camera,
KEY_NAME_INDEX_CameraFocus,
KEY_NAME_INDEX_EndCall,
KEY_NAME_INDEX_GoBack,
KEY_NAME_INDEX_GoHome,
KEY_NAME_INDEX_HeadsetHook,
KEY_NAME_INDEX_LastNumberRedial,
KEY_NAME_INDEX_Notification,
KEY_NAME_INDEX_MannerMode,
KEY_NAME_INDEX_VoiceDial,




KEY_NAME_INDEX_TV,
KEY_NAME_INDEX_TV3DMode,
KEY_NAME_INDEX_TVAntennaCable,
KEY_NAME_INDEX_TVAudioDescription,
KEY_NAME_INDEX_TVAudioDescriptionMixDown,
KEY_NAME_INDEX_TVAudioDescriptionMixUp,
KEY_NAME_INDEX_TVContentsMenu,
KEY_NAME_INDEX_TVDataService,
KEY_NAME_INDEX_TVInput,
KEY_NAME_INDEX_TVInputComponent1,
KEY_NAME_INDEX_TVInputComponent2,
KEY_NAME_INDEX_TVInputComposite1,
KEY_NAME_INDEX_TVInputComposite2,
KEY_NAME_INDEX_TVInputHDMI1,
KEY_NAME_INDEX_TVInputHDMI2,
KEY_NAME_INDEX_TVInputHDMI3,
KEY_NAME_INDEX_TVInputHDMI4,
KEY_NAME_INDEX_TVInputVGA1,
KEY_NAME_INDEX_TVMediaContext,
KEY_NAME_INDEX_TVNetwork,
KEY_NAME_INDEX_TVNumberEntry,
KEY_NAME_INDEX_TVPower,
KEY_NAME_INDEX_TVRadioService,
KEY_NAME_INDEX_TVSatellite,
KEY_NAME_INDEX_TVSatelliteBS,
KEY_NAME_INDEX_TVSatelliteCS,
KEY_NAME_INDEX_TVSatelliteToggle,
KEY_NAME_INDEX_TVTerrestrialAnalog,
KEY_NAME_INDEX_TVTerrestrialDigital,
KEY_NAME_INDEX_TVTimer,




KEY_NAME_INDEX_AVRInput,
KEY_NAME_INDEX_AVRPower,
KEY_NAME_INDEX_ColorF0Red,
KEY_NAME_INDEX_ColorF1Green,
KEY_NAME_INDEX_ColorF2Yellow,
KEY_NAME_INDEX_ColorF3Blue,
KEY_NAME_INDEX_ColorF4Grey,
KEY_NAME_INDEX_ColorF5Brown,
KEY_NAME_INDEX_ClosedCaptionToggle,
KEY_NAME_INDEX_Dimmer,
KEY_NAME_INDEX_DisplaySwap,
KEY_NAME_INDEX_DVR,
KEY_NAME_INDEX_Exit,
KEY_NAME_INDEX_FavoriteClear0,
KEY_NAME_INDEX_FavoriteClear1,
KEY_NAME_INDEX_FavoriteClear2,
KEY_NAME_INDEX_FavoriteClear3,
KEY_NAME_INDEX_FavoriteRecall0,
KEY_NAME_INDEX_FavoriteRecall1,
KEY_NAME_INDEX_FavoriteRecall2,
KEY_NAME_INDEX_FavoriteRecall3,
KEY_NAME_INDEX_FavoriteStore0,
KEY_NAME_INDEX_FavoriteStore1,
KEY_NAME_INDEX_FavoriteStore2,
KEY_NAME_INDEX_FavoriteStore3,
KEY_NAME_INDEX_Guide,
KEY_NAME_INDEX_GuideNextDay,
KEY_NAME_INDEX_GuidePreviousDay,
KEY_NAME_INDEX_Info,
KEY_NAME_INDEX_InstantReplay,
KEY_NAME_INDEX_Link,
KEY_NAME_INDEX_ListProgram,
KEY_NAME_INDEX_LiveContent,
KEY_NAME_INDEX_Lock,
KEY_NAME_INDEX_MediaApps,
KEY_NAME_INDEX_MediaAudioTrack,
KEY_NAME_INDEX_MediaLast,
KEY_NAME_INDEX_MediaSkipBackward,
KEY_NAME_INDEX_MediaSkipForward,
KEY_NAME_INDEX_MediaStepBackward,
KEY_NAME_INDEX_MediaStepForward,
KEY_NAME_INDEX_MediaTopMenu,
KEY_NAME_INDEX_NavigateIn,
KEY_NAME_INDEX_NavigateNext,
KEY_NAME_INDEX_NavigateOut,
KEY_NAME_INDEX_NavigatePrevious,
KEY_NAME_INDEX_NextFavoriteChannel,
KEY_NAME_INDEX_NextUserProfile,
KEY_NAME_INDEX_OnDemand,
KEY_NAME_INDEX_Pairing,
KEY_NAME_INDEX_PinPDown,
KEY_NAME_INDEX_PinPMove,
KEY_NAME_INDEX_PinPToggle,
KEY_NAME_INDEX_PinPUp,
KEY_NAME_INDEX_PlaySpeedDown,
KEY_NAME_INDEX_PlaySpeedReset,
KEY_NAME_INDEX_PlaySpeedUp,
KEY_NAME_INDEX_RandomToggle,
KEY_NAME_INDEX_RcLowBattery,
KEY_NAME_INDEX_RecordSpeedNext,
KEY_NAME_INDEX_RfBypass,
KEY_NAME_INDEX_ScanChannelsToggle,
KEY_NAME_INDEX_ScreenModeNext,
KEY_NAME_INDEX_Settings,
KEY_NAME_INDEX_SplitScreenToggle,
KEY_NAME_INDEX_STBInput,
KEY_NAME_INDEX_STBPower,
KEY_NAME_INDEX_Subtitle,
KEY_NAME_INDEX_Teletext,
KEY_NAME_INDEX_VideoModeNext,
KEY_NAME_INDEX_Wink,
KEY_NAME_INDEX_ZoomToggle,


  KEY_NAME_INDEX_USE_STRING
};



const nsCString ToString(KeyNameIndex aKeyNameIndex);




typedef uint8_t CodeNameIndexType;
enum CodeNameIndex : CodeNameIndexType
{

CODE_NAME_INDEX_UNKNOWN,


CODE_NAME_INDEX_Backquote,
CODE_NAME_INDEX_Backslash,
CODE_NAME_INDEX_Backspace,
CODE_NAME_INDEX_BracketLeft,
CODE_NAME_INDEX_BracketRight,
CODE_NAME_INDEX_Comma,
CODE_NAME_INDEX_Digit0,
CODE_NAME_INDEX_Digit1,
CODE_NAME_INDEX_Digit2,
CODE_NAME_INDEX_Digit3,
CODE_NAME_INDEX_Digit4,
CODE_NAME_INDEX_Digit5,
CODE_NAME_INDEX_Digit6,
CODE_NAME_INDEX_Digit7,
CODE_NAME_INDEX_Digit8,
CODE_NAME_INDEX_Digit9,
CODE_NAME_INDEX_Equal,
CODE_NAME_INDEX_IntlBackslash,
CODE_NAME_INDEX_IntlHash,
CODE_NAME_INDEX_IntlRo,
CODE_NAME_INDEX_IntlYen,
CODE_NAME_INDEX_KeyA,
CODE_NAME_INDEX_KeyB,
CODE_NAME_INDEX_KeyC,
CODE_NAME_INDEX_KeyD,
CODE_NAME_INDEX_KeyE,
CODE_NAME_INDEX_KeyF,
CODE_NAME_INDEX_KeyG,
CODE_NAME_INDEX_KeyH,
CODE_NAME_INDEX_KeyI,
CODE_NAME_INDEX_KeyJ,
CODE_NAME_INDEX_KeyK,
CODE_NAME_INDEX_KeyL,
CODE_NAME_INDEX_KeyM,
CODE_NAME_INDEX_KeyN,
CODE_NAME_INDEX_KeyO,
CODE_NAME_INDEX_KeyP,
CODE_NAME_INDEX_KeyQ,
CODE_NAME_INDEX_KeyR,
CODE_NAME_INDEX_KeyS,
CODE_NAME_INDEX_KeyT,
CODE_NAME_INDEX_KeyU,
CODE_NAME_INDEX_KeyV,
CODE_NAME_INDEX_KeyW,
CODE_NAME_INDEX_KeyX,
CODE_NAME_INDEX_KeyY,
CODE_NAME_INDEX_KeyZ,
CODE_NAME_INDEX_Minus,
CODE_NAME_INDEX_Period,
CODE_NAME_INDEX_Quote,
CODE_NAME_INDEX_Semicolon,
CODE_NAME_INDEX_Slash,


CODE_NAME_INDEX_AltLeft,
CODE_NAME_INDEX_AltRight,
CODE_NAME_INDEX_CapsLock,
CODE_NAME_INDEX_ContextMenu,
CODE_NAME_INDEX_ControlLeft,
CODE_NAME_INDEX_ControlRight,
CODE_NAME_INDEX_Enter,
CODE_NAME_INDEX_OSLeft,
CODE_NAME_INDEX_OSRight,
CODE_NAME_INDEX_ShiftLeft,
CODE_NAME_INDEX_ShiftRight,
CODE_NAME_INDEX_Space,
CODE_NAME_INDEX_Tab,


CODE_NAME_INDEX_Convert,
CODE_NAME_INDEX_KanaMode,
CODE_NAME_INDEX_Lang1,
CODE_NAME_INDEX_Lang2,
CODE_NAME_INDEX_Lang3,
CODE_NAME_INDEX_Lang4,
CODE_NAME_INDEX_Lang5,
CODE_NAME_INDEX_NonConvert,


CODE_NAME_INDEX_Delete,
CODE_NAME_INDEX_End,
CODE_NAME_INDEX_Help,
CODE_NAME_INDEX_Home,
CODE_NAME_INDEX_Insert,
CODE_NAME_INDEX_PageDown,
CODE_NAME_INDEX_PageUp,


CODE_NAME_INDEX_ArrowDown,
CODE_NAME_INDEX_ArrowLeft,
CODE_NAME_INDEX_ArrowRight,
CODE_NAME_INDEX_ArrowUp,


CODE_NAME_INDEX_NumLock,
CODE_NAME_INDEX_Numpad0,
CODE_NAME_INDEX_Numpad1,
CODE_NAME_INDEX_Numpad2,
CODE_NAME_INDEX_Numpad3,
CODE_NAME_INDEX_Numpad4,
CODE_NAME_INDEX_Numpad5,
CODE_NAME_INDEX_Numpad6,
CODE_NAME_INDEX_Numpad7,
CODE_NAME_INDEX_Numpad8,
CODE_NAME_INDEX_Numpad9,
CODE_NAME_INDEX_NumpadAdd,
CODE_NAME_INDEX_NumpadBackspace,
CODE_NAME_INDEX_NumpadClear,
CODE_NAME_INDEX_NumpadClearEntry,
CODE_NAME_INDEX_NumpadComma,
CODE_NAME_INDEX_NumpadDecimal,
CODE_NAME_INDEX_NumpadDivide,
CODE_NAME_INDEX_NumpadEnter,
CODE_NAME_INDEX_NumpadEqual,
CODE_NAME_INDEX_NumpadMemoryAdd,
CODE_NAME_INDEX_NumpadMemoryClear,
CODE_NAME_INDEX_NumpadMemoryRecall,
CODE_NAME_INDEX_NumpadMemoryStore,
CODE_NAME_INDEX_NumpadMemorySubtract,
CODE_NAME_INDEX_NumpadMultiply,
CODE_NAME_INDEX_NumpadParenLeft,
CODE_NAME_INDEX_NumpadParenRight,
CODE_NAME_INDEX_NumpadSubtract,


CODE_NAME_INDEX_Escape,
CODE_NAME_INDEX_F1,
CODE_NAME_INDEX_F2,
CODE_NAME_INDEX_F3,
CODE_NAME_INDEX_F4,
CODE_NAME_INDEX_F5,
CODE_NAME_INDEX_F6,
CODE_NAME_INDEX_F7,
CODE_NAME_INDEX_F8,
CODE_NAME_INDEX_F9,
CODE_NAME_INDEX_F10,
CODE_NAME_INDEX_F11,
CODE_NAME_INDEX_F12,
CODE_NAME_INDEX_F13,
CODE_NAME_INDEX_F14,
CODE_NAME_INDEX_F15,
CODE_NAME_INDEX_F16,
CODE_NAME_INDEX_F17,
CODE_NAME_INDEX_F18,
CODE_NAME_INDEX_F19,
CODE_NAME_INDEX_F20,
CODE_NAME_INDEX_F21,
CODE_NAME_INDEX_F22,
CODE_NAME_INDEX_F23,
CODE_NAME_INDEX_F24,
CODE_NAME_INDEX_Fn,
CODE_NAME_INDEX_FnLock,
CODE_NAME_INDEX_PrintScreen,
CODE_NAME_INDEX_ScrollLock,
CODE_NAME_INDEX_Pause,


CODE_NAME_INDEX_BrowserBack,
CODE_NAME_INDEX_BrowserFavorites,
CODE_NAME_INDEX_BrowserForward,
CODE_NAME_INDEX_BrowserHome,
CODE_NAME_INDEX_BrowserRefresh,
CODE_NAME_INDEX_BrowserSearch,
CODE_NAME_INDEX_BrowserStop,
CODE_NAME_INDEX_Eject,
CODE_NAME_INDEX_LaunchApp1,
CODE_NAME_INDEX_LaunchApp2,
CODE_NAME_INDEX_LaunchMail,
CODE_NAME_INDEX_MediaPlayPause,
CODE_NAME_INDEX_MediaSelect,
CODE_NAME_INDEX_MediaStop,
CODE_NAME_INDEX_MediaTrackNext,
CODE_NAME_INDEX_MediaTrackPrevious,
CODE_NAME_INDEX_Power,
CODE_NAME_INDEX_Sleep,
CODE_NAME_INDEX_VolumeDown,
CODE_NAME_INDEX_VolumeMute,
CODE_NAME_INDEX_VolumeUp,
CODE_NAME_INDEX_WakeUp,
CODE_NAME_INDEX_Again,
CODE_NAME_INDEX_Copy,
CODE_NAME_INDEX_Cut,
CODE_NAME_INDEX_Find,
CODE_NAME_INDEX_Open,
CODE_NAME_INDEX_Paste,
CODE_NAME_INDEX_Props,
CODE_NAME_INDEX_Select,
CODE_NAME_INDEX_Undo,


  CODE_NAME_INDEX_USE_STRING
};



const nsCString ToString(CodeNameIndex aCodeNameIndex);



typedef int8_t CommandInt;
enum Command : CommandInt
{
  CommandDoNothing


, CommandBeginLine
, CommandCharNext
, CommandCharPrevious
, CommandCopy
, CommandCut
, CommandDelete
, CommandDeleteCharBackward
, CommandDeleteCharForward
, CommandDeleteToBeginningOfLine
, CommandDeleteToEndOfLine
, CommandDeleteWordBackward
, CommandDeleteWordForward
, CommandEndLine
, CommandLineNext
, CommandLinePrevious
, CommandMoveBottom
, CommandMovePageDown
, CommandMovePageUp
, CommandMoveTop
, CommandPaste
, CommandScrollBottom
, CommandScrollLineDown
, CommandScrollLineUp
, CommandScrollPageDown
, CommandScrollPageUp
, CommandScrollTop
, CommandSelectAll
, CommandSelectBeginLine
, CommandSelectBottom
, CommandSelectCharNext
, CommandSelectCharPrevious
, CommandSelectEndLine
, CommandSelectLineNext
, CommandSelectLinePrevious
, CommandSelectPageDown
, CommandSelectPageUp
, CommandSelectTop
, CommandSelectWordNext
, CommandSelectWordPrevious
, CommandWordNext
, CommandWordPrevious
};


}





namespace mozilla {





class WidgetEvent;
class WidgetGUIEvent;
class WidgetInputEvent;
class InternalUIEvent;


class WidgetKeyboardEvent;
class WidgetCompositionEvent;
class WidgetQueryContentEvent;
class WidgetSelectionEvent;
class InternalEditorInputEvent;


class WidgetMouseEventBase;
class WidgetMouseEvent;
class WidgetDragEvent;
class WidgetMouseScrollEvent;
class WidgetWheelEvent;
class WidgetPointerEvent;


class WidgetGestureNotifyEvent;
class WidgetSimpleGestureEvent;
class WidgetTouchEvent;


class InternalScrollPortEvent;
class InternalScrollAreaEvent;
class InternalFormEvent;
class InternalClipboardEvent;
class InternalFocusEvent;
class InternalTransitionEvent;
class InternalAnimationEvent;
class InternalSMILTimeEvent;


class WidgetCommandEvent;
class WidgetContentCommandEvent;
class WidgetPluginEvent;


class InternalMutationEvent;





struct BaseEventFlags;
struct EventFlags;

class WidgetEventTime;

class NativeEventData;


struct AlternativeCharCode;
struct ShortcutKeyCandidate;

typedef nsTArray<ShortcutKeyCandidate> ShortcutKeyCandidateArray;
typedef AutoTArray<ShortcutKeyCandidate, 10> AutoShortcutKeyCandidateArray;


typedef uint8_t RawTextRangeType;
enum class TextRangeType : RawTextRangeType;

struct TextRangeStyle;
struct TextRange;

class TextRangeArray;


struct FontRange;

}
class nsCycleCollectionTraversalCallback;

namespace mozilla {
namespace dom {


template <typename T>
struct Nullable
{
private:
  Maybe<T> mValue;

public:
  Nullable()
    : mValue()
  {}

               Nullable(const decltype(nullptr)&)
    : mValue()
  {}

  explicit Nullable(const T& aValue)
    : mValue()
  {
    mValue.emplace(aValue);
  }

               Nullable(T&& aValue)
    : mValue()
  {
    mValue.emplace(mozilla::Move(aValue));
  }

  Nullable(Nullable<T>&& aOther)
    : mValue(mozilla::Move(aOther.mValue))
  {}

  Nullable(const Nullable<T>& aOther)
    : mValue(aOther.mValue)
  {}

  void operator=(const Nullable<T>& aOther)
  {
    mValue = aOther.mValue;
  }

  void SetValue(const T& aArgs)
  {
    mValue.reset();
    mValue.emplace(aArgs);
  }

  void SetValue(T&& aArgs)
  {
    mValue.reset();
    mValue.emplace(mozilla::Move(aArgs));
  }




  T& SetValue() {
    if (mValue.isNothing()) {
      mValue.emplace();
    }
    return mValue.ref();
  }

  void SetNull() {
    mValue.reset();
  }

  const T& Value() const {
    return mValue.ref();
  }

  T& Value() {
    return mValue.ref();
  }

  bool IsNull() const {
    return mValue.isNothing();
  }

  bool Equals(const Nullable<T>& aOtherNullable) const
  {
    return mValue == aOtherNullable.mValue;
  }

  bool operator==(const Nullable<T>& aOtherNullable) const
  {
    return Equals(aOtherNullable);
  }

  bool operator!=(const Nullable<T>& aOtherNullable) const
  {
    return !Equals(aOtherNullable);
  }

  friend std::ostream& operator<<(std::ostream& aStream,
                                  const Nullable& aNullable) {
    return aStream << aNullable.mValue;
  }
};


template<typename T>
void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            Nullable<T>& aNullable,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  if (!aNullable.IsNull()) {
    ImplCycleCollectionTraverse(aCallback, aNullable.Value(), aName, aFlags);
  }
}

template<typename T>
void
ImplCycleCollectionUnlink(Nullable<T>& aNullable)
{
  if (!aNullable.IsNull()) {
    ImplCycleCollectionUnlink(aNullable.Value());
  }
}

}
}

using mozilla::dom::Nullable;
namespace mozilla {
class EventChainVisitor;
class EventChainPostVisitor;
class EventChainPreVisitor;
class EventListenerManager;
namespace dom {
class EventTarget;
}
}
class nsPresContext;
class nsIScriptContext;

class nsIDOMEventListener;

class nsIDOMEvent;
class nsIDOMEventTarget : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult AddEventListener(const nsAString & type, nsIDOMEventListener *listener, bool useCapture, bool wantsUntrusted, uint8_t _argc) = 0;


  virtual nsresult AddSystemEventListener(const nsAString & type, nsIDOMEventListener *listener, bool aUseCapture, bool aWantsUntrusted, uint8_t _argc) = 0;


  nsresult AddEventListener(const nsAString& aType,
                            nsIDOMEventListener* aListener,
                            bool aUseCapture)
  {
    return AddEventListener(aType, aListener, aUseCapture, false, 1);
  }

  nsresult AddEventListener(const nsAString& aType,
                            nsIDOMEventListener* aListener,
                            bool aUseCapture,
                            bool aWantsUntrusted)
  {
    return AddEventListener(aType, aListener, aUseCapture, aWantsUntrusted, 2);
  }

  nsresult AddSystemEventListener(const nsAString& aType,
                                  nsIDOMEventListener* aListener,
                                  bool aUseCapture)
  {
    return AddSystemEventListener(aType, aListener, aUseCapture, false, 1);
  }

  nsresult AddSystemEventListener(const nsAString& aType,
                                  nsIDOMEventListener* aListener,
                                  bool aUseCapture,
                                  bool aWantsUntrusted)
  {
    return AddSystemEventListener(aType, aListener, aUseCapture,
                                  aWantsUntrusted, 2);
  }

  virtual nsresult RemoveEventListener(const nsAString & type, nsIDOMEventListener *listener, bool useCapture) = 0;


  virtual nsresult RemoveSystemEventListener(const nsAString & type, nsIDOMEventListener *listener, bool aUseCapture) = 0;


  virtual nsresult DispatchEvent(nsIDOMEvent *evt, bool *_retval) = 0;


  virtual mozilla::dom::EventTarget * GetTargetForDOMEvent(void) = 0;


  virtual mozilla::dom::EventTarget * GetTargetForEventTargetChain(void) = 0;


  virtual nsresult GetEventTargetParent(mozilla::EventChainPreVisitor & aVisitor) = 0;

   virtual nsresult PreHandleEvent(mozilla::EventChainVisitor& aVisitor)
  {
    return NS_OK;
  }

  virtual nsresult WillHandleEvent(mozilla::EventChainPostVisitor & aVisitor) = 0;


  virtual nsresult PostHandleEvent(mozilla::EventChainPostVisitor & aVisitor) = 0;


  virtual nsresult DispatchDOMEvent(mozilla::WidgetEvent *aEvent, nsIDOMEvent *aDOMEvent, nsPresContext *aPresContext, nsEventStatus *aEventStatus) = 0;


  virtual nsIScriptContext * GetContextForEventHandlers(nsresult *aRv) = 0;

};

  template<typename T> struct nsIDOMEventTarget::COMTypeInfo<nsIDOMEventTarget, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMEventTarget::COMTypeInfo<nsIDOMEventTarget, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x9a78ac3c, 0x9507, 0x4d00, { 0xb2, 0xd6, 0x10, 0xb5, 0x08, 0xd2, 0xec, 0x31 }};
struct jsid
{
    size_t asBits;
    bool operator==(const jsid& rhs) const { return asBits == rhs.asBits; }
    bool operator!=(const jsid& rhs) const { return asBits != rhs.asBits; }
} ;
static __attribute__((always_inline)) inline bool
JSID_IS_STRING(jsid iden)
{
    return ((iden.asBits) & 0x7) == 0;
}

static __attribute__((always_inline)) inline JSString*
JSID_TO_STRING(jsid iden)
{
    do { } while (0);
    return (JSString*)(iden.asBits);
}
jsid
INTERNED_STRING_TO_JSID(JSContext* cx, JSString* str);

static __attribute__((always_inline)) inline bool
JSID_IS_INT(jsid iden)
{
    return !!((iden.asBits) & 0x1);
}

static __attribute__((always_inline)) inline int32_t
JSID_TO_INT(jsid iden)
{
    do { } while (0);
    uint32_t bits = static_cast<uint32_t>((iden.asBits)) >> 1;
    return static_cast<int32_t>(bits);
}




static __attribute__((always_inline)) inline bool
INT_FITS_IN_JSID(int32_t i)
{
    return i >= 0;
}

static __attribute__((always_inline)) inline jsid
INT_TO_JSID(int32_t i)
{
    jsid iden;
    do { } while (0);
    uint32_t bits = (static_cast<uint32_t>(i) << 1) | 0x1;
    (iden.asBits) = static_cast<size_t>(bits);
    return iden;
}

static __attribute__((always_inline)) inline bool
JSID_IS_SYMBOL(jsid iden)
{
    return ((iden.asBits) & 0x7) == 0x4 &&
           (iden.asBits) != 0x4;
}

static __attribute__((always_inline)) inline JS::Symbol*
JSID_TO_SYMBOL(jsid iden)
{
    do { } while (0);
    return (JS::Symbol*)((iden.asBits) & ~(size_t)0x7);
}

static __attribute__((always_inline)) inline jsid
SYMBOL_TO_JSID(JS::Symbol* sym)
{
    jsid iden;
    do { } while (0);
    do { } while (0);
    do { } while (0);
    (iden.asBits) = (size_t(sym) | 0x4);
    return iden;
}

static __attribute__((always_inline)) inline bool
JSID_IS_GCTHING(jsid iden)
{
    return JSID_IS_STRING(iden) || JSID_IS_SYMBOL(iden);
}

static __attribute__((always_inline)) inline JS::GCCellPtr
JSID_TO_GCTHING(jsid iden)
{
    void* thing = (void*)((iden.asBits) & ~(size_t)0x7);
    if (JSID_IS_STRING(iden))
        return JS::GCCellPtr(thing, JS::TraceKind::String);
    do { } while (0);
    return JS::GCCellPtr(thing, JS::TraceKind::Symbol);
}

static __attribute__((always_inline)) inline bool
JSID_IS_VOID(const jsid iden)
{
    do { } while (0);

    return (size_t)(iden.asBits) == 0x2;
}

static __attribute__((always_inline)) inline bool
JSID_IS_EMPTY(const jsid iden)
{
    return (size_t)(iden.asBits) == 0x4;
}

extern const jsid JSID_VOID;
extern const jsid JSID_EMPTY;

extern const JS::HandleId JSID_VOIDHANDLE;
extern const JS::HandleId JSID_EMPTYHANDLE;

namespace JS {

template <>
struct GCPolicy<jsid>
{
    static jsid initial() { return JSID_VOID; }
    static void trace(JSTracer* trc, jsid* idp, const char* name) {
        js::UnsafeTraceManuallyBarrieredEdge(trc, idp, name);
    }
};

}

namespace js {

template <>
struct BarrierMethods<jsid>
{
    static void postBarrier(jsid* idp, jsid prev, jsid next) {}
    static void exposeToJS(jsid iden) {
        if (JSID_IS_GCTHING(iden))
            js::gc::ExposeGCThingToActiveJS(JSID_TO_GCTHING(iden));
    }
};



template <typename F, typename... Args>
auto
DispatchTyped(F f, const jsid& iden, Args&&... args)
  -> decltype(f(static_cast<JSString*>(nullptr), mozilla::Forward<Args>(args)...))
{
    if (JSID_IS_STRING(iden))
        return f(JSID_TO_STRING(iden), mozilla::Forward<Args>(args)...);
    if (JSID_IS_SYMBOL(iden))
        return f(JSID_TO_SYMBOL(iden), mozilla::Forward<Args>(args)...);
    do { } while (0);
    return F::defaultValue(iden);
}



}




namespace mozilla {
namespace dom {
class TabChildGlobal;
class ProcessGlobal;
}
}
class SandboxPrivate;
class nsInProcessTabChildGlobal;
class nsWindowRoot;
class nsWrapperCache
{
public:
  template<typename T, typename U> struct COMTypeInfo;

  nsWrapperCache() : mWrapper(nullptr), mFlags(0)
  {
  }
  ~nsWrapperCache()
  {
    do { } while (0);

  }







  JSObject* GetWrapper() const;
  JSObject* GetWrapperPreserveColor() const
  {
    return GetWrapperJSObject();
  }
  void SetWrapper(JSObject* aWrapper)
  {
    do { } while (0);
    do { } while (0);
    do { } while (0);


    SetWrapperJSObject(aWrapper);
  }





  void ClearWrapper()
  {
    do { } while (0);

    SetWrapperJSObject(nullptr);
  }







  void UpdateWrapper(JSObject* aNewObject, const JSObject* aOldObject)
  {
    if (mWrapper) {
      do { } while (0);
      mWrapper = aNewObject;
    }
  }

  bool PreservingWrapper() const
  {
    return HasWrapperFlag(WRAPPER_BIT_PRESERVED);
  }

  bool IsDOMBinding() const
  {
    return !HasWrapperFlag(WRAPPER_IS_NOT_DOM_BINDING);
  }





  virtual JSObject* WrapObject(JSContext* cx, JS::Handle<JSObject*> aGivenProto) = 0;





  bool HasKnownLiveWrapper() const;






  bool HasKnownLiveWrapperAndDoesNotNeedTracing(nsISupports* aThis);

  bool HasNothingToTrace(nsISupports* aThis);




  void MarkWrapperLive();


  void SetPreservingWrapper(bool aPreserve)
  {
    if(aPreserve) {
      SetWrapperFlags(WRAPPER_BIT_PRESERVED);
    }
    else {
      UnsetWrapperFlags(WRAPPER_BIT_PRESERVED);
    }
  }

  void TraceWrapper(const TraceCallbacks& aCallbacks, void* aClosure)
  {
    if (PreservingWrapper() && mWrapper) {
      aCallbacks.Trace(&mWrapper, "Preserved wrapper", aClosure);
    }
  }






  typedef uint32_t FlagsType;

  FlagsType GetFlags() const
  {
    return mFlags & ~kWrapperFlagsMask;
  }

  bool HasFlag(FlagsType aFlag) const
  {
    do { } while (0);
    return !!(mFlags & aFlag);
  }

  void SetFlags(FlagsType aFlagsToSet)
  {
    do { } while (0);
    mFlags |= aFlagsToSet;
  }

  void UnsetFlags(FlagsType aFlagsToUnset)
  {
    do { } while (0);
    mFlags &= ~aFlagsToUnset;
  }

  void PreserveWrapper(nsISupports* aScriptObjectHolder)
  {
    if (PreservingWrapper()) {
      return;
    }

    nsISupports* ccISupports;
    aScriptObjectHolder->QueryInterface((nsCycleCollectionISupports::COMTypeInfo<nsCycleCollectionISupports, void>::kIID),
                                        reinterpret_cast<void**>(&ccISupports));
    do { } while (0);

    nsXPCOMCycleCollectionParticipant* participant;
    CallQueryInterface(ccISupports, &participant);
    PreserveWrapper(ccISupports, participant);
  }

  void PreserveWrapper(void* aScriptObjectHolder, nsScriptObjectTracer* aTracer)
  {
    if (PreservingWrapper()) {
      return;
    }

    HoldJSObjects(aScriptObjectHolder, aTracer);
    SetPreservingWrapper(true);




  }

  void ReleaseWrapper(void* aScriptObjectHolder);

protected:
  void TraceWrapper(JSTracer* aTrc, const char* name)
  {
    if (mWrapper) {
      js::UnsafeTraceManuallyBarrieredEdge(aTrc, &mWrapper, name);
    }
  }

  void PoisonWrapper()
  {
    if (mWrapper) {


      mWrapper = reinterpret_cast<JSObject*>(1);
    }
  }

private:



  friend class mozilla::dom::TabChildGlobal;
  friend class mozilla::dom::ProcessGlobal;
  friend class SandboxPrivate;
  friend class nsInProcessTabChildGlobal;
  friend class nsWindowRoot;
  void SetIsNotDOMBinding()
  {
    do { } while (0);

    SetWrapperFlags(WRAPPER_IS_NOT_DOM_BINDING);
  }

  JSObject *GetWrapperJSObject() const
  {
    return mWrapper;
  }

  void SetWrapperJSObject(JSObject* aWrapper);

  FlagsType GetWrapperFlags() const
  {
    return mFlags & kWrapperFlagsMask;
  }

  bool HasWrapperFlag(FlagsType aFlag) const
  {
    do { } while (0);
    return !!(mFlags & aFlag);
  }

  void SetWrapperFlags(FlagsType aFlagsToSet)
  {
    do { } while (0);
    mFlags |= aFlagsToSet;
  }

  void UnsetWrapperFlags(FlagsType aFlagsToUnset)
  {
    do { } while (0);
    mFlags &= ~aFlagsToUnset;
  }

  void HoldJSObjects(void* aScriptObjectHolder,
                     nsScriptObjectTracer* aTracer);
  enum { WRAPPER_BIT_PRESERVED = 1 << 0 };





  enum { WRAPPER_IS_NOT_DOM_BINDING = 1 << 1 };

  enum { kWrapperFlagsMask = (WRAPPER_BIT_PRESERVED | WRAPPER_IS_NOT_DOM_BINDING) };

  JSObject* mWrapper;
  FlagsType mFlags;
};

enum { WRAPPER_CACHE_FLAGS_BITS_USED = 2 };

template<typename T> struct nsWrapperCache::COMTypeInfo<nsWrapperCache, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsWrapperCache::COMTypeInfo<nsWrapperCache, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x6f3179a1, 0x36f7, 0x4a5c, { 0x8c, 0xf1, 0xad, 0xc8, 0x7c, 0xde, 0x3e, 0x87 } };


class nsPIDOMWindowOuter;
class nsIGlobalObject;

namespace mozilla {

class AsyncEventDispatcher;
class ErrorResult;
class EventListenerManager;

namespace dom {

class AddEventListenerOptionsOrBoolean;
class Event;
class EventListener;
class EventListenerOptionsOrBoolean;
class EventHandlerNonNull;

template <class T> struct Nullable;






class EventTarget : public nsIDOMEventTarget,
                    public nsWrapperCache
{
public:
  template<typename T, typename U> struct COMTypeInfo;


  using nsIDOMEventTarget::AddEventListener;
  using nsIDOMEventTarget::RemoveEventListener;
  using nsIDOMEventTarget::DispatchEvent;
  virtual void AddEventListener(const nsAString& aType,
                                EventListener* aCallback,
                                const AddEventListenerOptionsOrBoolean& aOptions,
                                const Nullable<bool>& aWantsUntrusted,
                                ErrorResult& aRv) = 0;
  virtual void RemoveEventListener(const nsAString& aType,
                                   EventListener* aCallback,
                                   const EventListenerOptionsOrBoolean& aOptions,
                                   ErrorResult& aRv);
  bool DispatchEvent(Event& aEvent, CallerType aCallerType, ErrorResult& aRv);


  EventHandlerNonNull* GetEventHandler(const nsAString& aType)
  {
    nsCOMPtr<nsIAtom> type = NS_Atomize(aType);
    return GetEventHandler(type, EmptyString());
  }


  void SetEventHandler(const nsAString& aType, EventHandlerNonNull* aHandler,
                       ErrorResult& rv);


  virtual void EventListenerAdded(nsIAtom* aType) {}
  virtual void EventListenerRemoved(nsIAtom* aType) {}




  virtual nsPIDOMWindowOuter* GetOwnerGlobalForBindings() = 0;




  virtual nsIGlobalObject* GetOwnerGlobal() const = 0;




  virtual EventListenerManager* GetOrCreateListenerManager() = 0;





  virtual EventListenerManager* GetExistingListenerManager() const = 0;


  virtual void AsyncEventRunning(AsyncEventDispatcher* aEvent) {}

  virtual bool IsApzAware() const;

protected:
  EventHandlerNonNull* GetEventHandler(nsIAtom* aType,
                                       const nsAString& aTypeString);
  void SetEventHandler(nsIAtom* aType, const nsAString& aTypeString,
                       EventHandlerNonNull* aHandler);
};

template<typename T> struct EventTarget::COMTypeInfo<EventTarget, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID EventTarget::COMTypeInfo<EventTarget, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0xde651c36, 0x0053, 0x4c67, { 0xb1, 0x3d, 0x67, 0xb9, 0x40, 0xfc, 0x82, 0xe4 } };

}
}
class nsAttrAndChildArray;
class nsChildContentList;
struct nsCSSSelectorList;
class nsDOMAttributeMap;
class nsIAnimationObserver;
class nsIContent;
class nsIDocument;
class nsIDOMElement;
class nsIDOMNodeList;
class nsIEditor;
class nsIFrame;
class nsIMutationObserver;
class nsINode;
class nsINodeList;
class nsIPresShell;
class nsIPrincipal;
class nsIURI;
class nsNodeSupportsWeakRefTearoff;
class nsNodeWeakReference;
class nsDOMMutationObserver;

namespace mozilla {
class EventListenerManager;
namespace dom {




inline bool IsSpaceCharacter(char16_t aChar) {
  return aChar == ' ' || aChar == '\t' || aChar == '\n' || aChar == '\r' ||
         aChar == '\f';
}
inline bool IsSpaceCharacter(char aChar) {
  return aChar == ' ' || aChar == '\t' || aChar == '\n' || aChar == '\r' ||
         aChar == '\f';
}
class AccessibleNode;
struct BoxQuadOptions;
struct ConvertCoordinateOptions;
class DOMPoint;
class DOMQuad;
class DOMRectReadOnly;
class Element;
class EventHandlerNonNull;
template<typename T> class Optional;
class OwningNodeOrString;
template<typename> class Sequence;
class Text;
class TextOrElementOrDocument;
struct DOMPointInit;
struct GetRootNodeOptions;
enum class CallerType : uint32_t;
}
}




enum {

  NODE_HAS_LISTENERMANAGER = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (0))),


  NODE_HAS_PROPERTIES = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (1))),






  NODE_IS_ANONYMOUS_ROOT = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (2))),







  NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (3))),





  NODE_IS_NATIVE_ANONYMOUS_ROOT = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (4))),



  NODE_FORCE_XBL_BINDINGS = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (5))),


  NODE_MAY_BE_IN_BINDING_MNGR = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (6))),

  NODE_IS_EDITABLE = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (7))),
  NODE_IS_NATIVE_ANONYMOUS = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (8))),


  NODE_IS_IN_SHADOW_TREE = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (9))),


  NODE_HAS_EMPTY_SELECTOR = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (10))),



  NODE_HAS_SLOW_SELECTOR = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (11))),



  NODE_HAS_EDGE_CHILD_SELECTOR = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (12))),
  NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (13))),

  NODE_ALL_SELECTOR_FLAGS = NODE_HAS_EMPTY_SELECTOR |
                                          NODE_HAS_SLOW_SELECTOR |
                                          NODE_HAS_EDGE_CHILD_SELECTOR |
                                          NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS,



  NODE_NEEDS_FRAME = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (14))),




  NODE_DESCENDANTS_NEED_FRAMES = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (15))),


  NODE_HAS_ACCESSKEY = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (16))),


  NODE_HAS_DIRECTION_RTL = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (17))),


  NODE_HAS_DIRECTION_LTR = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (18))),

  NODE_ALL_DIRECTION_FLAGS = NODE_HAS_DIRECTION_LTR |
                                          NODE_HAS_DIRECTION_RTL,

  NODE_CHROME_ONLY_ACCESS = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (19))),

  NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (20))),






  NODE_SHARED_RESTYLE_BIT_1 = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (21))),
  NODE_SHARED_RESTYLE_BIT_2 = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (22))),


  NODE_HAS_DIRTY_DESCENDANTS_FOR_SERVO = NODE_SHARED_RESTYLE_BIT_1,



  NODE_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO =
    NODE_SHARED_RESTYLE_BIT_2,


  NODE_TYPE_SPECIFIC_BITS_OFFSET = 23
};






static_assert(WRAPPER_CACHE_FLAGS_BITS_USED + (NODE_TYPE_SPECIFIC_BITS_OFFSET) <= sizeof(nsWrapperCache::FlagsType) * 8, "Not enough space for our bits");







class nsMutationGuard {
public:
  nsMutationGuard()
  {
    mStartingGeneration = sGeneration;
  }
  bool Mutated(uint8_t aIgnoreCount)
  {
    return (sGeneration - mStartingGeneration) > aIgnoreCount;
  }




  static void DidMutate()
  {
    sGeneration++;
  }

private:

  uint64_t mStartingGeneration;


  static uint64_t sGeneration;
};
class nsINode : public mozilla::dom::EventTarget
{
public:
  typedef mozilla::dom::BoxQuadOptions BoxQuadOptions;
  typedef mozilla::dom::ConvertCoordinateOptions ConvertCoordinateOptions;
  typedef mozilla::dom::DOMPoint DOMPoint;
  typedef mozilla::dom::DOMPointInit DOMPointInit;
  typedef mozilla::dom::DOMQuad DOMQuad;
  typedef mozilla::dom::DOMRectReadOnly DOMRectReadOnly;
  typedef mozilla::dom::OwningNodeOrString OwningNodeOrString;
  typedef mozilla::dom::TextOrElementOrDocument TextOrElementOrDocument;
  typedef mozilla::dom::CallerType CallerType;
  typedef mozilla::ErrorResult ErrorResult;

  template<class T>
  using Sequence = mozilla::dom::Sequence<T>;

  template<typename T, typename U> struct COMTypeInfo;
  virtual size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;






  virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const {
    return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
  }

  friend class nsNodeUtils;
  friend class nsNodeWeakReference;
  friend class nsNodeSupportsWeakRefTearoff;
  friend class nsAttrAndChildArray;


  explicit nsINode(already_AddRefed<mozilla::dom::NodeInfo>& aNodeInfo)
  : mNodeInfo(aNodeInfo)
  , mParent(nullptr)
  , mBoolFlags(0)
  , mNextSibling(nullptr)
  , mPreviousSibling(nullptr)
  , mFirstChild(nullptr)
  , mSubtreeRoot(this)
  , mSlots(nullptr)
  {
  }


  virtual ~nsINode();




  enum {

    eCONTENT = 1 << 0,

    eDOCUMENT = 1 << 1,

    eATTRIBUTE = 1 << 2,

    eTEXT = 1 << 3,

    ePROCESSING_INSTRUCTION = 1 << 4,

    eCOMMENT = 1 << 5,

    eHTML_FORM_CONTROL = 1 << 6,

    eDOCUMENT_FRAGMENT = 1 << 7,


    eDATA_NODE = 1 << 8,

    eMEDIA = 1 << 9,

    eANIMATION = 1 << 10,

    eFILTER = 1 << 11
  };
  virtual bool IsNodeOfType(uint32_t aFlags) const = 0;

  virtual JSObject* WrapObject(JSContext *aCx, JS::Handle<JSObject*> aGivenProto) override;





  static bool HasBoxQuadsSupport(JSContext* aCx, JSObject* );

protected:
  virtual JSObject* WrapNode(JSContext *aCx, JS::Handle<JSObject*> aGivenProto) = 0;

public:
  mozilla::dom::ParentObject GetParentObject() const;






  virtual nsINode* GetScopeChainParent() const;




  bool IsElement() const {
    return GetBoolFlag(NodeIsElement);
  }





  mozilla::dom::Element* AsElement();
  const mozilla::dom::Element* AsElement() const;





  nsIContent* AsContent();
  const nsIContent* AsContent() const
  {
    return const_cast<nsINode*>(this)->AsContent();
  }





  mozilla::dom::Text* GetAsText();
  const mozilla::dom::Text* GetAsText() const;

  virtual nsIDOMNode* AsDOMNode() = 0;




  bool HasChildren() const { return !!mFirstChild; }





  virtual uint32_t GetChildCount() const = 0;






  virtual nsIContent* GetChildAt(uint32_t aIndex) const = 0;
  virtual nsIContent * const * GetChildArray(uint32_t* aChildCount) const = 0;
  virtual int32_t IndexOf(const nsINode* aPossibleChild) const = 0;
  nsIDocument *OwnerDoc() const
  {
    return mNodeInfo->GetDocument();
  }





  nsINode *OwnerDocAsNode() const;






  bool IsInUncomposedDoc() const
  {
    return GetBoolFlag(IsInDocument);
  }
  nsIDocument* GetUncomposedDoc() const
  {
    return IsInUncomposedDoc() ? OwnerDoc() : nullptr;
  }






  nsIDocument* GetComposedDoc() const
  {
    return IsInShadowTree() ?
      GetComposedDocInternal() : GetUncomposedDoc();
  }




  bool IsInComposedDoc() const
  {
    return IsInUncomposedDoc() || (IsInShadowTree() && GetComposedDocInternal());
  }





  uint16_t NodeType() const
  {
    return mNodeInfo->NodeType();
  }
  const nsString& NodeName() const
  {
    return mNodeInfo->NodeName();
  }
  const nsString& LocalName() const
  {
    return mNodeInfo->LocalName();
  }





  inline mozilla::dom::NodeInfo* NodeInfo() const
  {
    return mNodeInfo;
  }

  inline bool IsInNamespace(int32_t aNamespace) const
  {
    return mNodeInfo->NamespaceID() == aNamespace;
  }





  friend std::ostream& operator<<(std::ostream& aStream, const nsINode& aNode);

protected:


  inline bool IsNodeInternal() const
  {
    return false;
  }

  template<typename First, typename... Args>
  inline bool IsNodeInternal(First aFirst, Args... aArgs) const
  {
    return mNodeInfo->Equals(aFirst) || IsNodeInternal(aArgs...);
  }

public:
  inline bool IsHTMLElement() const
  {
    return IsElement() && IsInNamespace(3);
  }

  inline bool IsHTMLElement(nsIAtom* aTag) const
  {
    return IsElement() && mNodeInfo->Equals(aTag, 3);
  }

  template<typename First, typename... Args>
  inline bool IsAnyOfHTMLElements(First aFirst, Args... aArgs) const
  {
    return IsHTMLElement() && IsNodeInternal(aFirst, aArgs...);
  }

  inline bool IsSVGElement() const
  {
    return IsElement() && IsInNamespace(10);
  }

  inline bool IsSVGElement(nsIAtom* aTag) const
  {
    return IsElement() && mNodeInfo->Equals(aTag, 10);
  }

  template<typename First, typename... Args>
  inline bool IsAnyOfSVGElements(First aFirst, Args... aArgs) const
  {
    return IsSVGElement() && IsNodeInternal(aFirst, aArgs...);
  }

  inline bool IsXULElement() const
  {
    return IsElement() && IsInNamespace(9);
  }

  inline bool IsXULElement(nsIAtom* aTag) const
  {
    return IsElement() && mNodeInfo->Equals(aTag, 9);
  }

  template<typename First, typename... Args>
  inline bool IsAnyOfXULElements(First aFirst, Args... aArgs) const
  {
    return IsXULElement() && IsNodeInternal(aFirst, aArgs...);
  }

  inline bool IsMathMLElement() const
  {
    return IsElement() && IsInNamespace(7);
  }

  inline bool IsMathMLElement(nsIAtom* aTag) const
  {
    return IsElement() && mNodeInfo->Equals(aTag, 7);
  }

  template<typename First, typename... Args>
  inline bool IsAnyOfMathMLElements(First aFirst, Args... aArgs) const
  {
    return IsMathMLElement() && IsNodeInternal(aFirst, aArgs...);
  }
  virtual nsresult InsertChildAt(nsIContent* aKid, uint32_t aIndex,
                                 bool aNotify) = 0;
  nsresult AppendChildTo(nsIContent* aKid, bool aNotify)
  {
    return InsertChildAt(aKid, GetChildCount(), aNotify);
  }
  virtual void RemoveChildAt(uint32_t aIndex, bool aNotify) = 0;
  void* GetProperty(nsIAtom *aPropertyName,
                    nsresult *aStatus = nullptr) const
  {
    return GetProperty(0, aPropertyName, aStatus);
  }
  void* GetProperty(uint16_t aCategory, nsIAtom *aPropertyName,
                    nsresult *aStatus = nullptr) const;
  nsresult SetProperty(nsIAtom *aPropertyName, void *aValue,
                       NSPropertyDtorFunc aDtor = nullptr,
                       bool aTransfer = false)
  {
    return SetProperty(0, aPropertyName, aValue, aDtor, aTransfer);
  }
  nsresult SetProperty(uint16_t aCategory,
                       nsIAtom *aPropertyName, void *aValue,
                       NSPropertyDtorFunc aDtor = nullptr,
                       bool aTransfer = false,
                       void **aOldValue = nullptr);




  template<class T>
  static void DeleteProperty(void *, nsIAtom *, void *aPropertyValue, void *)
  {
    delete static_cast<T *>(aPropertyValue);
  }







  void DeleteProperty(nsIAtom *aPropertyName)
  {
    DeleteProperty(0, aPropertyName);
  }
  void DeleteProperty(uint16_t aCategory, nsIAtom *aPropertyName);
  void* UnsetProperty(nsIAtom *aPropertyName,
                      nsresult *aStatus = nullptr)
  {
    return UnsetProperty(0, aPropertyName, aStatus);
  }
  void* UnsetProperty(uint16_t aCategory, nsIAtom *aPropertyName,
                      nsresult *aStatus = nullptr);

  bool HasProperties() const
  {
    return HasFlag(NODE_HAS_PROPERTIES);
  }





  nsIPrincipal* NodePrincipal() const {
    return mNodeInfo->NodeInfoManager()->DocumentPrincipal();
  }





  nsIContent* GetParent() const {
    return (__builtin_expect(!!(GetBoolFlag(ParentIsContent)), 1)) ?
      reinterpret_cast<nsIContent*>(mParent) : nullptr;
  }






  nsINode* GetParentNode() const
  {
    return mParent;
  }
  inline nsINode* GetFlattenedTreeParentNode() const;







  inline nsINode* GetFlattenedTreeParentNodeForStyle() const;





  mozilla::dom::Element* GetParentElement() const
  {
    return mParent && mParent->IsElement() ? mParent->AsElement() : nullptr;
  }





  mozilla::dom::Element* GetParentElementCrossingShadowRoot() const;






  nsINode* SubtreeRoot() const;





  nsINode* GetRootNode(const mozilla::dom::GetRootNodeOptions& aOptions);




  virtual nsresult AddEventListener(const nsAString & type, nsIDOMEventListener *listener, bool useCapture, bool wantsUntrusted, uint8_t _argc) override; virtual nsresult AddSystemEventListener(const nsAString & type, nsIDOMEventListener *listener, bool aUseCapture, bool aWantsUntrusted, uint8_t _argc) override; virtual nsresult RemoveEventListener(const nsAString & type, nsIDOMEventListener *listener, bool useCapture) override; virtual nsresult RemoveSystemEventListener(const nsAString & type, nsIDOMEventListener *listener, bool aUseCapture) override; virtual nsresult DispatchEvent(nsIDOMEvent *evt, bool *_retval) override; virtual mozilla::dom::EventTarget * GetTargetForDOMEvent(void) override; virtual mozilla::dom::EventTarget * GetTargetForEventTargetChain(void) override; virtual nsresult GetEventTargetParent(mozilla::EventChainPreVisitor & aVisitor) override; virtual nsresult WillHandleEvent(mozilla::EventChainPostVisitor & aVisitor) override; virtual nsresult PostHandleEvent(mozilla::EventChainPostVisitor & aVisitor) override; virtual nsresult DispatchDOMEvent(mozilla::WidgetEvent *aEvent, nsIDOMEvent *aDOMEvent, nsPresContext *aPresContext, nsEventStatus *aEventStatus) override; virtual nsIScriptContext * GetContextForEventHandlers(nsresult *aRv) override;

  virtual mozilla::EventListenerManager*
    GetExistingListenerManager() const override;
  virtual mozilla::EventListenerManager*
    GetOrCreateListenerManager() override;

  using mozilla::dom::EventTarget::RemoveEventListener;
  using nsIDOMEventTarget::AddEventListener;
  virtual void AddEventListener(const nsAString& aType,
                                mozilla::dom::EventListener* aListener,
                                const mozilla::dom::AddEventListenerOptionsOrBoolean& aOptions,
                                const mozilla::dom::Nullable<bool>& aWantsUntrusted,
                                mozilla::ErrorResult& aRv) override;
  using nsIDOMEventTarget::AddSystemEventListener;

  virtual bool IsApzAware() const override;

  virtual nsPIDOMWindowOuter* GetOwnerGlobalForBindings() override;
  virtual nsIGlobalObject* GetOwnerGlobal() const override;






  bool IsStyledByServo() const;




  inline void UnsetRestyleFlagsIfGecko();
  void AddMutationObserver(nsIMutationObserver* aMutationObserver)
  {
    nsSlots* s = Slots();
    do { } while(0);


    s->mMutationObservers.AppendElement(aMutationObserver);
  }
  void AddMutationObserverUnlessExists(nsIMutationObserver* aMutationObserver)
  {
    nsSlots* s = Slots();
    s->mMutationObservers.AppendElementUnlessExists(aMutationObserver);
  }







  void AddAnimationObserver(nsIAnimationObserver* aAnimationObserver);





  void AddAnimationObserverUnlessExists(nsIAnimationObserver* aAnimationObserver);




  void RemoveMutationObserver(nsIMutationObserver* aMutationObserver)
  {
    nsSlots* s = GetExistingSlots();
    if (s) {
      s->mMutationObservers.RemoveElement(aMutationObserver);
    }
  }
  virtual nsresult Clone(mozilla::dom::NodeInfo *aNodeInfo, nsINode **aResult) const = 0;



  class nsSlots
  {
  public:
    nsSlots();



    virtual ~nsSlots();

    void Traverse(nsCycleCollectionTraversalCallback &cb);
    void Unlink();




    nsTObserverArray<nsIMutationObserver*> mMutationObservers;






    RefPtr<nsChildContentList> mChildNodes;





    nsNodeWeakReference* mWeakReference;





    uint32_t mEditableDescendantCount;
  };
  void SetFlags(FlagsType aFlagsToSet)
  {
    do { } while(0);







    nsWrapperCache::SetFlags(aFlagsToSet);
  }

  void UnsetFlags(FlagsType aFlagsToUnset)
  {
    do { } while(0);




    nsWrapperCache::UnsetFlags(aFlagsToUnset);
  }

  void ChangeEditableDescendantCount(int32_t aDelta);





  uint32_t EditableDescendantCount();







  void ResetEditableDescendantCount();

  void SetEditableFlag(bool aEditable)
  {
    if (aEditable) {
      SetFlags(NODE_IS_EDITABLE);
    }
    else {
      UnsetFlags(NODE_IS_EDITABLE);
    }
  }

  bool IsEditable() const
  {

    return IsEditableInternal();



  }





  bool IsNativeAnonymous() const
  {
    return HasFlag(NODE_IS_NATIVE_ANONYMOUS);
  }




  bool IsInNativeAnonymousSubtree() const
  {







    return HasFlag(NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE);

  }

  bool IsInAnonymousSubtree() const;


  bool IsAnonymousContentInSVGUseSubtree() const;



  bool ChromeOnlyAccess() const
  {
    return HasFlag(NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE | NODE_CHROME_ONLY_ACCESS);
  }

  bool IsInShadowTree() const
  {
    return HasFlag(NODE_IS_IN_SHADOW_TREE);
  }







  bool IsSelectionDescendant() const
  {
    return IsDescendantOfCommonAncestorForRangeInSelection() ||
           IsCommonAncestorForRangeInSelection();
  }






  nsIContent* GetTextEditorRootContent(nsIEditor** aEditor = nullptr);
  nsIContent* GetSelectionRootContent(nsIPresShell* aPresShell);

  virtual nsINodeList* ChildNodes();
  nsIContent* GetFirstChild() const { return mFirstChild; }
  nsIContent* GetLastChild() const
  {
    uint32_t count;
    nsIContent* const* children = GetChildArray(&count);

    return count > 0 ? children[count - 1] : nullptr;
  }





  nsIDocument* GetOwnerDocument() const;

  void Normalize();
  virtual already_AddRefed<nsIURI> GetBaseURI(bool aTryUseXHRDocBaseURI = false) const = 0;
  already_AddRefed<nsIURI> GetBaseURIObject() const;
  bool IsNodeApzAware() const
  {
    return NodeMayBeApzAware() ? IsNodeApzAwareInternal() : false;
  }
  virtual bool IsNodeApzAwareInternal() const;



  virtual bool IsHTMLShadowElement() const { return false; }



  virtual bool IsHTMLContentElement() const { return false; }

  void GetTextContent(nsAString& aTextContent,
                      mozilla::OOMReporter& aError)
  {
    GetTextContentInternal(aTextContent, aError);
  }
  void SetTextContent(const nsAString& aTextContent,
                      mozilla::ErrorResult& aError)
  {
    SetTextContentInternal(aTextContent, aError);
  }

  mozilla::dom::Element* QuerySelector(const nsAString& aSelector,
                                       mozilla::ErrorResult& aResult);
  already_AddRefed<nsINodeList> QuerySelectorAll(const nsAString& aSelector,
                                                 mozilla::ErrorResult& aResult);

protected:


  mozilla::dom::Element* GetElementById(const nsAString& aId);
  nsresult SetUserData(const nsAString& aKey, nsIVariant* aData,
                       nsIVariant** aResult);
  nsIVariant* GetUserData(const nsAString& aKey);

public:
  void LookupPrefix(const nsAString& aNamespace, nsAString& aResult);
  bool IsDefaultNamespace(const nsAString& aNamespaceURI)
  {
    nsAutoString defaultNamespace;
    LookupNamespaceURI(EmptyString(), defaultNamespace);
    return aNamespaceURI.Equals(defaultNamespace);
  }
  void LookupNamespaceURI(const nsAString& aNamespacePrefix,
                          nsAString& aNamespaceURI);

  nsIContent* GetNextSibling() const { return mNextSibling; }
  nsIContent* GetPreviousSibling() const { return mPreviousSibling; }
  nsIContent* GetNextNode(const nsINode* aRoot = nullptr) const
  {
    return GetNextNodeImpl(aRoot, false);
  }
  nsIContent* GetNextNonChildNode(const nsINode* aRoot = nullptr) const
  {
    return GetNextNodeImpl(aRoot, true);
  }






  bool Contains(const nsINode* aOther) const;

  bool UnoptimizableCCNode() const;

private:

  nsIDocument* GetComposedDocInternal() const;

  nsIContent* GetNextNodeImpl(const nsINode* aRoot,
                              const bool aSkipChildren) const
  {
    if (!aSkipChildren) {
      nsIContent* kid = GetFirstChild();
      if (kid) {
        return kid;
      }
    }
    if (this == aRoot) {
      return nullptr;
    }
    const nsINode* cur = this;
    while (1) {
      nsIContent* next = cur->GetNextSibling();
      if (next) {
        return next;
      }
      nsINode* parent = cur->GetParentNode();
      if (parent == aRoot) {
        return nullptr;
      }
      cur = parent;
    }
    do { } while(0);
  }

public:
  nsIContent* GetPreviousContent(const nsINode* aRoot = nullptr) const
  {
    if (this == aRoot) {
      return nullptr;
    }
    nsIContent* cur = this->GetParent();
    nsIContent* iter = this->GetPreviousSibling();
    while (iter) {
      cur = iter;
      iter = reinterpret_cast<nsINode*>(iter)->GetLastChild();
    }
    return cur;
  }




private:
  enum BooleanFlag {

    NodeHasRenderingObservers,


    IsInDocument,

    ParentIsContent,

    NodeIsElement,



    ElementHasID,

    ElementMayHaveClass,

    ElementMayHaveStyle,

    ElementHasName,

    ElementMayHaveContentEditableAttr,


    NodeIsCommonAncestorForRangeInSelection,

    NodeIsDescendantOfCommonAncestorForRangeInSelection,

    NodeIsCCMarkedRoot,

    NodeIsCCBlackTree,


    NodeIsPurpleRoot,

    ElementHasLockedStyleStates,

    ElementHasPointerLock,

    NodeMayHaveDOMMutationObserver,

    NodeIsContent,

    ElementHasAnimations,

    NodeHasValidDirAttribute,

    NodeHasFixedDir,


    NodeHasDirAutoSet,



    NodeHasTextNodeDirectionalityMap,

    NodeHasDirAuto,

    NodeAncestorHasDirAuto,


    ElementIsInStyleScope,

    ElementIsScopedStyleRoot,

    NodeHandlingClick,

    NodeHasRelevantHoverRules,


    ElementHasWeirdParserInsertionMode,

    ParserHasNotified,

    MayBeApzAware,

    BooleanFlagCount
  };

  void SetBoolFlag(BooleanFlag name, bool value) {
    static_assert(BooleanFlagCount <= 8*sizeof(mBoolFlags),
                  "Too many boolean flags");
    mBoolFlags = (mBoolFlags & ~(1 << name)) | (value << name);
  }

  void SetBoolFlag(BooleanFlag name) {
    static_assert(BooleanFlagCount <= 8*sizeof(mBoolFlags),
                  "Too many boolean flags");
    mBoolFlags |= (1 << name);
  }

  void ClearBoolFlag(BooleanFlag name) {
    static_assert(BooleanFlagCount <= 8*sizeof(mBoolFlags),
                  "Too many boolean flags");
    mBoolFlags &= ~(1 << name);
  }

  bool GetBoolFlag(BooleanFlag name) const {
    static_assert(BooleanFlagCount <= 8*sizeof(mBoolFlags),
                  "Too many boolean flags");
    return mBoolFlags & (1 << name);
  }

public:
  bool HasRenderingObservers() const
    { return GetBoolFlag(NodeHasRenderingObservers); }
  void SetHasRenderingObservers(bool aValue)
    { SetBoolFlag(NodeHasRenderingObservers, aValue); }
  bool IsContent() const { return GetBoolFlag(NodeIsContent); }
  bool HasID() const { return GetBoolFlag(ElementHasID); }
  bool MayHaveClass() const { return GetBoolFlag(ElementMayHaveClass); }
  void SetMayHaveClass() { SetBoolFlag(ElementMayHaveClass); }
  bool MayHaveStyle() const { return GetBoolFlag(ElementMayHaveStyle); }
  bool HasName() const { return GetBoolFlag(ElementHasName); }
  bool MayHaveContentEditableAttr() const
    { return GetBoolFlag(ElementMayHaveContentEditableAttr); }
  bool IsCommonAncestorForRangeInSelection() const
    { return GetBoolFlag(NodeIsCommonAncestorForRangeInSelection); }
  void SetCommonAncestorForRangeInSelection()
    { SetBoolFlag(NodeIsCommonAncestorForRangeInSelection); }
  void ClearCommonAncestorForRangeInSelection()
    { ClearBoolFlag(NodeIsCommonAncestorForRangeInSelection); }
  bool IsDescendantOfCommonAncestorForRangeInSelection() const
    { return GetBoolFlag(NodeIsDescendantOfCommonAncestorForRangeInSelection); }
  void SetDescendantOfCommonAncestorForRangeInSelection()
    { SetBoolFlag(NodeIsDescendantOfCommonAncestorForRangeInSelection); }
  void ClearDescendantOfCommonAncestorForRangeInSelection()
    { ClearBoolFlag(NodeIsDescendantOfCommonAncestorForRangeInSelection); }

  void SetCCMarkedRoot(bool aValue)
    { SetBoolFlag(NodeIsCCMarkedRoot, aValue); }
  bool CCMarkedRoot() const { return GetBoolFlag(NodeIsCCMarkedRoot); }
  void SetInCCBlackTree(bool aValue)
    { SetBoolFlag(NodeIsCCBlackTree, aValue); }
  bool InCCBlackTree() const { return GetBoolFlag(NodeIsCCBlackTree); }
  void SetIsPurpleRoot(bool aValue)
    { SetBoolFlag(NodeIsPurpleRoot, aValue); }
  bool IsPurpleRoot() const { return GetBoolFlag(NodeIsPurpleRoot); }
  bool MayHaveDOMMutationObserver()
    { return GetBoolFlag(NodeMayHaveDOMMutationObserver); }
  void SetMayHaveDOMMutationObserver()
    { SetBoolFlag(NodeMayHaveDOMMutationObserver, true); }
  bool HasListenerManager() { return HasFlag(NODE_HAS_LISTENERMANAGER); }
  bool HasPointerLock() const { return GetBoolFlag(ElementHasPointerLock); }
  void SetPointerLock() { SetBoolFlag(ElementHasPointerLock); }
  void ClearPointerLock() { ClearBoolFlag(ElementHasPointerLock); }
  bool MayHaveAnimations() const { return GetBoolFlag(ElementHasAnimations); }
  void SetMayHaveAnimations() { SetBoolFlag(ElementHasAnimations); }
  void SetHasValidDir() { SetBoolFlag(NodeHasValidDirAttribute); }
  void ClearHasValidDir() { ClearBoolFlag(NodeHasValidDirAttribute); }
  bool HasValidDir() const { return GetBoolFlag(NodeHasValidDirAttribute); }
  void SetHasFixedDir() {
    do { } while (0);

    SetBoolFlag(NodeHasFixedDir);
  }
  void ClearHasFixedDir() {
    do { } while (0);

    ClearBoolFlag(NodeHasFixedDir);
  }
  bool HasFixedDir() const { return GetBoolFlag(NodeHasFixedDir); }
  void SetHasDirAutoSet() {
    do { } while (0);

    SetBoolFlag(NodeHasDirAutoSet);
  }
  void ClearHasDirAutoSet() {
    do { } while (0);

    ClearBoolFlag(NodeHasDirAutoSet);
  }
  bool HasDirAutoSet() const
    { return GetBoolFlag(NodeHasDirAutoSet); }
  void SetHasTextNodeDirectionalityMap() {
    do { } while (0);

    SetBoolFlag(NodeHasTextNodeDirectionalityMap);
  }
  void ClearHasTextNodeDirectionalityMap() {
    do { } while (0);

    ClearBoolFlag(NodeHasTextNodeDirectionalityMap);
  }
  bool HasTextNodeDirectionalityMap() const {
    do { } while (0);

    return GetBoolFlag(NodeHasTextNodeDirectionalityMap);
  }

  void SetHasDirAuto() { SetBoolFlag(NodeHasDirAuto); }
  void ClearHasDirAuto() { ClearBoolFlag(NodeHasDirAuto); }
  bool HasDirAuto() const { return GetBoolFlag(NodeHasDirAuto); }

  void SetAncestorHasDirAuto() { SetBoolFlag(NodeAncestorHasDirAuto); }
  void ClearAncestorHasDirAuto() { ClearBoolFlag(NodeAncestorHasDirAuto); }
  bool AncestorHasDirAuto() const { return GetBoolFlag(NodeAncestorHasDirAuto); }

  bool NodeOrAncestorHasDirAuto() const
    { return HasDirAuto() || AncestorHasDirAuto(); }

  void SetIsElementInStyleScope(bool aValue) {
    do { } while (0);
    SetBoolFlag(ElementIsInStyleScope, aValue);
  }
  void SetIsElementInStyleScope() {
    do { } while (0);
    SetBoolFlag(ElementIsInStyleScope);
  }
  void ClearIsElementInStyleScope() {
    do { } while (0);
    ClearBoolFlag(ElementIsInStyleScope);
  }
  bool IsElementInStyleScope() const { return GetBoolFlag(ElementIsInStyleScope); }

  void SetIsScopedStyleRoot() { SetBoolFlag(ElementIsScopedStyleRoot); }
  void ClearIsScopedStyleRoot() { ClearBoolFlag(ElementIsScopedStyleRoot); }
  bool IsScopedStyleRoot() { return GetBoolFlag(ElementIsScopedStyleRoot); }
  bool HasRelevantHoverRules() const { return GetBoolFlag(NodeHasRelevantHoverRules); }
  void SetHasRelevantHoverRules() { SetBoolFlag(NodeHasRelevantHoverRules); }
  void SetParserHasNotified() { SetBoolFlag(ParserHasNotified); };
  bool HasParserNotified() { return GetBoolFlag(ParserHasNotified); }

  void SetMayBeApzAware() { SetBoolFlag(MayBeApzAware); }
  bool NodeMayBeApzAware() const
  {
    return GetBoolFlag(MayBeApzAware);
  }
protected:
  void SetParentIsContent(bool aValue) { SetBoolFlag(ParentIsContent, aValue); }
  void SetIsInDocument() { SetBoolFlag(IsInDocument); }
  void SetNodeIsContent() { SetBoolFlag(NodeIsContent); }
  void ClearInDocument() { ClearBoolFlag(IsInDocument); }
  void SetIsElement() { SetBoolFlag(NodeIsElement); }
  void SetHasID() { SetBoolFlag(ElementHasID); }
  void ClearHasID() { ClearBoolFlag(ElementHasID); }
  void SetMayHaveStyle() { SetBoolFlag(ElementMayHaveStyle); }
  void SetHasName() { SetBoolFlag(ElementHasName); }
  void ClearHasName() { ClearBoolFlag(ElementHasName); }
  void SetMayHaveContentEditableAttr()
    { SetBoolFlag(ElementMayHaveContentEditableAttr); }
  void SetHasLockedStyleStates() { SetBoolFlag(ElementHasLockedStyleStates); }
  void ClearHasLockedStyleStates() { ClearBoolFlag(ElementHasLockedStyleStates); }
  bool HasLockedStyleStates() const
    { return GetBoolFlag(ElementHasLockedStyleStates); }
  void SetHasWeirdParserInsertionMode() { SetBoolFlag(ElementHasWeirdParserInsertionMode); }
  bool HasWeirdParserInsertionMode() const
  { return GetBoolFlag(ElementHasWeirdParserInsertionMode); }
  bool HandlingClick() const { return GetBoolFlag(NodeHandlingClick); }
  void SetHandlingClick() { SetBoolFlag(NodeHandlingClick); }
  void ClearHandlingClick() { ClearBoolFlag(NodeHandlingClick); }

  void SetSubtreeRootPointer(nsINode* aSubtreeRoot)
  {
    do { } while(0);
    do { } while(0);

    mSubtreeRoot = aSubtreeRoot;
  }

  void ClearSubtreeRootPointer()
  {
    mSubtreeRoot = nullptr;
  }

public:

  void BindObject(nsISupports* aObject);


  void UnbindObject(nsISupports* aObject);

  void GetBoundMutationObservers(nsTArray<RefPtr<nsDOMMutationObserver> >& aResult);

  already_AddRefed<mozilla::dom::AccessibleNode> GetAccessibleNode();





  uint32_t Length() const;

  void GetNodeName(mozilla::dom::DOMString& aNodeName)
  {
    const nsString& nodeName = NodeName();
    aNodeName.SetStringBuffer(nsStringBuffer::FromString(nodeName),
                              nodeName.Length());
  }
  __attribute__ ((warn_unused_result)) nsresult GetBaseURI(nsAString& aBaseURI) const;




  void GetBaseURIFromJS(nsAString& aBaseURI,
                        CallerType aCallerType,
                        ErrorResult& aRv) const;
  bool HasChildNodes() const
  {
    return HasChildren();
  }
  uint16_t CompareDocumentPosition(nsINode& aOther) const;
  void GetNodeValue(nsAString& aNodeValue)
  {
    GetNodeValueInternal(aNodeValue);
  }
  void SetNodeValue(const nsAString& aNodeValue,
                    mozilla::ErrorResult& aError)
  {
    SetNodeValueInternal(aNodeValue, aError);
  }
  virtual void GetNodeValueInternal(nsAString& aNodeValue);
  virtual void SetNodeValueInternal(const nsAString& aNodeValue,
                                    mozilla::ErrorResult& aError)
  {


  }
  void EnsurePreInsertionValidity(nsINode& aNewChild, nsINode* aRefChild,
                                  mozilla::ErrorResult& aError);
  nsINode* InsertBefore(nsINode& aNode, nsINode* aChild,
                        mozilla::ErrorResult& aError)
  {
    return ReplaceOrInsertBefore(false, &aNode, aChild, aError);
  }
  nsINode* AppendChild(nsINode& aNode, mozilla::ErrorResult& aError)
  {
    return InsertBefore(aNode, nullptr, aError);
  }
  nsINode* ReplaceChild(nsINode& aNode, nsINode& aChild,
                        mozilla::ErrorResult& aError)
  {
    return ReplaceOrInsertBefore(true, &aNode, &aChild, aError);
  }
  nsINode* RemoveChild(nsINode& aChild, mozilla::ErrorResult& aError);
  already_AddRefed<nsINode> CloneNode(bool aDeep, mozilla::ErrorResult& aError);
  bool IsSameNode(nsINode* aNode);
  bool IsEqualNode(nsINode* aNode);
  void GetNamespaceURI(nsAString& aNamespaceURI) const
  {
    mNodeInfo->GetNamespaceURI(aNamespaceURI);
  }

  void GetPrefix(nsAString& aPrefix)
  {
    mNodeInfo->GetPrefix(aPrefix);
  }

  void GetLocalName(mozilla::dom::DOMString& aLocalName) const
  {
    const nsString& localName = LocalName();
    if (localName.IsVoid()) {
      aLocalName.SetNull();
    } else {
      aLocalName.SetStringBuffer(nsStringBuffer::FromString(localName),
                                 localName.Length());
    }
  }

  nsDOMAttributeMap* GetAttributes();
  void SetUserData(JSContext* aCx, const nsAString& aKey,
                   JS::Handle<JS::Value> aData,
                   JS::MutableHandle<JS::Value> aRetval,
                   mozilla::ErrorResult& aError);
  void GetUserData(JSContext* aCx, const nsAString& aKey,
                   JS::MutableHandle<JS::Value> aRetval,
                   mozilla::ErrorResult& aError);




  nsresult RemoveFromParent()
  {
    nsINode* parent = GetParentNode();
    mozilla::ErrorResult rv;
    parent->RemoveChild(*this, rv);
    return rv.StealNSResult();
  }


  mozilla::dom::Element* GetPreviousElementSibling() const;
  mozilla::dom::Element* GetNextElementSibling() const;

  void Before(const Sequence<OwningNodeOrString>& aNodes, ErrorResult& aRv);
  void After(const Sequence<OwningNodeOrString>& aNodes, ErrorResult& aRv);
  void ReplaceWith(const Sequence<OwningNodeOrString>& aNodes,
                   ErrorResult& aRv);



  void Remove();


  mozilla::dom::Element* GetFirstElementChild() const;
  mozilla::dom::Element* GetLastElementChild() const;

  void Prepend(const Sequence<OwningNodeOrString>& aNodes, ErrorResult& aRv);
  void Append(const Sequence<OwningNodeOrString>& aNodes, ErrorResult& aRv);

  void GetBoxQuads(const BoxQuadOptions& aOptions,
                   nsTArray<RefPtr<DOMQuad> >& aResult,
                   CallerType aCallerType,
                   ErrorResult& aRv);

  already_AddRefed<DOMQuad> ConvertQuadFromNode(DOMQuad& aQuad,
                                                const TextOrElementOrDocument& aFrom,
                                                const ConvertCoordinateOptions& aOptions,
                                                CallerType aCallerType,
                                                ErrorResult& aRv);
  already_AddRefed<DOMQuad> ConvertRectFromNode(DOMRectReadOnly& aRect,
                                                const TextOrElementOrDocument& aFrom,
                                                const ConvertCoordinateOptions& aOptions,
                                                CallerType aCallerType,
                                                ErrorResult& aRv);
  already_AddRefed<DOMPoint> ConvertPointFromNode(const DOMPointInit& aPoint,
                                                  const TextOrElementOrDocument& aFrom,
                                                  const ConvertCoordinateOptions& aOptions,
                                                  CallerType aCallerType,
                                                  ErrorResult& aRv);

protected:



  virtual nsINode::nsSlots* CreateSlots();

  bool HasSlots() const
  {
    return mSlots != nullptr;
  }

  nsSlots* GetExistingSlots() const
  {
    return mSlots;
  }

  nsSlots* Slots()
  {
    if (!HasSlots()) {
      mSlots = CreateSlots();
      do { } while (0);
    }
    return GetExistingSlots();
  }

  nsTObserverArray<nsIMutationObserver*> *GetMutationObservers()
  {
    return HasSlots() ? &GetExistingSlots()->mMutationObservers : nullptr;
  }

  bool IsEditableInternal() const;
  virtual bool IsEditableExternal() const
  {
    return IsEditableInternal();
  }

  virtual void GetTextContentInternal(nsAString& aTextContent,
                                      mozilla::OOMReporter& aError);
  virtual void SetTextContentInternal(const nsAString& aTextContent,
                                      mozilla::ErrorResult& aError)
  {
  }
  nsresult GetParentNode(nsIDOMNode** aParentNode);
  nsresult GetChildNodes(nsIDOMNodeList** aChildNodes);
  nsresult GetFirstChild(nsIDOMNode** aFirstChild);
  nsresult GetLastChild(nsIDOMNode** aLastChild);
  nsresult GetPreviousSibling(nsIDOMNode** aPrevSibling);
  nsresult GetNextSibling(nsIDOMNode** aNextSibling);
  nsresult GetOwnerDocument(nsIDOMDocument** aOwnerDocument);

  void EnsurePreInsertionValidity1(nsINode& aNewChild, nsINode* aRefChild,
                                   mozilla::ErrorResult& aError);
  void EnsurePreInsertionValidity2(bool aReplace, nsINode& aNewChild,
                                   nsINode* aRefChild,
                                   mozilla::ErrorResult& aError);
  nsINode* ReplaceOrInsertBefore(bool aReplace, nsINode* aNewChild,
                                 nsINode* aRefChild,
                                 mozilla::ErrorResult& aError);
  nsresult RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn);







  virtual mozilla::dom::Element* GetNameSpaceElement() = 0;
  void doRemoveChildAt(uint32_t aIndex, bool aNotify, nsIContent* aKid,
                       nsAttrAndChildArray& aChildArray);
  nsresult doInsertChildAt(nsIContent* aKid, uint32_t aIndex,
                           bool aNotify, nsAttrAndChildArray& aChildArray);
  nsCSSSelectorList* ParseSelectorList(const nsAString& aSelectorString,
                                       mozilla::ErrorResult& aRv);

public:
mozilla::dom::EventHandlerNonNull* GetOnabort(); void SetOnabort(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOncanplay(); void SetOncanplay(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOncanplaythrough(); void SetOncanplaythrough(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnchange(); void SetOnchange(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnauxclick(); void SetOnauxclick(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnclick(); void SetOnclick(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnclose(); void SetOnclose(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOncontextmenu(); void SetOncontextmenu(mozilla::dom::EventHandlerNonNull* listener);
mozilla::dom::EventHandlerNonNull* GetOndblclick(); void SetOndblclick(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOndrag(); void SetOndrag(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOndragend(); void SetOndragend(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOndragenter(); void SetOndragenter(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOndragexit(); void SetOndragexit(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOndragleave(); void SetOndragleave(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOndragover(); void SetOndragover(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOndragstart(); void SetOndragstart(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOndrop(); void SetOndrop(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOndurationchange(); void SetOndurationchange(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnemptied(); void SetOnemptied(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnended(); void SetOnended(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnfullscreenchange(); void SetOnfullscreenchange(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnfullscreenerror(); void SetOnfullscreenerror(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOninput(); void SetOninput(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOninvalid(); void SetOninvalid(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnkeydown(); void SetOnkeydown(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnkeypress(); void SetOnkeypress(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnkeyup(); void SetOnkeyup(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnmozkeydownonplugin(); void SetOnmozkeydownonplugin(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnmozkeyuponplugin(); void SetOnmozkeyuponplugin(mozilla::dom::EventHandlerNonNull* listener);







mozilla::dom::EventHandlerNonNull* GetOnloadeddata(); void SetOnloadeddata(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnloadedmetadata(); void SetOnloadedmetadata(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnloadend(); void SetOnloadend(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnloadstart(); void SetOnloadstart(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnmousedown(); void SetOnmousedown(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnmouseenter(); void SetOnmouseenter(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnmouseleave(); void SetOnmouseleave(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnmousemove(); void SetOnmousemove(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnmouseout(); void SetOnmouseout(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnmouseover(); void SetOnmouseover(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnmouseup(); void SetOnmouseup(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnmozfullscreenchange(); void SetOnmozfullscreenchange(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnmozfullscreenerror(); void SetOnmozfullscreenerror(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnmozpointerlockchange(); void SetOnmozpointerlockchange(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnmozpointerlockerror(); void SetOnmozpointerlockerror(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnpointerlockchange(); void SetOnpointerlockchange(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnpointerlockerror(); void SetOnpointerlockerror(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnpointerdown(); void SetOnpointerdown(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnpointermove(); void SetOnpointermove(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnpointerup(); void SetOnpointerup(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnpointercancel(); void SetOnpointercancel(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnpointerover(); void SetOnpointerover(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnpointerout(); void SetOnpointerout(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnpointerenter(); void SetOnpointerenter(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnpointerleave(); void SetOnpointerleave(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOngotpointercapture(); void SetOngotpointercapture(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnlostpointercapture(); void SetOnlostpointercapture(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnselectstart(); void SetOnselectstart(mozilla::dom::EventHandlerNonNull* listener);






mozilla::dom::EventHandlerNonNull* GetOnpause(); void SetOnpause(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnplay(); void SetOnplay(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnplaying(); void SetOnplaying(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnprogress(); void SetOnprogress(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnratechange(); void SetOnratechange(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnreset(); void SetOnreset(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnseeked(); void SetOnseeked(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnseeking(); void SetOnseeking(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnselect(); void SetOnselect(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnshow(); void SetOnshow(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnstalled(); void SetOnstalled(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnsubmit(); void SetOnsubmit(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnsuspend(); void SetOnsuspend(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOntimeupdate(); void SetOntimeupdate(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOntoggle(); void SetOntoggle(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnvolumechange(); void SetOnvolumechange(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnwaiting(); void SetOnwaiting(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnwheel(); void SetOnwheel(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOncopy(); void SetOncopy(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOncut(); void SetOncut(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnpaste(); void SetOnpaste(mozilla::dom::EventHandlerNonNull* listener);




mozilla::dom::EventHandlerNonNull* GetOnbeforescriptexecute(); void SetOnbeforescriptexecute(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnafterscriptexecute(); void SetOnafterscriptexecute(mozilla::dom::EventHandlerNonNull* listener);




mozilla::dom::EventHandlerNonNull* GetOnblur(); void SetOnblur(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnerror(); void SetOnerror(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnfocus(); void SetOnfocus(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnfocusin(); void SetOnfocusin(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnfocusout(); void SetOnfocusout(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnload(); void SetOnload(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnresize(); void SetOnresize(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnscroll(); void SetOnscroll(mozilla::dom::EventHandlerNonNull* listener);
mozilla::dom::EventHandlerNonNull* GetOntouchstart(); void SetOntouchstart(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOntouchend(); void SetOntouchend(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOntouchmove(); void SetOntouchmove(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOntouchcancel(); void SetOntouchcancel(mozilla::dom::EventHandlerNonNull* listener);




mozilla::dom::EventHandlerNonNull* GetOnreadystatechange(); void SetOnreadystatechange(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnselectionchange(); void SetOnselectionchange(mozilla::dom::EventHandlerNonNull* listener);
mozilla::dom::EventHandlerNonNull* GetOntransitionstart(); void SetOntransitionstart(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOntransitionrun(); void SetOntransitionrun(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOntransitionend(); void SetOntransitionend(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOntransitioncancel(); void SetOntransitioncancel(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnanimationstart(); void SetOnanimationstart(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnanimationend(); void SetOnanimationend(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnanimationiteration(); void SetOnanimationiteration(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnanimationcancel(); void SetOnanimationcancel(mozilla::dom::EventHandlerNonNull* listener);





mozilla::dom::EventHandlerNonNull* GetOnwebkitAnimationEnd(); void SetOnwebkitAnimationEnd(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnwebkitAnimationIteration(); void SetOnwebkitAnimationIteration(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnwebkitAnimationStart(); void SetOnwebkitAnimationStart(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnwebkitTransitionEnd(); void SetOnwebkitTransitionEnd(mozilla::dom::EventHandlerNonNull* listener);




mozilla::dom::EventHandlerNonNull* GetOnwebkitanimationend(); void SetOnwebkitanimationend(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnwebkitanimationiteration(); void SetOnwebkitanimationiteration(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnwebkitanimationstart(); void SetOnwebkitanimationstart(mozilla::dom::EventHandlerNonNull* listener);



mozilla::dom::EventHandlerNonNull* GetOnwebkittransitionend(); void SetOnwebkittransitionend(mozilla::dom::EventHandlerNonNull* listener);




protected:
  static bool Traverse(nsINode *tmp, nsCycleCollectionTraversalCallback &cb);
  static void Unlink(nsINode *tmp);

  RefPtr<mozilla::dom::NodeInfo> mNodeInfo;




  nsINode* mParent;

private:

  uint32_t mBoolFlags;

protected:


  nsIContent* mNextSibling;
  nsIContent* mPreviousSibling;



  nsIContent* mFirstChild;

  union {

    nsIFrame* mPrimaryFrame;




    nsINode* mSubtreeRoot;
  };


  nsSlots* mSlots;
};

inline nsIDOMNode* GetAsDOMNode(nsINode* aNode)
{
  return aNode ? aNode->AsDOMNode() : nullptr;
}






template<class C, class D>
inline nsINode* NODE_FROM(C& aContent, D& aDocument)
{
  if (aContent)
    return static_cast<nsINode*>(aContent);
  return static_cast<nsINode*>(aDocument);
}

template<typename T> struct nsINode::COMTypeInfo<nsINode, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsINode::COMTypeInfo<nsINode, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x70ba4547, 0x7699, 0x44fc, { 0xb3, 0x20, 0x52, 0xdb, 0xe3, 0xd1, 0xf9, 0x0a } };

inline nsISupports*
ToSupports(nsINode* aPointer)
{
  return aPointer;
}

inline nsISupports*
ToCanonicalSupports(nsINode* aPointer)
{
  return aPointer;
}


class nsAString;
class nsIAtom;
class nsIURI;
class nsRuleWalker;
class nsAttrValue;
class nsAttrName;
class nsTextFragment;
class nsIFrame;
class nsXBLBinding;

namespace mozilla {
class EventChainPreVisitor;
namespace dom {
class ShadowRoot;
}
namespace widget {
struct IMEState;
}
}

enum nsLinkState {
  eLinkState_Unvisited = 1,
  eLinkState_Visited = 2,
  eLinkState_NotLink = 3
};
class nsIContent : public nsINode {
public:
  typedef mozilla::widget::IMEState IMEState;





  explicit nsIContent(already_AddRefed<mozilla::dom::NodeInfo>& aNodeInfo)
    : nsINode(aNodeInfo)
  {
    do { } while (0);
    SetNodeIsContent();
  }


  template<typename T, typename U> struct COMTypeInfo;
  virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
                              nsIContent* aBindingParent,
                              bool aCompileEventHandlers) = 0;
  virtual void UnbindFromTree(bool aDeep = true,
                              bool aNullParent = true) = 0;

  enum {
    eAllChildren = 0,
    eAllButXBL = 1,





    eSkipPlaceholderContent = 2,






    eSkipDocumentLevelNativeAnonymousContent = 4,
  };
  virtual already_AddRefed<nsINodeList> GetChildren(uint32_t aFilter) = 0;






  bool IsRootOfNativeAnonymousSubtree() const
  {
    do { } while(0);



    return HasFlag(NODE_IS_NATIVE_ANONYMOUS_ROOT);
  }

  bool IsRootOfChromeAccessOnlySubtree() const
  {
    return HasFlag(NODE_IS_NATIVE_ANONYMOUS_ROOT |
                   NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS);
  }





  void SetIsNativeAnonymousRoot()
  {
    SetFlags(NODE_IS_ANONYMOUS_ROOT | NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE |
             NODE_IS_NATIVE_ANONYMOUS_ROOT | NODE_IS_NATIVE_ANONYMOUS);
  }





  virtual nsIContent* FindFirstNonChromeOnlyAccessContent() const;





  bool IsRootOfAnonymousSubtree() const
  {
    do { } while(0);



    do { } while(0);
    return HasFlag(NODE_IS_ANONYMOUS_ROOT);
  }






  bool IsInAnonymousSubtree() const
  {
    do { } while(0);




    return IsInNativeAnonymousSubtree() || (!IsInShadowTree() && GetBindingParent() != nullptr);
  }





  inline bool IsInHTMLDocument() const;





  virtual bool IsInChromeDocument() const;





  inline int32_t GetNameSpaceID() const
  {
    return mNodeInfo->NamespaceID();
  }

  inline bool IsHTMLElement() const
  {
    return IsInNamespace(3);
  }

  inline bool IsHTMLElement(nsIAtom* aTag) const
  {
    return mNodeInfo->Equals(aTag, 3);
  }

  template<typename First, typename... Args>
  inline bool IsAnyOfHTMLElements(First aFirst, Args... aArgs) const
  {
    return IsHTMLElement() && IsNodeInternal(aFirst, aArgs...);
  }

  inline bool IsSVGElement() const
  {
    return IsInNamespace(10);
  }

  inline bool IsSVGElement(nsIAtom* aTag) const
  {
    return mNodeInfo->Equals(aTag, 10);
  }

  template<typename First, typename... Args>
  inline bool IsAnyOfSVGElements(First aFirst, Args... aArgs) const
  {
    return IsSVGElement() && IsNodeInternal(aFirst, aArgs...);
  }

  inline bool IsXULElement() const
  {
    return IsInNamespace(9);
  }

  inline bool IsXULElement(nsIAtom* aTag) const
  {
    return mNodeInfo->Equals(aTag, 9);
  }

  template<typename First, typename... Args>
  inline bool IsAnyOfXULElements(First aFirst, Args... aArgs) const
  {
    return IsXULElement() && IsNodeInternal(aFirst, aArgs...);
  }

  inline bool IsMathMLElement() const
  {
    return IsInNamespace(7);
  }

  inline bool IsMathMLElement(nsIAtom* aTag) const
  {
    return mNodeInfo->Equals(aTag, 7);
  }

  template<typename First, typename... Args>
  inline bool IsAnyOfMathMLElements(First aFirst, Args... aArgs) const
  {
    return IsMathMLElement() && IsNodeInternal(aFirst, aArgs...);
  }
  inline bool IsActiveChildrenElement() const
  {
    return mNodeInfo->Equals(nsGkAtoms::children, 6) &&
           GetBindingParent();
  }

  bool IsGeneratedContentContainerForBefore() const
  {
    return IsRootOfNativeAnonymousSubtree() &&
           mNodeInfo->NameAtom() == nsGkAtoms::mozgeneratedcontentbefore;
  }

  bool IsGeneratedContentContainerForAfter() const
  {
    return IsRootOfNativeAnonymousSubtree() &&
           mNodeInfo->NameAtom() == nsGkAtoms::mozgeneratedcontentafter;
  }
  nsresult SetAttr(int32_t aNameSpaceID, nsIAtom* aName,
                   const nsAString& aValue, bool aNotify)
  {
    return SetAttr(aNameSpaceID, aName, nullptr, aValue, aNotify);
  }
  virtual nsresult SetAttr(int32_t aNameSpaceID, nsIAtom* aName,
                           nsIAtom* aPrefix, const nsAString& aValue,
                           bool aNotify) = 0;
  bool GetAttr(int32_t aNameSpaceID, nsIAtom* aName,
               nsAString& aResult) const;
  bool HasAttr(int32_t aNameSpaceID, nsIAtom* aName) const;
  bool AttrValueIs(int32_t aNameSpaceID,
                   nsIAtom* aName,
                   const nsAString& aValue,
                   nsCaseTreatment aCaseSensitive) const;
  bool AttrValueIs(int32_t aNameSpaceID,
                   nsIAtom* aName,
                   nsIAtom* aValue,
                   nsCaseTreatment aCaseSensitive) const;

  enum {
    ATTR_MISSING = -1,
    ATTR_VALUE_NO_MATCH = -2
  };
  typedef nsIAtom* const* const AttrValuesArray;
  virtual int32_t FindAttrValueIn(int32_t aNameSpaceID,
                                  nsIAtom* aName,
                                  AttrValuesArray* aValues,
                                  nsCaseTreatment aCaseSensitive) const
  {
    return ATTR_MISSING;
  }
  virtual nsresult UnsetAttr(int32_t aNameSpaceID, nsIAtom* aAttr,
                             bool aNotify) = 0;
  virtual const nsAttrName* GetAttrNameAt(uint32_t aIndex) const = 0;




  virtual mozilla::dom::BorrowedAttrInfo GetAttrInfoAt(uint32_t aIndex) const = 0;






  virtual uint32_t GetAttrCount() const = 0;






  virtual const nsTextFragment *GetText() = 0;





  virtual uint32_t TextLength() const = 0;
  virtual bool IsEventAttributeName(nsIAtom* aName)
  {
    return false;
  }






  virtual nsresult SetText(const char16_t* aBuffer, uint32_t aLength,
                           bool aNotify) = 0;






  virtual nsresult AppendText(const char16_t* aBuffer, uint32_t aLength,
                              bool aNotify) = 0;






  nsresult SetText(const nsAString& aStr, bool aNotify)
  {
    return SetText(aStr.BeginReading(), aStr.Length(), aNotify);
  }





  virtual bool TextIsOnlyWhitespace() = 0;




  virtual bool ThreadSafeTextIsOnlyWhitespace() const = 0;







  virtual bool HasTextForTranslation() = 0;





  virtual void AppendTextTo(nsAString& aResult) = 0;





  __attribute__ ((warn_unused_result))
  virtual bool AppendTextTo(nsAString& aResult, const mozilla::fallible_t&) = 0;
  bool IsFocusable(int32_t* aTabIndex = nullptr, bool aWithMouse = false);
  virtual bool IsFocusableInternal(int32_t* aTabIndex, bool aWithMouse);
  virtual bool PerformAccesskey(bool aKeyCausesActivation,
                                bool aIsTrustedEvent)
  {
    return false;
  }
  virtual IMEState GetDesiredIMEState();
  virtual nsIContent *GetBindingParent() const = 0;






  virtual nsXBLBinding *GetXBLBinding() const = 0;
  virtual void SetXBLBinding(nsXBLBinding* aBinding,
                             nsBindingManager* aOldBindingManager = nullptr) = 0;







  virtual void SetShadowRoot(mozilla::dom::ShadowRoot* aShadowRoot) = 0;






  inline mozilla::dom::ShadowRoot *GetShadowRoot() const;
  virtual mozilla::dom::ShadowRoot *GetContainingShadow() const = 0;






  virtual nsTArray<nsIContent*> &DestInsertionPoints() = 0;






  virtual nsTArray<nsIContent*> *GetExistingDestInsertionPoints() const = 0;







  virtual nsIContent *GetXBLInsertionParent() const = 0;






  virtual void SetXBLInsertionParent(nsIContent* aContent) = 0;





  inline nsIContent *GetFlattenedTreeParent() const;


  enum FlattenedParentType { eNotForStyle, eForStyle };
  nsINode* GetFlattenedTreeParentNodeInternal(FlattenedParentType aType) const;
  virtual bool IsLink(nsIURI** aURI) const = 0;
  virtual already_AddRefed<nsIURI> GetHrefURI() const
  {
    return nullptr;
  }
  virtual void DoneCreatingElement()
  {
  }







  virtual void BeginAddingChildren()
  {
  }
  virtual void DoneAddingChildren(bool aHaveNotified)
  {
  }
  virtual bool IsDoneAddingChildren()
  {
    return true;
  }





  nsIAtom* GetID() const {
    if (HasID()) {
      return DoGetID();
    }
    return nullptr;
  }





  virtual nsresult WalkContentStyleRules(nsRuleWalker* aRuleWalker) = 0;







  virtual void UpdateEditableState(bool aNotify);





  virtual void DestroyContent()
  {
  }




  virtual void SaveSubtreeState() = 0;
  nsIFrame* GetPrimaryFrame() const
  {
    return (IsInUncomposedDoc() || IsInShadowTree()) ? mPrimaryFrame : nullptr;
  }
  void SetPrimaryFrame(nsIFrame* aFrame) {
    do { } while (0);
    do { } while(0);

    mPrimaryFrame = aFrame;
  }

  nsresult LookupNamespaceURIInternal(const nsAString& aNamespacePrefix,
                                      nsAString& aNamespaceURI) const;





  bool HasIndependentSelection();






  mozilla::dom::Element* GetEditingHost();






  bool GetLang(nsAString& aResult) const {
    for (const nsIContent* content = this; content; content = content->GetParent()) {
      if (content->GetAttrCount() > 0) {


        bool hasAttr = content->GetAttr(2, nsGkAtoms::lang,
                                          aResult);
        if (!hasAttr && (content->IsHTMLElement() || content->IsSVGElement() ||
            content->IsXULElement())) {
          hasAttr = content->GetAttr(kNameSpaceID_None, nsGkAtoms::lang,
                                     aResult);
        }
        do { } while(0);

        if (hasAttr) {
          return true;
        }
      }
    }
    return false;
  }


  bool IsNativeScrollbarContent() const {
    return IsNativeAnonymous() &&
           IsAnyOfXULElements(nsGkAtoms::scrollbar,
                              nsGkAtoms::resizer,
                              nsGkAtoms::scrollcorner);
  }


  virtual already_AddRefed<nsIURI> GetBaseURI(bool aTryUseXHRDocBaseURI = false) const override;


  already_AddRefed<nsIURI> GetBaseURIForStyleAttr() const;

  virtual nsresult GetEventTargetParent(
                     mozilla::EventChainPreVisitor& aVisitor) override;

  virtual bool IsPurple() = 0;
  virtual void RemovePurple() = 0;

  virtual bool OwnedOnlyByTheDOMTree() { return false; }
protected:




  nsIAtom* DoGetID() const;


  inline nsIURI* GetBaseURIWithoutXMLBase() const;

public:
  virtual void Describe(nsAString& aOutDescription) const {
    aOutDescription = static_cast<const nsLiteralString&>(nsLiteralString(u"" "(not an element)"));
  }

  enum ETabFocusType {
    eTabFocus_textControlsMask = (1<<0),
    eTabFocus_formElementsMask = (1<<1),
    eTabFocus_linksMask = (1<<2),
    eTabFocus_any = 1 + (1<<1) + (1<<2)
  };


  static int32_t sTabFocusModel;



  static bool sTabFocusModelAppliesToXUL;
};

template<typename T> struct nsIContent::COMTypeInfo<nsIContent, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIContent::COMTypeInfo<nsIContent, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x8e1bab9d, 0x8815, 0x4d2c, { 0xa2, 0x4d, 0x7a, 0xba, 0x52, 0x39, 0xdc, 0x22 } };

inline nsIContent* nsINode::AsContent()
{
  do { } while (0);
  return static_cast<nsIContent*>(this);
}
class nsIWeakReference : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult QueryReferent(const nsIID & uuid, void **result) = 0;

     virtual size_t SizeOfOnlyThis(mozilla::MallocSizeOf aMallocSizeOf) const = 0;
};

  template<typename T> struct nsIWeakReference::COMTypeInfo<nsIWeakReference, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIWeakReference::COMTypeInfo<nsIWeakReference, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x9188bc85, 0xf92e, 0x11d2, { 0x81, 0xef, 0x00, 0x60, 0x08, 0x3a, 0x0b, 0xcf }};
class nsISupportsWeakReference : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetWeakReference(nsIWeakReference * *_retval) = 0;

};

  template<typename T> struct nsISupportsWeakReference::COMTypeInfo<nsISupportsWeakReference, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsISupportsWeakReference::COMTypeInfo<nsISupportsWeakReference, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x9188bc86, 0xf92e, 0x11d2, { 0x81, 0xef, 0x00, 0x60, 0x08, 0x3a, 0x0b, 0xcf }};

typedef nsCOMPtr<nsIWeakReference> nsWeakPtr;







template<class T, class DestinationType>
inline nsresult
CallQueryReferent(T* aSource, DestinationType** aDestination)
{
  do { } while(0);
  do { } while(0);

  return aSource->QueryReferent((DestinationType::template COMTypeInfo<DestinationType, void>::kIID),
                                reinterpret_cast<void**>(aDestination));
}


class nsQueryReferent final : public nsCOMPtr_helper
{
public:
  nsQueryReferent(nsIWeakReference* aWeakPtr, nsresult* aError)
    : mWeakPtr(aWeakPtr)
    , mErrorPtr(aError)
  {
  }

  virtual nsresult operator()(const nsIID& aIID, void**) const
    override;

private:
  nsIWeakReference* mWeakPtr;
  nsresult* mErrorPtr;
};

inline const nsQueryReferent
do_QueryReferent(nsIWeakReference* aRawPtr, nsresult* aError = 0)
{
  return nsQueryReferent(aRawPtr, aError);
}





extern nsIWeakReference* NS_GetWeakReference(nsISupports*,
                                             nsresult* aResult = 0);
inline already_AddRefed<nsIWeakReference>
do_GetWeakReference(nsISupports* aRawPtr, nsresult* aError = 0)
{
  return dont_AddRef(NS_GetWeakReference(aRawPtr, aError));
}

inline void
do_GetWeakReference(nsIWeakReference* aRawPtr, nsresult* aError = 0)
{



}

template<class T>
inline void
do_GetWeakReference(already_AddRefed<T>&)
{



}

template<class T>
inline void
do_GetWeakReference(already_AddRefed<T>&, nsresult*)
{



}
class nsAttrValue;
class nsIAtom;
class nsIContent;
class nsIDocument;
class nsINode;

namespace mozilla {
namespace dom {
class Element;
}
}
struct CharacterDataChangeInfo
{



  bool mAppend;




  uint32_t mChangeStart;






  uint32_t mChangeEnd;





  uint32_t mReplaceLength;
  struct Details {
    enum {
      eMerge,
      eSplit
    } mType;




    nsIContent* mNextSibling;
  };




  Details* mDetails;
};
class nsIMutationObserver : public nsISupports
{
public:
  template<typename T, typename U> struct COMTypeInfo;
  virtual void CharacterDataWillChange(nsIDocument *aDocument,
                                       nsIContent* aContent,
                                       CharacterDataChangeInfo* aInfo) = 0;
  virtual void CharacterDataChanged(nsIDocument *aDocument,
                                    nsIContent* aContent,
                                    CharacterDataChangeInfo* aInfo) = 0;
  virtual void AttributeWillChange(nsIDocument* aDocument,
                                   mozilla::dom::Element* aElement,
                                   int32_t aNameSpaceID,
                                   nsIAtom* aAttribute,
                                   int32_t aModType,
                                   const nsAttrValue* aNewValue) = 0;
  virtual void AttributeChanged(nsIDocument* aDocument,
                                mozilla::dom::Element* aElement,
                                int32_t aNameSpaceID,
                                nsIAtom* aAttribute,
                                int32_t aModType,
                                const nsAttrValue* aOldValue) = 0;
  virtual void NativeAnonymousChildListChange(nsIDocument* aDocument,
                                              nsIContent* aContent,
                                              bool aIsRemove) {}
  virtual void AttributeSetToCurrentValue(nsIDocument* aDocument,
                                          mozilla::dom::Element* aElement,
                                          int32_t aNameSpaceID,
                                          nsIAtom* aAttribute) {}
  virtual void ContentAppended(nsIDocument *aDocument,
                               nsIContent* aContainer,
                               nsIContent* aFirstNewContent,
                               int32_t aNewIndexInContainer) = 0;
  virtual void ContentInserted(nsIDocument *aDocument,
                               nsIContent* aContainer,
                               nsIContent* aChild,
                               int32_t aIndexInContainer) = 0;
  virtual void ContentRemoved(nsIDocument *aDocument,
                              nsIContent* aContainer,
                              nsIContent* aChild,
                              int32_t aIndexInContainer,
                              nsIContent* aPreviousSibling) = 0;
  virtual void NodeWillBeDestroyed(const nsINode *aNode) = 0;
  virtual void ParentChainChanged(nsIContent *aContent) = 0;
};

template<typename T> struct nsIMutationObserver::COMTypeInfo<nsIMutationObserver, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIMutationObserver::COMTypeInfo<nsIMutationObserver, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x6d674c17, 0x0fbc, 0x4633, { 0x8f, 0x46, 0x73, 0x4e, 0x87, 0xeb, 0xf0, 0xc7 } };

class nsCOMArray_base
{
  friend class nsArrayBase;
protected:
  nsCOMArray_base() {}
  explicit nsCOMArray_base(int32_t aCount) : mArray(aCount) {}
  nsCOMArray_base(const nsCOMArray_base& aOther);
  ~nsCOMArray_base();

  int32_t IndexOf(nsISupports* aObject, uint32_t aStartIndex = 0) const;
  bool Contains(nsISupports* aObject) const
  {
    return IndexOf(aObject) != -1;
  }

  int32_t IndexOfObject(nsISupports* aObject) const;
  bool ContainsObject(nsISupports* aObject) const
  {
    return IndexOfObject(aObject) != -1;
  }

  typedef bool (*nsBaseArrayEnumFunc)(void* aElement, void* aData);


  bool EnumerateForwards(nsBaseArrayEnumFunc aFunc, void* aData) const;

  bool EnumerateBackwards(nsBaseArrayEnumFunc aFunc, void* aData) const;

  typedef int (*nsBaseArrayComparatorFunc)(nsISupports* aElement1,
                                           nsISupports* aElement2,
                                           void* aData);

  struct nsCOMArrayComparatorContext
  {
    nsBaseArrayComparatorFunc mComparatorFunc;
    void* mData;
  };

  static int nsCOMArrayComparator(const void* aElement1, const void* aElement2,
                                  void* aData);
  void Sort(nsBaseArrayComparatorFunc aFunc, void* aData);

  bool InsertObjectAt(nsISupports* aObject, int32_t aIndex);
  void InsertElementAt(uint32_t aIndex, nsISupports* aElement);
  void InsertElementAt(uint32_t aIndex, already_AddRefed<nsISupports> aElement);
  bool InsertObjectsAt(const nsCOMArray_base& aObjects, int32_t aIndex);
  void InsertElementsAt(uint32_t aIndex, const nsCOMArray_base& aElements);
  void InsertElementsAt(uint32_t aIndex, nsISupports* const* aElements,
                        uint32_t aCount);
  void ReplaceObjectAt(nsISupports* aObject, int32_t aIndex);
  void ReplaceElementAt(uint32_t aIndex, nsISupports* aElement)
  {
    nsISupports* oldElement = mArray[aIndex];
    ns_if_addref(mArray[aIndex] = aElement);
    do { if (oldElement) { (oldElement)->Release(); (oldElement) = 0; } } while (0);
  }
  bool AppendObject(nsISupports* aObject)
  {
    return InsertObjectAt(aObject, Count());
  }
  void AppendElement(nsISupports* aElement)
  {
    InsertElementAt(Length(), aElement);
  }
  void AppendElement(already_AddRefed<nsISupports> aElement)
  {
    InsertElementAt(Length(), mozilla::Move(aElement));
  }

  bool AppendObjects(const nsCOMArray_base& aObjects)
  {
    return InsertObjectsAt(aObjects, Count());
  }
  void AppendElements(const nsCOMArray_base& aElements)
  {
    return InsertElementsAt(Length(), aElements);
  }
  void AppendElements(nsISupports* const* aElements, uint32_t aCount)
  {
    return InsertElementsAt(Length(), aElements, aCount);
  }
  bool RemoveObject(nsISupports* aObject);
  nsISupports** Elements() { return mArray.Elements(); }
  void SwapElements(nsCOMArray_base& aOther)
  {
    mArray.SwapElements(aOther.mArray);
  }

  void Adopt(nsISupports** aElements, uint32_t aCount);
  uint32_t Forget(nsISupports*** aElements);
public:

  int32_t Count() const { return mArray.Length(); }

  uint32_t Length() const { return mArray.Length(); }
  bool IsEmpty() const { return mArray.IsEmpty(); }



  bool SetCount(int32_t aNewCount);

  void TruncateLength(uint32_t aNewLength)
  {
    if (mArray.Length() > aNewLength) {
      RemoveElementsAt(aNewLength, mArray.Length() - aNewLength);
    }
  }


  void Clear();

  nsISupports* ObjectAt(int32_t aIndex) const { return mArray[aIndex]; }

  nsISupports* ElementAt(uint32_t aIndex) const { return mArray[aIndex]; }

  nsISupports* SafeObjectAt(int32_t aIndex) const
  {
    return mArray.SafeElementAt(aIndex, nullptr);
  }

  nsISupports* SafeElementAt(uint32_t aIndex) const
  {
    return mArray.SafeElementAt(aIndex, nullptr);
  }

  nsISupports* operator[](int32_t aIndex) const { return mArray[aIndex]; }



  bool RemoveObjectAt(int32_t aIndex);

  void RemoveElementAt(uint32_t aIndex);



  bool RemoveObjectsAt(int32_t aIndex, int32_t aCount);

  void RemoveElementsAt(uint32_t aIndex, uint32_t aCount);

  void SwapElementsAt(uint32_t aIndex1, uint32_t aIndex2)
  {
    nsISupports* tmp = mArray[aIndex1];
    mArray[aIndex1] = mArray[aIndex2];
    mArray[aIndex2] = tmp;
  }



  void SetCapacity(uint32_t aCapacity) { mArray.SetCapacity(aCapacity); }
  uint32_t Capacity() { return mArray.Capacity(); }
  size_t ShallowSizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return mArray.ShallowSizeOfExcludingThis(aMallocSizeOf);
  }

private:


  nsTArray<nsISupports*> mArray;


  nsCOMArray_base& operator=(const nsCOMArray_base& aOther) = delete;
};

inline void
ImplCycleCollectionUnlink(nsCOMArray_base& aField)
{
  aField.Clear();
}

inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            nsCOMArray_base& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  aFlags |= CycleCollectionEdgeNameArrayFlag;
  int32_t length = aField.Count();
  for (int32_t i = 0; i < length; ++i) {
    CycleCollectionNoteChild(aCallback, aField[i], aName, aFlags);
  }
}
template<class T>
class nsCOMArray : public nsCOMArray_base
{
public:
  typedef int32_t index_type;
  typedef mozilla::ArrayIterator<T*, nsCOMArray> iterator;
  typedef mozilla::ArrayIterator<const T*, nsCOMArray> const_iterator;
  typedef mozilla::ReverseIterator<iterator> reverse_iterator;
  typedef mozilla::ReverseIterator<const_iterator> const_reverse_iterator;

  nsCOMArray() {}
  explicit nsCOMArray(int32_t aCount) : nsCOMArray_base(aCount) {}
  explicit nsCOMArray(const nsCOMArray<T>& aOther) : nsCOMArray_base(aOther) {}
  nsCOMArray(nsCOMArray<T>&& aOther) { SwapElements(aOther); }
  ~nsCOMArray() {}


  nsCOMArray<T>& operator=(nsCOMArray<T> && aOther)
  {
    SwapElements(aOther);
    return *this;
  }


  T* ObjectAt(int32_t aIndex) const
  {
    return static_cast<T*>(nsCOMArray_base::ObjectAt(aIndex));
  }

  T* ElementAt(uint32_t aIndex) const
  {
    return static_cast<T*>(nsCOMArray_base::ElementAt(aIndex));
  }


  T* SafeObjectAt(int32_t aIndex) const
  {
    return static_cast<T*>(nsCOMArray_base::SafeObjectAt(aIndex));
  }

  T* SafeElementAt(uint32_t aIndex) const
  {
    return static_cast<T*>(nsCOMArray_base::SafeElementAt(aIndex));
  }


  T* operator[](int32_t aIndex) const { return ObjectAt(aIndex); }




  int32_t IndexOf(T* aObject, uint32_t aStartIndex = 0) const
  {
    return nsCOMArray_base::IndexOf(aObject, aStartIndex);
  }
  bool Contains(T* aObject) const
  {
    return nsCOMArray_base::Contains(aObject);
  }






  int32_t IndexOfObject(T* aObject) const
  {
    return nsCOMArray_base::IndexOfObject(aObject);
  }
  bool ContainsObject(nsISupports* aObject) const
  {
    return nsCOMArray_base::ContainsObject(aObject);
  }



  bool InsertObjectAt(T* aObject, int32_t aIndex)
  {
    return nsCOMArray_base::InsertObjectAt(aObject, aIndex);
  }

  void InsertElementAt(uint32_t aIndex, T* aElement)
  {
    nsCOMArray_base::InsertElementAt(aIndex, aElement);
  }



  bool InsertObjectsAt(const nsCOMArray<T>& aObjects, int32_t aIndex)
  {
    return nsCOMArray_base::InsertObjectsAt(aObjects, aIndex);
  }

  void InsertElementsAt(uint32_t aIndex, const nsCOMArray<T>& aElements)
  {
    nsCOMArray_base::InsertElementsAt(aIndex, aElements);
  }
  void InsertElementsAt(uint32_t aIndex, T* const* aElements, uint32_t aCount)
  {
    nsCOMArray_base::InsertElementsAt(
      aIndex, reinterpret_cast<nsISupports* const*>(aElements), aCount);
  }



  void ReplaceObjectAt(T* aObject, int32_t aIndex)
  {
    nsCOMArray_base::ReplaceObjectAt(aObject, aIndex);
  }

  void ReplaceElementAt(uint32_t aIndex, T* aElement)
  {
    nsCOMArray_base::ReplaceElementAt(aIndex, aElement);
  }

  typedef int (*nsCOMArrayComparatorFunc)(T* aElement1, T* aElement2,
                                          void* aData);

  void Sort(nsCOMArrayComparatorFunc aFunc, void* aData)
  {
    nsCOMArray_base::Sort(nsBaseArrayComparatorFunc(aFunc), aData);
  }


  bool AppendObject(T* aObject)
  {
    return nsCOMArray_base::AppendObject(aObject);
  }

  void AppendElement(T* aElement)
  {
    nsCOMArray_base::AppendElement(aElement);
  }
  void AppendElement(already_AddRefed<T> aElement)
  {
    nsCOMArray_base::AppendElement(mozilla::Move(aElement));
  }


  bool AppendObjects(const nsCOMArray<T>& aObjects)
  {
    return nsCOMArray_base::AppendObjects(aObjects);
  }

  void AppendElements(const nsCOMArray<T>& aElements)
  {
    return nsCOMArray_base::AppendElements(aElements);
  }
  void AppendElements(T* const* aElements, uint32_t aCount)
  {
    InsertElementsAt(Length(), aElements, aCount);
  }




  bool RemoveObject(T* aObject)
  {
    return nsCOMArray_base::RemoveObject(aObject);
  }

  bool RemoveElement(T* aElement)
  {
    return nsCOMArray_base::RemoveObject(aElement);
  }

  T** Elements()
  {
    return reinterpret_cast<T**>(nsCOMArray_base::Elements());
  }
  void SwapElements(nsCOMArray<T>& aOther)
  {
    nsCOMArray_base::SwapElements(aOther);
  }
  void Adopt(T** aElements, uint32_t aSize)
  {
    nsCOMArray_base::Adopt(reinterpret_cast<nsISupports**>(aElements), aSize);
  }
  uint32_t Forget(T*** aElements)
  {
    return nsCOMArray_base::Forget(reinterpret_cast<nsISupports***>(aElements));
  }


  iterator begin() { return iterator(*this, 0); }
  const_iterator begin() const { return const_iterator(*this, 0); }
  const_iterator cbegin() const { return begin(); }
  iterator end() { return iterator(*this, Length()); }
  const_iterator end() const { return const_iterator(*this, Length()); }
  const_iterator cend() const { return end(); }


  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
  const_reverse_iterator crbegin() const { return rbegin(); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
  const_reverse_iterator crend() const { return rend(); }

private:


  nsCOMArray<T>& operator=(const nsCOMArray<T>& aOther) = delete;
};

template<typename T>
inline void
ImplCycleCollectionUnlink(nsCOMArray<T>& aField)
{
  aField.Clear();
}

template<typename E>
inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            nsCOMArray<E>& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  aFlags |= CycleCollectionEdgeNameArrayFlag;
  int32_t length = aField.Count();
  for (int32_t i = 0; i < length; ++i) {
    CycleCollectionNoteChild(aCallback, aField[i], aName, aFlags);
  }
}

struct CharacterDataChangeInfo;
template<class E> class nsCOMArray;
class nsCycleCollectionTraversalCallback;
namespace mozilla {
struct NonOwningAnimationTarget;
namespace dom {
class Animation;
}
}

class nsNodeUtils
{
public:






  static void CharacterDataWillChange(nsIContent* aContent,
                                      CharacterDataChangeInfo* aInfo);







  static void CharacterDataChanged(nsIContent* aContent,
                                   CharacterDataChangeInfo* aInfo);
  static void AttributeWillChange(mozilla::dom::Element* aElement,
                                  int32_t aNameSpaceID,
                                  nsIAtom* aAttribute,
                                  int32_t aModType,
                                  const nsAttrValue* aNewValue);
  static void AttributeChanged(mozilla::dom::Element* aElement,
                               int32_t aNameSpaceID,
                               nsIAtom* aAttribute,
                               int32_t aModType,
                               const nsAttrValue* aOldValue);
  static void AttributeSetToCurrentValue(mozilla::dom::Element* aElement,
                                         int32_t aNameSpaceID,
                                         nsIAtom* aAttribute);
  static void ContentAppended(nsIContent* aContainer,
                              nsIContent* aFirstNewContent,
                              int32_t aNewIndexInContainer);







  static void NativeAnonymousChildListChange(nsIContent* aContent,
                                             bool aIsRemove);
  static void ContentInserted(nsINode* aContainer,
                              nsIContent* aChild,
                              int32_t aIndexInContainer);







  static void ContentRemoved(nsINode* aContainer,
                             nsIContent* aChild,
                             int32_t aIndexInContainer,
                             nsIContent* aPreviousSibling);





  static inline void ParentChainChanged(nsIContent *aContent)
  {
    nsINode::nsSlots* slots = aContent->GetExistingSlots();
    if (slots && !slots->mMutationObservers.IsEmpty()) {
      do { nsTObserverArray<nsIMutationObserver *>::ForwardIterator iter_(slots->mMutationObservers); nsIMutationObserver* obs_; while (iter_.HasMore()) { obs_ = iter_.GetNext(); obs_ -> ParentChainChanged (aContent) ; } } while(0);



    }
  }






  static mozilla::Maybe<mozilla::NonOwningAnimationTarget>
    GetTargetForAnimation(const mozilla::dom::Animation* aAnimation);





  static void AnimationAdded(mozilla::dom::Animation* aAnimation);
  static void AnimationChanged(mozilla::dom::Animation* aAnimation);
  static void AnimationRemoved(mozilla::dom::Animation* aAnimation);





  static void LastRelease(nsINode* aNode);
  static nsresult Clone(nsINode *aNode, bool aDeep,
                        nsNodeInfoManager *aNewNodeInfoManager,
                        nsCOMArray<nsINode> &aNodesWithProperties,
                        nsINode **aResult)
  {
    return CloneAndAdopt(aNode, true, aDeep, aNewNodeInfoManager,
                         nullptr, aNodesWithProperties, nullptr, aResult);
  }




  static nsresult Clone(nsINode *aNode, bool aDeep, nsINode **aResult)
  {
    nsCOMArray<nsINode> dummyNodeWithProperties;
    return CloneAndAdopt(aNode, true, aDeep, nullptr, nullptr,
                         dummyNodeWithProperties, aNode->GetParent(), aResult);
  }
  static nsresult Adopt(nsINode *aNode, nsNodeInfoManager *aNewNodeInfoManager,
                        JS::Handle<JSObject*> aReparentScope,
                        nsCOMArray<nsINode> &aNodesWithProperties)
  {
    nsCOMPtr<nsINode> node;
    nsresult rv = CloneAndAdopt(aNode, false, true, aNewNodeInfoManager,
                                aReparentScope, aNodesWithProperties,
                                nullptr, getter_AddRefs(node));

    nsMutationGuard::DidMutate();

    return rv;
  }







  static void TraverseUserData(nsINode* aNode,
                               nsCycleCollectionTraversalCallback &aCb);
  static nsresult CloneNodeImpl(nsINode *aNode, bool aDeep, nsINode **aResult);






  static void UnlinkUserData(nsINode *aNode);






  static bool IsTemplateElement(const nsINode *aNode);
  static nsIContent* GetFirstChildOfTemplateOrNode(nsINode* aNode);

private:
  static nsresult CloneAndAdopt(nsINode *aNode, bool aClone, bool aDeep,
                                nsNodeInfoManager *aNewNodeInfoManager,
                                JS::Handle<JSObject*> aReparentScope,
                                nsCOMArray<nsINode> &aNodesWithProperties,
                                nsINode *aParent, nsINode **aResult);

  enum class AnimationMutationType
  {
    Added,
    Changed,
    Removed
  };






  static void AnimationMutated(mozilla::dom::Animation* aAnimation,
                               AnimationMutationType aMutatedType);

};
class nsIDOMHTMLCollection : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetLength(uint32_t *aLength) = 0;


  virtual nsresult Item(uint32_t index, nsIDOMNode * *_retval) = 0;


  virtual nsresult NamedItem(const nsAString & name, nsIDOMNode * *_retval) = 0;

};

  template<typename T> struct nsIDOMHTMLCollection::COMTypeInfo<nsIDOMHTMLCollection, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMHTMLCollection::COMTypeInfo<nsIDOMHTMLCollection, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xbb07f567, 0x5b37, 0x4172, { 0x92, 0xaa, 0x7d, 0x00, 0xce, 0xed, 0x48, 0x09 }};





class nsINode;
class nsString;

namespace mozilla {
namespace dom {
class Element;
}
}
class nsIHTMLCollection : public nsIDOMHTMLCollection
{
public:
  template<typename T, typename U> struct COMTypeInfo;




  virtual nsINode* GetParentObject() = 0;

  using nsIDOMHTMLCollection::Item;
  using nsIDOMHTMLCollection::NamedItem;

  uint32_t Length()
  {
    uint32_t length;
    GetLength(&length);
    return length;
  }
  virtual mozilla::dom::Element* GetElementAt(uint32_t index) = 0;
  mozilla::dom::Element* Item(uint32_t index)
  {
    return GetElementAt(index);
  }
  mozilla::dom::Element* IndexedGetter(uint32_t index, bool& aFound)
  {
    mozilla::dom::Element* item = Item(index);
    aFound = !!item;
    return item;
  }
  mozilla::dom::Element* NamedItem(const nsAString& aName)
  {
    bool dummy;
    return NamedGetter(aName, dummy);
  }
  mozilla::dom::Element* NamedGetter(const nsAString& aName, bool& aFound)
  {
    return GetFirstNamedElement(aName, aFound);
  }
  virtual mozilla::dom::Element*
  GetFirstNamedElement(const nsAString& aName, bool& aFound) = 0;

  virtual void GetSupportedNames(nsTArray<nsString>& aNames) = 0;

  JSObject* GetWrapperPreserveColor()
  {
    return GetWrapperPreserveColorInternal();
  }
  JSObject* GetWrapper()
  {
    JSObject* obj = GetWrapperPreserveColor();
    if (obj) {
      JS::ExposeObjectToActiveJS(obj);
    }
    return obj;
  }
  virtual JSObject* WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) = 0;
protected:
  virtual JSObject* GetWrapperPreserveColorInternal() = 0;
};

template<typename T> struct nsIHTMLCollection::COMTypeInfo<nsIHTMLCollection, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIHTMLCollection::COMTypeInfo<nsIHTMLCollection, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x4e169191, 0x5196, 0x4e17, { 0xa4, 0x79, 0xd5, 0x35, 0x0b, 0x5b, 0x0a, 0xcd } };
class nsIHashable : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult Equals(nsIHashable *aOther, bool *_retval) = 0;


  virtual nsresult GetHashCode(uint32_t *aHashCode) = 0;

};

  template<typename T> struct nsIHashable::COMTypeInfo<nsIHashable, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIHashable::COMTypeInfo<nsIHashable, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x17e595fa, 0xb57a, 0x4933, { 0xbd, 0x0f, 0xb1, 0x81, 0x2e, 0x8a, 0xb1, 0x88 }};


typedef uint32_t PLDHashNumber;

class PLDHashTable;
struct PLDHashTableOps;
struct PLDHashEntryHdr
{
private:
  friend class PLDHashTable;

  PLDHashNumber mKeyHash;
};
class PLDHashTable
{
private:


  class EntryStore
  {
  private:
    char* mEntryStore;
    uint32_t mGeneration;

  public:
    EntryStore() : mEntryStore(nullptr), mGeneration(0) {}

    ~EntryStore()
    {
      free(mEntryStore);
      mEntryStore = nullptr;
      mGeneration++;
    }

    char* Get() { return mEntryStore; }
    const char* Get() const { return mEntryStore; }

    void Set(char* aEntryStore)
    {
      mEntryStore = aEntryStore;
      mGeneration++;
    }

    uint32_t Generation() const { return mGeneration; }
  };

  const PLDHashTableOps* const mOps;
  int16_t mHashShift;
  const uint32_t mEntrySize;
  uint32_t mEntryCount;
  uint32_t mRemovedCount;
  EntryStore mEntryStore;





public:






  static const uint32_t kMaxCapacity = ((uint32_t)1 << 26);

  static const uint32_t kMinCapacity = 8;



  static const uint32_t kMaxInitialLength = kMaxCapacity / 2;


  static const uint32_t kDefaultInitialLength = 4;
  PLDHashTable(const PLDHashTableOps* aOps, uint32_t aEntrySize,
               uint32_t aLength = kDefaultInitialLength);

  PLDHashTable(PLDHashTable&& aOther)


    : mOps(aOther.mOps)
    , mEntrySize(aOther.mEntrySize)


    , mEntryStore()



  {
    *this = mozilla::Move(aOther);
  }

  PLDHashTable& operator=(PLDHashTable&& aOther);

  ~PLDHashTable();


  const PLDHashTableOps* Ops() const { return mOps; }




  uint32_t Capacity() const
  {
    return mEntryStore.Get() ? CapacityFromHashShift() : 0;
  }

  uint32_t EntrySize() const { return mEntrySize; }
  uint32_t EntryCount() const { return mEntryCount; }
  uint32_t Generation() const { return mEntryStore.Generation(); }







  PLDHashEntryHdr* Search(const void* aKey);
  PLDHashEntryHdr* Add(const void* aKey, const mozilla::fallible_t&);



  PLDHashEntryHdr* Add(const void* aKey);







  void Remove(const void* aKey);







  void RemoveEntry(PLDHashEntryHdr* aEntry);







  void RawRemove(PLDHashEntryHdr* aEntry);



  void Clear();
  void ClearAndPrepareForLength(uint32_t aLength);




  size_t ShallowSizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;


  size_t ShallowSizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;
  static const PLDHashTableOps* StubOps();


  static PLDHashNumber HashVoidPtrKeyStub(const void* aKey);
  static bool MatchEntryStub(const PLDHashEntryHdr* aEntry, const void* aKey);
  static void MoveEntryStub(PLDHashTable* aTable, const PLDHashEntryHdr* aFrom,
                            PLDHashEntryHdr* aTo);
  static void ClearEntryStub(PLDHashTable* aTable, PLDHashEntryHdr* aEntry);


  static PLDHashNumber HashStringKey(const void* aKey);
  static bool MatchStringKey(const PLDHashEntryHdr* aEntry, const void* aKey);
  class Iterator
  {
  public:
    explicit Iterator(PLDHashTable* aTable);
    Iterator(Iterator&& aOther);
    ~Iterator();


    bool Done() const { return mNexts == mNextsLimit; }


    PLDHashEntryHdr* Get() const
    {
      do { } while (0);

      PLDHashEntryHdr* entry = reinterpret_cast<PLDHashEntryHdr*>(mCurrent);
      do { } while (0);
      return entry;
    }


    void Next();



    void Remove();

  protected:
    PLDHashTable* mTable;

  private:
    char* mStart;
    char* mLimit;
    char* mCurrent;
    uint32_t mNexts;
    uint32_t mNextsLimit;

    bool mHaveRemoved;

    bool IsOnNonLiveEntry() const;
    void MoveToNextEntry();

    Iterator() = delete;
    Iterator(const Iterator&) = delete;
    Iterator& operator=(const Iterator&) = delete;
    Iterator& operator=(const Iterator&&) = delete;
  };

  Iterator Iter() { return Iterator(this); }



  Iterator ConstIter() const
  {
    return Iterator(const_cast<PLDHashTable*>(this));
  }

private:


  static const uint32_t kHashBits = 32;
  static const uint32_t kGoldenRatio = 0x9E3779B9U;

  static uint32_t HashShift(uint32_t aEntrySize, uint32_t aLength);

  static const PLDHashNumber kCollisionFlag = 1;

  static bool EntryIsFree(PLDHashEntryHdr* aEntry)
  {
    return aEntry->mKeyHash == 0;
  }
  static bool EntryIsRemoved(PLDHashEntryHdr* aEntry)
  {
    return aEntry->mKeyHash == 1;
  }
  static bool EntryIsLive(PLDHashEntryHdr* aEntry)
  {
    return aEntry->mKeyHash >= 2;
  }

  static void MarkEntryFree(PLDHashEntryHdr* aEntry)
  {
    aEntry->mKeyHash = 0;
  }
  static void MarkEntryRemoved(PLDHashEntryHdr* aEntry)
  {
    aEntry->mKeyHash = 1;
  }

  PLDHashNumber Hash1(PLDHashNumber aHash0);
  void Hash2(PLDHashNumber aHash, uint32_t& aHash2Out, uint32_t& aSizeMaskOut);

  static bool MatchEntryKeyhash(PLDHashEntryHdr* aEntry, PLDHashNumber aHash);
  PLDHashEntryHdr* AddressEntry(uint32_t aIndex);



  uint32_t CapacityFromHashShift() const
  {
    return ((uint32_t)1 << (kHashBits - mHashShift));
  }

  PLDHashNumber ComputeKeyHash(const void* aKey);

  enum SearchReason { ForSearchOrRemove, ForAdd };

  template <SearchReason Reason>
  PLDHashEntryHdr*
    SearchTable(const void* aKey, PLDHashNumber aKeyHash);

  PLDHashEntryHdr* FindFreeEntry(PLDHashNumber aKeyHash);

  bool ChangeTable(int aDeltaLog2);

  void ShrinkIfAppropriate();

  PLDHashTable(const PLDHashTable& aOther) = delete;
  PLDHashTable& operator=(const PLDHashTable& aOther) = delete;
};



typedef PLDHashNumber (*PLDHashHashKey)(const void* aKey);



typedef bool (*PLDHashMatchEntry)(const PLDHashEntryHdr* aEntry,
                                  const void* aKey);





typedef void (*PLDHashMoveEntry)(PLDHashTable* aTable,
                                 const PLDHashEntryHdr* aFrom,
                                 PLDHashEntryHdr* aTo);



typedef void (*PLDHashClearEntry)(PLDHashTable* aTable,
                                  PLDHashEntryHdr* aEntry);





typedef void (*PLDHashInitEntry)(PLDHashEntryHdr* aEntry, const void* aKey);
struct PLDHashTableOps
{

  PLDHashHashKey hashKey;
  PLDHashMatchEntry matchEntry;
  PLDHashMoveEntry moveEntry;
  PLDHashClearEntry clearEntry;


  PLDHashInitEntry initEntry;
};


struct PLDHashEntryStub : public PLDHashEntryHdr
{
  const void* key;
};



const char* NS_strspnp(const char* aDelims, const char* aStr);
char* NS_strtok(const char* aDelims, char** aStr);




uint32_t NS_strlen(const char16_t* aString);




int NS_strcmp(const char16_t* aStrA, const char16_t* aStrB);




int NS_strncmp(const char16_t* aStrA, const char16_t* aStrB, size_t aLen);




char16_t* NS_strdup(const char16_t* aString);




char* NS_strdup(const char* aString);
template<typename CharT>
CharT* NS_strndup(const CharT* aString, uint32_t aLen);





class nsLowerUpperUtils
{
public:
  static const unsigned char kLower2Upper[256];
  static const unsigned char kUpper2Lower[256];
};

inline char
NS_ToUpper(char aChar)
{
  return (char)nsLowerUpperUtils::kLower2Upper[(unsigned char)aChar];
}

inline char
NS_ToLower(char aChar)
{
  return (char)nsLowerUpperUtils::kUpper2Lower[(unsigned char)aChar];
}

bool NS_IsUpper(char aChar);
bool NS_IsLower(char aChar);

bool NS_IsAscii(char16_t aChar);
bool NS_IsAscii(const char16_t* aString);
bool NS_IsAsciiAlpha(char16_t aChar);
bool NS_IsAsciiDigit(char16_t aChar);
bool NS_IsAsciiWhitespace(char16_t aChar);
bool NS_IsAscii(const char* aString);
bool NS_IsAscii(const char* aString, uint32_t aLength);


void NS_MakeRandomString(char* aBuf, int32_t aBufLen);
void ToLowerCase(nsAString&);
void ToUpperCase(nsAString&);

void ToLowerCase(const nsAString& aSource, nsAString& aDest);
void ToUpperCase(const nsAString& aSource, nsAString& aDest);

uint32_t ToLowerCase(uint32_t);
uint32_t ToUpperCase(uint32_t);
uint32_t ToTitleCase(uint32_t);

void ToLowerCase(const char16_t*, char16_t*, uint32_t);
void ToUpperCase(const char16_t*, char16_t*, uint32_t);

inline bool IsUpperCase(uint32_t c) {
  return ToLowerCase(c) != c;
}

inline bool IsLowerCase(uint32_t c) {
  return ToUpperCase(c) != c;
}



class nsCaseInsensitiveStringComparator : public nsStringComparator
{
public:
  virtual int32_t operator() (const char16_t*,
                              const char16_t*,
                              uint32_t,
                              uint32_t) const override;
};

class nsCaseInsensitiveUTF8StringComparator : public nsCStringComparator
{
public:
  virtual int32_t operator() (const char*,
                              const char*,
                              uint32_t,
                              uint32_t) const override;
};

class nsCaseInsensitiveStringArrayComparator
{
public:
  template<class A, class B>
  bool Equals(const A& a, const B& b) const {
    return a.Equals(b, nsCaseInsensitiveStringComparator());
  }
};

class nsASCIICaseInsensitiveStringComparator : public nsStringComparator
{
public:
  nsASCIICaseInsensitiveStringComparator() {}
  virtual int operator() (const char16_t*,
                          const char16_t*,
                          uint32_t,
                          uint32_t) const override;
};

inline bool
CaseInsensitiveFindInReadable(const nsAString& aPattern,
                              nsAString::const_iterator& aSearchStart,
                              nsAString::const_iterator& aSearchEnd)
{
  return FindInReadable(aPattern, aSearchStart, aSearchEnd,
                        nsCaseInsensitiveStringComparator());
}

inline bool
CaseInsensitiveFindInReadable(const nsAString& aPattern,
                              const nsAString& aHay)
{
  nsAString::const_iterator searchBegin, searchEnd;
  return FindInReadable(aPattern, aHay.BeginReading(searchBegin),
                        aHay.EndReading(searchEnd),
                        nsCaseInsensitiveStringComparator());
}



int32_t
CaseInsensitiveCompare(const char16_t *a, const char16_t *b, uint32_t len);

int32_t
CaseInsensitiveCompare(const char* aLeft, const char* aRight,
                       uint32_t aLeftBytes, uint32_t aRightBytes);
bool
CaseInsensitiveUTF8CharsEqual(const char* aLeft, const char* aRight,
                              const char* aLeftEnd, const char* aRightEnd,
                              const char** aLeftNext, const char** aRightNext,
                              bool* aErr);

namespace mozilla {
uint32_t
HashUTF8AsUTF16(const char* aUTF8, uint32_t aLength, bool* aErr);

bool
IsSegmentBreakSkipChar(uint32_t u);

}
template<class T>
class nsPtrHashKey : public PLDHashEntryHdr
{
public:
  typedef T* KeyType;
  typedef const T* KeyTypePointer;

  explicit nsPtrHashKey(const T* aKey) : mKey(const_cast<T*>(aKey)) {}
  nsPtrHashKey(const nsPtrHashKey<T>& aToCopy) : mKey(aToCopy.mKey) {}
  ~nsPtrHashKey() {}

  KeyType GetKey() const { return mKey; }
  bool KeyEquals(KeyTypePointer aKey) const { return aKey == mKey; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {
    return ((uint32_t)(intptr_t)(aKey)) >> 2;
  }
  enum { ALLOW_MEMMOVE = true };

protected:
  T* mKey;
};

typedef nsPtrHashKey<const void> nsVoidPtrHashKey;






namespace mozilla {



inline uint32_t
HashString(const nsAString& aStr)
{
  return HashString(aStr.BeginReading(), aStr.Length());
}

inline uint32_t
HashString(const nsACString& aStr)
{
  return HashString(aStr.BeginReading(), aStr.Length());
}

}
class nsStringHashKey : public PLDHashEntryHdr
{
public:
  typedef const nsAString& KeyType;
  typedef const nsAString* KeyTypePointer;

  explicit nsStringHashKey(KeyTypePointer aStr) : mStr(*aStr) {}
  nsStringHashKey(const nsStringHashKey& aToCopy) : mStr(aToCopy.mStr) {}
  ~nsStringHashKey() {}

  KeyType GetKey() const { return mStr; }
  bool KeyEquals(const KeyTypePointer aKey) const
  {
    return mStr.Equals(*aKey);
  }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(const KeyTypePointer aKey)
  {
    return mozilla::HashString(*aKey);
  }



  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return GetKey().SizeOfExcludingThisIfUnshared(aMallocSizeOf);
  }


  enum { ALLOW_MEMMOVE = true };

private:
  const nsString mStr;
};
class nsStringCaseInsensitiveHashKey : public PLDHashEntryHdr
{
public:
  typedef const nsAString& KeyType;
  typedef const nsAString* KeyTypePointer;

  explicit nsStringCaseInsensitiveHashKey(KeyTypePointer aStr)
    : mStr(*aStr)
  {

  }
  nsStringCaseInsensitiveHashKey(const nsStringCaseInsensitiveHashKey& aToCopy)
    : mStr(aToCopy.mStr)
  {
  }
  ~nsStringCaseInsensitiveHashKey() {}

  KeyType GetKey() const { return mStr; }
  bool KeyEquals(const KeyTypePointer aKey) const
  {
    return mStr.Equals(*aKey, nsCaseInsensitiveStringComparator());
  }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(const KeyTypePointer aKey)
  {
    nsAutoString tmKey(*aKey);
    ToLowerCase(tmKey);
    return mozilla::HashString(tmKey);
  }
  enum { ALLOW_MEMMOVE = true };


  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return GetKey().SizeOfExcludingThisIfUnshared(aMallocSizeOf);
  }

private:
  const nsString mStr;
};
class nsCStringHashKey : public PLDHashEntryHdr
{
public:
  typedef const nsACString& KeyType;
  typedef const nsACString* KeyTypePointer;

  explicit nsCStringHashKey(const nsACString* aStr) : mStr(*aStr) {}
  nsCStringHashKey(const nsCStringHashKey& aToCopy) : mStr(aToCopy.mStr) {}
  ~nsCStringHashKey() {}

  KeyType GetKey() const { return mStr; }
  bool KeyEquals(KeyTypePointer aKey) const { return mStr.Equals(*aKey); }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {
    return mozilla::HashString(*aKey);
  }



  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return GetKey().SizeOfExcludingThisIfUnshared(aMallocSizeOf);
  }


  enum { ALLOW_MEMMOVE = true };

private:
  const nsCString mStr;
};






class nsUint32HashKey : public PLDHashEntryHdr
{
public:
  typedef const uint32_t& KeyType;
  typedef const uint32_t* KeyTypePointer;

  explicit nsUint32HashKey(KeyTypePointer aKey) : mValue(*aKey) {}
  nsUint32HashKey(const nsUint32HashKey& aToCopy) : mValue(aToCopy.mValue) {}
  ~nsUint32HashKey() {}

  KeyType GetKey() const { return mValue; }
  bool KeyEquals(KeyTypePointer aKey) const { return *aKey == mValue; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey) { return *aKey; }
  enum { ALLOW_MEMMOVE = true };

private:
  const uint32_t mValue;
};






class nsUint64HashKey : public PLDHashEntryHdr
{
public:
  typedef const uint64_t& KeyType;
  typedef const uint64_t* KeyTypePointer;

  explicit nsUint64HashKey(KeyTypePointer aKey) : mValue(*aKey) {}
  nsUint64HashKey(const nsUint64HashKey& aToCopy) : mValue(aToCopy.mValue) {}
  ~nsUint64HashKey() {}

  KeyType GetKey() const { return mValue; }
  bool KeyEquals(KeyTypePointer aKey) const { return *aKey == mValue; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {
    return PLDHashNumber(*aKey);
  }
  enum { ALLOW_MEMMOVE = true };

private:
  const uint64_t mValue;
};






class nsFloatHashKey : public PLDHashEntryHdr
{
public:
  typedef const float& KeyType;
  typedef const float* KeyTypePointer;

  explicit nsFloatHashKey(KeyTypePointer aKey) : mValue(*aKey) {}
  nsFloatHashKey(const nsFloatHashKey& aToCopy) : mValue(aToCopy.mValue) {}
  ~nsFloatHashKey() {}

  KeyType GetKey() const { return mValue; }
  bool KeyEquals(KeyTypePointer aKey) const { return *aKey == mValue; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {
    return *reinterpret_cast<const uint32_t*>(aKey);
  }
  enum { ALLOW_MEMMOVE = true };

private:
  const float mValue;
};






class nsISupportsHashKey : public PLDHashEntryHdr
{
public:
  typedef nsISupports* KeyType;
  typedef const nsISupports* KeyTypePointer;

  explicit nsISupportsHashKey(const nsISupports* aKey)
    : mSupports(const_cast<nsISupports*>(aKey))
  {
  }
  nsISupportsHashKey(const nsISupportsHashKey& aToCopy)
    : mSupports(aToCopy.mSupports)
  {
  }
  ~nsISupportsHashKey() {}

  KeyType GetKey() const { return mSupports; }
  bool KeyEquals(KeyTypePointer aKey) const { return aKey == mSupports; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {
    return ((uint32_t)(intptr_t)(aKey)) >> 2;
  }
  enum { ALLOW_MEMMOVE = true };

private:
  nsCOMPtr<nsISupports> mSupports;
};






template<class T>
class nsRefPtrHashKey : public PLDHashEntryHdr
{
public:
  typedef T* KeyType;
  typedef const T* KeyTypePointer;

  explicit nsRefPtrHashKey(const T* aKey) : mKey(const_cast<T*>(aKey)) {}
  nsRefPtrHashKey(const nsRefPtrHashKey& aToCopy) : mKey(aToCopy.mKey) {}
  ~nsRefPtrHashKey() {}

  KeyType GetKey() const { return mKey; }
  bool KeyEquals(KeyTypePointer aKey) const { return aKey == mKey; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {
    return ((uint32_t)(intptr_t)(aKey)) >> 2;
  }
  enum { ALLOW_MEMMOVE = true };

private:
  RefPtr<T> mKey;
};

template<class T>
inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            nsRefPtrHashKey<T>& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  CycleCollectionNoteChild(aCallback, aField.GetKey(), aName, aFlags);
}
template<class T>
class nsClearingPtrHashKey : public nsPtrHashKey<T>
{
public:
  explicit nsClearingPtrHashKey(const T* aKey) : nsPtrHashKey<T>(aKey) {}
  nsClearingPtrHashKey(const nsClearingPtrHashKey<T>& aToCopy)
    : nsPtrHashKey<T>(aToCopy)
  {
  }
  ~nsClearingPtrHashKey() { nsPtrHashKey<T>::mKey = nullptr; }
};

typedef nsClearingPtrHashKey<const void> nsClearingVoidPtrHashKey;






template<class T>
class nsFuncPtrHashKey : public PLDHashEntryHdr
{
public:
  typedef T& KeyType;
  typedef const T* KeyTypePointer;

  explicit nsFuncPtrHashKey(const T* aKey) : mKey(*const_cast<T*>(aKey)) {}
  nsFuncPtrHashKey(const nsFuncPtrHashKey<T>& aToCopy) : mKey(aToCopy.mKey) {}
  ~nsFuncPtrHashKey() {}

  KeyType GetKey() const { return const_cast<T&>(mKey); }
  bool KeyEquals(KeyTypePointer aKey) const { return *aKey == mKey; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {
    return ((uint32_t)(intptr_t)(*aKey)) >> 2;
  }
  enum { ALLOW_MEMMOVE = true };

protected:
  T mKey;
};






class nsIDHashKey : public PLDHashEntryHdr
{
public:
  typedef const nsID& KeyType;
  typedef const nsID* KeyTypePointer;

  explicit nsIDHashKey(const nsID* aInID) : mID(*aInID) {}
  nsIDHashKey(const nsIDHashKey& aToCopy) : mID(aToCopy.mID) {}
  ~nsIDHashKey() {}

  KeyType GetKey() const { return mID; }
  bool KeyEquals(KeyTypePointer aKey) const { return aKey->Equals(mID); }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {

    return mozilla::HashBytes(aKey, sizeof(KeyType));
  }

  enum { ALLOW_MEMMOVE = true };

private:
  const nsID mID;
};
class nsDepCharHashKey : public PLDHashEntryHdr
{
public:
  typedef const char* KeyType;
  typedef const char* KeyTypePointer;

  explicit nsDepCharHashKey(const char* aKey) : mKey(aKey) {}
  nsDepCharHashKey(const nsDepCharHashKey& aToCopy) : mKey(aToCopy.mKey) {}
  ~nsDepCharHashKey() {}

  const char* GetKey() const { return mKey; }
  bool KeyEquals(const char* aKey) const { return !strcmp(mKey, aKey); }

  static const char* KeyToPointer(const char* aKey) { return aKey; }
  static PLDHashNumber HashKey(const char* aKey)
  {
    return mozilla::HashString(aKey);
  }
  enum { ALLOW_MEMMOVE = true };

private:
  const char* mKey;
};






class nsCharPtrHashKey : public PLDHashEntryHdr
{
public:
  typedef const char* KeyType;
  typedef const char* KeyTypePointer;

  explicit nsCharPtrHashKey(const char* aKey) : mKey(strdup(aKey)) {}
  nsCharPtrHashKey(const nsCharPtrHashKey& aToCopy)
    : mKey(strdup(aToCopy.mKey))
  {
  }

  nsCharPtrHashKey(nsCharPtrHashKey&& aOther)
    : mKey(aOther.mKey)
  {
    aOther.mKey = nullptr;
  }

  ~nsCharPtrHashKey()
  {
    if (mKey) {
      free(const_cast<char*>(mKey));
    }
  }

  const char* GetKey() const { return mKey; }
  bool KeyEquals(KeyTypePointer aKey) const { return !strcmp(mKey, aKey); }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {
    return mozilla::HashString(aKey);
  }

  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return aMallocSizeOf(mKey);
  }

  enum { ALLOW_MEMMOVE = true };

private:
  const char* mKey;
};






class nsUnicharPtrHashKey : public PLDHashEntryHdr
{
public:
  typedef const char16_t* KeyType;
  typedef const char16_t* KeyTypePointer;

  explicit nsUnicharPtrHashKey(const char16_t* aKey) : mKey(NS_strdup(aKey)) {}
  nsUnicharPtrHashKey(const nsUnicharPtrHashKey& aToCopy)
    : mKey(NS_strdup(aToCopy.mKey))
  {
  }

  nsUnicharPtrHashKey(nsUnicharPtrHashKey&& aOther)
    : mKey(aOther.mKey)
  {
    aOther.mKey = nullptr;
  }

  ~nsUnicharPtrHashKey()
  {
    if (mKey) {
      free(const_cast<char16_t*>(mKey));
    }
  }

  const char16_t* GetKey() const { return mKey; }
  bool KeyEquals(KeyTypePointer aKey) const { return !NS_strcmp(mKey, aKey); }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {
    return mozilla::HashString(aKey);
  }

  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return aMallocSizeOf(mKey);
  }

  enum { ALLOW_MEMMOVE = true };

private:
  const char16_t* mKey;
};




class nsHashableHashKey : public PLDHashEntryHdr
{
public:
  typedef nsIHashable* KeyType;
  typedef const nsIHashable* KeyTypePointer;

  explicit nsHashableHashKey(const nsIHashable* aKey)
    : mKey(const_cast<nsIHashable*>(aKey))
  {
  }
  nsHashableHashKey(const nsHashableHashKey& aToCopy) : mKey(aToCopy.mKey) {}
  ~nsHashableHashKey() {}

  nsIHashable* GetKey() const { return mKey; }

  bool KeyEquals(const nsIHashable* aKey) const
  {
    bool eq;
    if (((bool)(__builtin_expect(!!(!NS_FAILED_impl(mKey->Equals(const_cast<nsIHashable*>(aKey), &eq))), 1)))) {
      return eq;
    }
    return false;
  }

  static const nsIHashable* KeyToPointer(nsIHashable* aKey) { return aKey; }
  static PLDHashNumber HashKey(const nsIHashable* aKey)
  {
    uint32_t code = 8888;



      const_cast<nsIHashable*>(aKey)->GetHashCode(&code);
    do { } while(0);
    return code;
  }

  enum { ALLOW_MEMMOVE = true };

private:
  nsCOMPtr<nsIHashable> mKey;
};

namespace mozilla {

template <typename T>
PLDHashNumber
Hash(const T& aValue)
{
  return aValue.Hash();
}

}





template<typename T>
class nsGenericHashKey : public PLDHashEntryHdr
{
public:
  typedef const T& KeyType;
  typedef const T* KeyTypePointer;

  explicit nsGenericHashKey(KeyTypePointer aKey) : mKey(*aKey) {}
  nsGenericHashKey(const nsGenericHashKey<T>& aOther) : mKey(aOther.mKey) {}

  KeyType GetKey() const { return mKey; }
  bool KeyEquals(KeyTypePointer aKey) const { return *aKey == mKey; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey) { return ::mozilla::Hash(*aKey); }
  enum { ALLOW_MEMMOVE = true };

private:
  T mKey;
};
template<class EntryType>
class nsTHashtable
{
  typedef mozilla::fallible_t fallible_t;
  static_assert(mozilla::IsPointer<typename EntryType::KeyTypePointer>::value,
                "KeyTypePointer should be a pointer");

public:


  nsTHashtable()
    : mTable(Ops(), sizeof(EntryType), PLDHashTable::kDefaultInitialLength)
  {}
  explicit nsTHashtable(uint32_t aInitLength)
    : mTable(Ops(), sizeof(EntryType), aInitLength)
  {}




  ~nsTHashtable();

  nsTHashtable(nsTHashtable<EntryType>&& aOther);





  uint32_t GetGeneration() const { return mTable.Generation(); }




  typedef typename EntryType::KeyType KeyType;




  typedef typename EntryType::KeyTypePointer KeyTypePointer;





  uint32_t Count() const { return mTable.EntryCount(); }




  bool IsEmpty() const { return Count() == 0; }







  EntryType* GetEntry(KeyType aKey) const
  {
    return static_cast<EntryType*>(
      const_cast<PLDHashTable*>(&mTable)->Search(EntryType::KeyToPointer(aKey)));
  }






  bool Contains(KeyType aKey) const { return !!GetEntry(aKey); }







  EntryType* PutEntry(KeyType aKey)
  {

    return static_cast<EntryType*>(mTable.Add(EntryType::KeyToPointer(aKey)));
  }

  __attribute__ ((warn_unused_result))
  EntryType* PutEntry(KeyType aKey, const fallible_t&)
  {
    return static_cast<EntryType*>(mTable.Add(EntryType::KeyToPointer(aKey),
                                              mozilla::fallible));
  }





  void RemoveEntry(KeyType aKey)
  {
    mTable.Remove(EntryType::KeyToPointer(aKey));
  }





  void RemoveEntry(EntryType* aEntry)
  {
    mTable.RemoveEntry(aEntry);
  }
  void RawRemoveEntry(EntryType* aEntry)
  {
    mTable.RawRemove(aEntry);
  }
  class Iterator : public PLDHashTable::Iterator
  {
  public:
    typedef PLDHashTable::Iterator Base;

    explicit Iterator(nsTHashtable* aTable) : Base(&aTable->mTable) {}
    Iterator(Iterator&& aOther) : Base(aOther.mTable) {}
    ~Iterator() {}

    EntryType* Get() const { return static_cast<EntryType*>(Base::Get()); }

  private:
    Iterator() = delete;
    Iterator(const Iterator&) = delete;
    Iterator& operator=(const Iterator&) = delete;
    Iterator& operator=(const Iterator&&) = delete;
  };

  Iterator Iter() { return Iterator(this); }

  Iterator ConstIter() const
  {
    return Iterator(const_cast<nsTHashtable*>(this));
  }






  void Clear()
  {
    mTable.Clear();
  }
  size_t ShallowSizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return mTable.ShallowSizeOfExcludingThis(aMallocSizeOf);
  }




  size_t ShallowSizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return aMallocSizeOf(this) + ShallowSizeOfExcludingThis(aMallocSizeOf);
  }






  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    size_t n = ShallowSizeOfExcludingThis(aMallocSizeOf);
    for (auto iter = ConstIter(); !iter.Done(); iter.Next()) {
      n += (*iter.Get()).SizeOfExcludingThis(aMallocSizeOf);
    }
    return n;
  }




  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
  }




  void SwapElements(nsTHashtable<EntryType>& aOther)
  {
    do { } while (0);

    mozilla::Swap(this->mTable, aOther.mTable);
  }
protected:
  PLDHashTable mTable;

  static PLDHashNumber s_HashKey(const void* aKey);

  static bool s_MatchEntry(const PLDHashEntryHdr* aEntry,
                           const void* aKey);

  static void s_CopyEntry(PLDHashTable* aTable, const PLDHashEntryHdr* aFrom,
                          PLDHashEntryHdr* aTo);

  static void s_ClearEntry(PLDHashTable* aTable, PLDHashEntryHdr* aEntry);

  static void s_InitEntry(PLDHashEntryHdr* aEntry, const void* aKey);

private:

  nsTHashtable(nsTHashtable<EntryType>& aToCopy) = delete;




  static const PLDHashTableOps* Ops();


  nsTHashtable<EntryType>& operator=(nsTHashtable<EntryType>& aToEqual) = delete;
};





template<class EntryType>
nsTHashtable<EntryType>::nsTHashtable(nsTHashtable<EntryType>&& aOther)
  : mTable(mozilla::Move(aOther.mTable))
{


  do {} while (0);
}

template<class EntryType>
nsTHashtable<EntryType>::~nsTHashtable()
{
}

template<class EntryType>
             const PLDHashTableOps*
nsTHashtable<EntryType>::Ops()
{



  static const PLDHashTableOps sOps =
  {
    s_HashKey,
    s_MatchEntry,
    EntryType::ALLOW_MEMMOVE ? PLDHashTable::MoveEntryStub : s_CopyEntry,
    s_ClearEntry,
    s_InitEntry
  };
  return &sOps;
}



template<class EntryType>
PLDHashNumber
nsTHashtable<EntryType>::s_HashKey(const void* aKey)
{
  return EntryType::HashKey(static_cast<const KeyTypePointer>(aKey));
}

template<class EntryType>
bool
nsTHashtable<EntryType>::s_MatchEntry(const PLDHashEntryHdr* aEntry,
                                      const void* aKey)
{
  return ((const EntryType*)aEntry)->KeyEquals(
    static_cast<const KeyTypePointer>(aKey));
}

template<class EntryType>
void
nsTHashtable<EntryType>::s_CopyEntry(PLDHashTable* aTable,
                                     const PLDHashEntryHdr* aFrom,
                                     PLDHashEntryHdr* aTo)
{
  EntryType* fromEntry =
    const_cast<EntryType*>(static_cast<const EntryType*>(aFrom));

  new (mozilla::KnownNotNull, aTo) EntryType(mozilla::Move(*fromEntry));

  fromEntry->~EntryType();
}

template<class EntryType>
void
nsTHashtable<EntryType>::s_ClearEntry(PLDHashTable* aTable,
                                      PLDHashEntryHdr* aEntry)
{
  static_cast<EntryType*>(aEntry)->~EntryType();
}

template<class EntryType>
void
nsTHashtable<EntryType>::s_InitEntry(PLDHashEntryHdr* aEntry,
                                     const void* aKey)
{
  new (mozilla::KnownNotNull, aEntry) EntryType(static_cast<KeyTypePointer>(aKey));
}

class nsCycleCollectionTraversalCallback;

template<class EntryType>
inline void
ImplCycleCollectionUnlink(nsTHashtable<EntryType>& aField)
{
  aField.Clear();
}

template<class EntryType>
inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            nsTHashtable<EntryType>& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  for (auto iter = aField.Iter(); !iter.Done(); iter.Next()) {
    EntryType* entry = iter.Get();
    ImplCycleCollectionTraverse(aCallback, *entry, aName, aFlags);
  }
}
namespace detail {

class VoidPtrHashKey : public nsPtrHashKey<const void>
{
  typedef nsPtrHashKey<const void> Base;

public:
  explicit VoidPtrHashKey(const void* aKey) : Base(aKey) {}
};

}





template<typename T>
class nsTHashtable<nsPtrHashKey<T>> : protected nsTHashtable<::detail::VoidPtrHashKey>
{
  typedef nsTHashtable<::detail::VoidPtrHashKey> Base;
  typedef nsPtrHashKey<T> EntryType;



  static_assert(sizeof(nsPtrHashKey<T>) == sizeof(::detail::VoidPtrHashKey),
                "hash keys must be the same size");

  nsTHashtable(const nsTHashtable& aOther) = delete;
  nsTHashtable& operator=(const nsTHashtable& aOther) = delete;

public:
  nsTHashtable() = default;
  explicit nsTHashtable(uint32_t aInitLength)
    : Base(aInitLength)
  {}

  ~nsTHashtable() = default;

  nsTHashtable(nsTHashtable&&) = default;


  using Base::GetGeneration;
  using Base::Count;
  using Base::IsEmpty;
  using Base::Clear;

  using Base::ShallowSizeOfExcludingThis;
  using Base::ShallowSizeOfIncludingThis;





  EntryType* GetEntry(T* aKey) const
  {
    return reinterpret_cast<EntryType*>(Base::GetEntry(aKey));
  }

  bool Contains(T* aKey) const
  {
    return Base::Contains(aKey);
  }

  EntryType* PutEntry(T* aKey)
  {
    return reinterpret_cast<EntryType*>(Base::PutEntry(aKey));
  }

  __attribute__ ((warn_unused_result))
  EntryType* PutEntry(T* aKey, const mozilla::fallible_t&)
  {
    return reinterpret_cast<EntryType*>(
      Base::PutEntry(aKey, mozilla::fallible));
  }

  void RemoveEntry(T* aKey)
  {
    Base::RemoveEntry(aKey);
  }

  void RemoveEntry(EntryType* aEntry)
  {
    Base::RemoveEntry(reinterpret_cast<::detail::VoidPtrHashKey*>(aEntry));
  }

  void RawRemoveEntry(EntryType* aEntry)
  {
    Base::RawRemoveEntry(reinterpret_cast<::detail::VoidPtrHashKey*>(aEntry));
  }

  class Iterator : public Base::Iterator
  {
  public:
    typedef nsTHashtable::Base::Iterator Base;

    explicit Iterator(nsTHashtable* aTable) : Base(aTable) {}
    Iterator(Iterator&& aOther) : Base(mozilla::Move(aOther)) {}
    ~Iterator() = default;

    EntryType* Get() const { return reinterpret_cast<EntryType*>(Base::Get()); }

  private:
    Iterator() = delete;
    Iterator(const Iterator&) = delete;
    Iterator& operator=(const Iterator&) = delete;
    Iterator& operator=(Iterator&&) = delete;
  };

  Iterator Iter() { return Iterator(this); }

  Iterator ConstIter() const
  {
    return Iterator(const_cast<nsTHashtable*>(this));
  }

  void SwapElements(nsTHashtable& aOther)
  {
    Base::SwapElements(aOther);
  }
};


template<class KeyClass, class DataType, class UserDataType>
class nsBaseHashtable;






template<class KeyClass, class DataType>
class nsBaseHashtableET : public KeyClass
{
public:
  DataType mData;
  friend class nsTHashtable<nsBaseHashtableET<KeyClass, DataType>>;

private:
  typedef typename KeyClass::KeyType KeyType;
  typedef typename KeyClass::KeyTypePointer KeyTypePointer;

  explicit nsBaseHashtableET(KeyTypePointer aKey);
  nsBaseHashtableET(nsBaseHashtableET<KeyClass, DataType>&& aToMove);
  ~nsBaseHashtableET();
};
template<class KeyClass, class DataType, class UserDataType>
class nsBaseHashtable
  : protected nsTHashtable<nsBaseHashtableET<KeyClass, DataType>>
{
  typedef mozilla::fallible_t fallible_t;

public:
  typedef typename KeyClass::KeyType KeyType;
  typedef nsBaseHashtableET<KeyClass, DataType> EntryType;

  using nsTHashtable<EntryType>::Contains;

  nsBaseHashtable() {}
  explicit nsBaseHashtable(uint32_t aInitLength)
    : nsTHashtable<EntryType>(aInitLength)
  {
  }





  uint32_t Count() const { return nsTHashtable<EntryType>::Count(); }
  bool Get(KeyType aKey, UserDataType* aData) const
  {
    EntryType* ent = this->GetEntry(aKey);
    if (!ent) {
      return false;
    }

    if (aData) {
      *aData = ent->mData;
    }

    return true;
  }
  UserDataType Get(KeyType aKey) const
  {
    EntryType* ent = this->GetEntry(aKey);
    if (!ent) {
      return UserDataType{};
    }

    return ent->mData;
  }






  DataType& GetOrInsert(const KeyType& aKey)
  {
    EntryType* ent = this->GetEntry(aKey);
    if (ent) {
      return ent->mData;
    }

    ent = this->PutEntry(aKey);
    return ent->mData;
  }







  void Put(KeyType aKey, const UserDataType& aData)
  {
    if (!Put(aKey, aData, mozilla::fallible)) {
      NS_ABORT_OOM(this->mTable.EntrySize() * this->mTable.EntryCount());
    }
  }

  __attribute__ ((warn_unused_result)) bool Put(KeyType aKey, const UserDataType& aData,
                        const fallible_t&)
  {
    EntryType* ent = this->PutEntry(aKey, mozilla::fallible);
    if (!ent) {
      return false;
    }

    ent->mData = aData;

    return true;
  }





  void Remove(KeyType aKey) { this->RemoveEntry(aKey); }
  class Iterator : public PLDHashTable::Iterator
  {
  public:
    typedef PLDHashTable::Iterator Base;

    explicit Iterator(nsBaseHashtable* aTable) : Base(&aTable->mTable) {}
    Iterator(Iterator&& aOther) : Base(aOther.mTable) {}
    ~Iterator() {}

    KeyType Key() const { return static_cast<EntryType*>(Get())->GetKey(); }
    UserDataType UserData() const
    {
      return static_cast<EntryType*>(Get())->mData;
    }
    DataType& Data() const { return static_cast<EntryType*>(Get())->mData; }

  private:
    Iterator() = delete;
    Iterator(const Iterator&) = delete;
    Iterator& operator=(const Iterator&) = delete;
    Iterator& operator=(const Iterator&&) = delete;
  };

  Iterator Iter() { return Iterator(this); }

  Iterator ConstIter() const
  {
    return Iterator(const_cast<nsBaseHashtable*>(this));
  }




  void Clear() { nsTHashtable<EntryType>::Clear(); }
  size_t ShallowSizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return this->mTable.ShallowSizeOfExcludingThis(aMallocSizeOf);
  }




  size_t ShallowSizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return aMallocSizeOf(this) + ShallowSizeOfExcludingThis(aMallocSizeOf);
  }




  void SwapElements(nsBaseHashtable& aOther)
  {
    nsTHashtable<EntryType>::SwapElements(aOther);
  }





};





template<class KeyClass, class DataType>
nsBaseHashtableET<KeyClass, DataType>::nsBaseHashtableET(KeyTypePointer aKey)
  : KeyClass(aKey)
  , mData()
{
}

template<class KeyClass, class DataType>
nsBaseHashtableET<KeyClass, DataType>::nsBaseHashtableET(
      nsBaseHashtableET<KeyClass, DataType>&& aToMove)
  : KeyClass(mozilla::Move(aToMove))
  , mData(mozilla::Move(aToMove.mData))
{
}

template<class KeyClass, class DataType>
nsBaseHashtableET<KeyClass, DataType>::~nsBaseHashtableET()
{
}
template<class KeyClass, class DataType>
class nsDataHashtable
  : public nsBaseHashtable<KeyClass, DataType, DataType>
{
private:
  typedef nsBaseHashtable<KeyClass, DataType, DataType> BaseClass;

public:
  using typename BaseClass::KeyType;
  using typename BaseClass::EntryType;

  nsDataHashtable() {}
  explicit nsDataHashtable(uint32_t aInitLength)
    : BaseClass(aInitLength)
  {
  }
  mozilla::Maybe<DataType> GetAndRemove(KeyType aKey)
  {
    mozilla::Maybe<DataType> value;
    if (EntryType* ent = this->GetEntry(aKey)) {
      value.emplace(mozilla::Move(ent->mData));
      this->RemoveEntry(ent);
    }
    return value;
  }
};

class ContentUnbinder;
class nsContentList;
class nsDOMAttributeMap;
class nsDOMTokenList;
class nsIControllers;
class nsICSSDeclaration;
class nsIDocument;
class nsDOMStringMap;
class nsIURI;

namespace mozilla {
class DeclarationBlock;
namespace dom {
struct CustomElementData;
class DOMIntersectionObserver;
class Element;
}
}





class nsNodeWeakReference final : public nsIWeakReference
{
public:
  explicit nsNodeWeakReference(nsINode* aNode)
    : mNode(aNode)
  {
  }


  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:


  virtual nsresult QueryReferent(const nsIID & uuid, void **result) override;
  virtual size_t SizeOfOnlyThis(mozilla::MallocSizeOf aMallocSizeOf) const override;

  void NoticeNodeDestruction()
  {
    mNode = nullptr;
  }

private:
  ~nsNodeWeakReference();

  nsINode* mNode;
};




class nsNodeSupportsWeakRefTearoff final : public nsISupportsWeakReference
{
public:
  explicit nsNodeSupportsWeakRefTearoff(nsINode* aNode)
    : mNode(aNode)
  {
  }


  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; virtual void DeleteCycleCollectable(void); typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:


  virtual nsresult GetWeakReference(nsIWeakReference * *_retval) override;

  class cycleCollection : public nsXPCOMCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = false) : nsXPCOMCycleCollectionParticipant(aSkip) {} private: public: virtual nsresult TraverseNative(void *p, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "nsNodeSupportsWeakRefTearoff"; }; virtual void DeleteCycleCollectable(void *p) override { DowncastCCParticipant<nsNodeSupportsWeakRefTearoff>(p)->DeleteCycleCollectable(); } static nsNodeSupportsWeakRefTearoff* Downcast(nsISupports* s) { return static_cast<nsNodeSupportsWeakRefTearoff*>(static_cast<nsNodeSupportsWeakRefTearoff*>(s)); } static nsISupports* Upcast(nsNodeSupportsWeakRefTearoff *p) { return static_cast<nsISupports*>(static_cast<nsNodeSupportsWeakRefTearoff*>(p)); } template<typename T> friend nsISupports* ToSupports(T* p, cycleCollection* dummy); virtual void Unlink(void *p) override; static constexpr nsXPCOMCycleCollectionParticipant* GetParticipant() { return &nsNodeSupportsWeakRefTearoff::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;

private:
  ~nsNodeSupportsWeakRefTearoff() {}

  nsCOMPtr<nsINode> mNode;
};





namespace mozilla {
namespace dom {

class ShadowRoot;

class FragmentOrElement : public nsIContent
{
public:
  explicit FragmentOrElement(already_AddRefed<mozilla::dom::NodeInfo>& aNodeInfo);
  explicit FragmentOrElement(already_AddRefed<mozilla::dom::NodeInfo>&& aNodeInfo);

  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; virtual void DeleteCycleCollectable(void); typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:

  virtual size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const override;


  virtual uint32_t GetChildCount() const override;
  virtual nsIContent *GetChildAt(uint32_t aIndex) const override;
  virtual nsIContent * const * GetChildArray(uint32_t* aChildCount) const override;
  virtual int32_t IndexOf(const nsINode* aPossibleChild) const override;
  virtual nsresult InsertChildAt(nsIContent* aKid, uint32_t aIndex,
                                 bool aNotify) override;
  virtual void RemoveChildAt(uint32_t aIndex, bool aNotify) override;
  virtual void GetTextContentInternal(nsAString& aTextContent,
                                      mozilla::OOMReporter& aError) override;
  virtual void SetTextContentInternal(const nsAString& aTextContent,
                                      mozilla::ErrorResult& aError) override;


  virtual already_AddRefed<nsINodeList> GetChildren(uint32_t aFilter) override;
  virtual const nsTextFragment *GetText() override;
  virtual uint32_t TextLength() const override;
  virtual nsresult SetText(const char16_t* aBuffer, uint32_t aLength,
                           bool aNotify) override;

  nsresult SetText(const nsAString& aStr, bool aNotify)
  {
    return SetText(aStr.BeginReading(), aStr.Length(), aNotify);
  }
  virtual nsresult AppendText(const char16_t* aBuffer, uint32_t aLength,
                              bool aNotify) override;
  virtual bool TextIsOnlyWhitespace() override;
  virtual bool ThreadSafeTextIsOnlyWhitespace() const override;
  virtual bool HasTextForTranslation() override;
  virtual void AppendTextTo(nsAString& aResult) override;
  __attribute__ ((warn_unused_result))
  virtual bool AppendTextTo(nsAString& aResult, const mozilla::fallible_t&) override;
  virtual nsIContent *GetBindingParent() const override;
  virtual nsXBLBinding *GetXBLBinding() const override;
  virtual void SetXBLBinding(nsXBLBinding* aBinding,
                             nsBindingManager* aOldBindingManager = nullptr) override;
  virtual ShadowRoot *GetContainingShadow() const override;
  virtual nsTArray<nsIContent*> &DestInsertionPoints() override;
  virtual nsTArray<nsIContent*> *GetExistingDestInsertionPoints() const override;
  virtual void SetShadowRoot(ShadowRoot* aBinding) override;
  virtual nsIContent *GetXBLInsertionParent() const override;
  virtual void SetXBLInsertionParent(nsIContent* aContent) override;
  virtual bool IsLink(nsIURI** aURI) const override;

  virtual void DestroyContent() override;
  virtual void SaveSubtreeState() override;

  virtual nsresult WalkContentStyleRules(nsRuleWalker* aRuleWalker) override;

  nsIHTMLCollection* Children();
  uint32_t ChildElementCount()
  {
    return Children()->Length();
  }







  void SetIsElementInStyleScopeFlagOnSubtree(bool aInStyleScope);

public:




  static void FireNodeInserted(nsIDocument* aDoc,
                               nsINode* aParent,
                               nsTArray<nsCOMPtr<nsIContent> >& aNodes);

  class cycleCollection : public nsXPCOMCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = true) : nsXPCOMCycleCollectionParticipant(true) {} private: public: virtual nsresult TraverseNative(void *p, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "FragmentOrElement"; }; virtual void DeleteCycleCollectable(void *p) override { DowncastCCParticipant<FragmentOrElement>(p)->DeleteCycleCollectable(); } static FragmentOrElement* Downcast(nsISupports* s) { return static_cast<FragmentOrElement*>(static_cast<FragmentOrElement*>(s)); } static nsISupports* Upcast(FragmentOrElement *p) { return static_cast<nsISupports*>(static_cast<FragmentOrElement*>(p)); } template<typename T> friend nsISupports* ToSupports(T* p, cycleCollection* dummy); virtual void Unlink(void *p) override; virtual void Trace(void *p, const TraceCallbacks &cb, void *closure) override; virtual bool CanSkipReal(void *p, bool aRemovingAllowed) override; virtual bool CanSkipInCCReal(void *p) override; virtual bool CanSkipThisReal(void *p) override; static constexpr nsXPCOMCycleCollectionParticipant* GetParticipant() { return &FragmentOrElement::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;




  void FireNodeRemovedForChildren();

  virtual bool OwnedOnlyByTheDOMTree() override
  {
    uint32_t rc = mRefCnt.get();
    if (GetParent()) {
      --rc;
    }
    rc -= mAttrsAndChildren.ChildCount();
    return rc == 0;
  }

  virtual bool IsPurple() override
  {
    return mRefCnt.IsPurple();
  }

  virtual void RemovePurple() override
  {
    mRefCnt.RemovePurple();
  }

  static void ClearContentUnbinder();
  static bool CanSkip(nsINode* aNode, bool aRemovingAllowed);
  static bool CanSkipInCC(nsINode* aNode);
  static bool CanSkipThis(nsINode* aNode);
  static void RemoveBlackMarkedNode(nsINode* aNode);
  static void MarkNodeChildren(nsINode* aNode);
  static void InitCCCallbacks();
  static void MarkUserData(void* aObject, nsIAtom* aKey, void* aChild,
                           void *aData);




  static bool IsHTMLVoid(nsIAtom* aLocalName);
protected:
  virtual ~FragmentOrElement();





  nsresult CopyInnerTo(FragmentOrElement* aDest);

public:
  class nsDOMSlots : public nsINode::nsSlots
  {
  public:
    nsDOMSlots();
    virtual ~nsDOMSlots();

    void Traverse(nsCycleCollectionTraversalCallback &cb, bool aIsXUL);
    void Unlink(bool aIsXUL);

    size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;






    nsCOMPtr<nsICSSDeclaration> mStyle;





    nsDOMStringMap* mDataset;





    nsCOMPtr<nsICSSDeclaration> mSMILOverrideStyle;




    RefPtr<mozilla::DeclarationBlock> mSMILOverrideStyleDeclaration;





    RefPtr<nsDOMAttributeMap> mAttributeMap;

    union {




      nsIContent* mBindingParent;




      nsIControllers* mControllers;
    };




    RefPtr<nsContentList> mChildrenList;




    RefPtr<nsDOMTokenList> mClassList;




    RefPtr<ShadowRoot> mShadowRoot;




    RefPtr<ShadowRoot> mContainingShadow;





    nsTArray<nsIContent*> mDestInsertionPoints;




    RefPtr<nsXBLBinding> mXBLBinding;




    nsCOMPtr<nsIContent> mXBLInsertionParent;




    RefPtr<CustomElementData> mCustomElementData;




    nsDataHashtable<nsRefPtrHashKey<DOMIntersectionObserver>, int32_t>
      mRegisteredIntersectionObservers;
  };

protected:
  void GetMarkup(bool aIncludeSelf, nsAString& aMarkup);
  void SetInnerHTMLInternal(const nsAString& aInnerHTML, ErrorResult& aError);


  virtual nsINode::nsSlots* CreateSlots() override;

  nsDOMSlots *DOMSlots()
  {
    return static_cast<nsDOMSlots*>(Slots());
  }

  nsDOMSlots *GetExistingDOMSlots() const
  {
    return static_cast<nsDOMSlots*>(GetExistingSlots());
  }







  void SetIsElementInStyleScopeFlagOnShadowTree(bool aInStyleScope);

  friend class ::ContentUnbinder;



  nsAttrAndChildArray mAttrsAndChildren;
};

}
}



class nsIContent;
class nsAString;
class nsAttrValue;
class nsTextNode;

namespace mozilla {
namespace dom {
class Element;
}
}

namespace mozilla {

enum Directionality : uint8_t {
  eDir_NotSet,
  eDir_RTL,
  eDir_LTR,
  eDir_Auto
};
Directionality RecomputeDirectionality(mozilla::dom::Element* aElement,
                                       bool aNotify = true);
void SetDirectionalityOnDescendants(mozilla::dom::Element* aElement,
                                    Directionality aDir,
                                    bool aNotify = true);







void WalkDescendantsResetAutoDirection(mozilla::dom::Element* aElement);
void WalkDescendantsSetDirAuto(mozilla::dom::Element* aElement,
                               bool aNotify = true);






void WalkDescendantsClearAncestorDirAuto(mozilla::dom::Element* aElement);







bool TextNodeWillChangeDirection(nsIContent* aTextNode, Directionality* aOldDir,
                                 uint32_t aOffset);





void TextNodeChangedDirection(nsTextNode* aTextNode, Directionality aOldDir,
                              bool aNotify);





void SetDirectionFromNewTextNode(nsTextNode* aTextNode);







void ResetDirectionSetByTextNode(nsTextNode* aTextNode);





void SetDirectionalityFromValue(mozilla::dom::Element* aElement,
                                const nsAString& aValue,
                                bool aNotify);
void OnSetDirAttr(mozilla::dom::Element* aElement,
                  const nsAttrValue* aNewValue,
                  bool hadValidDir,
                  bool hadDirAuto,
                  bool aNotify);






void SetDirOnBind(mozilla::dom::Element* aElement, nsIContent* aParent);






void ResetDir(mozilla::dom::Element* aElement);
}
class nsIDOMMozNamedAttrMap;
class nsIDOMElement : public nsIDOMNode {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetTagName(nsAString & aTagName) = 0;


  virtual nsresult GetAttributes(nsIDOMMozNamedAttrMap * *aAttributes) = 0;


  virtual nsresult GetAttribute(const nsAString & name, nsAString & _retval) = 0;


  virtual nsresult SetAttribute(const nsAString & name, const nsAString & value) = 0;


  virtual nsresult HasAttribute(const nsAString & name, bool *_retval) = 0;


  virtual nsresult GetAttributeNode(const nsAString & name, nsIDOMAttr * *_retval) = 0;


  virtual nsresult GetAttributeNodeNS(const nsAString & namespaceURI, const nsAString & localName, nsIDOMAttr * *_retval) = 0;

};

  template<typename T> struct nsIDOMElement::COMTypeInfo<nsIDOMElement, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMElement::COMTypeInfo<nsIDOMElement, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x6289999b, 0x1008, 0x4269, { 0xb4, 0x2a, 0x41, 0x3e, 0xc5, 0xa9, 0xd3, 0xf4 }};
class nsIContent;
class nsIDocShell;
class nsIInputStream;
class nsIRequest;
class nsILinkHandler : public nsISupports
{
public:
  template<typename T, typename U> struct COMTypeInfo;
  virtual nsresult OnLinkClick(nsIContent* aContent,
                         nsIURI* aURI,
                         const char16_t* aTargetSpec,
                         const nsAString& aFileName,
                         nsIInputStream* aPostDataStream,
                         nsIInputStream* aHeadersDataStream,
                         bool aIsTrusted,
                         nsIPrincipal* aTriggeringPrincipal) = 0;
  virtual nsresult OnLinkClickSync(nsIContent* aContent,
                             nsIURI* aURI,
                             const char16_t* aTargetSpec,
                             const nsAString& aFileName,
                             nsIInputStream* aPostDataStream = 0,
                             nsIInputStream* aHeadersDataStream = 0,
                             bool aNoOpenerImplied = false,
                             nsIDocShell** aDocShell = 0,
                             nsIRequest** aRequest = 0,
                             nsIPrincipal* aTriggeringPrincipal = nullptr) = 0;
  virtual nsresult OnOverLink(nsIContent* aContent,
                        nsIURI* aURLSpec,
                        const char16_t* aTargetSpec) = 0;




  virtual nsresult OnLeaveLink() = 0;
};

template<typename T> struct nsILinkHandler::COMTypeInfo<nsILinkHandler, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsILinkHandler::COMTypeInfo<nsILinkHandler, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0xceb9aade, 0x43da, 0x4f1a, { 0xac, 0x8a, 0xc7, 0x09, 0xfb, 0x22, 0x46, 0x64 } };
class nsIDOMNodeList : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult Item(uint32_t index, nsIDOMNode * *_retval) = 0;


  virtual nsresult GetLength(uint32_t *aLength) = 0;

};

  template<typename T> struct nsIDOMNodeList::COMTypeInfo<nsIDOMNodeList, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMNodeList::COMTypeInfo<nsIDOMNodeList, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x450cf0ba, 0xde90, 0x4f86, { 0x85, 0xbf, 0xe1, 0x0c, 0xc8, 0xb8, 0x71, 0x3f }};








class nsIContent;
class nsINode;




class nsINodeList : public nsIDOMNodeList,
                    public nsWrapperCache
{
public:
  template<typename T, typename U> struct COMTypeInfo;





  virtual int32_t IndexOf(nsIContent* aContent) = 0;




  virtual nsINode* GetParentObject() = 0;

  using nsIDOMNodeList::Item;

  uint32_t Length()
  {
    uint32_t length;
    GetLength(&length);
    return length;
  }
  virtual nsIContent* Item(uint32_t aIndex) = 0;
  nsIContent* IndexedGetter(uint32_t aIndex, bool& aFound)
  {
    nsIContent* item = Item(aIndex);
    aFound = !!item;
    return item;
  }
};




template<typename T> struct nsINodeList::COMTypeInfo<nsINodeList, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsINodeList::COMTypeInfo<nsINodeList, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0xadb5e54c, 0x6e96, 0x4102, { 0x8d, 0x40, 0xe0, 0x12, 0x3d, 0xcf, 0x48, 0x7a } };



namespace mozilla {
enum class FlushType : uint8_t {
  None = 0,
  Content = 1,
  ContentAndNotify = 2,


  Style = 3,
  Frames = Style,
  InterruptibleLayout = 4,


  Layout = 5,

  Display = 6,

  Count
};

struct ChangesToFlush {
  ChangesToFlush(FlushType aFlushType, bool aFlushAnimations)
    : mFlushType(aFlushType)
    , mFlushAnimations(aFlushAnimations)
  {}

  FlushType mFlushType;
  bool mFlushAnimations;
};

}
class nsDOMAttributeMap;





class nsIAttribute : public nsINode
{
public:
  template<typename T, typename U> struct COMTypeInfo;

  virtual void SetMap(nsDOMAttributeMap *aMap) = 0;

  nsDOMAttributeMap *GetMap()
  {
    return mAttrMap;
  }

  mozilla::dom::NodeInfo *NodeInfo() const
  {
    return mNodeInfo;
  }





  virtual nsresult SetOwnerDocument(nsIDocument* aDocument) = 0;

protected:

  nsIAttribute(nsDOMAttributeMap *aAttrMap,
               already_AddRefed<mozilla::dom::NodeInfo>& aNodeInfo);

  virtual ~nsIAttribute();

  RefPtr<nsDOMAttributeMap> mAttrMap;
};

template<typename T> struct nsIAttribute::COMTypeInfo<nsIAttribute, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIAttribute::COMTypeInfo<nsIAttribute, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x84d43da7, 0xb45d, 0x47ae, { 0x8f, 0xbf, 0x95, 0x26, 0x78, 0x4d, 0x5e, 0x47 } };
class nsIDOMAttr : public nsIDOMNode {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetName(nsAString & aName) = 0;


  virtual nsresult GetSpecified(bool *aSpecified) = 0;


  virtual nsresult GetValue(nsAString & aValue) = 0;
  virtual nsresult SetValue(const nsAString & aValue) = 0;


  virtual nsresult GetOwnerElement(nsIDOMElement * *aOwnerElement) = 0;


  virtual nsresult GetIsId(bool *aIsId) = 0;

};

  template<typename T> struct nsIDOMAttr::COMTypeInfo<nsIDOMAttr, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMAttr::COMTypeInfo<nsIDOMAttr, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x7db491e8, 0xa3a3, 0x4432, { 0xad, 0x67, 0xe6, 0xc3, 0x3e, 0x24, 0xac, 0x6d }};
class nsIDOMCharacterData : public nsIDOMNode {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetData(nsAString & aData) = 0;
  virtual nsresult SetData(const nsAString & aData) = 0;


  virtual nsresult GetLength(uint32_t *aLength) = 0;


  virtual nsresult SubstringData(uint32_t offset, uint32_t count, nsAString & _retval) = 0;


  virtual nsresult AppendData(const nsAString & arg) = 0;


  virtual nsresult InsertData(uint32_t offset, const nsAString & arg) = 0;


  virtual nsresult DeleteData(uint32_t offset, uint32_t count) = 0;


  virtual nsresult ReplaceData(uint32_t offset, uint32_t count, const nsAString & arg) = 0;

};

  template<typename T> struct nsIDOMCharacterData::COMTypeInfo<nsIDOMCharacterData, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMCharacterData::COMTypeInfo<nsIDOMCharacterData, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x4109a2d2, 0xe7af, 0x445d, { 0xbb, 0x72, 0xc7, 0xc9, 0xb8, 0x75, 0xf3, 0x5e }};
class nsIDOMText : public nsIDOMCharacterData {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult SplitText(uint32_t offset, nsIDOMText * *_retval) = 0;


  virtual nsresult GetWholeText(nsAString & aWholeText) = 0;

};

  template<typename T> struct nsIDOMText::COMTypeInfo<nsIDOMText, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMText::COMTypeInfo<nsIDOMText, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x67273994, 0x6aff, 0x4091, { 0x9d, 0xe9, 0xb7, 0x88, 0xa2, 0x49, 0xf7, 0x83 }};




class nsStubMutationObserver : public nsIMutationObserver {
public:
  virtual void CharacterDataWillChange(nsIDocument* aDocument, nsIContent* aContent, CharacterDataChangeInfo* aInfo) override; virtual void CharacterDataChanged(nsIDocument* aDocument, nsIContent* aContent, CharacterDataChangeInfo* aInfo) override; virtual void AttributeWillChange(nsIDocument* aDocument, mozilla::dom::Element* aElement, int32_t aNameSpaceID, nsIAtom* aAttribute, int32_t aModType, const nsAttrValue* aNewValue) override; virtual void NativeAnonymousChildListChange(nsIDocument* aDocument, nsIContent* aContent, bool aIsRemove) override; virtual void AttributeChanged(nsIDocument* aDocument, mozilla::dom::Element* aElement, int32_t aNameSpaceID, nsIAtom* aAttribute, int32_t aModType, const nsAttrValue* aOldValue) override; virtual void ContentAppended(nsIDocument* aDocument, nsIContent* aContainer, nsIContent* aFirstNewContent, int32_t aNewIndexInContainer) override; virtual void ContentInserted(nsIDocument* aDocument, nsIContent* aContainer, nsIContent* aChild, int32_t aIndexInContainer) override; virtual void ContentRemoved(nsIDocument* aDocument, nsIContent* aContainer, nsIContent* aChild, int32_t aIndexInContainer, nsIContent* aPreviousSibling) override; virtual void NodeWillBeDestroyed(const nsINode* aNode) override; virtual void ParentChainChanged(nsIContent *aContent) override;
};

class nsIDocument;

namespace mozilla {
class EventChainPreVisitor;
namespace dom {



class Attr final : public nsIAttribute,
                   public nsIDOMAttr
{
  virtual ~Attr() {}

public:
  Attr(nsDOMAttributeMap* aAttrMap,
       already_AddRefed<mozilla::dom::NodeInfo>&& aNodeInfo,
       const nsAString& aValue);

  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; virtual void DeleteCycleCollectable(void); typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:


  virtual nsresult GetNodeName(nsAString& aNodeName) final override { aNodeName = nsINode::NodeName(); return NS_OK; } virtual nsresult GetNodeValue(nsAString& aNodeValue) final override { nsINode::GetNodeValue(aNodeValue); return NS_OK; } virtual nsresult SetNodeValue(const nsAString& aNodeValue) final override { mozilla::ErrorResult rv; nsINode::SetNodeValue(aNodeValue, rv); return rv.StealNSResult(); } virtual nsresult GetNodeType(uint16_t* aNodeType) final override { *aNodeType = nsINode::NodeType(); return NS_OK; } virtual nsresult GetParentNode(nsIDOMNode** aParentNode) final override { return nsINode::GetParentNode(aParentNode); } virtual nsresult GetChildNodes(nsIDOMNodeList** aChildNodes) final override { return nsINode::GetChildNodes(aChildNodes); } virtual nsresult GetFirstChild(nsIDOMNode** aFirstChild) final override { return nsINode::GetFirstChild(aFirstChild); } virtual nsresult GetLastChild(nsIDOMNode** aLastChild) final override { return nsINode::GetLastChild(aLastChild); } virtual nsresult GetPreviousSibling(nsIDOMNode** aPreviousSibling) final override { return nsINode::GetPreviousSibling(aPreviousSibling); } virtual nsresult GetNextSibling(nsIDOMNode** aNextSibling) final override { return nsINode::GetNextSibling(aNextSibling); } virtual nsresult GetOwnerDocument(nsIDOMDocument** aOwnerDocument) final override { return nsINode::GetOwnerDocument(aOwnerDocument); } virtual nsresult RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aResult) final override { return nsINode::RemoveChild(aOldChild, aResult); } virtual nsresult HasChildNodes(bool* aResult) final override { *aResult = nsINode::HasChildNodes(); return NS_OK; } virtual nsresult CloneNode(bool aDeep, uint8_t aArgc, nsIDOMNode** aResult) final override { if (aArgc == 0) { aDeep = true; } mozilla::ErrorResult rv; nsCOMPtr<nsINode> clone = nsINode::CloneNode(aDeep, rv); if (rv.Failed()) { return rv.StealNSResult(); } *aResult = clone.forget().take()->AsDOMNode(); return NS_OK; } virtual nsresult GetNamespaceURI(nsAString& aNamespaceURI) final override { nsINode::GetNamespaceURI(aNamespaceURI); return NS_OK; } virtual nsresult GetPrefix(nsAString& aPrefix) final override { nsINode::GetPrefix(aPrefix); return NS_OK; } virtual nsresult GetLocalName(nsAString& aLocalName) final override { aLocalName = nsINode::LocalName(); return NS_OK; } virtual nsresult GetTextContent(nsAString& aTextContent) final override { mozilla::ErrorResult rv; nsINode::GetTextContent(aTextContent, rv); return rv.StealNSResult(); } virtual nsresult SetTextContent(const nsAString& aTextContent) final override { mozilla::ErrorResult rv; nsINode::SetTextContent(aTextContent, rv); return rv.StealNSResult(); }
  virtual void GetTextContentInternal(nsAString& aTextContent,
                                      OOMReporter& aError) override;
  virtual void SetTextContentInternal(const nsAString& aTextContent,
                                      ErrorResult& aError) override;
  virtual void GetNodeValueInternal(nsAString& aNodeValue) override;
  virtual void SetNodeValueInternal(const nsAString& aNodeValue,
                                    ErrorResult& aError) override;


  virtual nsresult GetName(nsAString & aName) override; virtual nsresult GetSpecified(bool *aSpecified) override; virtual nsresult GetValue(nsAString & aValue) override; virtual nsresult SetValue(const nsAString & aValue) override; virtual nsresult GetOwnerElement(nsIDOMElement * *aOwnerElement) override; virtual nsresult GetIsId(bool *aIsId) override;

  virtual nsresult GetEventTargetParent(EventChainPreVisitor& aVisitor) override;


  void SetMap(nsDOMAttributeMap *aMap) override;
  Element* GetElement() const;
  nsresult SetOwnerDocument(nsIDocument* aDocument) override;


  virtual bool IsNodeOfType(uint32_t aFlags) const override;
  virtual uint32_t GetChildCount() const override;
  virtual nsIContent *GetChildAt(uint32_t aIndex) const override;
  virtual nsIContent * const * GetChildArray(uint32_t* aChildCount) const override;
  virtual int32_t IndexOf(const nsINode* aPossibleChild) const override;
  virtual nsresult InsertChildAt(nsIContent* aKid, uint32_t aIndex,
                                 bool aNotify) override;
  virtual void RemoveChildAt(uint32_t aIndex, bool aNotify) override;
  virtual nsresult Clone(mozilla::dom::NodeInfo *aNodeInfo, nsINode **aResult) const override;
  virtual already_AddRefed<nsIURI> GetBaseURI(bool aTryUseXHRDocBaseURI = false) const override;

  static void Initialize();
  static void Shutdown();

  class cycleCollection : public nsXPCOMCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = true) : nsXPCOMCycleCollectionParticipant(true) {} private: public: virtual nsresult TraverseNative(void *p, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "Attr"; }; virtual void DeleteCycleCollectable(void *p) override { DowncastCCParticipant<Attr>(p)->DeleteCycleCollectable(); } static Attr* Downcast(nsISupports* s) { return static_cast<Attr*>(static_cast<nsIAttribute*>(s)); } static nsISupports* Upcast(Attr *p) { return static_cast<nsISupports*>(static_cast<nsIAttribute*>(p)); } template<typename T> friend nsISupports* ToSupports(T* p, cycleCollection* dummy); virtual void Unlink(void *p) override; virtual void Trace(void *p, const TraceCallbacks &cb, void *closure) override; virtual bool CanSkipReal(void *p, bool aRemovingAllowed) override; virtual bool CanSkipInCCReal(void *p) override; virtual bool CanSkipThisReal(void *p) override; static constexpr nsXPCOMCycleCollectionParticipant* GetParticipant() { return &Attr::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;


  virtual nsIDOMNode* AsDOMNode() override { return this; }


  virtual JSObject* WrapNode(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;




  void SetValue(const nsAString& aValue, ErrorResult& aRv);

  bool Specified() const;





  Element* GetOwnerElement(ErrorResult& aRv);

protected:
  virtual Element* GetNameSpaceElement() override
  {
    return GetElement();
  }

  static bool sInitialized;

private:
  nsString mValue;
};

}
}


class nsIDOMMozNamedAttrMap : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetNamedItem(const nsAString & name, nsIDOMAttr * *_retval) = 0;


  virtual nsresult SetNamedItem(nsIDOMAttr *arg, nsIDOMAttr * *_retval) = 0;


  virtual nsresult RemoveNamedItem(const nsAString & name, nsIDOMAttr * *_retval) = 0;


  virtual nsresult Item(uint32_t index, nsIDOMAttr * *_retval) = 0;


  virtual nsresult GetLength(uint32_t *aLength) = 0;


  virtual nsresult GetNamedItemNS(const nsAString & namespaceURI, const nsAString & localName, nsIDOMAttr * *_retval) = 0;


  virtual nsresult SetNamedItemNS(nsIDOMAttr *arg, nsIDOMAttr * *_retval) = 0;


  virtual nsresult RemoveNamedItemNS(const nsAString & namespaceURI, const nsAString & localName, nsIDOMAttr * *_retval) = 0;

};

  template<typename T> struct nsIDOMMozNamedAttrMap::COMTypeInfo<nsIDOMMozNamedAttrMap, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMMozNamedAttrMap::COMTypeInfo<nsIDOMMozNamedAttrMap, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xcb5564cd, 0x26ec, 0x418f, { 0xa6, 0xd6, 0x1d, 0x57, 0xcd, 0x2c, 0x97, 0x1c }};
template<class KeyClass, class PtrType>
class nsRefPtrHashtable
  : public nsBaseHashtable<KeyClass, RefPtr<PtrType>, PtrType*>
{
public:
  typedef typename KeyClass::KeyType KeyType;
  typedef PtrType* UserDataType;
  typedef nsBaseHashtable<KeyClass, RefPtr<PtrType>, PtrType*> base_type;

  nsRefPtrHashtable() {}
  explicit nsRefPtrHashtable(uint32_t aInitLength)
    : nsBaseHashtable<KeyClass, RefPtr<PtrType>, PtrType*>(aInitLength)
  {
  }






  bool Get(KeyType aKey, UserDataType* aData) const;







  PtrType* GetWeak(KeyType aKey, bool* aFound = nullptr) const;


  using base_type::Put;

  void Put(KeyType aKey, already_AddRefed<PtrType> aData);

  __attribute__ ((warn_unused_result)) bool Put(KeyType aKey, already_AddRefed<PtrType> aData,
                        const mozilla::fallible_t&);


  using base_type::Remove;
  bool Remove(KeyType aKey, UserDataType* aData);
};

template<typename K, typename T>
inline void
ImplCycleCollectionUnlink(nsRefPtrHashtable<K, T>& aField)
{
  aField.Clear();
}

template<typename K, typename T>
inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            nsRefPtrHashtable<K, T>& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  for (auto iter = aField.ConstIter(); !iter.Done(); iter.Next()) {
    CycleCollectionNoteChild(aCallback, iter.UserData(), aName, aFlags);
  }
}





template<class KeyClass, class PtrType>
bool
nsRefPtrHashtable<KeyClass, PtrType>::Get(KeyType aKey,
                                          UserDataType* aRefPtr) const
{
  typename base_type::EntryType* ent = this->GetEntry(aKey);

  if (ent) {
    if (aRefPtr) {
      *aRefPtr = ent->mData;

      ns_if_addref(*aRefPtr);
    }

    return true;
  }



  if (aRefPtr) {
    *aRefPtr = nullptr;
  }

  return false;
}

template<class KeyClass, class PtrType>
PtrType*
nsRefPtrHashtable<KeyClass, PtrType>::GetWeak(KeyType aKey, bool* aFound) const
{
  typename base_type::EntryType* ent = this->GetEntry(aKey);

  if (ent) {
    if (aFound) {
      *aFound = true;
    }

    return ent->mData;
  }


  if (aFound) {
    *aFound = false;
  }

  return nullptr;
}

template<class KeyClass, class PtrType>
void
nsRefPtrHashtable<KeyClass, PtrType>::Put(KeyType aKey,
                                          already_AddRefed<PtrType> aData)
{
  if (!Put(aKey, mozilla::Move(aData), mozilla::fallible)) {
    NS_ABORT_OOM(this->mTable.EntrySize() * this->mTable.EntryCount());
  }
}

template<class KeyClass, class PtrType>
bool
nsRefPtrHashtable<KeyClass, PtrType>::Put(KeyType aKey,
                                          already_AddRefed<PtrType> aData,
                                          const mozilla::fallible_t&)
{
  typename base_type::EntryType* ent = this->PutEntry(aKey);

  if (!ent) {
    return false;
  }

  ent->mData = aData;

  return true;
}

template<class KeyClass, class PtrType>
bool
nsRefPtrHashtable<KeyClass, PtrType>::Remove(KeyType aKey,
                                             UserDataType* aRefPtr)
{
  do { } while (0);
  typename base_type::EntryType* ent = this->GetEntry(aKey);

  if (ent) {
    ent->mData.forget(aRefPtr);
    this->Remove(aKey);
    return true;
  }



  *aRefPtr = nullptr;
  return false;
}



class nsIAtom;
class nsIDocument;




class nsAttrKey
{
public:



  int32_t mNamespaceID;





  void* mLocalName;

  nsAttrKey(int32_t aNs, nsIAtom* aName)
    : mNamespaceID(aNs), mLocalName(aName) {}

  nsAttrKey(const nsAttrKey& aAttr)
    : mNamespaceID(aAttr.mNamespaceID), mLocalName(aAttr.mLocalName) {}
};




class nsAttrHashKey : public PLDHashEntryHdr
{
public:
  typedef const nsAttrKey& KeyType;
  typedef const nsAttrKey* KeyTypePointer;

  explicit nsAttrHashKey(KeyTypePointer aKey) : mKey(*aKey) {}
  nsAttrHashKey(const nsAttrHashKey& aCopy) : mKey(aCopy.mKey) {}
  ~nsAttrHashKey() {}

  KeyType GetKey() const { return mKey; }
  bool KeyEquals(KeyTypePointer aKey) const
    {
      return mKey.mLocalName == aKey->mLocalName &&
             mKey.mNamespaceID == aKey->mNamespaceID;
    }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
    {
      if (!aKey)
        return 0;

      return mozilla::HashGeneric(aKey->mNamespaceID, aKey->mLocalName);
    }
  enum { ALLOW_MEMMOVE = true };

private:
  nsAttrKey mKey;
};


class nsDOMAttributeMap final : public nsIDOMMozNamedAttrMap
                              , public nsWrapperCache
{
public:
  typedef mozilla::dom::Attr Attr;
  typedef mozilla::dom::Element Element;
  typedef mozilla::ErrorResult ErrorResult;

  explicit nsDOMAttributeMap(Element *aContent);

  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; virtual void DeleteCycleCollectable(void); typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:
  class cycleCollection : public nsXPCOMCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = true) : nsXPCOMCycleCollectionParticipant(true) {} private: public: virtual nsresult TraverseNative(void *p, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "nsDOMAttributeMap"; }; virtual void DeleteCycleCollectable(void *p) override { DowncastCCParticipant<nsDOMAttributeMap>(p)->DeleteCycleCollectable(); } static nsDOMAttributeMap* Downcast(nsISupports* s) { return static_cast<nsDOMAttributeMap*>(static_cast<nsDOMAttributeMap*>(s)); } static nsISupports* Upcast(nsDOMAttributeMap *p) { return static_cast<nsISupports*>(static_cast<nsDOMAttributeMap*>(p)); } template<typename T> friend nsISupports* ToSupports(T* p, cycleCollection* dummy); virtual void Unlink(void *p) override; virtual void Trace(void *p, const TraceCallbacks &cb, void *closure) override; virtual bool CanSkipReal(void *p, bool aRemovingAllowed) override; virtual bool CanSkipInCCReal(void *p) override; virtual bool CanSkipThisReal(void *p) override; static constexpr nsXPCOMCycleCollectionParticipant* GetParticipant() { return &nsDOMAttributeMap::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;


  virtual nsresult GetNamedItem(const nsAString & name, nsIDOMAttr * *_retval) override; virtual nsresult SetNamedItem(nsIDOMAttr *arg, nsIDOMAttr * *_retval) override; virtual nsresult RemoveNamedItem(const nsAString & name, nsIDOMAttr * *_retval) override; virtual nsresult Item(uint32_t index, nsIDOMAttr * *_retval) override; virtual nsresult GetLength(uint32_t *aLength) override; virtual nsresult GetNamedItemNS(const nsAString & namespaceURI, const nsAString & localName, nsIDOMAttr * *_retval) override; virtual nsresult SetNamedItemNS(nsIDOMAttr *arg, nsIDOMAttr * *_retval) override; virtual nsresult RemoveNamedItemNS(const nsAString & namespaceURI, const nsAString & localName, nsIDOMAttr * *_retval) override;

  void DropReference();

  Element* GetContent()
  {
    return mContent;
  }





  nsresult SetOwnerDocument(nsIDocument* aDocument);





  void DropAttribute(int32_t aNamespaceID, nsIAtom* aLocalName);
  uint32_t Count() const;

  typedef nsRefPtrHashtable<nsAttrHashKey, Attr> AttrCache;

  static void BlastSubtreeToPieces(nsINode *aNode);

  Element* GetParentObject() const
  {
    return mContent;
  }
  virtual JSObject* WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;


  Attr* GetNamedItem(const nsAString& aAttrName);
  Attr* NamedGetter(const nsAString& aAttrName, bool& aFound);
  already_AddRefed<Attr>
  RemoveNamedItem(mozilla::dom::NodeInfo* aNodeInfo, ErrorResult& aError);
  already_AddRefed<Attr>
  RemoveNamedItem(const nsAString& aName, ErrorResult& aError);

  Attr* Item(uint32_t aIndex);
  Attr* IndexedGetter(uint32_t aIndex, bool& aFound);
  uint32_t Length() const;

  Attr*
  GetNamedItemNS(const nsAString& aNamespaceURI,
                 const nsAString& aLocalName);
  already_AddRefed<Attr>
  SetNamedItemNS(Attr& aNode, ErrorResult& aError);
  already_AddRefed<Attr>
  RemoveNamedItemNS(const nsAString& aNamespaceURI, const nsAString& aLocalName,
                    ErrorResult& aError);

  void
  GetSupportedNames(nsTArray<nsString>& aNames);

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

protected:
  virtual ~nsDOMAttributeMap();

private:
  nsCOMPtr<Element> mContent;




  AttrCache mAttributeCache;

  already_AddRefed<mozilla::dom::NodeInfo>
  GetAttrNodeInfo(const nsAString& aNamespaceURI,
                  const nsAString& aLocalName);

  Attr* GetAttribute(mozilla::dom::NodeInfo* aNodeInfo);
};





namespace mozilla {
namespace detail {
const MozRefCountType DEAD = 0xffffdead;
enum RefCountAtomicity
{
  AtomicRefCount,
  NonAtomicRefCount
};

template<typename T, RefCountAtomicity Atomicity>
class RefCounted
{
protected:
  RefCounted() : mRefCnt(0) {}
  ~RefCounted() { do { } while (0); }

public:

  void AddRef() const
  {

    do { } while (0);

    ++mRefCnt;







  }

  void Release() const
  {

    do { } while (0);

    MozRefCountType cnt = --mRefCnt;
    if (0 == cnt) {







      delete static_cast<const T*>(this);
    }
  }


  void ref() { AddRef(); }
  void deref() { Release(); }
  MozRefCountType refCount() const { return mRefCnt; }
  bool hasOneRef() const
  {
    do { } while (0);
    return mRefCnt == 1;
  }

private:
  mutable typename Conditional<Atomicity == AtomicRefCount,
                               Atomic<MozRefCountType>,
                               MozRefCountType>::Type mRefCnt;
};
}

template<typename T>
class RefCounted : public detail::RefCounted<T, detail::NonAtomicRefCount>
{
public:
  ~RefCounted()
  {
    static_assert(IsBaseOf<RefCounted, T>::value,
                  "T must derive from RefCounted<T>");
  }
};

namespace external {
template<typename T>
class AtomicRefCounted :
  public mozilla::detail::RefCounted<T, mozilla::detail::AtomicRefCount>
{
public:
  ~AtomicRefCounted()
  {
    static_assert(IsBaseOf<AtomicRefCounted, T>::value,
                  "T must derive from AtomicRefCounted<T>");
  }
};

}

}
namespace mozilla {

template <typename T> class WeakPtr;
template <typename T> class SupportsWeakPtr;
namespace detail {



template<class T>
class WeakReference : public ::mozilla::RefCounted<WeakReference<T> >
{
public:
  explicit WeakReference(T* p) : mPtr(p)
  {
    do { } while (false);
  }

  T* get() const {
    do { } while (false);
    return mPtr;
  }
private:
  friend class mozilla::SupportsWeakPtr<T>;

  void detach() {
    do { } while (false);
    mPtr = nullptr;
  }

  T* mPtr;

};

}

template <typename T>
class SupportsWeakPtr
{
protected:
  ~SupportsWeakPtr()
  {
    static_assert(IsBaseOf<SupportsWeakPtr<T>, T>::value,
                  "T must derive from SupportsWeakPtr<T>");
    if (mSelfReferencingWeakPtr) {
      mSelfReferencingWeakPtr.mRef->detach();
    }
  }

private:
  const WeakPtr<T>& SelfReferencingWeakPtr()
  {
    if (!mSelfReferencingWeakPtr) {
      mSelfReferencingWeakPtr.mRef = new detail::WeakReference<T>(static_cast<T*>(this));
    } else {
      do { } while (false);
    }
    return mSelfReferencingWeakPtr;
  }

  const WeakPtr<const T>& SelfReferencingWeakPtr() const
  {
    const WeakPtr<T>& p = const_cast<SupportsWeakPtr*>(this)->SelfReferencingWeakPtr();
    return reinterpret_cast<const WeakPtr<const T>&>(p);
  }

  friend class WeakPtr<T>;
  friend class WeakPtr<const T>;

  WeakPtr<T> mSelfReferencingWeakPtr;
};

template <typename T>
class WeakPtr
{
  typedef detail::WeakReference<T> WeakReference;

public:
  WeakPtr& operator=(const WeakPtr& aOther)
  {
    mRef = aOther.mRef;
    do { } while (false);
    return *this;
  }

  WeakPtr(const WeakPtr& aOther)
  {

    *this = aOther;
  }

  WeakPtr& operator=(T* aOther)
  {
    if (aOther) {
      *this = aOther->SelfReferencingWeakPtr();
    } else if (!mRef || mRef->get()) {

      mRef = new WeakReference(nullptr);
    }


    return *this;
  }

               WeakPtr(T* aOther)
  {
    *this = aOther;
    do { } while (false);
  }


  WeakPtr() : mRef(new WeakReference(nullptr)) {}

  operator T*() const { return mRef->get(); }
  T& operator*() const { return *mRef->get(); }

  T* operator->() const { return mRef->get(); }

  T* get() const { return mRef->get(); }

private:
  friend class SupportsWeakPtr<T>;

  explicit WeakPtr(const RefPtr<WeakReference>& aOther) : mRef(aOther) {}

  RefPtr<WeakReference> mRef;
};

}



class nsQueryFrame
{
public:
  enum FrameIID {






BRFrame_id,
DetailsFrame_id,
nsAutoRepeatBoxFrame_id,
nsBCTableCellFrame_id,
nsBackdropFrame_id,
nsBlockFrame_id,
nsBox_id,
nsBoxFrame_id,
nsBulletFrame_id,
nsButtonBoxFrame_id,
nsCanvasFrame_id,
nsColorControlFrame_id,
nsColumnSetFrame_id,
nsComboboxControlFrame_id,
nsComboboxDisplayFrame_id,
nsContainerFrame_id,
nsContinuingTextFrame_id,
nsDateTimeControlFrame_id,
nsDeckFrame_id,
nsDocElementBoxFrame_id,
nsFieldSetFrame_id,
nsFileControlFrame_id,
nsFirstLetterFrame_id,
nsFirstLineFrame_id,
nsFlexContainerFrame_id,
nsFormControlFrame_id,
nsFrame_id,
nsGfxButtonControlFrame_id,
nsGfxCheckboxControlFrame_id,
nsGfxRadioControlFrame_id,
nsGridContainerFrame_id,
nsGridRowGroupFrame_id,
nsGridRowLeafFrame_id,
nsGroupBoxFrame_id,
nsHTMLButtonControlFrame_id,
nsHTMLCanvasFrame_id,
nsHTMLFramesetBlankFrame_id,
nsHTMLFramesetBorderFrame_id,
nsHTMLFramesetFrame_id,
nsHTMLScrollFrame_id,
nsIAnonymousContentCreator_id,
nsIComboboxControlFrame_id,
nsIFormControlFrame_id,
nsIFrame_id,
nsIFrameFrame_id,
nsIListControlFrame_id,
nsIMathMLFrame_id,
nsIMenuFrame_id,
nsIObjectFrame_id,
nsIPageSequenceFrame_id,
nsIPercentBSizeObserver_id,
nsIRootBox_id,
nsSVGDisplayableFrame_id,
nsISVGSVGFrame_id,
nsIScrollableFrame_id,
nsIScrollbarMediator_id,
nsISelectControlFrame_id,
nsIStatefulFrame_id,
nsITableCellLayout_id,
nsITableLayout_id,
nsITextControlFrame_id,
nsITreeBoxObject_id,
nsImageBoxFrame_id,
nsImageControlFrame_id,
nsImageFrame_id,
nsInlineFrame_id,
nsLeafBoxFrame_id,
nsLeafFrame_id,
nsLegendFrame_id,
nsListBoxBodyFrame_id,
nsListControlFrame_id,
nsListItemFrame_id,
nsMathMLContainerFrame_id,
nsMathMLFrame_id,
nsMathMLmactionFrame_id,
nsMathMLmathBlockFrame_id,
nsMathMLmathInlineFrame_id,
nsMathMLmencloseFrame_id,
nsMathMLmfencedFrame_id,
nsMathMLmfracFrame_id,
nsMathMLmmultiscriptsFrame_id,
nsMathMLmoFrame_id,
nsMathMLmoverFrame_id,
nsMathMLmpaddedFrame_id,
nsMathMLmrootFrame_id,
nsMathMLmrowFrame_id,
nsMathMLmspaceFrame_id,
nsMathMLmsqrtFrame_id,
nsMathMLmstyleFrame_id,
nsMathMLmtableFrame_id,
nsMathMLmtableWrapperFrame_id,
nsMathMLmtdFrame_id,
nsMathMLmtdInnerFrame_id,
nsMathMLmtrFrame_id,
nsMathMLmunderFrame_id,
nsMathMLmunderoverFrame_id,
nsMathMLsemanticsFrame_id,
nsMathMLTokenFrame_id,
nsMenuBarFrame_id,
nsMenuFrame_id,
nsMenuPopupFrame_id,
nsMeterFrame_id,
nsNumberControlFrame_id,
nsPluginFrame_id,
nsPageBreakFrame_id,
nsPageContentFrame_id,
nsPageFrame_id,
nsPlaceholderFrame_id,
nsPopupSetFrame_id,
nsProgressFrame_id,
nsProgressMeterFrame_id,
nsRangeFrame_id,
nsResizerFrame_id,
nsRootBoxFrame_id,
nsRubyBaseContainerFrame_id,
nsRubyBaseFrame_id,
nsRubyContentFrame_id,
nsRubyFrame_id,
nsRubyTextContainerFrame_id,
nsRubyTextFrame_id,
nsScrollbarButtonFrame_id,
nsScrollbarFrame_id,
nsSelectsAreaFrame_id,
nsSimplePageSequenceFrame_id,
nsSliderFrame_id,
nsSplittableFrame_id,
nsSplitterFrame_id,
nsStackFrame_id,
nsSubDocumentFrame_id,
nsSVGAFrame_id,
nsSVGClipPathFrame_id,
nsSVGContainerFrame_id,
nsSVGDisplayContainerFrame_id,
SVGFEContainerFrame_id,
SVGFEImageFrame_id,
SVGFELeafFrame_id,
SVGFEUnstyledLeafFrame_id,
nsSVGFilterFrame_id,
nsSVGForeignObjectFrame_id,
nsSVGGenericContainerFrame_id,
nsSVGGFrame_id,
nsSVGGradientFrame_id,
nsSVGImageFrame_id,
nsSVGInnerSVGFrame_id,
nsSVGLinearGradientFrame_id,
nsSVGMarkerFrame_id,
nsSVGMarkerAnonChildFrame_id,
nsSVGMaskFrame_id,
nsSVGOuterSVGFrame_id,
nsSVGOuterSVGAnonChildFrame_id,
nsSVGPaintServerFrame_id,
SVGGeometryFrame_id,
nsSVGPatternFrame_id,
nsSVGRadialGradientFrame_id,
nsSVGStopFrame_id,
nsSVGSwitchFrame_id,
SVGTextFrame_id,
nsSVGUseFrame_id,
SVGViewFrame_id,
nsTableCellFrame_id,
nsTableColFrame_id,
nsTableColGroupFrame_id,
nsTableFrame_id,
nsTableWrapperFrame_id,
nsTableRowFrame_id,
nsTableRowGroupFrame_id,
nsTextBoxFrame_id,
nsTextControlFrame_id,
nsTextFrame_id,
nsTitleBarFrame_id,
nsTreeBodyFrame_id,
nsTreeColFrame_id,
nsVideoFrame_id,
nsXULLabelFrame_id,
nsXULScrollFrame_id,
ViewportFrame_id,








    NON_FRAME_MARKER = 0x20000000
  };

  virtual void* QueryFrame(FrameIID id) = 0;
};

class do_QueryFrame
{
public:
  explicit do_QueryFrame(nsQueryFrame *s) : mRawPtr(s) { }



  typedef void (do_QueryFrame::* MatchNullptr)(double, float);

               do_QueryFrame(MatchNullptr aRawPtr) : mRawPtr(nullptr) {}

  template<class Dest>
  operator Dest*() {
    static_assert(mozilla::IsSame<Dest, typename Dest::Has_NS_DECL_QUERYFRAME_TARGET>::value,
                  "Dest must declare itself as a queryframe target");
    if (!mRawPtr)
      return nullptr;

    return reinterpret_cast<Dest*>(mRawPtr->QueryFrame(Dest::kFrameIID));
  }

private:
  nsQueryFrame *mRawPtr;
};

namespace mozilla {

enum ArenaObjectID {
  eArenaObjectID_DummyBeforeFirstObjectID = nsQueryFrame::NON_FRAME_MARKER - 1,




eArenaObjectID_nsLineBox,
eArenaObjectID_nsRuleNode,
eArenaObjectID_nsStyleContext,
eArenaObjectID_nsInheritedStyleData,
eArenaObjectID_nsResetStyleData,
eArenaObjectID_nsConditionalResetStyleData,
eArenaObjectID_nsConditionalResetStyleDataEntry,
eArenaObjectID_nsFrameList,
eArenaObjectID_CustomCounterStyle,
eArenaObjectID_DependentBuiltinCounterStyle,




eArenaObjectID_nsStyleFont,



eArenaObjectID_nsStyleColor,


eArenaObjectID_nsStyleList,




eArenaObjectID_nsStyleText,





eArenaObjectID_nsStyleVisibility,


eArenaObjectID_nsStyleUserInterface,


eArenaObjectID_nsStyleTableBorder,




eArenaObjectID_nsStyleSVG,





eArenaObjectID_nsStyleVariables,

eArenaObjectID_nsStyleBackground,





eArenaObjectID_nsStylePosition,




eArenaObjectID_nsStyleTextReset,





eArenaObjectID_nsStyleDisplay,




eArenaObjectID_nsStyleContent,




eArenaObjectID_nsStyleUIReset,


eArenaObjectID_nsStyleTable,


eArenaObjectID_nsStyleMargin,




eArenaObjectID_nsStylePadding,




eArenaObjectID_nsStyleBorder,





eArenaObjectID_nsStyleOutline,





eArenaObjectID_nsStyleXUL,


eArenaObjectID_nsStyleSVGReset,





eArenaObjectID_nsStyleColumn,





eArenaObjectID_nsStyleEffects,
  eArenaObjectID_NON_OBJECT_MARKER = 0x40000000
};

};



namespace mozilla {
template<class T>
class StaticAutoPtr
{
public:
  StaticAutoPtr<T>& operator=(T* aRhs)
  {
    Assign(aRhs);
    return *this;
  }

  T* get() const { return mRawPtr; }

  operator T*() const { return get(); }

  T* operator->() const
  {
    do { } while (0);
    return get();
  }

  T& operator*() const { return *get(); }

private:
  void Assign(T* aNewPtr)
  {
    do { } while (0);
    T* oldPtr = mRawPtr;
    mRawPtr = aNewPtr;
    delete oldPtr;
  }

  T* mRawPtr;
};

template<class T>
class StaticRefPtr
{
public:
  StaticRefPtr<T>& operator=(T* aRhs)
  {
    AssignWithAddref(aRhs);
    return *this;
  }

  StaticRefPtr<T>& operator=(const StaticRefPtr<T>& aRhs)
  {
    return (this = aRhs.mRawPtr);
  }

  StaticRefPtr<T>& operator=(already_AddRefed<T>& aRhs)
  {
    AssignAssumingAddRef(aRhs.take());
    return *this;
  }

  StaticRefPtr<T>& operator=(already_AddRefed<T>&& aRhs)
  {
    AssignAssumingAddRef(aRhs.take());
    return *this;
  }

  already_AddRefed<T>
  forget()
  {
    T* temp = mRawPtr;
    mRawPtr = nullptr;
    return already_AddRefed<T>(temp);
  }

  T* get() const { return mRawPtr; }

  operator T*() const { return get(); }

  T* operator->() const
  {
    do { } while (0);
    return get();
  }

  T& operator*() const { return *get(); }

private:
  void AssignWithAddref(T* aNewPtr)
  {
    if (aNewPtr) {
      aNewPtr->AddRef();
    }
    AssignAssumingAddRef(aNewPtr);
  }

  void AssignAssumingAddRef(T* aNewPtr)
  {
    T* oldPtr = mRawPtr;
    mRawPtr = aNewPtr;
    if (oldPtr) {
      oldPtr->Release();
    }
  }

  T* mRawPtr;
};

namespace StaticPtr_internal {
class Zero;
}
template<class T, class U>
inline bool
operator==(const StaticAutoPtr<T>& aLhs, const StaticAutoPtr<U>& aRhs)
{
  return aLhs.get() == aRhs.get();
}

template<class T, class U>
inline bool
operator!=(const StaticAutoPtr<T>& aLhs, const StaticAutoPtr<U>& aRhs)
{
  return !(aLhs == aRhs);
}

template<class T, class U> inline bool operator==(const StaticAutoPtr<T>& lhs, const U* rhs) { return lhs.get() == rhs; } template<class T, class U> inline bool operator==(const U* lhs, const StaticAutoPtr<T>& rhs) { return rhs == lhs; } template<class T, class U> inline bool operator!=(const StaticAutoPtr<T>& lhs, const U* rhs) { return !(lhs == rhs); } template<class T, class U> inline bool operator!=(const U* lhs, const StaticAutoPtr<T>& rhs) { return !(lhs == rhs); }


template<class T, class U> inline bool operator==(const StaticAutoPtr<T>& lhs, U* rhs) { return lhs.get() == rhs; } template<class T, class U> inline bool operator==(U* lhs, const StaticAutoPtr<T>& rhs) { return rhs == lhs; } template<class T, class U> inline bool operator!=(const StaticAutoPtr<T>& lhs, U* rhs) { return !(lhs == rhs); } template<class T, class U> inline bool operator!=(U* lhs, const StaticAutoPtr<T>& rhs) { return !(lhs == rhs); }



template<class T> inline bool operator==(const StaticAutoPtr<T>& lhs, StaticPtr_internal::Zero* rhs) { return lhs.get() == nullptr; } template<class T> inline bool operator==(StaticPtr_internal::Zero* lhs, const StaticAutoPtr<T>& rhs) { return rhs == lhs; } template<class T> inline bool operator!=(const StaticAutoPtr<T>& lhs, StaticPtr_internal::Zero* rhs) { return !(lhs == rhs); } template<class T> inline bool operator!=(StaticPtr_internal::Zero* lhs, const StaticAutoPtr<T>& rhs) { return !(lhs == rhs); }




template<class T, class U>
inline bool
operator==(const StaticRefPtr<T>& aLhs, const StaticRefPtr<U>& aRhs)
{
  return aLhs.get() == aRhs.get();
}

template<class T, class U>
inline bool
operator!=(const StaticRefPtr<T>& aLhs, const StaticRefPtr<U>& aRhs)
{
  return !(aLhs == aRhs);
}

template<class T, class U> inline bool operator==(const StaticRefPtr<T>& lhs, const U* rhs) { return lhs.get() == rhs; } template<class T, class U> inline bool operator==(const U* lhs, const StaticRefPtr<T>& rhs) { return rhs == lhs; } template<class T, class U> inline bool operator!=(const StaticRefPtr<T>& lhs, const U* rhs) { return !(lhs == rhs); } template<class T, class U> inline bool operator!=(const U* lhs, const StaticRefPtr<T>& rhs) { return !(lhs == rhs); }


template<class T, class U> inline bool operator==(const StaticRefPtr<T>& lhs, U* rhs) { return lhs.get() == rhs; } template<class T, class U> inline bool operator==(U* lhs, const StaticRefPtr<T>& rhs) { return rhs == lhs; } template<class T, class U> inline bool operator!=(const StaticRefPtr<T>& lhs, U* rhs) { return !(lhs == rhs); } template<class T, class U> inline bool operator!=(U* lhs, const StaticRefPtr<T>& rhs) { return !(lhs == rhs); }



template<class T> inline bool operator==(const StaticRefPtr<T>& lhs, StaticPtr_internal::Zero* rhs) { return lhs.get() == nullptr; } template<class T> inline bool operator==(StaticPtr_internal::Zero* lhs, const StaticRefPtr<T>& rhs) { return rhs == lhs; } template<class T> inline bool operator!=(const StaticRefPtr<T>& lhs, StaticPtr_internal::Zero* rhs) { return !(lhs == rhs); } template<class T> inline bool operator!=(StaticPtr_internal::Zero* lhs, const StaticRefPtr<T>& rhs) { return !(lhs == rhs); }




}


template<class T> template<class U>
RefPtr<T>::RefPtr(const mozilla::StaticRefPtr<U>& aOther)
  : RefPtr(aOther.get())
{}

template<class T> template<class U>
RefPtr<T>&
RefPtr<T>::operator=(const mozilla::StaticRefPtr<U>& aOther)
{
  return operator=(aOther.get());
}
namespace mozilla {






enum class SheetType : uint8_t {
  Agent,
  User,
  PresHint,
  Doc,
  ScopedDoc,
  StyleAttr,
  Override,
  Animation,
  Transition,

  Count,
  Unknown = 0xff
};

}
namespace mozilla {




enum class StyleBackendType : uint8_t
{
  None,
  Gecko,
  Servo
};

}
namespace mozilla {

class StyleSheet;
struct StyleSheetAtoms;

namespace dom {

struct NativePropertyHooks;
class ProtoAndIfaceCache;

}

}

namespace mozilla {
namespace dom {

enum class CSSStyleSheetParsingMode : uint8_t {
  Author,
  User,
  Agent,
  EndGuard_
};

namespace CSSStyleSheetParsingModeValues {
extern const EnumEntry strings[4];
}

bool
ToJSValue(JSContext* aCx, CSSStyleSheetParsingMode aArgument, JS::MutableHandle<JS::Value> aValue);


namespace CSSStyleSheetBinding {

  typedef mozilla::StyleSheet NativeType;

  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::StyleSheet* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetProtoObjectHandle(JSContext* aCx);

  JS::Handle<JSObject*>
  GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true);

  JSObject*
  GetConstructorObject(JSContext* aCx);

}



}
}








class nsILoadGroup;

typedef uint32_t nsLoadFlags;
class nsIRequest : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetName(nsACString & aName) = 0;


  virtual nsresult IsPending(bool *_retval) = 0;


  virtual nsresult GetStatus(nsresult *aStatus) = 0;


  virtual nsresult Cancel(nsresult aStatus) = 0;


  virtual nsresult Suspend(void) = 0;


  virtual nsresult Resume(void) = 0;


  virtual nsresult GetLoadGroup(nsILoadGroup * *aLoadGroup) = 0;
  virtual nsresult SetLoadGroup(nsILoadGroup *aLoadGroup) = 0;


  virtual nsresult GetLoadFlags(nsLoadFlags *aLoadFlags) = 0;
  virtual nsresult SetLoadFlags(nsLoadFlags aLoadFlags) = 0;

  enum {
    LOAD_REQUESTMASK = 65535U,
    LOAD_NORMAL = 0U,
    LOAD_BACKGROUND = 1U,
    LOAD_HTML_OBJECT_DATA = 2U,
    INHIBIT_CACHING = 128U,
    INHIBIT_PERSISTENT_CACHING = 256U,
    LOAD_BYPASS_CACHE = 512U,
    LOAD_FROM_CACHE = 1024U,
    VALIDATE_ALWAYS = 2048U,
    VALIDATE_NEVER = 4096U,
    VALIDATE_ONCE_PER_SESSION = 8192U,
    LOAD_ANONYMOUS = 16384U,
    LOAD_FRESH_CONNECTION = 32768U
  };

};

  template<typename T> struct nsIRequest::COMTypeInfo<nsIRequest, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIRequest::COMTypeInfo<nsIRequest, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xef6bfbd2, 0xfd46, 0x48d8, { 0x96, 0xb7, 0x9f, 0x8f, 0x0f, 0xd3, 0x87, 0xfe }};



class nsIURI;

class nsIDOMNode;

class nsIPrincipal;

typedef uint32_t nsContentPolicyType;
class nsIContentPolicyBase : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    TYPE_INVALID = 0U,
    TYPE_OTHER = 1U,
    TYPE_SCRIPT = 2U,
    TYPE_IMAGE = 3U,
    TYPE_STYLESHEET = 4U,
    TYPE_OBJECT = 5U,
    TYPE_DOCUMENT = 6U,
    TYPE_SUBDOCUMENT = 7U,
    TYPE_REFRESH = 8U,
    TYPE_XBL = 9U,
    TYPE_PING = 10U,
    TYPE_XMLHTTPREQUEST = 11U,
    TYPE_DATAREQUEST = 11U,
    TYPE_OBJECT_SUBREQUEST = 12U,
    TYPE_DTD = 13U,
    TYPE_FONT = 14U,
    TYPE_MEDIA = 15U,
    TYPE_WEBSOCKET = 16U,
    TYPE_CSP_REPORT = 17U,
    TYPE_XSLT = 18U,
    TYPE_BEACON = 19U,
    TYPE_FETCH = 20U,
    TYPE_IMAGESET = 21U,
    TYPE_WEB_MANIFEST = 22U,
    TYPE_INTERNAL_SCRIPT = 23U,
    TYPE_INTERNAL_WORKER = 24U,
    TYPE_INTERNAL_SHARED_WORKER = 25U,
    TYPE_INTERNAL_EMBED = 26U,
    TYPE_INTERNAL_OBJECT = 27U,
    TYPE_INTERNAL_FRAME = 28U,
    TYPE_INTERNAL_IFRAME = 29U,
    TYPE_INTERNAL_AUDIO = 30U,
    TYPE_INTERNAL_VIDEO = 31U,
    TYPE_INTERNAL_TRACK = 32U,
    TYPE_INTERNAL_XMLHTTPREQUEST = 33U,
    TYPE_INTERNAL_EVENTSOURCE = 34U,
    TYPE_INTERNAL_SERVICE_WORKER = 35U,
    TYPE_INTERNAL_SCRIPT_PRELOAD = 36U,
    TYPE_INTERNAL_IMAGE = 37U,
    TYPE_INTERNAL_IMAGE_PRELOAD = 38U,
    TYPE_INTERNAL_STYLESHEET = 39U,
    TYPE_INTERNAL_STYLESHEET_PRELOAD = 40U,
    TYPE_INTERNAL_IMAGE_FAVICON = 41U,
    TYPE_INTERNAL_WORKER_IMPORT_SCRIPTS = 42U,
    REJECT_REQUEST = -1,
    REJECT_TYPE = -2,
    REJECT_SERVER = -3,
    REJECT_OTHER = -4,
    ACCEPT = 1
  };

};

  template<typename T> struct nsIContentPolicyBase::COMTypeInfo<nsIContentPolicyBase, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIContentPolicyBase::COMTypeInfo<nsIContentPolicyBase, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x17418187, 0xd86f, 0x48dd, { 0x92, 0xd1, 0x23, 0x88, 0x38, 0xdf, 0x0a, 0x4e }};






class nsIURI;

class nsIDOMNode;

class nsIPrincipal;
class nsIContentPolicy : public nsIContentPolicyBase {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult ShouldLoad(nsContentPolicyType aContentType, nsIURI *aContentLocation, nsIURI *aRequestOrigin, nsISupports *aContext, const nsACString & aMimeTypeGuess, nsISupports *aExtra, nsIPrincipal *aRequestPrincipal, int16_t *_retval) = 0;


  virtual nsresult ShouldProcess(nsContentPolicyType aContentType, nsIURI *aContentLocation, nsIURI *aRequestOrigin, nsISupports *aContext, const nsACString & aMimeType, nsISupports *aExtra, nsIPrincipal *aRequestPrincipal, int16_t *_retval) = 0;

};

  template<typename T> struct nsIContentPolicy::COMTypeInfo<nsIContentPolicy, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIContentPolicy::COMTypeInfo<nsIContentPolicy, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xcaad4f1f, 0xd047, 0x46ac, { 0xae, 0x9d, 0xdc, 0x59, 0x8e, 0x4f, 0xb9, 0x1b }};
class nsIDOMDocument;

class nsINode;

class nsIPrincipal;











namespace mozilla {
template<typename T>
class RangedPtr
{
  T* mPtr;






  void checkSanity()
  {
    do { } while (0);
    do { } while (0);
  }


  RangedPtr<T> create(T* aPtr) const
  {



    return RangedPtr<T>(aPtr, nullptr, size_t(0));

  }

  uintptr_t asUintptr() const { return reinterpret_cast<uintptr_t>(mPtr); }

public:
  RangedPtr(T* aPtr, T* aStart, T* aEnd)
    : mPtr(aPtr)



  {
    do { } while (0);
    checkSanity();
  }
  RangedPtr(T* aPtr, T* aStart, size_t aLength)
    : mPtr(aPtr)



  {
    do { } while (0);
    do { } while (0);

    checkSanity();
  }


  RangedPtr(T* aPtr, size_t aLength)
    : mPtr(aPtr)



  {
    do { } while (0);
    do { } while (0);

    checkSanity();
  }


  template<size_t N>
  explicit RangedPtr(T (&aArr)[N])
    : mPtr(aArr)



  {
    checkSanity();
  }

  T* get() const { return mPtr; }

  explicit operator bool() const { return mPtr != nullptr; }

  void checkIdenticalRange(const RangedPtr<T>& aOther) const
  {
    do { } while (0);
    do { } while (0);
  }
  RangedPtr<T>& operator=(const RangedPtr<T>& aOther)
  {
    checkIdenticalRange(aOther);
    mPtr = aOther.mPtr;
    checkSanity();
    return *this;
  }

  RangedPtr<T> operator+(size_t aInc) const
  {
    do { } while (0);
    do { } while (0);
    return create(mPtr + aInc);
  }

  RangedPtr<T> operator-(size_t aDec) const
  {
    do { } while (0);
    do { } while (0);
    return create(mPtr - aDec);
  }





  template <typename U>
  RangedPtr<T>& operator=(U* aPtr)
  {
    *this = create(aPtr);
    return *this;
  }

  template <typename U>
  RangedPtr<T>& operator=(const RangedPtr<U>& aPtr)
  {
    do { } while (0);
    do { } while (0);
    mPtr = aPtr.mPtr;
    checkSanity();
    return *this;
  }

  RangedPtr<T>& operator++()
  {
    return (*this += 1);
  }

  RangedPtr<T> operator++(int)
  {
    RangedPtr<T> rcp = *this;
    ++*this;
    return rcp;
  }

  RangedPtr<T>& operator--()
  {
    return (*this -= 1);
  }

  RangedPtr<T> operator--(int)
  {
    RangedPtr<T> rcp = *this;
    --*this;
    return rcp;
  }

  RangedPtr<T>& operator+=(size_t aInc)
  {
    *this = *this + aInc;
    return *this;
  }

  RangedPtr<T>& operator-=(size_t aDec)
  {
    *this = *this - aDec;
    return *this;
  }

  T& operator[](int aIndex) const
  {
    do { } while (0);
    return *create(mPtr + aIndex);
  }

  T& operator*() const
  {
    do { } while (0);
    do { } while (0);
    return *mPtr;
  }

  T* operator->() const
  {
    do { } while (0);
    do { } while (0);
    return mPtr;
  }

  template <typename U>
  bool operator==(const RangedPtr<U>& aOther) const
  {
    return mPtr == aOther.mPtr;
  }
  template <typename U>
  bool operator!=(const RangedPtr<U>& aOther) const
  {
    return !(*this == aOther);
  }

  template<typename U>
  bool operator==(const U* u) const
  {
    return mPtr == u;
  }
  template<typename U>
  bool operator!=(const U* u) const
  {
    return !(*this == u);
  }

  template <typename U>
  bool operator<(const RangedPtr<U>& aOther) const
  {
    return mPtr < aOther.mPtr;
  }
  template <typename U>
  bool operator<=(const RangedPtr<U>& aOther) const
  {
    return mPtr <= aOther.mPtr;
  }

  template <typename U>
  bool operator>(const RangedPtr<U>& aOther) const
  {
    return mPtr > aOther.mPtr;
  }
  template <typename U>
  bool operator>=(const RangedPtr<U>& aOther) const
  {
    return mPtr >= aOther.mPtr;
  }

  size_t operator-(const RangedPtr<T>& aOther) const
  {
    do { } while (0);
    return PointerRangeSize(aOther.mPtr, mPtr);
  }

private:
  RangedPtr() = delete;
};

}




namespace mozilla {


template <typename T>
class Range
{
  const RangedPtr<T> mStart;
  const RangedPtr<T> mEnd;

public:
  Range() : mStart(nullptr, 0), mEnd(nullptr, 0) {}
  Range(T* aPtr, size_t aLength)
    : mStart(aPtr, aPtr, aPtr + aLength),
      mEnd(aPtr + aLength, aPtr, aPtr + aLength)
  {}
  Range(const RangedPtr<T>& aStart, const RangedPtr<T>& aEnd)
    : mStart(aStart.get(), aStart.get(), aEnd.get()),
      mEnd(aEnd.get(), aStart.get(), aEnd.get())
  {

    aStart.checkIdenticalRange(aEnd);
    do { } while (0);
  }

  template<typename U,
           class = typename EnableIf<IsConvertible<U (*)[], T (*)[]>::value,
                                     int>::Type>
               Range(const Range<U>& aOther)
    : mStart(aOther.mStart),
      mEnd(aOther.mEnd)
  {}

               Range(Span<T> aSpan)
    : Range(aSpan.Elements(), aSpan.Length())
  {
  }

  template<typename U,
           class = typename EnableIf<IsConvertible<U (*)[], T (*)[]>::value,
                                     int>::Type>
               Range(const Span<U>& aSpan)
    : Range(aSpan.Elements(), aSpan.Length())
  {
  }

  RangedPtr<T> begin() const { return mStart; }
  RangedPtr<T> end() const { return mEnd; }
  size_t length() const { return mEnd - mStart; }

  T& operator[](size_t aOffset) const { return mStart[aOffset]; }

  explicit operator bool() const { return mStart != nullptr; }

  operator Span<T>() { return Span<T>(mStart.get(), length()); }

  operator Span<const T>() const { return Span<T>(mStart.get(), length()); }
};

template<class T>
Span<T>
MakeSpan(Range<T>& aRange)
{
  return aRange;
}

template<class T>
Span<const T>
MakeSpan(const Range<T>& aRange)
{
  return aRange;
}

}











typedef bool
(* JSNative)(JSContext* cx, unsigned argc, JS::Value* vp);

namespace JS {

extern const HandleValue UndefinedHandleValue;

namespace detail {





extern Value
ComputeThis(JSContext* cx, JS::Value* vp);


extern void
CheckIsValidConstructible(const Value& v);


class IncludeUsedRval
{
  protected:

    mutable bool usedRval_;
    void setUsedRval() const { usedRval_ = true; }
    void clearUsedRval() const { usedRval_ = false; }
    void assertUnusedRval() const { do { } while (0); }





};

class NoUsedRval
{
  protected:
    void setUsedRval() const {}
    void clearUsedRval() const {}
    void assertUnusedRval() const {}
};

template<class WantUsedRval>
class CallArgsBase : public WantUsedRval
{
    static_assert(mozilla::IsSame<WantUsedRval, IncludeUsedRval>::value ||
                  mozilla::IsSame<WantUsedRval, NoUsedRval>::value,
                  "WantUsedRval can only be IncludeUsedRval or NoUsedRval");

  protected:
    Value* argv_;
    unsigned argc_;
    bool constructing_:1;


    bool ignoresReturnValue_:1;

  public:






    HandleValue calleev() const {
        this->assertUnusedRval();
        return HandleValue::fromMarkedLocation(&argv_[-2]);
    }





    JSObject& callee() const {
        return calleev().toObject();
    }



    bool isConstructing() const {
        if (!argv_[-1].isMagic())
            return false;


        if (!this->usedRval_)
            CheckIsValidConstructible(calleev());


        return true;
    }

    bool ignoresReturnValue() const {
        return ignoresReturnValue_;
    }

    MutableHandleValue newTarget() const {
        do { } while (0);
        return MutableHandleValue::fromMarkedLocation(&this->argv_[argc_]);
    }







    HandleValue thisv() const {



        return HandleValue::fromMarkedLocation(&argv_[-1]);
    }

    Value computeThis(JSContext* cx) const {
        if (thisv().isObject())
            return thisv();

        return ComputeThis(cx, base());
    }




    unsigned length() const { return argc_; }


    MutableHandleValue operator[](unsigned i) const {
        do { } while (0);
        return MutableHandleValue::fromMarkedLocation(&this->argv_[i]);
    }





    HandleValue get(unsigned i) const {
        return i < length()
               ? HandleValue::fromMarkedLocation(&this->argv_[i])
               : UndefinedHandleValue;
    }





    bool hasDefined(unsigned i) const {
        return i < argc_ && !this->argv_[i].isUndefined();
    }
    MutableHandleValue rval() const {
        this->setUsedRval();
        return MutableHandleValue::fromMarkedLocation(&argv_[-2]);
    }

  public:




    void setCallee(const Value& aCalleev) const {
        this->clearUsedRval();
        argv_[-2] = aCalleev;
    }

    void setThis(const Value& aThisv) const {
        argv_[-1] = aThisv;
    }

    MutableHandleValue mutableThisv() const {
        return MutableHandleValue::fromMarkedLocation(&argv_[-1]);
    }

  public:




    Value* array() const { return argv_; }
    Value* end() const { return argv_ + argc_ + constructing_; }

  public:



    Value* base() const { return argv_ - 2; }

    Value* spAfterCall() const {
        this->setUsedRval();
        return argv_ - 1;
    }
};

}

class CallArgs : public detail::CallArgsBase<detail::IncludeUsedRval>
{
  private:
    friend CallArgs CallArgsFromVp(unsigned argc, Value* vp);
    friend CallArgs CallArgsFromSp(unsigned stackSlots, Value* sp, bool constructing,
                                   bool ignoresReturnValue);

    static CallArgs create(unsigned argc, Value* argv, bool constructing,
                           bool ignoresReturnValue = false) {
        CallArgs args;
        args.clearUsedRval();
        args.argv_ = argv;
        args.argc_ = argc;
        args.constructing_ = constructing;
        args.ignoresReturnValue_ = ignoresReturnValue;






        return args;
    }

  public:




    bool requireAtLeast(JSContext* cx, const char* fnname, unsigned required) const;

};

__attribute__((always_inline)) inline CallArgs
CallArgsFromVp(unsigned argc, Value* vp)
{
    return CallArgs::create(argc, vp + 2, vp[1].isMagic(JS_IS_CONSTRUCTING));
}




__attribute__((always_inline)) inline CallArgs
CallArgsFromSp(unsigned stackSlots, Value* sp, bool constructing = false,
               bool ignoresReturnValue = false)
{
    return CallArgs::create(stackSlots - constructing, sp - stackSlots, constructing,
                            ignoresReturnValue);
}

}
__attribute__((always_inline)) inline JS::Value
JS_THIS(JSContext* cx, JS::Value* vp)
{
    return vp[1].isPrimitive() ? JS::detail::ComputeThis(cx, vp) : vp[1];
}
class JSFlatString;

namespace JS {







class Latin1Chars : public mozilla::Range<Latin1Char>
{
    typedef mozilla::Range<Latin1Char> Base;

  public:
    using CharT = Latin1Char;

    Latin1Chars() : Base() {}
    Latin1Chars(char* aBytes, size_t aLength) : Base(reinterpret_cast<Latin1Char*>(aBytes), aLength) {}
    Latin1Chars(const Latin1Char* aBytes, size_t aLength)
      : Base(const_cast<Latin1Char*>(aBytes), aLength)
    {}
    Latin1Chars(const char* aBytes, size_t aLength)
      : Base(reinterpret_cast<Latin1Char*>(const_cast<char*>(aBytes)), aLength)
    {}
};




class Latin1CharsZ : public mozilla::RangedPtr<Latin1Char>
{
    typedef mozilla::RangedPtr<Latin1Char> Base;

  public:
    using CharT = Latin1Char;

    Latin1CharsZ() : Base(nullptr, 0) {}

    Latin1CharsZ(char* aBytes, size_t aLength)
      : Base(reinterpret_cast<Latin1Char*>(aBytes), aLength)
    {
        do { } while (0);
    }

    Latin1CharsZ(Latin1Char* aBytes, size_t aLength)
      : Base(aBytes, aLength)
    {
        do { } while (0);
    }

    using Base::operator=;

    char* c_str() { return reinterpret_cast<char*>(get()); }
};

class UTF8Chars : public mozilla::Range<unsigned char>
{
    typedef mozilla::Range<unsigned char> Base;

  public:
    using CharT = unsigned char;

    UTF8Chars() : Base() {}
    UTF8Chars(char* aBytes, size_t aLength)
      : Base(reinterpret_cast<unsigned char*>(aBytes), aLength)
    {}
    UTF8Chars(const char* aBytes, size_t aLength)
      : Base(reinterpret_cast<unsigned char*>(const_cast<char*>(aBytes)), aLength)
    {}
};




class UTF8CharsZ : public mozilla::RangedPtr<unsigned char>
{
    typedef mozilla::RangedPtr<unsigned char> Base;

  public:
    using CharT = unsigned char;

    UTF8CharsZ() : Base(nullptr, 0) {}

    UTF8CharsZ(char* aBytes, size_t aLength)
      : Base(reinterpret_cast<unsigned char*>(aBytes), aLength)
    {
        do { } while (0);
    }

    UTF8CharsZ(unsigned char* aBytes, size_t aLength)
      : Base(aBytes, aLength)
    {
        do { } while (0);
    }

    using Base::operator=;

    char* c_str() { return reinterpret_cast<char*>(get()); }
};







class ConstUTF8CharsZ
{
    const char* data_;

  public:
    using CharT = unsigned char;

    ConstUTF8CharsZ() : data_(nullptr)
    {}

    ConstUTF8CharsZ(const char* aBytes, size_t aLength)
      : data_(aBytes)
    {
        do { } while (0);



    }

    const void* get() const { return data_; }

    const char* c_str() const { return data_; }

    explicit operator bool() const { return data_ != nullptr; }

  private:



};
class TwoByteChars : public mozilla::Range<char16_t>
{
    typedef mozilla::Range<char16_t> Base;

  public:
    using CharT = char16_t;

    TwoByteChars() : Base() {}
    TwoByteChars(char16_t* aChars, size_t aLength) : Base(aChars, aLength) {}
    TwoByteChars(const char16_t* aChars, size_t aLength) : Base(const_cast<char16_t*>(aChars), aLength) {}
};




class TwoByteCharsZ : public mozilla::RangedPtr<char16_t>
{
    typedef mozilla::RangedPtr<char16_t> Base;

  public:
    using CharT = char16_t;

    TwoByteCharsZ() : Base(nullptr, 0) {}

    TwoByteCharsZ(char16_t* chars, size_t length)
      : Base(chars, length)
    {
        do { } while (0);
    }

    using Base::operator=;
};

typedef mozilla::RangedPtr<const char16_t> ConstCharPtr;




class ConstTwoByteChars : public mozilla::Range<const char16_t>
{
    typedef mozilla::Range<const char16_t> Base;

  public:
    using CharT = char16_t;

    ConstTwoByteChars() : Base() {}
    ConstTwoByteChars(const char16_t* aChars, size_t aLength) : Base(aChars, aLength) {}
};
extern Latin1CharsZ
LossyTwoByteCharsToNewLatin1CharsZ(JSContext* cx,
                                   const mozilla::Range<const char16_t> tbchars);

inline Latin1CharsZ
LossyTwoByteCharsToNewLatin1CharsZ(JSContext* cx, const char16_t* begin, size_t length)
{
    const mozilla::Range<const char16_t> tbchars(begin, length);
    return JS::LossyTwoByteCharsToNewLatin1CharsZ(cx, tbchars);
}

template <typename CharT>
extern UTF8CharsZ
CharsToNewUTF8CharsZ(JSContext* maybeCx, const mozilla::Range<CharT> chars);

uint32_t
Utf8ToOneUcs4Char(const uint8_t* utf8Buffer, int utf8Length);







extern TwoByteCharsZ
UTF8CharsToNewTwoByteCharsZ(JSContext* cx, const UTF8Chars utf8, size_t* outlen);




extern TwoByteCharsZ
UTF8CharsToNewTwoByteCharsZ(JSContext* cx, const ConstUTF8CharsZ& utf8, size_t* outlen);






extern TwoByteCharsZ
LossyUTF8CharsToNewTwoByteCharsZ(JSContext* cx, const UTF8Chars utf8, size_t* outlen);

extern TwoByteCharsZ
LossyUTF8CharsToNewTwoByteCharsZ(JSContext* cx, const ConstUTF8CharsZ& utf8, size_t* outlen);





size_t
GetDeflatedUTF8StringLength(JSFlatString* s);
void
DeflateStringToUTF8Buffer(JSFlatString* src, mozilla::RangedPtr<char> dst,
                          size_t* dstlenp = nullptr, size_t* numcharsp = nullptr);





enum class SmallestEncoding {
    ASCII,
    Latin1,
    UTF16
};






SmallestEncoding
FindSmallestEncoding(UTF8Chars utf8);







extern Latin1CharsZ
UTF8CharsToNewLatin1CharsZ(JSContext* cx, const UTF8Chars utf8, size_t* outlen);






extern Latin1CharsZ
LossyUTF8CharsToNewLatin1CharsZ(JSContext* cx, const UTF8Chars utf8, size_t* outlen);





extern bool
StringIsASCII(const char* s);

}

inline void JS_free(JS::Latin1CharsZ& ptr) { js_free((void*)ptr.get()); }
inline void JS_free(JS::UTF8CharsZ& ptr) { js_free((void*)ptr.get()); }
struct JSAtomState;
struct JSFreeOp;
struct JSFunctionSpec;

namespace js {

struct Class;
class FreeOp;
class Shape;



extern const js::Class* const FunctionClassPtr;

}

namespace JS {

class AutoIdVector;





enum class IsArrayAnswer
{
    Array,
    NotArray,
    RevokedProxy
};
extern bool
IsArray(JSContext* cx, HandleObject obj, bool* isArray);
extern bool
IsArray(JSContext* cx, HandleObject obj, IsArrayAnswer* answer);
class ObjectOpResult
{
  private:
    uintptr_t code_;

  public:
    enum SpecialCodes : uintptr_t {
        OkCode = 0,
        Uninitialized = uintptr_t(-1)
    };

    ObjectOpResult() : code_(Uninitialized) {}


    bool ok() const {
        do { } while (0);
        return code_ == OkCode;
    }

    explicit operator bool() const { return ok(); }


    bool succeed() {
        code_ = OkCode;
        return true;
    }
    bool fail(uint32_t msg) {
        do { } while (0);
        code_ = msg;
        return true;
    }

    bool failCantRedefineProp();
    bool failReadOnly();
    bool failGetterOnly();
    bool failCantDelete();

    bool failCantSetInterposed();
    bool failCantDefineWindowElement();
    bool failCantDeleteWindowElement();
    bool failCantDeleteWindowNamedProperty();
    bool failCantPreventExtensions();
    bool failCantSetProto();
    bool failNoNamedSetter();
    bool failNoIndexedSetter();

    uint32_t failureCode() const {
        do { } while (0);
        return uint32_t(code_);
    }
    bool checkStrictErrorOrWarning(JSContext* cx, HandleObject obj, HandleId id, bool strict) {
        if (ok())
            return true;
        return reportStrictErrorOrWarning(cx, obj, id, strict);
    }







    bool checkStrictErrorOrWarning(JSContext* cx, HandleObject obj, bool strict) {
        return ok() || reportStrictErrorOrWarning(cx, obj, strict);
    }


    bool reportError(JSContext* cx, HandleObject obj, HandleId id) {
        return reportStrictErrorOrWarning(cx, obj, id, true);
    }





    bool reportError(JSContext* cx, HandleObject obj) {
        return reportStrictErrorOrWarning(cx, obj, true);
    }


    bool reportStrictErrorOrWarning(JSContext* cx, HandleObject obj, HandleId id, bool strict);
    bool reportStrictErrorOrWarning(JSContext* cx, HandleObject obj, bool strict);





    bool checkStrict(JSContext* cx, HandleObject obj, HandleId id) {
        return checkStrictErrorOrWarning(cx, obj, id, true);
    }





    bool checkStrict(JSContext* cx, HandleObject obj) {
        return checkStrictErrorOrWarning(cx, obj, true);
    }
};

class PropertyResult
{
    union {
        js::Shape* shape_;
        uintptr_t bits_;
    };

    static const uintptr_t NotFound = 0;
    static const uintptr_t NonNativeProperty = 1;
    static const uintptr_t DenseOrTypedArrayElement = 1;

  public:
    PropertyResult() : bits_(NotFound) {}

    explicit PropertyResult(js::Shape* propertyShape)
      : shape_(propertyShape)
    {
        do { } while (0);
    }

    explicit operator bool() const {
        return isFound();
    }

    bool isFound() const {
        return bits_ != NotFound;
    }

    bool isNonNativeProperty() const {
        return bits_ == NonNativeProperty;
    }

    bool isDenseOrTypedArrayElement() const {
        return bits_ == DenseOrTypedArrayElement;
    }

    bool isNativeProperty() const {
        return isFound() && !isNonNativeProperty();
    }

    js::Shape* maybeShape() const {
        do { } while (0);
        return isFound() ? shape_ : nullptr;
    }

    js::Shape* shape() const {
        do { } while (0);
        return shape_;
    }

    void setNotFound() {
        bits_ = NotFound;
    }

    void setNativeProperty(js::Shape* propertyShape) {
        shape_ = propertyShape;
        do { } while (0);
    }

    void setNonNativeProperty() {
        bits_ = NonNativeProperty;
    }

    void setDenseOrTypedArrayElement() {
        bits_ = DenseOrTypedArrayElement;
    }

    void trace(JSTracer* trc);
};

}

namespace js {

template <class Wrapper>
class WrappedPtrOperations<JS::PropertyResult, Wrapper>
{
    const JS::PropertyResult& value() const { return static_cast<const Wrapper*>(this)->get(); }

  public:
    bool isFound() const { return value().isFound(); }
    explicit operator bool() const { return bool(value()); }
    js::Shape* maybeShape() const { return value().maybeShape(); }
    js::Shape* shape() const { return value().shape(); }
    bool isNativeProperty() const { return value().isNativeProperty(); }
    bool isNonNativeProperty() const { return value().isNonNativeProperty(); }
    bool isDenseOrTypedArrayElement() const { return value().isDenseOrTypedArrayElement(); }
    js::Shape* asTaggedShape() const { return value().asTaggedShape(); }
};

template <class Wrapper>
class MutableWrappedPtrOperations<JS::PropertyResult, Wrapper>
  : public WrappedPtrOperations<JS::PropertyResult, Wrapper>
{
    JS::PropertyResult& value() { return static_cast<Wrapper*>(this)->get(); }

  public:
    void setNotFound() {
        value().setNotFound();
    }
    void setNativeProperty(js::Shape* shape) {
        value().setNativeProperty(shape);
    }
    void setNonNativeProperty() {
        value().setNonNativeProperty();
    }
    void setDenseOrTypedArrayElement() {
        value().setDenseOrTypedArrayElement();
    }
};

}
typedef bool
(* JSGetterOp)(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
               JS::MutableHandleValue vp);


typedef bool
(* JSAddPropertyOp)(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleValue v);
typedef bool
(* JSSetterOp)(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
               JS::MutableHandleValue vp, JS::ObjectOpResult& result);
typedef bool
(* JSDeletePropertyOp)(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                       JS::ObjectOpResult& result);
typedef bool
(* JSNewEnumerateOp)(JSContext* cx, JS::HandleObject obj, JS::AutoIdVector& properties,
                     bool enumerableOnly);





typedef bool
(* JSEnumerateOp)(JSContext* cx, JS::HandleObject obj);






typedef JSString*
(* JSFunToStringOp)(JSContext* cx, JS::HandleObject obj, unsigned indent);
typedef bool
(* JSResolveOp)(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                bool* resolvedp);
typedef bool
(* JSMayResolveOp)(const JSAtomState& names, jsid id, JSObject* maybeObj);






typedef void
(* JSFinalizeOp)(JSFreeOp* fop, JSObject* obj);


struct JSStringFinalizer {
    void (*finalize)(JS::Zone* zone, const JSStringFinalizer* fin, char16_t* chars);
};






typedef bool
(* JSHasInstanceOp)(JSContext* cx, JS::HandleObject obj, JS::MutableHandleValue vp,
                    bool* bp);
typedef void
(* JSTraceOp)(JSTracer* trc, JSObject* obj);

typedef JSObject*
(* JSWeakmapKeyDelegateOp)(JSObject* obj);

typedef void
(* JSObjectMovedOp)(JSObject* obj, const JSObject* old);



namespace js {

typedef bool
(* LookupPropertyOp)(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                     JS::MutableHandleObject objp, JS::MutableHandle<JS::PropertyResult> propp);
typedef bool
(* DefinePropertyOp)(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                     JS::Handle<JS::PropertyDescriptor> desc,
                     JS::ObjectOpResult& result);
typedef bool
(* HasPropertyOp)(JSContext* cx, JS::HandleObject obj, JS::HandleId id, bool* foundp);
typedef bool
(* GetPropertyOp)(JSContext* cx, JS::HandleObject obj, JS::HandleValue receiver, JS::HandleId id,
                  JS::MutableHandleValue vp);
typedef bool
(* SetPropertyOp)(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleValue v,
                  JS::HandleValue receiver, JS::ObjectOpResult& result);
typedef bool
(* GetOwnPropertyOp)(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                     JS::MutableHandle<JS::PropertyDescriptor> desc);
typedef bool
(* DeletePropertyOp)(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                     JS::ObjectOpResult& result);

typedef bool
(* WatchOp)(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleObject callable);

typedef bool
(* UnwatchOp)(JSContext* cx, JS::HandleObject obj, JS::HandleId id);

class ElementAdder
{
  public:
    enum GetBehavior {


        CheckHasElemPreserveHoles,


        GetElement
    };

  private:

    JS::RootedObject resObj_;
    JS::Value* vp_;

    uint32_t index_;



    GetBehavior getBehavior_;

  public:
    ElementAdder(JSContext* cx, JSObject* obj, uint32_t length, GetBehavior behavior)
      : resObj_(cx, obj), vp_(nullptr), index_(0),



        getBehavior_(behavior)
    {}
    ElementAdder(JSContext* cx, JS::Value* vp, uint32_t length, GetBehavior behavior)
      : resObj_(cx), vp_(vp), index_(0),



        getBehavior_(behavior)
    {}

    GetBehavior getBehavior() const { return getBehavior_; }

    bool append(JSContext* cx, JS::HandleValue v);
    void appendHole();
};

typedef bool
(* GetElementsOp)(JSContext* cx, JS::HandleObject obj, uint32_t begin, uint32_t end,
                  ElementAdder* adder);

typedef void
(* FinalizeOp)(FreeOp* fop, JSObject* obj);
struct ClassOps
{

    JSAddPropertyOp addProperty;
    JSDeletePropertyOp delProperty;
    JSGetterOp getProperty;
    JSSetterOp setProperty;
    JSEnumerateOp enumerate;
    JSResolveOp resolve;
    JSMayResolveOp mayResolve;
    FinalizeOp finalize;
    JSNative call;
    JSHasInstanceOp hasInstance;
    JSNative construct;
    JSTraceOp trace;
};


typedef JSObject* (*ClassObjectCreationOp)(JSContext* cx, JSProtoKey key);


typedef bool (*FinishClassInitOp)(JSContext* cx, JS::HandleObject ctor,
                                  JS::HandleObject proto);

const size_t JSCLASS_CACHED_PROTO_WIDTH = 6;

struct ClassSpec
{
    ClassObjectCreationOp createConstructor;
    ClassObjectCreationOp createPrototype;
    const JSFunctionSpec* constructorFunctions;
    const JSPropertySpec* constructorProperties;
    const JSFunctionSpec* prototypeFunctions;
    const JSPropertySpec* prototypeProperties;
    FinishClassInitOp finishInit;
    uintptr_t flags;

    static const size_t ProtoKeyWidth = JSCLASS_CACHED_PROTO_WIDTH;

    static const uintptr_t ProtoKeyMask = (1 << ProtoKeyWidth) - 1;
    static const uintptr_t DontDefineConstructor = 1 << ProtoKeyWidth;

    bool defined() const { return !!createConstructor; }


    JSProtoKey inheritanceProtoKey() const {
        do { } while (0);
        static_assert(JSProto_Null == 0, "zeroed key must be null");


        if (!(flags & ProtoKeyMask))
            return JSProto_Object;

        return JSProtoKey(flags & ProtoKeyMask);
    }

    bool shouldDefineConstructor() const {
        do { } while (0);
        return !(flags & DontDefineConstructor);
    }
};

struct ClassExtension
{
    JSWeakmapKeyDelegateOp weakmapKeyDelegateOp;
    JSObjectMovedOp objectMovedOp;
};




struct ObjectOps
{
    LookupPropertyOp lookupProperty;
    DefinePropertyOp defineProperty;
    HasPropertyOp hasProperty;
    GetPropertyOp getProperty;
    SetPropertyOp setProperty;
    GetOwnPropertyOp getOwnPropertyDescriptor;
    DeletePropertyOp deleteProperty;
    WatchOp watch;
    UnwatchOp unwatch;
    GetElementsOp getElements;
    JSNewEnumerateOp enumerate;
    JSFunToStringOp funToString;
};



}



typedef void (*JSClassInternal)();

struct JSClassOps
{

    JSAddPropertyOp addProperty;
    JSDeletePropertyOp delProperty;
    JSGetterOp getProperty;
    JSSetterOp setProperty;
    JSEnumerateOp enumerate;
    JSResolveOp resolve;
    JSMayResolveOp mayResolve;
    JSFinalizeOp finalize;
    JSNative call;
    JSHasInstanceOp hasInstance;
    JSNative construct;
    JSTraceOp trace;
};



struct JSClass {
    const char* name; uint32_t flags; const JSClassOps* cOps; JSAddPropertyOp getAddProperty() const { return cOps ? cOps->addProperty : nullptr; } JSDeletePropertyOp getDelProperty() const { return cOps ? cOps->delProperty : nullptr; } JSGetterOp getGetProperty() const { return cOps ? cOps->getProperty : nullptr; } JSSetterOp getSetProperty() const { return cOps ? cOps->setProperty : nullptr; } JSEnumerateOp getEnumerate() const { return cOps ? cOps->enumerate : nullptr; } JSResolveOp getResolve() const { return cOps ? cOps->resolve : nullptr; } JSMayResolveOp getMayResolve() const { return cOps ? cOps->mayResolve : nullptr; } JSNative getCall() const { return cOps ? cOps->call : nullptr; } JSHasInstanceOp getHasInstance() const { return cOps ? cOps->hasInstance : nullptr; } JSNative getConstruct() const { return cOps ? cOps->construct : nullptr; } bool hasFinalize() const { return cOps && cOps->finalize; } bool hasTrace() const { return cOps && cOps->trace; } bool isTrace(JSTraceOp trace) const { return cOps && cOps->trace == trace; } void doFinalize(JSFreeOp* fop, JSObject* obj) const { do { } while (0); cOps->finalize(fop, obj); } void doTrace(JSTracer* trc, JSObject* obj) const { do { } while (0); cOps->trace(trc, obj); };

    void* reserved[3];
};
namespace js {

struct Class
{
    const char* name; uint32_t flags; const js::ClassOps* cOps; JSAddPropertyOp getAddProperty() const { return cOps ? cOps->addProperty : nullptr; } JSDeletePropertyOp getDelProperty() const { return cOps ? cOps->delProperty : nullptr; } JSGetterOp getGetProperty() const { return cOps ? cOps->getProperty : nullptr; } JSSetterOp getSetProperty() const { return cOps ? cOps->setProperty : nullptr; } JSEnumerateOp getEnumerate() const { return cOps ? cOps->enumerate : nullptr; } JSResolveOp getResolve() const { return cOps ? cOps->resolve : nullptr; } JSMayResolveOp getMayResolve() const { return cOps ? cOps->mayResolve : nullptr; } JSNative getCall() const { return cOps ? cOps->call : nullptr; } JSHasInstanceOp getHasInstance() const { return cOps ? cOps->hasInstance : nullptr; } JSNative getConstruct() const { return cOps ? cOps->construct : nullptr; } bool hasFinalize() const { return cOps && cOps->finalize; } bool hasTrace() const { return cOps && cOps->trace; } bool isTrace(JSTraceOp trace) const { return cOps && cOps->trace == trace; } void doFinalize(FreeOp* fop, JSObject* obj) const { do { } while (0); cOps->finalize(fop, obj); } void doTrace(JSTracer* trc, JSObject* obj) const { do { } while (0); cOps->trace(trc, obj); };
    const ClassSpec* spec;
    const ClassExtension* ext;
    const ObjectOps* oOps;
    static const uint32_t NON_NATIVE = (1<<((8 + 8)+2));

    bool isNative() const {
        return !(flags & NON_NATIVE);
    }

    bool hasPrivate() const {
        return !!(flags & (1<<0));
    }

    bool emulatesUndefined() const {
        return flags & (1<<6);
    }

    bool isJSFunction() const {
        return this == js::FunctionClassPtr;
    }

    bool nonProxyCallable() const {
        do { } while (0);
        return isJSFunction() || getCall();
    }

    bool isProxy() const {
        return flags & (1<<((8 + 8)+4));
    }

    bool isDOMClass() const {
        return flags & (1<<4);
    }

    bool shouldDelayMetadataBuilder() const {
        return flags & (1<<1);
    }

    bool isWrappedNative() const {
        return flags & (1<<2);
    }

    static size_t offsetOfFlags() { return __builtin_offsetof(Class, flags); }

    bool specDefined() const { return spec ? spec->defined() : false; }
    JSProtoKey specInheritanceProtoKey()
                               const { return spec ? spec->inheritanceProtoKey() : JSProto_Null; }
    bool specShouldDefineConstructor()
                               const { return spec ? spec->shouldDefineConstructor() : true; }
    ClassObjectCreationOp specCreateConstructorHook()
                               const { return spec ? spec->createConstructor : nullptr; }
    ClassObjectCreationOp specCreatePrototypeHook()
                               const { return spec ? spec->createPrototype : nullptr; }
    const JSFunctionSpec* specConstructorFunctions()
                               const { return spec ? spec->constructorFunctions : nullptr; }
    const JSPropertySpec* specConstructorProperties()
                               const { return spec ? spec->constructorProperties : nullptr; }
    const JSFunctionSpec* specPrototypeFunctions()
                               const { return spec ? spec->prototypeFunctions : nullptr; }
    const JSPropertySpec* specPrototypeProperties()
                               const { return spec ? spec->prototypeProperties : nullptr; }
    FinishClassInitOp specFinishInitHook()
                               const { return spec ? spec->finishInit : nullptr; }

    JSWeakmapKeyDelegateOp extWeakmapKeyDelegateOp()
                               const { return ext ? ext->weakmapKeyDelegateOp : nullptr; }
    JSObjectMovedOp extObjectMovedOp()
                               const { return ext ? ext->objectMovedOp : nullptr; }

    LookupPropertyOp getOpsLookupProperty() const { return oOps ? oOps->lookupProperty : nullptr; }
    DefinePropertyOp getOpsDefineProperty() const { return oOps ? oOps->defineProperty : nullptr; }
    HasPropertyOp getOpsHasProperty() const { return oOps ? oOps->hasProperty : nullptr; }
    GetPropertyOp getOpsGetProperty() const { return oOps ? oOps->getProperty : nullptr; }
    SetPropertyOp getOpsSetProperty() const { return oOps ? oOps->setProperty : nullptr; }
    GetOwnPropertyOp getOpsGetOwnPropertyDescriptor()
                                            const { return oOps ? oOps->getOwnPropertyDescriptor
                                                                                     : nullptr; }
    DeletePropertyOp getOpsDeleteProperty() const { return oOps ? oOps->deleteProperty : nullptr; }
    WatchOp getOpsWatch() const { return oOps ? oOps->watch : nullptr; }
    UnwatchOp getOpsUnwatch() const { return oOps ? oOps->unwatch : nullptr; }
    GetElementsOp getOpsGetElements() const { return oOps ? oOps->getElements : nullptr; }
    JSNewEnumerateOp getOpsEnumerate() const { return oOps ? oOps->enumerate : nullptr; }
    JSFunToStringOp getOpsFunToString() const { return oOps ? oOps->funToString : nullptr; }
};

static_assert(__builtin_offsetof(JSClassOps, addProperty) == __builtin_offsetof(ClassOps, addProperty),
              "ClassOps and JSClassOps must be consistent");
static_assert(__builtin_offsetof(JSClassOps, delProperty) == __builtin_offsetof(ClassOps, delProperty),
              "ClassOps and JSClassOps must be consistent");
static_assert(__builtin_offsetof(JSClassOps, getProperty) == __builtin_offsetof(ClassOps, getProperty),
              "ClassOps and JSClassOps must be consistent");
static_assert(__builtin_offsetof(JSClassOps, setProperty) == __builtin_offsetof(ClassOps, setProperty),
              "ClassOps and JSClassOps must be consistent");
static_assert(__builtin_offsetof(JSClassOps, enumerate) == __builtin_offsetof(ClassOps, enumerate),
              "ClassOps and JSClassOps must be consistent");
static_assert(__builtin_offsetof(JSClassOps, resolve) == __builtin_offsetof(ClassOps, resolve),
              "ClassOps and JSClassOps must be consistent");
static_assert(__builtin_offsetof(JSClassOps, mayResolve) == __builtin_offsetof(ClassOps, mayResolve),
              "ClassOps and JSClassOps must be consistent");
static_assert(__builtin_offsetof(JSClassOps, finalize) == __builtin_offsetof(ClassOps, finalize),
              "ClassOps and JSClassOps must be consistent");
static_assert(__builtin_offsetof(JSClassOps, call) == __builtin_offsetof(ClassOps, call),
              "ClassOps and JSClassOps must be consistent");
static_assert(__builtin_offsetof(JSClassOps, construct) == __builtin_offsetof(ClassOps, construct),
              "ClassOps and JSClassOps must be consistent");
static_assert(__builtin_offsetof(JSClassOps, hasInstance) == __builtin_offsetof(ClassOps, hasInstance),
              "ClassOps and JSClassOps must be consistent");
static_assert(__builtin_offsetof(JSClassOps, trace) == __builtin_offsetof(ClassOps, trace),
              "ClassOps and JSClassOps must be consistent");
static_assert(sizeof(JSClassOps) == sizeof(ClassOps),
              "ClassOps and JSClassOps must be consistent");

static_assert(__builtin_offsetof(JSClass, name) == __builtin_offsetof(Class, name),
              "Class and JSClass must be consistent");
static_assert(__builtin_offsetof(JSClass, flags) == __builtin_offsetof(Class, flags),
              "Class and JSClass must be consistent");
static_assert(__builtin_offsetof(JSClass, cOps) == __builtin_offsetof(Class, cOps),
              "Class and JSClass must be consistent");
static_assert(sizeof(JSClass) == sizeof(Class),
              "Class and JSClass must be consistent");

static __attribute__((always_inline)) inline const JSClass*
Jsvalify(const Class* c)
{
    return (const JSClass*)c;
}

static __attribute__((always_inline)) inline const Class*
Valueify(const JSClass* c)
{
    return (const Class*)c;
}





enum class ESClass {
    Object,
    Array,
    Number,
    String,
    Boolean,
    RegExp,
    ArrayBuffer,
    SharedArrayBuffer,
    Date,
    Set,
    Map,
    Promise,
    MapIterator,
    SetIterator,
    Arguments,
    Error,


    Other
};


bool
Unbox(JSContext* cx, JS::HandleObject obj, JS::MutableHandleValue vp);






}
namespace js {

class TempAllocPolicy;

namespace detail {

template <typename T>
struct TypeIsGCThing : mozilla::FalseType
{};






}

template <typename T,
          size_t MinInlineCapacity = 0,
          class AllocPolicy = TempAllocPolicy,

         typename = typename mozilla::EnableIf<!detail::TypeIsGCThing<T>::value>::Type
         >
using Vector = mozilla::Vector<T, MinInlineCapacity, AllocPolicy>;

}

namespace JS {
template <typename T,
          size_t MinInlineCapacity = 0,
          typename AllocPolicy = js::TempAllocPolicy>
class GCVector
{
    mozilla::Vector<T, MinInlineCapacity, AllocPolicy> vector;

  public:
    explicit GCVector(AllocPolicy alloc = AllocPolicy())
      : vector(alloc)
    {}

    GCVector(GCVector&& vec)
      : vector(mozilla::Move(vec.vector))
    {}

    GCVector& operator=(GCVector&& vec) {
        vector = mozilla::Move(vec.vector);
        return *this;
    }

    size_t length() const { return vector.length(); }
    bool empty() const { return vector.empty(); }
    size_t capacity() const { return vector.capacity(); }

    T* begin() { return vector.begin(); }
    const T* begin() const { return vector.begin(); }

    T* end() { return vector.end(); }
    const T* end() const { return vector.end(); }

    T& operator[](size_t i) { return vector[i]; }
    const T& operator[](size_t i) const { return vector[i]; }

    T& back() { return vector.back(); }
    const T& back() const { return vector.back(); }

    bool initCapacity(size_t cap) { return vector.initCapacity(cap); }
    __attribute__ ((warn_unused_result)) bool reserve(size_t req) { return vector.reserve(req); }
    void shrinkBy(size_t amount) { return vector.shrinkBy(amount); }
    __attribute__ ((warn_unused_result)) bool growBy(size_t amount) { return vector.growBy(amount); }
    __attribute__ ((warn_unused_result)) bool resize(size_t newLen) { return vector.resize(newLen); }

    void clear() { return vector.clear(); }
    void clearAndFree() { return vector.clearAndFree(); }

    template<typename U> bool append(U&& item) { return vector.append(mozilla::Forward<U>(item)); }

    template<typename... Args>
    __attribute__ ((warn_unused_result)) bool
    emplaceBack(Args&&... args) {
        return vector.emplaceBack(mozilla::Forward<Args>(args)...);
    }

    template<typename U>
    void infallibleAppend(U&& aU) {
        return vector.infallibleAppend(mozilla::Forward<U>(aU));
    }
    void infallibleAppendN(const T& aT, size_t aN) {
        return vector.infallibleAppendN(aT, aN);
    }
    template<typename U> void
    infallibleAppend(const U* aBegin, const U* aEnd) {
        return vector.infallibleAppend(aBegin, aEnd);
    }
    template<typename U> void infallibleAppend(const U* aBegin, size_t aLength) {
        return vector.infallibleAppend(aBegin, aLength);
    }

    template<typename U, size_t O, class BP>
    __attribute__ ((warn_unused_result)) bool appendAll(const mozilla::Vector<U, O, BP>& aU) { return vector.appendAll(aU); }
    template<typename U, size_t O, class BP>
    __attribute__ ((warn_unused_result)) bool appendAll(const GCVector<U, O, BP>& aU) {
        return vector.append(aU.begin(), aU.length());
    }

    __attribute__ ((warn_unused_result)) bool appendN(const T& val, size_t count) { return vector.appendN(val, count); }

    template<typename U>
    __attribute__ ((warn_unused_result)) bool append(const U* aBegin, const U* aEnd) {
        return vector.append(aBegin, aEnd);
    }
    template<typename U>
    __attribute__ ((warn_unused_result)) bool append(const U* aBegin, size_t aLength) {
        return vector.append(aBegin, aLength);
    }

    void popBack() { return vector.popBack(); }
    T popCopy() { return vector.popCopy(); }

    size_t sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
        return vector.sizeOfExcludingThis(mallocSizeOf);
    }

    size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
        return vector.sizeOfIncludingThis(mallocSizeOf);
    }

    static void trace(GCVector* vec, JSTracer* trc) { vec->trace(trc); }

    void trace(JSTracer* trc) {
        for (auto& elem : vector)
            GCPolicy<T>::trace(trc, &elem, "vector element");
    }

    void sweep() {
        uint32_t src, dst = 0;
        for (src = 0; src < length(); src++) {
            if (!GCPolicy<T>::needsSweep(&vector[src])) {
                if (dst != src)
                    vector[dst] = vector[src].unbarrieredGet();
                dst++;
            }
        }

        if (dst != length())
            vector.shrinkTo(dst);
    }
};

}

namespace js {

template <typename Wrapper, typename T, size_t Capacity, typename AllocPolicy>
class WrappedPtrOperations<JS::GCVector<T, Capacity, AllocPolicy>, Wrapper>
{
    using Vec = JS::GCVector<T, Capacity, AllocPolicy>;
    const Vec& vec() const { return static_cast<const Wrapper*>(this)->get(); }

  public:
    const AllocPolicy& allocPolicy() const { return vec().allocPolicy(); }
    size_t length() const { return vec().length(); }
    bool empty() const { return vec().empty(); }
    size_t capacity() const { return vec().capacity(); }
    const T* begin() const { return vec().begin(); }
    const T* end() const { return vec().end(); }
    const T& back() const { return vec().back(); }

    JS::Handle<T> operator[](size_t aIndex) const {
        return JS::Handle<T>::fromMarkedLocation(&vec().operator[](aIndex));
    }
};

template <typename Wrapper, typename T, size_t Capacity, typename AllocPolicy>
class MutableWrappedPtrOperations<JS::GCVector<T, Capacity, AllocPolicy>, Wrapper>
  : public WrappedPtrOperations<JS::GCVector<T, Capacity, AllocPolicy>, Wrapper>
{
    using Vec = JS::GCVector<T, Capacity, AllocPolicy>;
    const Vec& vec() const { return static_cast<const Wrapper*>(this)->get(); }
    Vec& vec() { return static_cast<Wrapper*>(this)->get(); }

  public:
    const AllocPolicy& allocPolicy() const { return vec().allocPolicy(); }
    AllocPolicy& allocPolicy() { return vec().allocPolicy(); }
    const T* begin() const { return vec().begin(); }
    T* begin() { return vec().begin(); }
    const T* end() const { return vec().end(); }
    T* end() { return vec().end(); }
    const T& back() const { return vec().back(); }
    T& back() { return vec().back(); }

    JS::Handle<T> operator[](size_t aIndex) const {
        return JS::Handle<T>::fromMarkedLocation(&vec().operator[](aIndex));
    }
    JS::MutableHandle<T> operator[](size_t aIndex) {
        return JS::MutableHandle<T>::fromMarkedLocation(&vec().operator[](aIndex));
    }

    __attribute__ ((warn_unused_result)) bool initCapacity(size_t aRequest) { return vec().initCapacity(aRequest); }
    __attribute__ ((warn_unused_result)) bool reserve(size_t aRequest) { return vec().reserve(aRequest); }
    void shrinkBy(size_t aIncr) { vec().shrinkBy(aIncr); }
    __attribute__ ((warn_unused_result)) bool growBy(size_t aIncr) { return vec().growBy(aIncr); }
    __attribute__ ((warn_unused_result)) bool resize(size_t aNewLength) { return vec().resize(aNewLength); }
    __attribute__ ((warn_unused_result)) bool growByUninitialized(size_t aIncr) { return vec().growByUninitialized(aIncr); }
    void infallibleGrowByUninitialized(size_t aIncr) { vec().infallibleGrowByUninitialized(aIncr); }
    __attribute__ ((warn_unused_result)) bool resizeUninitialized(size_t aNewLength) { return vec().resizeUninitialized(aNewLength); }
    void clear() { vec().clear(); }
    void clearAndFree() { vec().clearAndFree(); }
    template<typename U>
    __attribute__ ((warn_unused_result)) bool append(U&& aU) { return vec().append(mozilla::Forward<U>(aU)); }
    template<typename... Args>
    __attribute__ ((warn_unused_result)) bool emplaceBack(Args&&... aArgs) {
        return vec().emplaceBack(mozilla::Forward<Args...>(aArgs...));
    }
    template<typename U, size_t O, class BP>
    __attribute__ ((warn_unused_result)) bool appendAll(const mozilla::Vector<U, O, BP>& aU) { return vec().appendAll(aU); }
    template<typename U, size_t O, class BP>
    __attribute__ ((warn_unused_result)) bool appendAll(const JS::GCVector<U, O, BP>& aU) { return vec().appendAll(aU); }
    __attribute__ ((warn_unused_result)) bool appendN(const T& aT, size_t aN) { return vec().appendN(aT, aN); }
    template<typename U>
    __attribute__ ((warn_unused_result)) bool append(const U* aBegin, const U* aEnd) {
        return vec().append(aBegin, aEnd);
    }
    template<typename U>
    __attribute__ ((warn_unused_result)) bool append(const U* aBegin, size_t aLength) {
        return vec().append(aBegin, aLength);
    }
    template<typename U> void infallibleAppend(U&& aU) {
        vec().infallibleAppend(mozilla::Forward<U>(aU));
    }
    void infallibleAppendN(const T& aT, size_t aN) { vec().infallibleAppendN(aT, aN); }
    template<typename U> void infallibleAppend(const U* aBegin, const U* aEnd) {
        vec().infallibleAppend(aBegin, aEnd);
    }
    template<typename U> void infallibleAppend(const U* aBegin, size_t aLength) {
        vec().infallibleAppend(aBegin, aLength);
    }
    void popBack() { vec().popBack(); }
    T popCopy() { return vec().popCopy(); }
    template<typename U> T* insert(T* aP, U&& aVal) {
        return vec().insert(aP, mozilla::Forward<U>(aVal));
    }
    void erase(T* aT) { vec().erase(aT); }
    void erase(T* aBegin, T* aEnd) { vec().erase(aBegin, aEnd); }
};

}


namespace mozilla {

template <typename ExitFunction>
class ScopeExit {
  ExitFunction mExitFunction;
  bool mExecuteOnDestruction;


public:
  explicit ScopeExit(ExitFunction&& cleanup
                                                    )
   : mExitFunction(cleanup)
   , mExecuteOnDestruction(true)
  {
    do { } while (0);
  }

  ScopeExit(ScopeExit&& rhs)
   : mExitFunction(mozilla::Move(rhs.mExitFunction))
   , mExecuteOnDestruction(rhs.mExecuteOnDestruction)
  {
    rhs.release();
  }

  ~ScopeExit() {
    if (mExecuteOnDestruction) {
      mExitFunction();
    }
  }

  void release() {
    mExecuteOnDestruction = false;
  }

private:
  explicit ScopeExit(const ScopeExit&) = delete;
  ScopeExit& operator=(const ScopeExit&) = delete;
  ScopeExit& operator=(ScopeExit&&) = delete;
};

template <typename ExitFunction>
ScopeExit<ExitFunction>
MakeScopeExit(ExitFunction&& exitFunction)
{
  return ScopeExit<ExitFunction>(mozilla::Move(exitFunction));
}

}
namespace mozilla {

template<typename AllocPolicy>
class BufferList : private AllocPolicy
{


  struct Segment
  {
    char* mData;
    size_t mSize;
    size_t mCapacity;

    Segment(char* aData, size_t aSize, size_t aCapacity)
     : mData(aData),
       mSize(aSize),
       mCapacity(aCapacity)
    {
    }

    Segment(const Segment&) = delete;
    Segment& operator=(const Segment&) = delete;

    Segment(Segment&&) = default;
    Segment& operator=(Segment&&) = default;

    char* Start() const { return mData; }
    char* End() const { return mData + mSize; }
  };

  template<typename OtherAllocPolicy>
  friend class BufferList;

 public:





  static const size_t kSegmentAlignment = 8;






  BufferList(size_t aInitialSize,
             size_t aInitialCapacity,
             size_t aStandardCapacity,
             AllocPolicy aAP = AllocPolicy())
   : AllocPolicy(aAP),
     mOwning(true),
     mSegments(aAP),
     mSize(0),
     mStandardCapacity(aStandardCapacity)
  {
    do { } while (0);
    do { } while (0);

    if (aInitialCapacity) {
      AllocateSegment(aInitialSize, aInitialCapacity);
    }
  }

  BufferList(const BufferList& aOther) = delete;

  BufferList(BufferList&& aOther)
   : mOwning(aOther.mOwning),
     mSegments(Move(aOther.mSegments)),
     mSize(aOther.mSize),
     mStandardCapacity(aOther.mStandardCapacity)
  {
    aOther.mSegments.clear();
    aOther.mSize = 0;
  }

  BufferList& operator=(const BufferList& aOther) = delete;

  BufferList& operator=(BufferList&& aOther)
  {
    Clear();

    mOwning = aOther.mOwning;
    mSegments = Move(aOther.mSegments);
    mSize = aOther.mSize;
    aOther.mSegments.clear();
    aOther.mSize = 0;
    return *this;
  }

  ~BufferList() { Clear(); }


  size_t Size() const { return mSize; }

  void Clear()
  {
    if (mOwning) {
      for (Segment& segment : mSegments) {
        this->free_(segment.mData);
      }
    }
    mSegments.clear();

    mSize = 0;
  }



  class IterImpl
  {




    uintptr_t mSegment;
    char* mData;
    char* mDataEnd;

    friend class BufferList;

  public:
    explicit IterImpl(const BufferList& aBuffers)
     : mSegment(0),
       mData(nullptr),
       mDataEnd(nullptr)
    {
      if (!aBuffers.mSegments.empty()) {
        mData = aBuffers.mSegments[0].Start();
        mDataEnd = aBuffers.mSegments[0].End();
      }
    }



    char* Data() const
    {
      do { static_assert(mozilla::detail::AssertionConditionType<decltype(!Done())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(!Done()))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "!Done()" ")"); do { *((volatile int*) __null) = 162; ::abort(); } while (0); } } while (0);
      return mData;
    }



    bool HasRoomFor(size_t aBytes) const
    {
      do { static_assert(mozilla::detail::AssertionConditionType<decltype(mData <= mDataEnd)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(mData <= mDataEnd))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "mData <= mDataEnd" ")"); do { *((volatile int*) __null) = 170; ::abort(); } while (0); } } while (0);
      return size_t(mDataEnd - mData) >= aBytes;
    }



    size_t RemainingInSegment() const
    {
      do { static_assert(mozilla::detail::AssertionConditionType<decltype(mData <= mDataEnd)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(mData <= mDataEnd))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "mData <= mDataEnd" ")"); do { *((volatile int*) __null) = 178; ::abort(); } while (0); } } while (0);
      return mDataEnd - mData;
    }





    void Advance(const BufferList& aBuffers, size_t aBytes)
    {
      const Segment& segment = aBuffers.mSegments[mSegment];
      do { static_assert(mozilla::detail::AssertionConditionType<decltype(segment.Start() <= mData)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(segment.Start() <= mData))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "segment.Start() <= mData" ")"); do { *((volatile int*) __null) = 189; ::abort(); } while (0); } } while (0);
      do { static_assert(mozilla::detail::AssertionConditionType<decltype(mData <= mDataEnd)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(mData <= mDataEnd))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "mData <= mDataEnd" ")"); do { *((volatile int*) __null) = 190; ::abort(); } while (0); } } while (0);
      do { static_assert(mozilla::detail::AssertionConditionType<decltype(mDataEnd == segment.End())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(mDataEnd == segment.End()))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "mDataEnd == segment.End()" ")"); do { *((volatile int*) __null) = 191; ::abort(); } while (0); } } while (0);

      do { static_assert(mozilla::detail::AssertionConditionType<decltype(HasRoomFor(aBytes))>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(HasRoomFor(aBytes)))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "HasRoomFor(aBytes)" ")"); do { *((volatile int*) __null) = 193; ::abort(); } while (0); } } while (0);
      mData += aBytes;

      if (mData == mDataEnd && mSegment + 1 < aBuffers.mSegments.length()) {
        mSegment++;
        const Segment& nextSegment = aBuffers.mSegments[mSegment];
        mData = nextSegment.Start();
        mDataEnd = nextSegment.End();
        do { static_assert(mozilla::detail::AssertionConditionType<decltype(mData < mDataEnd)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(mData < mDataEnd))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "mData < mDataEnd" ")"); do { *((volatile int*) __null) = 201; ::abort(); } while (0); } } while (0);
      }
    }




    bool AdvanceAcrossSegments(const BufferList& aBuffers, size_t aBytes)
    {
      size_t bytes = aBytes;
      while (bytes) {
        size_t toAdvance = std::min(bytes, RemainingInSegment());
        if (!toAdvance) {
          return false;
        }
        Advance(aBuffers, toAdvance);
        bytes -= toAdvance;
      }
      return true;
    }


    bool Done() const
    {
      return mData == mDataEnd;
    }

   private:


    size_t BytesUntil(const BufferList& aBuffers, const IterImpl& aTarget) const {
      size_t offset = 0;

      do { } while (0);

      char* data = mData;
      for (uintptr_t segment = mSegment; segment < aTarget.mSegment; segment++) {
        offset += aBuffers.mSegments[segment].End() - data;
        data = aBuffers.mSegments[segment].mData;
      }

      do { static_assert(mozilla::detail::AssertionConditionType<decltype(IsIn(aBuffers))>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(IsIn(aBuffers)))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "IsIn(aBuffers)" ")"); do { *((volatile int*) __null) = 242; ::abort(); } while (0); } } while (0);
      do { static_assert(mozilla::detail::AssertionConditionType<decltype(aTarget.mData >= data)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(aTarget.mData >= data))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "aTarget.mData >= data" ")"); do { *((volatile int*) __null) = 243; ::abort(); } while (0); } } while (0);

      offset += aTarget.mData - data;
      return offset;
    }

    bool IsIn(const BufferList& aBuffers) const {
      return mSegment < aBuffers.mSegments.length() &&
             mData >= aBuffers.mSegments[mSegment].mData &&
             mData < aBuffers.mSegments[mSegment].End();
    }
  };


  char* Start() { return mSegments[0].mData; }
  const char* Start() const { return mSegments[0].mData; }

  IterImpl Iter() const { return IterImpl(*this); }



  inline bool WriteBytes(const char* aData, size_t aSize);




  inline bool ReadBytes(IterImpl& aIter, char* aData, size_t aSize) const;







  template<typename BorrowingAllocPolicy>
  BufferList<BorrowingAllocPolicy> Borrow(IterImpl& aIter, size_t aSize, bool* aSuccess,
                                          BorrowingAllocPolicy aAP = BorrowingAllocPolicy()) const;







  template<typename OtherAllocPolicy>
  BufferList<OtherAllocPolicy> MoveFallible(bool* aSuccess, OtherAllocPolicy aAP = OtherAllocPolicy());
  BufferList Extract(IterImpl& aIter, size_t aSize, bool* aSuccess);



  size_t RangeLength(const IterImpl& start, const IterImpl& end) const {
    do { } while (0);
    return start.BytesUntil(*this, end);
  }

private:
  explicit BufferList(AllocPolicy aAP)
   : AllocPolicy(aAP),
     mOwning(false),
     mSize(0),
     mStandardCapacity(0)
  {
  }

  void* AllocateSegment(size_t aSize, size_t aCapacity)
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(mOwning)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(mOwning))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "mOwning" ")"); do { *((volatile int*) __null) = 318; ::abort(); } while (0); } } while (0);
    do { } while (0);

    char* data = this->template pod_malloc<char>(aCapacity);
    if (!data) {
      return nullptr;
    }
    if (!mSegments.append(Segment(data, aSize, aCapacity))) {
      this->free_(data);
      return nullptr;
    }
    mSize += aSize;
    return data;
  }

  bool mOwning;
  Vector<Segment, 1, AllocPolicy> mSegments;
  size_t mSize;
  size_t mStandardCapacity;
};

template<typename AllocPolicy>
bool
BufferList<AllocPolicy>::WriteBytes(const char* aData, size_t aSize)
{
  do { static_assert(mozilla::detail::AssertionConditionType<decltype(mOwning)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(mOwning))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "mOwning" ")"); do { *((volatile int*) __null) = 343; ::abort(); } while (0); } } while (0);
  do { static_assert(mozilla::detail::AssertionConditionType<decltype(mStandardCapacity)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(mStandardCapacity))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "mStandardCapacity" ")"); do { *((volatile int*) __null) = 344; ::abort(); } while (0); } } while (0);

  size_t copied = 0;
  size_t remaining = aSize;

  if (!mSegments.empty()) {
    Segment& lastSegment = mSegments.back();

    size_t toCopy = std::min(aSize, lastSegment.mCapacity - lastSegment.mSize);
    memcpy(lastSegment.mData + lastSegment.mSize, aData, toCopy);
    lastSegment.mSize += toCopy;
    mSize += toCopy;

    copied += toCopy;
    remaining -= toCopy;
  }

  while (remaining) {
    size_t toCopy = std::min(remaining, mStandardCapacity);

    void* data = AllocateSegment(toCopy, mStandardCapacity);
    if (!data) {
      return false;
    }
    memcpy(data, aData + copied, toCopy);

    copied += toCopy;
    remaining -= toCopy;
  }

  return true;
}

template<typename AllocPolicy>
bool
BufferList<AllocPolicy>::ReadBytes(IterImpl& aIter, char* aData, size_t aSize) const
{
  size_t copied = 0;
  size_t remaining = aSize;
  while (remaining) {
    size_t toCopy = std::min(aIter.RemainingInSegment(), remaining);
    if (!toCopy) {

      return false;
    }
    memcpy(aData + copied, aIter.Data(), toCopy);
    copied += toCopy;
    remaining -= toCopy;

    aIter.Advance(*this, toCopy);
  }

  return true;
}

template<typename AllocPolicy> template<typename BorrowingAllocPolicy>
BufferList<BorrowingAllocPolicy>
BufferList<AllocPolicy>::Borrow(IterImpl& aIter, size_t aSize, bool* aSuccess,
                                BorrowingAllocPolicy aAP) const
{
  BufferList<BorrowingAllocPolicy> result(aAP);

  size_t size = aSize;
  while (size) {
    size_t toAdvance = std::min(size, aIter.RemainingInSegment());

    if (!toAdvance || !result.mSegments.append(typename BufferList<BorrowingAllocPolicy>::Segment(aIter.mData, toAdvance, toAdvance))) {
      *aSuccess = false;
      return result;
    }
    aIter.Advance(*this, toAdvance);
    size -= toAdvance;
  }

  result.mSize = aSize;
  *aSuccess = true;
  return result;
}

template<typename AllocPolicy> template<typename OtherAllocPolicy>
BufferList<OtherAllocPolicy>
BufferList<AllocPolicy>::MoveFallible(bool* aSuccess, OtherAllocPolicy aAP)
{
  BufferList<OtherAllocPolicy> result(0, 0, mStandardCapacity, aAP);

  IterImpl iter = Iter();
  while (!iter.Done()) {
    size_t toAdvance = iter.RemainingInSegment();

    if (!toAdvance || !result.mSegments.append(typename BufferList<OtherAllocPolicy>::Segment(iter.mData, toAdvance, toAdvance))) {
      *aSuccess = false;
      result.mSegments.clear();
      return result;
    }
    iter.Advance(*this, toAdvance);
  }

  result.mSize = mSize;
  mSegments.clear();
  mSize = 0;
  *aSuccess = true;
  return result;
}

template<typename AllocPolicy>
BufferList<AllocPolicy>
BufferList<AllocPolicy>::Extract(IterImpl& aIter, size_t aSize, bool* aSuccess)
{
  do { static_assert(mozilla::detail::AssertionConditionType<decltype(aSize)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(aSize))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "aSize" ")"); do { *((volatile int*) __null) = 452; ::abort(); } while (0); } } while (0);
  do { static_assert(mozilla::detail::AssertionConditionType<decltype(mOwning)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(mOwning))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "mOwning" ")"); do { *((volatile int*) __null) = 453; ::abort(); } while (0); } } while (0);
  do { } while (0);
  do { } while (0);

  IterImpl iter = aIter;
  size_t size = aSize;
  size_t toCopy = std::min(size, aIter.RemainingInSegment());
  do { } while (0);

  BufferList result(0, toCopy, mStandardCapacity);
  BufferList error(0, 0, mStandardCapacity);


  if (!result.WriteBytes(aIter.mData, toCopy)) {
    *aSuccess = false;
    return error;
  }
  iter.Advance(*this, toCopy);
  size -= toCopy;


  auto resultGuard = MakeScopeExit([&] {
    *aSuccess = false;
    result.mSegments.erase(result.mSegments.begin()+1, result.mSegments.end());
  });

  size_t movedSize = 0;
  uintptr_t toRemoveStart = iter.mSegment;
  uintptr_t toRemoveEnd = iter.mSegment;
  while (!iter.Done() &&
         !iter.HasRoomFor(size)) {
    if (!result.mSegments.append(Segment(mSegments[iter.mSegment].mData,
                                         mSegments[iter.mSegment].mSize,
                                         mSegments[iter.mSegment].mCapacity))) {
      return error;
    }
    movedSize += iter.RemainingInSegment();
    size -= iter.RemainingInSegment();
    toRemoveEnd++;
    iter.Advance(*this, iter.RemainingInSegment());
  }

  if (size) {
    if (!iter.HasRoomFor(size) ||
        !result.WriteBytes(iter.Data(), size)) {
      return error;
    }
    iter.Advance(*this, size);
  }

  mSegments.erase(mSegments.begin() + toRemoveStart, mSegments.begin() + toRemoveEnd);
  mSize -= movedSize;
  aIter.mSegment = iter.mSegment - (toRemoveEnd - toRemoveStart);
  aIter.mData = iter.mData;
  aIter.mDataEnd = iter.mDataEnd;
  do { } while (0);
  result.mSize = aSize;

  resultGuard.release();
  *aSuccess = true;
  return result;
}

}
struct JSRuntime;
struct JSStructuredCloneReader;
struct JSStructuredCloneWriter;



namespace JS {

enum class StructuredCloneScope : uint32_t {
    SameProcessSameThread,
    SameProcessDifferentThread,
    DifferentProcess
};

enum TransferableOwnership {

    SCTAG_TMO_UNFILLED = 0,


    SCTAG_TMO_UNOWNED = 1,


    SCTAG_TMO_FIRST_OWNED = 2,


    SCTAG_TMO_ALLOC_DATA = 2,


    SCTAG_TMO_MAPPED_DATA = 3,






    SCTAG_TMO_CUSTOM = 4,

    SCTAG_TMO_USER_MIN
};

class CloneDataPolicy
{
    bool sharedArrayBuffer_;

  public:


    CloneDataPolicy() :
      sharedArrayBuffer_(true)
    {}
    CloneDataPolicy& denySharedArrayBuffer() {
        sharedArrayBuffer_ = false;
        return *this;
    }

    bool isSharedArrayBufferAllowed() const {
        return sharedArrayBuffer_;
    }
};

}
typedef JSObject* (*ReadStructuredCloneOp)(JSContext* cx, JSStructuredCloneReader* r,
                                           uint32_t tag, uint32_t data, void* closure);
typedef bool (*WriteStructuredCloneOp)(JSContext* cx, JSStructuredCloneWriter* w,
                                       JS::HandleObject obj, void* closure);






typedef void (*StructuredCloneErrorOp)(JSContext* cx, uint32_t errorid);
typedef bool (*ReadTransferStructuredCloneOp)(JSContext* cx, JSStructuredCloneReader* r,
                                              uint32_t tag, void* content, uint64_t extraData,
                                              void* closure,
                                              JS::MutableHandleObject returnObject);
typedef bool (*TransferStructuredCloneOp)(JSContext* cx,
                                          JS::Handle<JSObject*> obj,
                                          void* closure,

                                          uint32_t* tag,
                                          JS::TransferableOwnership* ownership,
                                          void** content,
                                          uint64_t* extraData);






typedef void (*FreeTransferStructuredCloneOp)(uint32_t tag, JS::TransferableOwnership ownership,
                                              void* content, uint64_t extraData, void* closure);







struct JSStructuredCloneCallbacks {
    ReadStructuredCloneOp read;
    WriteStructuredCloneOp write;
    StructuredCloneErrorOp reportError;
    ReadTransferStructuredCloneOp readTransfer;
    TransferStructuredCloneOp writeTransfer;
    FreeTransferStructuredCloneOp freeTransfer;
};

enum OwnTransferablePolicy {
    OwnsTransferablesIfAny,
    IgnoreTransferablesIfAny,
    NoTransferables
};

class JSStructuredCloneData :
    public mozilla::BufferList<js::SystemAllocPolicy>
{
    typedef js::SystemAllocPolicy AllocPolicy;
    typedef mozilla::BufferList<js::SystemAllocPolicy> BufferList;

    static const size_t kInitialSize = 0;
    static const size_t kInitialCapacity = 4096;
    static const size_t kStandardCapacity = 4096;

    const JSStructuredCloneCallbacks* callbacks_;
    void* closure_;
    OwnTransferablePolicy ownTransferables_;

    void setOptionalCallbacks(const JSStructuredCloneCallbacks* callbacks,
                              void* closure,
                              OwnTransferablePolicy policy) {
        callbacks_ = callbacks;
        closure_ = closure;
        ownTransferables_ = policy;
    }

    friend struct JSStructuredCloneWriter;
    friend class JSAutoStructuredCloneBuffer;

public:
    explicit JSStructuredCloneData(AllocPolicy aAP = AllocPolicy())
        : BufferList(kInitialSize, kInitialCapacity, kStandardCapacity, aAP)
        , callbacks_(nullptr)
        , closure_(nullptr)
        , ownTransferables_(OwnTransferablePolicy::NoTransferables)
    {}
                 JSStructuredCloneData(BufferList&& buffers)
        : BufferList(Move(buffers))
        , callbacks_(nullptr)
        , closure_(nullptr)
        , ownTransferables_(OwnTransferablePolicy::NoTransferables)
    {}
    JSStructuredCloneData(JSStructuredCloneData&& other) = default;
    JSStructuredCloneData& operator=(JSStructuredCloneData&& other) = default;
    ~JSStructuredCloneData();

    using BufferList::BufferList;
};


bool
JS_ReadStructuredClone(JSContext* cx, JSStructuredCloneData& data, uint32_t version,
                       JS::StructuredCloneScope scope,
                       JS::MutableHandleValue vp,
                       const JSStructuredCloneCallbacks* optionalCallbacks, void* closure);

bool
JS_WriteStructuredClone(JSContext* cx, JS::HandleValue v, JSStructuredCloneData* data,
                        JS::StructuredCloneScope scope,
                        JS::CloneDataPolicy cloneDataPolicy,
                        const JSStructuredCloneCallbacks* optionalCallbacks,
                        void* closure, JS::HandleValue transferable);

bool
JS_StructuredCloneHasTransferables(JSStructuredCloneData& data, bool* hasTransferable);

bool
JS_StructuredClone(JSContext* cx, JS::HandleValue v, JS::MutableHandleValue vp,
                   const JSStructuredCloneCallbacks* optionalCallbacks, void* closure);


class JSAutoStructuredCloneBuffer {
    const JS::StructuredCloneScope scope_;
    JSStructuredCloneData data_;
    uint32_t version_;

  public:
    JSAutoStructuredCloneBuffer(JS::StructuredCloneScope scope,
                                const JSStructuredCloneCallbacks* callbacks, void* closure)
        : scope_(scope), version_(8)
    {
        data_.setOptionalCallbacks(callbacks, closure, OwnTransferablePolicy::NoTransferables);
    }

    JSAutoStructuredCloneBuffer(JSAutoStructuredCloneBuffer&& other);
    JSAutoStructuredCloneBuffer& operator=(JSAutoStructuredCloneBuffer&& other);

    ~JSAutoStructuredCloneBuffer() { clear(); }

    JSStructuredCloneData& data() { return data_; }
    bool empty() const { return !data_.Size(); }

    void clear(const JSStructuredCloneCallbacks* optionalCallbacks=nullptr, void* closure=nullptr);


    bool copy(const JSStructuredCloneData& data, uint32_t version=8,
              const JSStructuredCloneCallbacks* callbacks=nullptr, void* closure=nullptr);






    void adopt(JSStructuredCloneData&& data, uint32_t version=8,
               const JSStructuredCloneCallbacks* callbacks=nullptr, void* closure=nullptr);




    void steal(JSStructuredCloneData* data, uint32_t* versionp=nullptr,
               const JSStructuredCloneCallbacks** callbacks=nullptr, void** closure=nullptr);







    void abandon() { data_.ownTransferables_ = OwnTransferablePolicy::IgnoreTransferablesIfAny; }

    bool read(JSContext* cx, JS::MutableHandleValue vp,
              const JSStructuredCloneCallbacks* optionalCallbacks=nullptr, void* closure=nullptr);

    bool write(JSContext* cx, JS::HandleValue v,
               const JSStructuredCloneCallbacks* optionalCallbacks=nullptr, void* closure=nullptr);

    bool write(JSContext* cx, JS::HandleValue v, JS::HandleValue transferable,
               JS::CloneDataPolicy cloneDataPolicy,
               const JSStructuredCloneCallbacks* optionalCallbacks=nullptr, void* closure=nullptr);

  private:

    JSAutoStructuredCloneBuffer(const JSAutoStructuredCloneBuffer& other) = delete;
    JSAutoStructuredCloneBuffer& operator=(const JSAutoStructuredCloneBuffer& other) = delete;
};
bool
JS_ReadUint32Pair(JSStructuredCloneReader* r, uint32_t* p1, uint32_t* p2);

bool
JS_ReadBytes(JSStructuredCloneReader* r, void* p, size_t len);

bool
JS_ReadTypedArray(JSStructuredCloneReader* r, JS::MutableHandleValue vp);

bool
JS_WriteUint32Pair(JSStructuredCloneWriter* w, uint32_t tag, uint32_t data);

bool
JS_WriteBytes(JSStructuredCloneWriter* w, const void* p, size_t len);

bool
JS_WriteString(JSStructuredCloneWriter* w, JS::HandleString str);

bool
JS_WriteTypedArray(JSStructuredCloneWriter* w, JS::HandleValue v);

bool
JS_ObjectNotWritten(JSStructuredCloneWriter* w, JS::HandleObject obj);

JS::StructuredCloneScope
JS_GetStructuredCloneScope(JSStructuredCloneWriter* w);

namespace js {
    struct PerformanceGroup;
}

struct JSPrincipals {

    mozilla::Atomic<int32_t> refcount;



    uint32_t debugToken;


    JSPrincipals() : refcount(0) {}

    void setDebugToken(uint32_t token) {

        debugToken = token;

    }





    virtual bool write(JSContext* cx, JSStructuredCloneWriter* writer) = 0;





    void dump();
};

extern void
JS_HoldPrincipals(JSPrincipals* principals);

extern void
JS_DropPrincipals(JSContext* cx, JSPrincipals* principals);




typedef bool
(* JSSubsumesOp)(JSPrincipals* first, JSPrincipals* second);





typedef bool
(* JSCSPEvalChecker)(JSContext* cx);

struct JSSecurityCallbacks {
    JSCSPEvalChecker contentSecurityPolicyAllows;
    JSSubsumesOp subsumes;
};

extern void
JS_SetSecurityCallbacks(JSContext* cx, const JSSecurityCallbacks* callbacks);

extern const JSSecurityCallbacks*
JS_GetSecurityCallbacks(JSContext* cx);
extern void
JS_SetTrustedPrincipals(JSContext* cx, JSPrincipals* prin);

typedef void
(* JSDestroyPrincipalsOp)(JSPrincipals* principals);






extern void
JS_InitDestroyPrincipalsCallback(JSContext* cx, JSDestroyPrincipalsOp destroyPrincipals);
using JSReadPrincipalsOp = bool (*)(JSContext* cx, JSStructuredCloneReader* reader,
                                    JSPrincipals** outPrincipals);





extern void
JS_InitReadPrincipalsCallback(JSContext* cx, JSReadPrincipalsOp read);
struct JSContext;
class JSObject;

namespace JS {

extern JSObject*
GetRealmObjectPrototype(JSContext* cx);

extern JSObject*
GetRealmFunctionPrototype(JSContext* cx);

extern JSObject*
GetRealmArrayPrototype(JSContext* cx);

extern JSObject*
GetRealmErrorPrototype(JSContext* cx);

extern JSObject*
GetRealmIteratorPrototype(JSContext* cx);

}
namespace js {

template <typename T>
class RefCounted
{
    static const MozRefCountType DEAD = 0xffffdead;

  protected:
    RefCounted() : mRefCnt(0) {}
    ~RefCounted() { do { } while (0); }

  public:
    void AddRef() const
    {
        do { } while (0);
        ++mRefCnt;
    }

    void Release() const
    {
      do { } while (0);
      MozRefCountType cnt = --mRefCnt;
      if (0 == cnt) {



          js_delete(const_cast<T*>(static_cast<const T*>(this)));
      }
    }

  private:
    mutable MozRefCountType mRefCnt;
};

template <typename T>
class AtomicRefCounted
{
    static const MozRefCountType DEAD = 0xffffdead;

  protected:
    AtomicRefCounted() : mRefCnt(0) {}
    ~AtomicRefCounted() { do { } while (0); }

  public:
    void AddRef() const
    {
        do { } while (0);
        ++mRefCnt;
    }

    void Release() const
    {
        do { } while (0);
        MozRefCountType cnt = --mRefCnt;
        if (0 == cnt) {



            js_delete(const_cast<T*>(static_cast<const T*>(this)));
        }
    }

  private:
    mutable mozilla::Atomic<MozRefCountType> mRefCnt;
};

}
namespace JS {

class TwoByteChars;



class AutoCheckRequestDepth
{
    JSContext* cx;
  public:
    explicit AutoCheckRequestDepth(JSContext* cx);
    ~AutoCheckRequestDepth();
};
template <size_t N>
class AutoValueArray : public AutoGCRooter
{
    const size_t length_;
    Value elements_[N];

  public:
    explicit AutoValueArray(JSContext* cx
                                                           )
      : AutoGCRooter(cx, VALARRAY), length_(N)
    {

        mozilla::PodArrayZero(elements_);
        do { } while (0);
    }

    unsigned length() const { return length_; }
    const Value* begin() const { return elements_; }
    Value* begin() { return elements_; }

    HandleValue operator[](unsigned i) const {
        do { } while (0);
        return HandleValue::fromMarkedLocation(&elements_[i]);
    }
    MutableHandleValue operator[](unsigned i) {
        do { } while (0);
        return MutableHandleValue::fromMarkedLocation(&elements_[i]);
    }


};

template<class T>
class AutoVectorRooterBase : protected AutoGCRooter
{
    typedef js::Vector<T, 8> VectorImpl;
    VectorImpl vector;

  public:
    explicit AutoVectorRooterBase(JSContext* cx, ptrdiff_t tag
                                                             )
      : AutoGCRooter(cx, tag), vector(cx)
    {
        do { } while (0);
    }

    typedef T ElementType;
    typedef typename VectorImpl::Range Range;

    size_t length() const { return vector.length(); }
    bool empty() const { return vector.empty(); }

    __attribute__ ((warn_unused_result)) bool append(const T& v) { return vector.append(v); }
    __attribute__ ((warn_unused_result)) bool appendN(const T& v, size_t len) { return vector.appendN(v, len); }
    __attribute__ ((warn_unused_result)) bool append(const T* ptr, size_t len) { return vector.append(ptr, len); }
    __attribute__ ((warn_unused_result)) bool appendAll(const AutoVectorRooterBase<T>& other) {
        return vector.appendAll(other.vector);
    }

    __attribute__ ((warn_unused_result)) bool insert(T* p, const T& val) { return vector.insert(p, val); }


    void infallibleAppend(const T& v) { vector.infallibleAppend(v); }

    void popBack() { vector.popBack(); }
    T popCopy() { return vector.popCopy(); }

    __attribute__ ((warn_unused_result)) bool growBy(size_t inc) {
        size_t oldLength = vector.length();
        if (!vector.growByUninitialized(inc))
            return false;
        makeRangeGCSafe(oldLength);
        return true;
    }

    __attribute__ ((warn_unused_result)) bool resize(size_t newLength) {
        size_t oldLength = vector.length();
        if (newLength <= oldLength) {
            vector.shrinkBy(oldLength - newLength);
            return true;
        }
        if (!vector.growByUninitialized(newLength - oldLength))
            return false;
        makeRangeGCSafe(oldLength);
        return true;
    }

    void clear() { vector.clear(); }

    __attribute__ ((warn_unused_result)) bool reserve(size_t newLength) {
        return vector.reserve(newLength);
    }

    JS::MutableHandle<T> operator[](size_t i) {
        return JS::MutableHandle<T>::fromMarkedLocation(&vector[i]);
    }
    JS::Handle<T> operator[](size_t i) const {
        return JS::Handle<T>::fromMarkedLocation(&vector[i]);
    }

    const T* begin() const { return vector.begin(); }
    T* begin() { return vector.begin(); }

    const T* end() const { return vector.end(); }
    T* end() { return vector.end(); }

    Range all() { return vector.all(); }

    const T& back() const { return vector.back(); }

    friend void AutoGCRooter::trace(JSTracer* trc);

  private:
    void makeRangeGCSafe(size_t oldLength) {
        T* t = vector.begin() + oldLength;
        for (size_t i = oldLength; i < vector.length(); ++i, ++t)
            memset(t, 0, sizeof(T));
    }


};

template <typename T>
class AutoVectorRooter : public AutoVectorRooterBase<T>
{
  public:
    explicit AutoVectorRooter(JSContext* cx
                                                            )
        : AutoVectorRooterBase<T>(cx, this->GetTag(T()))
    {
        do { } while (0);
    }


};

class AutoValueVector : public Rooted<GCVector<Value, 8>> {
    using Vec = GCVector<Value, 8>;
    using Base = Rooted<Vec>;
  public:
    explicit AutoValueVector(JSContext* cx) : Base(cx, Vec(cx)) {}
};

class AutoIdVector : public Rooted<GCVector<jsid, 8>> {
    using Vec = GCVector<jsid, 8>;
    using Base = Rooted<Vec>;
  public:
    explicit AutoIdVector(JSContext* cx) : Base(cx, Vec(cx)) {}

    bool appendAll(const AutoIdVector& other) { return this->Base::appendAll(other.get()); }
};

class AutoObjectVector : public Rooted<GCVector<JSObject*, 8>> {
    using Vec = GCVector<JSObject*, 8>;
    using Base = Rooted<Vec>;
  public:
    explicit AutoObjectVector(JSContext* cx) : Base(cx, Vec(cx)) {}
};

using ValueVector = JS::GCVector<JS::Value>;
using IdVector = JS::GCVector<jsid>;
using ScriptVector = JS::GCVector<JSScript*>;
using StringVector = JS::GCVector<JSString*>;

template<class Key, class Value>
class AutoHashMapRooter : protected AutoGCRooter
{
  private:
    typedef js::HashMap<Key, Value> HashMapImpl;

  public:
    explicit AutoHashMapRooter(JSContext* cx, ptrdiff_t tag
                                                              )
      : AutoGCRooter(cx, tag), map(cx)
    {
        do { } while (0);
    }

    typedef Key KeyType;
    typedef Value ValueType;
    typedef typename HashMapImpl::Entry Entry;
    typedef typename HashMapImpl::Lookup Lookup;
    typedef typename HashMapImpl::Ptr Ptr;
    typedef typename HashMapImpl::AddPtr AddPtr;

    bool init(uint32_t len = 16) {
        return map.init(len);
    }
    bool initialized() const {
        return map.initialized();
    }
    Ptr lookup(const Lookup& l) const {
        return map.lookup(l);
    }
    void remove(Ptr p) {
        map.remove(p);
    }
    AddPtr lookupForAdd(const Lookup& l) const {
        return map.lookupForAdd(l);
    }

    template<typename KeyInput, typename ValueInput>
    bool add(AddPtr& p, const KeyInput& k, const ValueInput& v) {
        return map.add(p, k, v);
    }

    bool add(AddPtr& p, const Key& k) {
        return map.add(p, k);
    }

    template<typename KeyInput, typename ValueInput>
    bool relookupOrAdd(AddPtr& p, const KeyInput& k, const ValueInput& v) {
        return map.relookupOrAdd(p, k, v);
    }

    typedef typename HashMapImpl::Range Range;
    Range all() const {
        return map.all();
    }

    typedef typename HashMapImpl::Enum Enum;

    void clear() {
        map.clear();
    }

    void finish() {
        map.finish();
    }

    bool empty() const {
        return map.empty();
    }

    uint32_t count() const {
        return map.count();
    }

    size_t capacity() const {
        return map.capacity();
    }

    size_t sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
        return map.sizeOfExcludingThis(mallocSizeOf);
    }
    size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
        return map.sizeOfIncludingThis(mallocSizeOf);
    }



    bool has(const Lookup& l) const {
        return map.has(l);
    }

    template<typename KeyInput, typename ValueInput>
    bool put(const KeyInput& k, const ValueInput& v) {
        return map.put(k, v);
    }

    template<typename KeyInput, typename ValueInput>
    bool putNew(const KeyInput& k, const ValueInput& v) {
        return map.putNew(k, v);
    }

    Ptr lookupWithDefault(const Key& k, const Value& defaultValue) {
        return map.lookupWithDefault(k, defaultValue);
    }

    void remove(const Lookup& l) {
        map.remove(l);
    }

    friend void AutoGCRooter::trace(JSTracer* trc);

  private:
    AutoHashMapRooter(const AutoHashMapRooter& hmr) = delete;
    AutoHashMapRooter& operator=(const AutoHashMapRooter& hmr) = delete;

    HashMapImpl map;


};

template<class T>
class AutoHashSetRooter : protected AutoGCRooter
{
  private:
    typedef js::HashSet<T> HashSetImpl;

  public:
    explicit AutoHashSetRooter(JSContext* cx, ptrdiff_t tag
                                                              )
      : AutoGCRooter(cx, tag), set(cx)
    {
        do { } while (0);
    }

    typedef typename HashSetImpl::Lookup Lookup;
    typedef typename HashSetImpl::Ptr Ptr;
    typedef typename HashSetImpl::AddPtr AddPtr;

    bool init(uint32_t len = 16) {
        return set.init(len);
    }
    bool initialized() const {
        return set.initialized();
    }
    Ptr lookup(const Lookup& l) const {
        return set.lookup(l);
    }
    void remove(Ptr p) {
        set.remove(p);
    }
    AddPtr lookupForAdd(const Lookup& l) const {
        return set.lookupForAdd(l);
    }

    bool add(AddPtr& p, const T& t) {
        return set.add(p, t);
    }

    bool relookupOrAdd(AddPtr& p, const Lookup& l, const T& t) {
        return set.relookupOrAdd(p, l, t);
    }

    typedef typename HashSetImpl::Range Range;
    Range all() const {
        return set.all();
    }

    typedef typename HashSetImpl::Enum Enum;

    void clear() {
        set.clear();
    }

    void finish() {
        set.finish();
    }

    bool empty() const {
        return set.empty();
    }

    uint32_t count() const {
        return set.count();
    }

    size_t capacity() const {
        return set.capacity();
    }

    size_t sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
        return set.sizeOfExcludingThis(mallocSizeOf);
    }
    size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
        return set.sizeOfIncludingThis(mallocSizeOf);
    }



    bool has(const Lookup& l) const {
        return set.has(l);
    }

    bool put(const T& t) {
        return set.put(t);
    }

    bool putNew(const T& t) {
        return set.putNew(t);
    }

    void remove(const Lookup& l) {
        set.remove(l);
    }

    friend void AutoGCRooter::trace(JSTracer* trc);

  private:
    AutoHashSetRooter(const AutoHashSetRooter& hmr) = delete;
    AutoHashSetRooter& operator=(const AutoHashSetRooter& hmr) = delete;

    HashSetImpl set;


};




class CustomAutoRooter : private AutoGCRooter
{
  public:
    template <typename CX>
    explicit CustomAutoRooter(const CX& cx )
      : AutoGCRooter(cx, CUSTOM)
    {
        do { } while (0);
    }

    friend void AutoGCRooter::trace(JSTracer* trc);

  protected:
    virtual ~CustomAutoRooter() {}


    virtual void trace(JSTracer* trc) = 0;

  private:

};


class HandleValueArray
{
    const size_t length_;
    const Value * const elements_;

    HandleValueArray(size_t len, const Value* elements) : length_(len), elements_(elements) {}

  public:
    explicit HandleValueArray(const RootedValue& value) : length_(1), elements_(value.address()) {}

                 HandleValueArray(const AutoValueVector& values)
      : length_(values.length()), elements_(values.begin()) {}

    template <size_t N>
                 HandleValueArray(const AutoValueArray<N>& values) : length_(N), elements_(values.begin()) {}


                 HandleValueArray(const JS::CallArgs& args) : length_(args.length()), elements_(args.array()) {}


    static HandleValueArray fromMarkedLocation(size_t len, const Value* elements) {
        return HandleValueArray(len, elements);
    }

    static HandleValueArray subarray(const HandleValueArray& values, size_t startIndex, size_t len) {
        do { } while (0);
        return HandleValueArray(len, values.begin() + startIndex);
    }

    static HandleValueArray empty() {
        return HandleValueArray(0, nullptr);
    }

    size_t length() const { return length_; }
    const Value* begin() const { return elements_; }

    HandleValue operator[](size_t i) const {
        do { } while (0);
        return HandleValue::fromMarkedLocation(&elements_[i]);
    }
};

}



struct JSFreeOp {
  protected:
    JSRuntime* runtime_;

    explicit JSFreeOp(JSRuntime* rt)
      : runtime_(rt) { }

  public:
    JSRuntime* runtime() const {
        do { } while (0);
        return runtime_;
    }
};





typedef enum JSGCStatus {
    JSGC_BEGIN,
    JSGC_END
} JSGCStatus;

typedef void
(* JSGCCallback)(JSContext* cx, JSGCStatus status, void* data);

typedef void
(* JSObjectsTenuredCallback)(JSContext* cx, void* data);

typedef enum JSFinalizeStatus {





    JSFINALIZE_GROUP_START,







    JSFINALIZE_GROUP_END,




    JSFINALIZE_COLLECTION_END
} JSFinalizeStatus;

typedef void
(* JSFinalizeCallback)(JSFreeOp* fop, JSFinalizeStatus status, bool isZoneGC, void* data);

typedef void
(* JSWeakPointerZonesCallback)(JSContext* cx, void* data);

typedef void
(* JSWeakPointerCompartmentCallback)(JSContext* cx, JSCompartment* comp, void* data);

typedef bool
(* JSInterruptCallback)(JSContext* cx);

typedef JSObject*
(* JSGetIncumbentGlobalCallback)(JSContext* cx);

typedef bool
(* JSEnqueuePromiseJobCallback)(JSContext* cx, JS::HandleObject job,
                                JS::HandleObject allocationSite, JS::HandleObject incumbentGlobal,
                                void* data);

enum class PromiseRejectionHandlingState {
    Unhandled,
    Handled
};

typedef void
(* JSPromiseRejectionTrackerCallback)(JSContext* cx, JS::HandleObject promise,
                                      PromiseRejectionHandlingState state, void* data);

typedef void
(* JSProcessPromiseCallback)(JSContext* cx, JS::HandleObject promise);
typedef enum JSExnType {
    JSEXN_ERR,
    JSEXN_FIRST = JSEXN_ERR,
        JSEXN_INTERNALERR,
        JSEXN_EVALERR,
        JSEXN_RANGEERR,
        JSEXN_REFERENCEERR,
        JSEXN_SYNTAXERR,
        JSEXN_TYPEERR,
        JSEXN_URIERR,
        JSEXN_DEBUGGEEWOULDRUN,
        JSEXN_WASMCOMPILEERROR,
        JSEXN_WASMLINKERROR,
        JSEXN_WASMRUNTIMEERROR,
    JSEXN_ERROR_LIMIT,
    JSEXN_WARN = JSEXN_ERROR_LIMIT,
    JSEXN_NOTE,
    JSEXN_LIMIT
} JSExnType;

typedef struct JSErrorFormatString {

    const char* name;


    const char* format;


    uint16_t argCount;


    int16_t exnType;
} JSErrorFormatString;

typedef const JSErrorFormatString*
(* JSErrorCallback)(void* userRef, const unsigned errorNumber);

typedef bool
(* JSLocaleToUpperCase)(JSContext* cx, JS::HandleString src, JS::MutableHandleValue rval);

typedef bool
(* JSLocaleToLowerCase)(JSContext* cx, JS::HandleString src, JS::MutableHandleValue rval);

typedef bool
(* JSLocaleCompare)(JSContext* cx, JS::HandleString src1, JS::HandleString src2,
                    JS::MutableHandleValue rval);

typedef bool
(* JSLocaleToUnicode)(JSContext* cx, const char* src, JS::MutableHandleValue rval);
typedef JSObject*
(* JSWrapObjectCallback)(JSContext* cx, JS::HandleObject existing, JS::HandleObject obj);






typedef void
(* JSPreWrapCallback)(JSContext* cx, JS::HandleObject scope, JS::HandleObject obj,
                      JS::HandleObject objectPassedToWrap,
                      JS::MutableHandleObject retObj);

struct JSWrapObjectCallbacks
{
    JSWrapObjectCallback wrap;
    JSPreWrapCallback preWrap;
};

typedef void
(* JSDestroyCompartmentCallback)(JSFreeOp* fop, JSCompartment* compartment);

typedef size_t
(* JSSizeOfIncludingThisCompartmentCallback)(mozilla::MallocSizeOf mallocSizeOf,
                                             JSCompartment* compartment);

typedef void
(* JSZoneCallback)(JS::Zone* zone);

typedef void
(* JSCompartmentNameCallback)(JSContext* cx, JSCompartment* compartment,
                              char* buf, size_t bufsize);
using JSExternalStringSizeofCallback =
    size_t (*)(JSString* str, mozilla::MallocSizeOf mallocSizeOf);



static __attribute__((always_inline)) inline JS::Value
JS_NumberValue(double d)
{
    int32_t i;
    d = JS::CanonicalizeNaN(d);
    if (mozilla::NumberIsInt32(d, &i))
        return JS::Int32Value(i);
    return JS::DoubleValue(d);
}



bool
JS_StringHasBeenPinned(JSContext* cx, JSString* str);

namespace JS {
class SourceBufferHolder final
{
  public:
    enum Ownership {
      NoOwnership,
      GiveOwnership
    };

    SourceBufferHolder(const char16_t* data, size_t dataLength, Ownership ownership)
      : data_(data),
        length_(dataLength),
        ownsChars_(ownership == GiveOwnership)
    {


        static const char16_t NullChar_ = 0;
        if (!get()) {
            data_ = &NullChar_;
            length_ = 0;
            ownsChars_ = false;
        }
    }

    SourceBufferHolder(SourceBufferHolder&& other)
      : data_(other.data_),
        length_(other.length_),
        ownsChars_(other.ownsChars_)
    {
        other.data_ = nullptr;
        other.length_ = 0;
        other.ownsChars_ = false;
    }

    ~SourceBufferHolder() {
        if (ownsChars_)
            js_free(const_cast<char16_t*>(data_));
    }


    const char16_t* get() const { return data_; }


    size_t length() const { return length_; }



    bool ownsChars() const { return ownsChars_; }
    char16_t* take() {
        do { } while (0);
        ownsChars_ = false;
        return const_cast<char16_t*>(data_);
    }

  private:
    SourceBufferHolder(SourceBufferHolder&) = delete;
    SourceBufferHolder& operator=(SourceBufferHolder&) = delete;

    const char16_t* data_;
    size_t length_;
    bool ownsChars_;
};

}
extern int64_t
JS_Now(void);


extern JS::Value
JS_GetNaNValue(JSContext* cx);

extern JS::Value
JS_GetNegativeInfinityValue(JSContext* cx);

extern JS::Value
JS_GetPositiveInfinityValue(JSContext* cx);

extern JS::Value
JS_GetEmptyStringValue(JSContext* cx);

extern JSString*
JS_GetEmptyString(JSContext* cx);

extern bool
JS_ValueToObject(JSContext* cx, JS::HandleValue v, JS::MutableHandleObject objp);

extern JSFunction*
JS_ValueToFunction(JSContext* cx, JS::HandleValue v);

extern JSFunction*
JS_ValueToConstructor(JSContext* cx, JS::HandleValue v);

extern JSString*
JS_ValueToSource(JSContext* cx, JS::Handle<JS::Value> v);

extern bool
JS_DoubleIsInt32(double d, int32_t* ip);

extern JSType
JS_TypeOfValue(JSContext* cx, JS::Handle<JS::Value> v);

namespace JS {

extern const char*
InformalValueTypeName(const JS::Value& v);

}

extern bool
JS_StrictlyEqual(JSContext* cx, JS::Handle<JS::Value> v1, JS::Handle<JS::Value> v2, bool* equal);

extern bool
JS_LooselyEqual(JSContext* cx, JS::Handle<JS::Value> v1, JS::Handle<JS::Value> v2, bool* equal);

extern bool
JS_SameValue(JSContext* cx, JS::Handle<JS::Value> v1, JS::Handle<JS::Value> v2, bool* same);


extern bool
JS_IsBuiltinEvalFunction(JSFunction* fun);


extern bool
JS_IsBuiltinFunctionConstructor(JSFunction* fun);
extern JSContext*
JS_NewContext(uint32_t maxbytes,
              uint32_t maxNurseryBytes = JS::DefaultNurseryBytes,
              JSRuntime* parentRuntime = nullptr);







extern void
JS_YieldCooperativeContext(JSContext* cx);



extern void
JS_ResumeCooperativeContext(JSContext* cx);





extern JSContext*
JS_NewCooperativeContext(JSContext* siblingContext);




extern void
JS_DestroyContext(JSContext* cx);

void*
JS_GetContextPrivate(JSContext* cx);

void
JS_SetContextPrivate(JSContext* cx, void* data);

extern JSRuntime*
JS_GetParentRuntime(JSContext* cx);

extern void
JS_BeginRequest(JSContext* cx);

extern void
JS_EndRequest(JSContext* cx);

extern void
JS_SetFutexCanWait(JSContext* cx);

namespace JS {
typedef void (*BeginSingleThreadedExecutionCallback)(JSContext* cx);
typedef void (*EndSingleThreadedExecutionCallback)(JSContext* cx);

extern void
SetSingleThreadedExecutionCallbacks(JSContext* cx,
                                    BeginSingleThreadedExecutionCallback begin,
                                    EndSingleThreadedExecutionCallback end);

}

namespace js {

void
AssertHeapIsIdle();

}

class JSAutoRequest
{
  public:
    explicit JSAutoRequest(JSContext* cx
                                                          )
      : mContext(cx)
    {
        do { } while (0);
        JS_BeginRequest(mContext);
    }
    ~JSAutoRequest() {
        JS_EndRequest(mContext);
    }

  protected:
    JSContext* mContext;







};

extern JSVersion
JS_GetVersion(JSContext* cx);
void
JS_SetVersionForCompartment(JSCompartment* compartment, JSVersion version);

extern const char*
JS_VersionToString(JSVersion version);

extern JSVersion
JS_StringToVersion(const char* string);

namespace JS {

class ContextOptions {
  public:
    ContextOptions()
      : baseline_(true),
        ion_(true),
        asmJS_(true),
        wasm_(false),
        wasmAlwaysBaseline_(false),
        throwOnAsmJSValidationFailure_(false),
        nativeRegExp_(true),
        unboxedArrays_(false),
        asyncStack_(true),
        throwOnDebuggeeWouldRun_(true),
        dumpStackOnDebuggeeWouldRun_(false),
        werror_(false),
        strictMode_(false),
        extraWarnings_(false),

        forEachStatement_(false)



    {
    }

    bool baseline() const { return baseline_; }
    ContextOptions& setBaseline(bool flag) {
        baseline_ = flag;
        return *this;
    }
    ContextOptions& toggleBaseline() {
        baseline_ = !baseline_;
        return *this;
    }

    bool ion() const { return ion_; }
    ContextOptions& setIon(bool flag) {
        ion_ = flag;
        return *this;
    }
    ContextOptions& toggleIon() {
        ion_ = !ion_;
        return *this;
    }

    bool asmJS() const { return asmJS_; }
    ContextOptions& setAsmJS(bool flag) {
        asmJS_ = flag;
        return *this;
    }
    ContextOptions& toggleAsmJS() {
        asmJS_ = !asmJS_;
        return *this;
    }

    bool wasm() const { return wasm_; }
    ContextOptions& setWasm(bool flag) {
        wasm_ = flag;
        return *this;
    }
    ContextOptions& toggleWasm() {
        wasm_ = !wasm_;
        return *this;
    }

    bool wasmAlwaysBaseline() const { return wasmAlwaysBaseline_; }
    ContextOptions& setWasmAlwaysBaseline(bool flag) {
        wasmAlwaysBaseline_ = flag;
        return *this;
    }
    ContextOptions& toggleWasmAlwaysBaseline() {
        wasmAlwaysBaseline_ = !wasmAlwaysBaseline_;
        return *this;
    }

    bool throwOnAsmJSValidationFailure() const { return throwOnAsmJSValidationFailure_; }
    ContextOptions& setThrowOnAsmJSValidationFailure(bool flag) {
        throwOnAsmJSValidationFailure_ = flag;
        return *this;
    }
    ContextOptions& toggleThrowOnAsmJSValidationFailure() {
        throwOnAsmJSValidationFailure_ = !throwOnAsmJSValidationFailure_;
        return *this;
    }

    bool nativeRegExp() const { return nativeRegExp_; }
    ContextOptions& setNativeRegExp(bool flag) {
        nativeRegExp_ = flag;
        return *this;
    }

    bool unboxedArrays() const { return unboxedArrays_; }
    ContextOptions& setUnboxedArrays(bool flag) {
        unboxedArrays_ = flag;
        return *this;
    }

    bool asyncStack() const { return asyncStack_; }
    ContextOptions& setAsyncStack(bool flag) {
        asyncStack_ = flag;
        return *this;
    }

    bool throwOnDebuggeeWouldRun() const { return throwOnDebuggeeWouldRun_; }
    ContextOptions& setThrowOnDebuggeeWouldRun(bool flag) {
        throwOnDebuggeeWouldRun_ = flag;
        return *this;
    }

    bool dumpStackOnDebuggeeWouldRun() const { return dumpStackOnDebuggeeWouldRun_; }
    ContextOptions& setDumpStackOnDebuggeeWouldRun(bool flag) {
        dumpStackOnDebuggeeWouldRun_ = flag;
        return *this;
    }

    bool werror() const { return werror_; }
    ContextOptions& setWerror(bool flag) {
        werror_ = flag;
        return *this;
    }
    ContextOptions& toggleWerror() {
        werror_ = !werror_;
        return *this;
    }

    bool strictMode() const { return strictMode_; }
    ContextOptions& setStrictMode(bool flag) {
        strictMode_ = flag;
        return *this;
    }
    ContextOptions& toggleStrictMode() {
        strictMode_ = !strictMode_;
        return *this;
    }

    bool extraWarnings() const { return extraWarnings_; }
    ContextOptions& setExtraWarnings(bool flag) {
        extraWarnings_ = flag;
        return *this;
    }
    ContextOptions& toggleExtraWarnings() {
        extraWarnings_ = !extraWarnings_;
        return *this;
    }

    bool forEachStatement() const { return forEachStatement_; }
    ContextOptions& setForEachStatement(bool flag) {
        forEachStatement_ = flag;
        return *this;
    }
  private:
    bool baseline_ : 1;
    bool ion_ : 1;
    bool asmJS_ : 1;
    bool wasm_ : 1;
    bool wasmAlwaysBaseline_ : 1;
    bool throwOnAsmJSValidationFailure_ : 1;
    bool nativeRegExp_ : 1;
    bool unboxedArrays_ : 1;
    bool asyncStack_ : 1;
    bool throwOnDebuggeeWouldRun_ : 1;
    bool dumpStackOnDebuggeeWouldRun_ : 1;
    bool werror_ : 1;
    bool strictMode_ : 1;
    bool extraWarnings_ : 1;
    bool forEachStatement_: 1;




};

ContextOptions&
ContextOptionsRef(JSContext* cx);






bool
InitSelfHostedCode(JSContext* cx);





void
AssertObjectBelongsToCurrentThread(JSObject* obj);

}

extern const char*
JS_GetImplementationVersion(void);

extern void
JS_SetDestroyCompartmentCallback(JSContext* cx, JSDestroyCompartmentCallback callback);

extern void
JS_SetSizeOfIncludingThisCompartmentCallback(JSContext* cx,
                                             JSSizeOfIncludingThisCompartmentCallback callback);

extern void
JS_SetDestroyZoneCallback(JSContext* cx, JSZoneCallback callback);

extern void
JS_SetSweepZoneCallback(JSContext* cx, JSZoneCallback callback);

extern void
JS_SetCompartmentNameCallback(JSContext* cx, JSCompartmentNameCallback callback);

extern void
JS_SetWrapObjectCallbacks(JSContext* cx, const JSWrapObjectCallbacks* callbacks);

extern void
JS_SetExternalStringSizeofCallback(JSContext* cx, JSExternalStringSizeofCallback callback);

extern void
JS_SetCompartmentPrivate(JSCompartment* compartment, void* data);

extern void*
JS_GetCompartmentPrivate(JSCompartment* compartment);

extern void
JS_SetZoneUserData(JS::Zone* zone, void* data);

extern void*
JS_GetZoneUserData(JS::Zone* zone);

extern bool
JS_WrapObject(JSContext* cx, JS::MutableHandleObject objp);

extern bool
JS_WrapValue(JSContext* cx, JS::MutableHandleValue vp);

extern JSObject*
JS_TransplantObject(JSContext* cx, JS::HandleObject origobj, JS::HandleObject target);

extern bool
JS_RefreshCrossCompartmentWrappers(JSContext* cx, JS::Handle<JSObject*> obj);
class JSAutoCompartment
{
    JSContext* cx_;
    JSCompartment* oldCompartment_;
  public:
    JSAutoCompartment(JSContext* cx, JSObject* target
                                                     );
    JSAutoCompartment(JSContext* cx, JSScript* target
                                                     );
    ~JSAutoCompartment();


};

class JSAutoNullableCompartment
{
    JSContext* cx_;
    JSCompartment* oldCompartment_;
  public:
    explicit JSAutoNullableCompartment(JSContext* cx, JSObject* targetOrNull
                                                                      );
    ~JSAutoNullableCompartment();


};


extern JSCompartment*
JS_EnterCompartment(JSContext* cx, JSObject* target);

extern void
JS_LeaveCompartment(JSContext* cx, JSCompartment* oldCompartment);

typedef void (*JSIterateCompartmentCallback)(JSContext* cx, void* data, JSCompartment* compartment);






extern void
JS_IterateCompartments(JSContext* cx, void* data,
                       JSIterateCompartmentCallback compartmentCallback);







extern void
JS_MarkCrossZoneId(JSContext* cx, jsid id);





extern void
JS_MarkCrossZoneIdValue(JSContext* cx, const JS::Value& value);
extern bool
JS_InitStandardClasses(JSContext* cx, JS::Handle<JSObject*> obj);
extern bool
JS_ResolveStandardClass(JSContext* cx, JS::HandleObject obj, JS::HandleId id, bool* resolved);

extern bool
JS_MayResolveStandardClass(const JSAtomState& names, jsid id, JSObject* maybeObj);

extern bool
JS_EnumerateStandardClasses(JSContext* cx, JS::HandleObject obj);

extern bool
JS_GetClassObject(JSContext* cx, JSProtoKey key, JS::MutableHandle<JSObject*> objp);

extern bool
JS_GetClassPrototype(JSContext* cx, JSProtoKey key, JS::MutableHandle<JSObject*> objp);

namespace JS {






extern JSProtoKey
IdentifyStandardInstance(JSObject* obj);

extern JSProtoKey
IdentifyStandardPrototype(JSObject* obj);

extern JSProtoKey
IdentifyStandardInstanceOrPrototype(JSObject* obj);

extern JSProtoKey
IdentifyStandardConstructor(JSObject* obj);

extern void
ProtoKeyToId(JSContext* cx, JSProtoKey key, JS::MutableHandleId idp);

}

extern JSProtoKey
JS_IdToProtoKey(JSContext* cx, JS::HandleId id);





extern JSObject*
JS_GetFunctionPrototype(JSContext* cx, JS::HandleObject forObj);





extern JSObject*
JS_GetObjectPrototype(JSContext* cx, JS::HandleObject forObj);





extern JSObject*
JS_GetArrayPrototype(JSContext* cx, JS::HandleObject forObj);





extern JSObject*
JS_GetErrorPrototype(JSContext* cx);





extern JSObject*
JS_GetIteratorPrototype(JSContext* cx);

extern JSObject*
JS_GetGlobalForObject(JSContext* cx, JSObject* obj);

extern bool
JS_IsGlobalObject(JSObject* obj);

extern JSObject*
JS_GlobalLexicalEnvironment(JSObject* obj);

extern bool
JS_HasExtensibleLexicalEnvironment(JSObject* obj);

extern JSObject*
JS_ExtensibleLexicalEnvironment(JSObject* obj);





extern JSObject*
JS_GetGlobalForCompartmentOrNull(JSContext* cx, JSCompartment* c);

namespace JS {

extern JSObject*
CurrentGlobalOrNull(JSContext* cx);

}





extern bool
JS_InitReflectParse(JSContext* cx, JS::HandleObject global);





extern bool
JS_DefineProfilingFunctions(JSContext* cx, JS::HandleObject obj);


extern bool
JS_DefineDebuggerObject(JSContext* cx, JS::HandleObject obj);






extern bool
JS_InitCTypesClass(JSContext* cx, JS::HandleObject global);






typedef char*
(* JSCTypesUnicodeToNativeFun)(JSContext* cx, const char16_t* source, size_t slen);






struct JSCTypesCallbacks {
    JSCTypesUnicodeToNativeFun unicodeToNative;
};

typedef struct JSCTypesCallbacks JSCTypesCallbacks;







extern void
JS_SetCTypesCallbacks(JSObject* ctypesObj, const JSCTypesCallbacks* callbacks);


extern void*
JS_malloc(JSContext* cx, size_t nbytes);

extern void*
JS_realloc(JSContext* cx, void* p, size_t oldBytes, size_t newBytes);






extern void
JS_free(JSContext* cx, void* p);





extern void
JS_freeop(JSFreeOp* fop, void* p);

extern void
JS_updateMallocCounter(JSContext* cx, size_t nbytes);

extern char*
JS_strdup(JSContext* cx, const char* s);
extern bool
JS_AddExtraGCRootsTracer(JSContext* cx, JSTraceDataOp traceOp, void* data);


extern void
JS_RemoveExtraGCRootsTracer(JSContext* cx, JSTraceDataOp traceOp, void* data);




extern void
JS_GC(JSContext* cx);

extern void
JS_MaybeGC(JSContext* cx);

extern void
JS_SetGCCallback(JSContext* cx, JSGCCallback cb, void* data);

extern void
JS_SetObjectsTenuredCallback(JSContext* cx, JSObjectsTenuredCallback cb,
                             void* data);

extern bool
JS_AddFinalizeCallback(JSContext* cx, JSFinalizeCallback cb, void* data);

extern void
JS_RemoveFinalizeCallback(JSContext* cx, JSFinalizeCallback cb);
extern bool
JS_AddWeakPointerZonesCallback(JSContext* cx, JSWeakPointerZonesCallback cb, void* data);

extern void
JS_RemoveWeakPointerZonesCallback(JSContext* cx, JSWeakPointerZonesCallback cb);

extern bool
JS_AddWeakPointerCompartmentCallback(JSContext* cx, JSWeakPointerCompartmentCallback cb,
                                     void* data);

extern void
JS_RemoveWeakPointerCompartmentCallback(JSContext* cx, JSWeakPointerCompartmentCallback cb);

extern void
JS_UpdateWeakPointerAfterGC(JS::Heap<JSObject*>* objp);

extern void
JS_UpdateWeakPointerAfterGCUnbarriered(JSObject** objp);

typedef enum JSGCParamKey {

    JSGC_MAX_BYTES = 0,


    JSGC_MAX_MALLOC_BYTES = 1,


    JSGC_MAX_NURSERY_BYTES = 2,


    JSGC_BYTES = 3,


    JSGC_NUMBER = 4,


    JSGC_MODE = 6,


    JSGC_UNUSED_CHUNKS = 7,


    JSGC_TOTAL_CHUNKS = 8,


    JSGC_SLICE_TIME_BUDGET = 9,


    JSGC_MARK_STACK_LIMIT = 10,





    JSGC_HIGH_FREQUENCY_TIME_LIMIT = 11,


    JSGC_HIGH_FREQUENCY_LOW_LIMIT = 12,


    JSGC_HIGH_FREQUENCY_HIGH_LIMIT = 13,


    JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX = 14,


    JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN = 15,


    JSGC_LOW_FREQUENCY_HEAP_GROWTH = 16,





    JSGC_DYNAMIC_HEAP_GROWTH = 17,


    JSGC_DYNAMIC_MARK_SLICE = 18,


    JSGC_ALLOCATION_THRESHOLD = 19,





    JSGC_MIN_EMPTY_CHUNK_COUNT = 21,


    JSGC_MAX_EMPTY_CHUNK_COUNT = 22,


    JSGC_COMPACTING_ENABLED = 23,


    JSGC_REFRESH_FRAME_SLICES_ENABLED = 24,
} JSGCParamKey;

extern void
JS_SetGCParameter(JSContext* cx, JSGCParamKey key, uint32_t value);

extern uint32_t
JS_GetGCParameter(JSContext* cx, JSGCParamKey key);

extern void
JS_SetGCParametersBasedOnAvailableMemory(JSContext* cx, uint32_t availMem);





extern JSString*
JS_NewExternalString(JSContext* cx, const char16_t* chars, size_t length,
                     const JSStringFinalizer* fin);
extern JSString*
JS_NewMaybeExternalString(JSContext* cx, const char16_t* chars, size_t length,
                          const JSStringFinalizer* fin, bool* isExternal);





extern bool
JS_IsExternalString(JSString* str);




extern const JSStringFinalizer*
JS_GetExternalStringFinalizer(JSString* str);
extern void
JS_SetNativeStackQuota(JSContext* cx, size_t systemCodeStackSize,
                       size_t trustedScriptStackSize = 0,
                       size_t untrustedScriptStackSize = 0);



extern bool
JS_ValueToId(JSContext* cx, JS::HandleValue v, JS::MutableHandleId idp);

extern bool
JS_StringToId(JSContext* cx, JS::HandleString s, JS::MutableHandleId idp);

extern bool
JS_IdToValue(JSContext* cx, jsid id, JS::MutableHandle<JS::Value> vp);

namespace JS {
extern bool
ToPrimitive(JSContext* cx, JS::HandleObject obj, JSType hint, JS::MutableHandleValue vp);
extern bool
GetFirstArgumentAsTypeHint(JSContext* cx, CallArgs args, JSType *result);

}

extern bool
JS_PropertyStub(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                JS::MutableHandleValue vp);

extern bool
JS_StrictPropertyStub(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                      JS::MutableHandleValue vp, JS::ObjectOpResult& result);

template<typename T>
struct JSConstScalarSpec {
    const char* name;
    T val;
};

typedef JSConstScalarSpec<double> JSConstDoubleSpec;
typedef JSConstScalarSpec<int32_t> JSConstIntegerSpec;

struct JSJitInfo;






typedef struct JSNativeWrapper {
    JSNative op;
    const JSJitInfo* info;
} JSNativeWrapper;
struct JSPropertySpec {
    struct SelfHostedWrapper {
        void* unused;
        const char* funname;
    };

    struct ValueWrapper {
        uintptr_t type;
        union {
            const char* string;
            int32_t int32;
        };
    };

    const char* name;
    uint8_t flags;
    union {
        struct {
            union {
                JSNativeWrapper native;
                SelfHostedWrapper selfHosted;
            } getter;
            union {
                JSNativeWrapper native;
                SelfHostedWrapper selfHosted;
            } setter;
        } accessors;
        ValueWrapper value;
    };

    bool isAccessor() const {
        return !(flags & 0x80);
    }
    bool getValue(JSContext* cx, JS::MutableHandleValue value) const;

    bool isSelfHosted() const {
        do { } while (0);
        return (flags & 0x10);
    }

    static_assert(sizeof(SelfHostedWrapper) == sizeof(JSNativeWrapper),
                  "JSPropertySpec::getter/setter must be compact");
    static_assert(__builtin_offsetof(SelfHostedWrapper, funname) == __builtin_offsetof(JSNativeWrapper, info),
                  "JS_SELF_HOSTED* macros below require that "
                  "SelfHostedWrapper::funname overlay "
                  "JSNativeWrapper::info");
private:
    void checkAccessorsAreNative() const {
        do { } while (0);




        do { } while (0);
    }

    void checkAccessorsAreSelfHosted() const {
        do { } while (0);
        do { } while (0);
    }
};

namespace JS {
namespace detail {


inline int CheckIsNative(JSNative native);


template<size_t N>
inline int
CheckIsCharacterLiteral(const char (&arr)[N]);


inline int CheckIsInt32(int32_t value);


inline int CheckIsGetterOp(JSGetterOp op);


inline int CheckIsSetterOp(JSSetterOp op);

}
}
struct JSFunctionSpec {
    const char* name;
    JSNativeWrapper call;
    uint16_t nargs;
    uint16_t flags;
    const char* selfHostedName;
};
extern JSObject*
JS_InitClass(JSContext* cx, JS::HandleObject obj, JS::HandleObject parent_proto,
             const JSClass* clasp, JSNative constructor, unsigned nargs,
             const JSPropertySpec* ps, const JSFunctionSpec* fs,
             const JSPropertySpec* static_ps, const JSFunctionSpec* static_fs);





extern bool
JS_LinkConstructorAndPrototype(JSContext* cx, JS::Handle<JSObject*> ctor,
                               JS::Handle<JSObject*> proto);

extern const JSClass*
JS_GetClass(JSObject* obj);

extern bool
JS_InstanceOf(JSContext* cx, JS::Handle<JSObject*> obj, const JSClass* clasp, JS::CallArgs* args);

extern bool
JS_HasInstance(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<JS::Value> v, bool* bp);

namespace JS {





extern bool
OrdinaryHasInstance(JSContext* cx, HandleObject objArg, HandleValue v, bool* bp);

}

extern void*
JS_GetPrivate(JSObject* obj);

extern void
JS_SetPrivate(JSObject* obj, void* data);

extern void*
JS_GetInstancePrivate(JSContext* cx, JS::Handle<JSObject*> obj, const JSClass* clasp,
                      JS::CallArgs* args);

extern JSObject*
JS_GetConstructor(JSContext* cx, JS::Handle<JSObject*> proto);

namespace JS {


enum ZoneSpecifier {


    SystemZone,


    ExistingZone,


    NewZoneInNewZoneGroup,


    NewZoneInSystemZoneGroup,


    NewZoneInExistingZoneGroup
};
class CompartmentCreationOptions
{
  public:
    CompartmentCreationOptions()
      : addonId_(nullptr),
        traceGlobal_(nullptr),
        zoneSpec_(NewZoneInSystemZoneGroup),
        zonePointer_(nullptr),
        invisibleToDebugger_(false),
        mergeable_(false),
        preserveJitCode_(false),
        cloneSingletons_(false),
        experimentalNumberFormatFormatToPartsEnabled_(false),
        sharedMemoryAndAtomics_(false),
        secureContext_(false)
    {}



    JSAddonId* addonIdOrNull() const { return addonId_; }
    CompartmentCreationOptions& setAddonId(JSAddonId* id) {
        addonId_ = id;
        return *this;
    }

    JSTraceOp getTrace() const {
        return traceGlobal_;
    }
    CompartmentCreationOptions& setTrace(JSTraceOp op) {
        traceGlobal_ = op;
        return *this;
    }

    void* zonePointer() const { return zonePointer_; }
    ZoneSpecifier zoneSpecifier() const { return zoneSpec_; }


    CompartmentCreationOptions& setSystemZone();
    CompartmentCreationOptions& setExistingZone(JSObject* obj);
    CompartmentCreationOptions& setNewZoneInNewZoneGroup();
    CompartmentCreationOptions& setNewZoneInSystemZoneGroup();
    CompartmentCreationOptions& setNewZoneInExistingZoneGroup(JSObject* obj);





    bool invisibleToDebugger() const { return invisibleToDebugger_; }
    CompartmentCreationOptions& setInvisibleToDebugger(bool flag) {
        invisibleToDebugger_ = flag;
        return *this;
    }





    bool mergeable() const { return mergeable_; }
    CompartmentCreationOptions& setMergeable(bool flag) {
        mergeable_ = flag;
        return *this;
    }



    bool preserveJitCode() const { return preserveJitCode_; }
    CompartmentCreationOptions& setPreserveJitCode(bool flag) {
        preserveJitCode_ = flag;
        return *this;
    }

    bool cloneSingletons() const { return cloneSingletons_; }
    CompartmentCreationOptions& setCloneSingletons(bool flag) {
        cloneSingletons_ = flag;
        return *this;
    }
    bool experimentalNumberFormatFormatToPartsEnabled() const {
        return experimentalNumberFormatFormatToPartsEnabled_;
    }
    CompartmentCreationOptions& setExperimentalNumberFormatFormatToPartsEnabled(bool flag) {
        experimentalNumberFormatFormatToPartsEnabled_ = flag;
        return *this;
    }

    bool getSharedMemoryAndAtomicsEnabled() const;
    CompartmentCreationOptions& setSharedMemoryAndAtomicsEnabled(bool flag);





    bool secureContext() const { return secureContext_; }
    CompartmentCreationOptions& setSecureContext(bool flag) {
        secureContext_ = flag;
        return *this;
    }

  private:
    JSAddonId* addonId_;
    JSTraceOp traceGlobal_;
    ZoneSpecifier zoneSpec_;
    void* zonePointer_;
    bool invisibleToDebugger_;
    bool mergeable_;
    bool preserveJitCode_;
    bool cloneSingletons_;
    bool experimentalNumberFormatFormatToPartsEnabled_;
    bool sharedMemoryAndAtomics_;
    bool secureContext_;
};





class CompartmentBehaviors
{
  public:
    class Override {
      public:
        Override() : mode_(Default) {}

        bool get(bool defaultValue) const {
            if (mode_ == Default)
                return defaultValue;
            return mode_ == ForceTrue;
        }

        void set(bool overrideValue) {
            mode_ = overrideValue ? ForceTrue : ForceFalse;
        }

        void reset() {
            mode_ = Default;
        }

      private:
        enum Mode {
            Default,
            ForceTrue,
            ForceFalse
        };

        Mode mode_;
    };

    CompartmentBehaviors()
      : version_(JSVERSION_UNKNOWN)
      , discardSource_(false)
      , disableLazyParsing_(false)
      , singletonsAsTemplates_(true)
    {
    }

    JSVersion version() const { return version_; }
    CompartmentBehaviors& setVersion(JSVersion aVersion) {
        do { } while (0);
        version_ = aVersion;
        return *this;
    }



    bool discardSource() const { return discardSource_; }
    CompartmentBehaviors& setDiscardSource(bool flag) {
        discardSource_ = flag;
        return *this;
    }

    bool disableLazyParsing() const { return disableLazyParsing_; }
    CompartmentBehaviors& setDisableLazyParsing(bool flag) {
        disableLazyParsing_ = flag;
        return *this;
    }

    bool extraWarnings(JSContext* cx) const;
    Override& extraWarningsOverride() { return extraWarningsOverride_; }

    bool getSingletonsAsTemplates() const {
        return singletonsAsTemplates_;
    }
    CompartmentBehaviors& setSingletonsAsValues() {
        singletonsAsTemplates_ = false;
        return *this;
    }

  private:
    JSVersion version_;
    bool discardSource_;
    bool disableLazyParsing_;
    Override extraWarningsOverride_;




    bool singletonsAsTemplates_;
};







class CompartmentOptions
{
  public:
    explicit CompartmentOptions()
      : creationOptions_(),
        behaviors_()
    {}

    CompartmentOptions(const CompartmentCreationOptions& compartmentCreation,
                       const CompartmentBehaviors& compartmentBehaviors)
      : creationOptions_(compartmentCreation),
        behaviors_(compartmentBehaviors)
    {}




    CompartmentCreationOptions& creationOptions() {
        return creationOptions_;
    }
    const CompartmentCreationOptions& creationOptions() const {
        return creationOptions_;
    }



    CompartmentBehaviors& behaviors() {
        return behaviors_;
    }
    const CompartmentBehaviors& behaviors() const {
        return behaviors_;
    }

  private:
    CompartmentCreationOptions creationOptions_;
    CompartmentBehaviors behaviors_;
};

const CompartmentCreationOptions&
CompartmentCreationOptionsRef(JSCompartment* compartment);

const CompartmentCreationOptions&
CompartmentCreationOptionsRef(JSObject* obj);

const CompartmentCreationOptions&
CompartmentCreationOptionsRef(JSContext* cx);

CompartmentBehaviors&
CompartmentBehaviorsRef(JSCompartment* compartment);

CompartmentBehaviors&
CompartmentBehaviorsRef(JSObject* obj);

CompartmentBehaviors&
CompartmentBehaviorsRef(JSContext* cx);
enum OnNewGlobalHookOption {
    FireOnNewGlobalHook,
    DontFireOnNewGlobalHook
};

}

extern JSObject*
JS_NewGlobalObject(JSContext* cx, const JSClass* clasp, JSPrincipals* principals,
                   JS::OnNewGlobalHookOption hookOption,
                   const JS::CompartmentOptions& options);
extern void
JS_GlobalObjectTraceHook(JSTracer* trc, JSObject* global);

extern void
JS_FireOnNewGlobalObject(JSContext* cx, JS::HandleObject global);

extern JSObject*
JS_NewObject(JSContext* cx, const JSClass* clasp);

extern bool
JS_IsNative(JSObject* obj);





extern JSObject*
JS_NewObjectWithGivenProto(JSContext* cx, const JSClass* clasp, JS::Handle<JSObject*> proto);


extern JSObject*
JS_NewPlainObject(JSContext* cx);






extern bool
JS_DeepFreezeObject(JSContext* cx, JS::Handle<JSObject*> obj);




extern bool
JS_FreezeObject(JSContext* cx, JS::Handle<JSObject*> obj);




namespace JS {

struct PropertyDescriptor {
    JSObject* obj;
    unsigned attrs;
    JSGetterOp getter;
    JSSetterOp setter;
    JS::Value value;

    PropertyDescriptor()
      : obj(nullptr), attrs(0), getter(nullptr), setter(nullptr), value(JS::UndefinedValue())
    {}

    static void trace(PropertyDescriptor* self, JSTracer* trc) { self->trace(trc); }
    void trace(JSTracer* trc);
};

}

namespace js {

template <typename Wrapper>
class WrappedPtrOperations<JS::PropertyDescriptor, Wrapper>
{
    const JS::PropertyDescriptor& desc() const { return static_cast<const Wrapper*>(this)->get(); }

    bool has(unsigned bit) const {
        do { } while (0);
        do { } while (0);
        return (desc().attrs & bit) != 0;
    }

    bool hasAny(unsigned bits) const {
        return (desc().attrs & bits) != 0;
    }

    bool hasAll(unsigned bits) const {
        return (desc().attrs & bits) == bits;
    }


    enum { SHADOWABLE = 0x80 };

  public:


    bool isAccessorDescriptor() const { return hasAny(0x10 | 0x20); }
    bool isGenericDescriptor() const {
        return (desc().attrs&
                (0x10 | 0x20 | 0x8000 | 0x20000)) ==
               (0x8000 | 0x20000);
    }
    bool isDataDescriptor() const { return !isAccessorDescriptor() && !isGenericDescriptor(); }

    bool hasConfigurable() const { return !has(0x10000); }
    bool configurable() const { do { } while (0); return !has(0x04); }

    bool hasEnumerable() const { return !has(0x4000); }
    bool enumerable() const { do { } while (0); return has(0x01); }

    bool hasValue() const { return !isAccessorDescriptor() && !has(0x20000); }
    JS::HandleValue value() const {
        return JS::HandleValue::fromMarkedLocation(&desc().value);
    }

    bool hasWritable() const { return !isAccessorDescriptor() && !has(0x8000); }
    bool writable() const { do { } while (0); return !has(0x02); }

    bool hasGetterObject() const { return has(0x10); }
    JS::HandleObject getterObject() const {
        do { } while (0);
        return JS::HandleObject::fromMarkedLocation(
                reinterpret_cast<JSObject* const*>(&desc().getter));
    }
    bool hasSetterObject() const { return has(0x20); }
    JS::HandleObject setterObject() const {
        do { } while (0);
        return JS::HandleObject::fromMarkedLocation(
                reinterpret_cast<JSObject* const*>(&desc().setter));
    }

    bool hasGetterOrSetter() const { return desc().getter || desc().setter; }
    bool isShared() const { return has(0x40); }

    JS::HandleObject object() const {
        return JS::HandleObject::fromMarkedLocation(&desc().obj);
    }
    unsigned attributes() const { return desc().attrs; }
    JSGetterOp getter() const { return desc().getter; }
    JSSetterOp setter() const { return desc().setter; }

    void assertValid() const {
    }

    void assertComplete() const {
    }

    void assertCompleteIfFound() const {




    }
};

template <typename Wrapper>
class MutableWrappedPtrOperations<JS::PropertyDescriptor, Wrapper>
    : public js::WrappedPtrOperations<JS::PropertyDescriptor, Wrapper>
{
    JS::PropertyDescriptor& desc() { return static_cast<Wrapper*>(this)->get(); }

  public:
    void clear() {
        object().set(nullptr);
        setAttributes(0);
        setGetter(nullptr);
        setSetter(nullptr);
        value().setUndefined();
    }

    void initFields(JS::HandleObject obj, JS::HandleValue v, unsigned attrs,
                    JSGetterOp getterOp, JSSetterOp setterOp) {
        do { } while (0);
        do { } while (0);

        object().set(obj);
        value().set(v);
        setAttributes(attrs);
        setGetter(getterOp);
        setSetter(setterOp);
    }

    void assign(JS::PropertyDescriptor& other) {
        object().set(other.obj);
        setAttributes(other.attrs);
        setGetter(other.getter);
        setSetter(other.setter);
        value().set(other.value);
    }

    void setDataDescriptor(JS::HandleValue v, unsigned attrs) {
        do { } while (0);





        object().set(nullptr);
        setAttributes(attrs);
        setGetter(nullptr);
        setSetter(nullptr);
        value().set(v);
    }

    JS::MutableHandleObject object() {
        return JS::MutableHandleObject::fromMarkedLocation(&desc().obj);
    }
    unsigned& attributesRef() { return desc().attrs; }
    JSGetterOp& getter() { return desc().getter; }
    JSSetterOp& setter() { return desc().setter; }
    JS::MutableHandleValue value() {
        return JS::MutableHandleValue::fromMarkedLocation(&desc().value);
    }
    void setValue(JS::HandleValue v) {
        do { } while (0);
        attributesRef() &= ~0x20000;
        value().set(v);
    }

    void setConfigurable(bool configurable) {
        setAttributes((desc().attrs & ~(0x10000 | 0x04)) |
                      (configurable ? 0 : 0x04));
    }
    void setEnumerable(bool enumerable) {
        setAttributes((desc().attrs & ~(0x4000 | 0x01)) |
                      (enumerable ? 0x01 : 0));
    }
    void setWritable(bool writable) {
        do { } while (0);
        setAttributes((desc().attrs & ~(0x8000 | 0x02)) |
                      (writable ? 0 : 0x02));
    }
    void setAttributes(unsigned attrs) { desc().attrs = attrs; }

    void setGetter(JSGetterOp op) {
        do { } while (0);
        desc().getter = op;
    }
    void setSetter(JSSetterOp op) {
        do { } while (0);
        desc().setter = op;
    }
    void setGetterObject(JSObject* obj) {
        desc().getter = reinterpret_cast<JSGetterOp>(obj);
        desc().attrs &= ~(0x20000 | 0x8000 | 0x02);
        desc().attrs |= 0x10 | 0x40;
    }
    void setSetterObject(JSObject* obj) {
        desc().setter = reinterpret_cast<JSSetterOp>(obj);
        desc().attrs &= ~(0x20000 | 0x8000 | 0x02);
        desc().attrs |= 0x20 | 0x40;
    }

    JS::MutableHandleObject getterObject() {
        do { } while (0);
        return JS::MutableHandleObject::fromMarkedLocation(
                reinterpret_cast<JSObject**>(&desc().getter));
    }
    JS::MutableHandleObject setterObject() {
        do { } while (0);
        return JS::MutableHandleObject::fromMarkedLocation(
                reinterpret_cast<JSObject**>(&desc().setter));
    }
};

}

namespace JS {

extern bool
ObjectToCompletePropertyDescriptor(JSContext* cx,
                                   JS::HandleObject obj,
                                   JS::HandleValue descriptor,
                                   JS::MutableHandle<PropertyDescriptor> desc);






extern bool
FromPropertyDescriptor(JSContext* cx,
                       JS::Handle<JS::PropertyDescriptor> desc,
                       JS::MutableHandleValue vp);

}
extern bool
JS_GetPrototype(JSContext* cx, JS::HandleObject obj, JS::MutableHandleObject result);
extern bool
JS_GetPrototypeIfOrdinary(JSContext* cx, JS::HandleObject obj, bool* isOrdinary,
                          JS::MutableHandleObject result);
extern bool
JS_SetPrototype(JSContext* cx, JS::HandleObject obj, JS::HandleObject proto);
extern bool
JS_IsExtensible(JSContext* cx, JS::HandleObject obj, bool* extensible);
extern bool
JS_PreventExtensions(JSContext* cx, JS::HandleObject obj, JS::ObjectOpResult& result);
extern bool
JS_SetImmutablePrototype(JSContext* cx, JS::HandleObject obj, bool* succeeded);







extern bool
JS_GetOwnPropertyDescriptorById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                                JS::MutableHandle<JS::PropertyDescriptor> desc);

extern bool
JS_GetOwnPropertyDescriptor(JSContext* cx, JS::HandleObject obj, const char* name,
                            JS::MutableHandle<JS::PropertyDescriptor> desc);

extern bool
JS_GetOwnUCPropertyDescriptor(JSContext* cx, JS::HandleObject obj, const char16_t* name,
                              JS::MutableHandle<JS::PropertyDescriptor> desc);







extern bool
JS_GetPropertyDescriptorById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                             JS::MutableHandle<JS::PropertyDescriptor> desc);

extern bool
JS_GetPropertyDescriptor(JSContext* cx, JS::HandleObject obj, const char* name,
                         JS::MutableHandle<JS::PropertyDescriptor> desc);
extern bool
JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                      JS::Handle<JS::PropertyDescriptor> desc,
                      JS::ObjectOpResult& result);





extern bool
JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                      JS::Handle<JS::PropertyDescriptor> desc);

extern bool
JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleValue value,
                      unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleObject value,
                      unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleString value,
                      unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, int32_t value,
                      unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, uint32_t value,
                      unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, double value,
                      unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineProperty(JSContext* cx, JS::HandleObject obj, const char* name, JS::HandleValue value,
                  unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineProperty(JSContext* cx, JS::HandleObject obj, const char* name, JS::HandleObject value,
                  unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineProperty(JSContext* cx, JS::HandleObject obj, const char* name, JS::HandleString value,
                  unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineProperty(JSContext* cx, JS::HandleObject obj, const char* name, int32_t value,
                  unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineProperty(JSContext* cx, JS::HandleObject obj, const char* name, uint32_t value,
                  unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineProperty(JSContext* cx, JS::HandleObject obj, const char* name, double value,
                  unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                    JS::Handle<JS::PropertyDescriptor> desc,
                    JS::ObjectOpResult& result);

extern bool
JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                    JS::Handle<JS::PropertyDescriptor> desc);

extern bool
JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                    JS::HandleValue value, unsigned attrs,
                    JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                    JS::HandleObject value, unsigned attrs,
                    JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                    JS::HandleString value, unsigned attrs,
                    JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                    int32_t value, unsigned attrs,
                    JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                    uint32_t value, unsigned attrs,
                    JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                    double value, unsigned attrs,
                    JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::HandleValue value,
                 unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::HandleObject value,
                 unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::HandleString value,
                 unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineElement(JSContext* cx, JS::HandleObject obj, uint32_t index, int32_t value,
                 unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineElement(JSContext* cx, JS::HandleObject obj, uint32_t index, uint32_t value,
                 unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);

extern bool
JS_DefineElement(JSContext* cx, JS::HandleObject obj, uint32_t index, double value,
                 unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
extern bool
JS_HasPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, bool* foundp);

extern bool
JS_HasProperty(JSContext* cx, JS::HandleObject obj, const char* name, bool* foundp);

extern bool
JS_HasUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                 bool* vp);

extern bool
JS_HasElement(JSContext* cx, JS::HandleObject obj, uint32_t index, bool* foundp);






extern bool
JS_HasOwnPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, bool* foundp);

extern bool
JS_HasOwnProperty(JSContext* cx, JS::HandleObject obj, const char* name, bool* foundp);
extern bool
JS_ForwardGetPropertyTo(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                        JS::HandleValue receiver, JS::MutableHandleValue vp);

extern bool
JS_ForwardGetElementTo(JSContext* cx, JS::HandleObject obj, uint32_t index,
                       JS::HandleObject receiver, JS::MutableHandleValue vp);







extern bool
JS_GetPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                   JS::MutableHandleValue vp);

extern bool
JS_GetProperty(JSContext* cx, JS::HandleObject obj, const char* name, JS::MutableHandleValue vp);

extern bool
JS_GetUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                 JS::MutableHandleValue vp);

extern bool
JS_GetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::MutableHandleValue vp);
extern bool
JS_ForwardSetPropertyTo(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleValue v,
                        JS::HandleValue receiver, JS::ObjectOpResult& result);







extern bool
JS_SetPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleValue v);

extern bool
JS_SetProperty(JSContext* cx, JS::HandleObject obj, const char* name, JS::HandleValue v);

extern bool
JS_SetUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                 JS::HandleValue v);

extern bool
JS_SetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::HandleValue v);

extern bool
JS_SetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::HandleObject v);

extern bool
JS_SetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::HandleString v);

extern bool
JS_SetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, int32_t v);

extern bool
JS_SetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, uint32_t v);

extern bool
JS_SetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, double v);
extern bool
JS_DeletePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                      JS::ObjectOpResult& result);

extern bool
JS_DeleteProperty(JSContext* cx, JS::HandleObject obj, const char* name,
                  JS::ObjectOpResult& result);

extern bool
JS_DeleteUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                    JS::ObjectOpResult& result);

extern bool
JS_DeleteElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::ObjectOpResult& result);





extern bool
JS_DeletePropertyById(JSContext* cx, JS::HandleObject obj, jsid id);

extern bool
JS_DeleteProperty(JSContext* cx, JS::HandleObject obj, const char* name);

extern bool
JS_DeleteElement(JSContext* cx, JS::HandleObject obj, uint32_t index);
extern bool
JS_Enumerate(JSContext* cx, JS::HandleObject obj, JS::MutableHandle<JS::IdVector> props);







namespace JS {
extern bool
IsCallable(JSObject* obj);
extern bool
IsConstructor(JSObject* obj);

}
extern bool
JS_CallFunctionValue(JSContext* cx, JS::HandleObject obj, JS::HandleValue fval,
                     const JS::HandleValueArray& args, JS::MutableHandleValue rval);

extern bool
JS_CallFunction(JSContext* cx, JS::HandleObject obj, JS::HandleFunction fun,
                const JS::HandleValueArray& args, JS::MutableHandleValue rval);




extern bool
JS_CallFunctionName(JSContext* cx, JS::HandleObject obj, const char* name,
                    const JS::HandleValueArray& args, JS::MutableHandleValue rval);

namespace JS {

static inline bool
Call(JSContext* cx, JS::HandleObject thisObj, JS::HandleFunction fun,
     const JS::HandleValueArray& args, MutableHandleValue rval)
{
    return !!JS_CallFunction(cx, thisObj, fun, args, rval);
}

static inline bool
Call(JSContext* cx, JS::HandleObject thisObj, JS::HandleValue fun, const JS::HandleValueArray& args,
     MutableHandleValue rval)
{
    return !!JS_CallFunctionValue(cx, thisObj, fun, args, rval);
}

static inline bool
Call(JSContext* cx, JS::HandleObject thisObj, const char* name, const JS::HandleValueArray& args,
     MutableHandleValue rval)
{
    return !!JS_CallFunctionName(cx, thisObj, name, args, rval);
}

extern bool
Call(JSContext* cx, JS::HandleValue thisv, JS::HandleValue fun, const JS::HandleValueArray& args,
     MutableHandleValue rval);

static inline bool
Call(JSContext* cx, JS::HandleValue thisv, JS::HandleObject funObj, const JS::HandleValueArray& args,
     MutableHandleValue rval)
{
    do { } while (0);
    JS::RootedValue fun(cx, JS::ObjectValue(*funObj));
    return Call(cx, thisv, fun, args, rval);
}
extern bool
Construct(JSContext* cx, JS::HandleValue fun, HandleObject newTarget,
          const JS::HandleValueArray &args, MutableHandleObject objp);
extern bool
Construct(JSContext* cx, JS::HandleValue fun, const JS::HandleValueArray& args,
          MutableHandleObject objp);

}





extern JSObject*
JS_New(JSContext* cx, JS::HandleObject ctor, const JS::HandleValueArray& args);




extern JSObject*
JS_DefineObject(JSContext* cx, JS::HandleObject obj, const char* name,
                const JSClass* clasp = nullptr, unsigned attrs = 0);

extern bool
JS_DefineConstDoubles(JSContext* cx, JS::HandleObject obj, const JSConstDoubleSpec* cds);

extern bool
JS_DefineConstIntegers(JSContext* cx, JS::HandleObject obj, const JSConstIntegerSpec* cis);

extern bool
JS_DefineProperties(JSContext* cx, JS::HandleObject obj, const JSPropertySpec* ps);




extern bool
JS_AlreadyHasOwnPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                             bool* foundp);

extern bool
JS_AlreadyHasOwnProperty(JSContext* cx, JS::HandleObject obj, const char* name,
                         bool* foundp);

extern bool
JS_AlreadyHasOwnUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name,
                           size_t namelen, bool* foundp);

extern bool
JS_AlreadyHasOwnElement(JSContext* cx, JS::HandleObject obj, uint32_t index, bool* foundp);

extern JSObject*
JS_NewArrayObject(JSContext* cx, const JS::HandleValueArray& contents);

extern JSObject*
JS_NewArrayObject(JSContext* cx, size_t length);
extern bool
JS_IsArrayObject(JSContext* cx, JS::HandleValue value, bool* isArray);
extern bool
JS_IsArrayObject(JSContext* cx, JS::HandleObject obj, bool* isArray);

extern bool
JS_GetArrayLength(JSContext* cx, JS::Handle<JSObject*> obj, uint32_t* lengthp);

extern bool
JS_SetArrayLength(JSContext* cx, JS::Handle<JSObject*> obj, uint32_t length);

namespace JS {
extern bool
IsMapObject(JSContext* cx, JS::HandleObject obj, bool* isMap);
extern bool
IsSetObject(JSContext* cx, JS::HandleObject obj, bool* isSet);

}





void
JS_SetAllNonReservedSlotsToUndefined(JSContext* cx, JSObject* objArg);






extern JSObject*
JS_NewArrayBufferWithContents(JSContext* cx, size_t nbytes, void* contents);





extern JSObject*
JS_NewArrayBufferWithExternalContents(JSContext* cx, size_t nbytes, void* contents);







extern void*
JS_StealArrayBufferContents(JSContext* cx, JS::HandleObject obj);
extern void*
JS_ExternalizeArrayBufferContents(JSContext* cx, JS::HandleObject obj);






extern JSObject*
JS_NewMappedArrayBufferWithContents(JSContext* cx, size_t nbytes, void* contents);





extern void*
JS_CreateMappedArrayBufferContents(int fd, size_t offset, size_t length);
extern void
JS_ReleaseMappedArrayBufferContents(void* contents, size_t length);

extern JS::Value
JS_GetReservedSlot(JSObject* obj, uint32_t index);

extern void
JS_SetReservedSlot(JSObject* obj, uint32_t index, const JS::Value& v);







extern JSFunction*
JS_NewFunction(JSContext* cx, JSNative call, unsigned nargs, unsigned flags,
               const char* name);

namespace JS {

extern JSFunction*
GetSelfHostedFunction(JSContext* cx, const char* selfHostedName, HandleId id,
                      unsigned nargs);
extern JSFunction*
NewFunctionFromSpec(JSContext* cx, const JSFunctionSpec* fs, HandleId id);

}

extern JSObject*
JS_GetFunctionObject(JSFunction* fun);







extern JSString*
JS_GetFunctionId(JSFunction* fun);
extern JSString*
JS_GetFunctionDisplayId(JSFunction* fun);




extern uint16_t
JS_GetFunctionArity(JSFunction* fun);







extern bool
JS_ObjectIsFunction(JSContext* cx, JSObject* obj);

extern bool
JS_IsNativeFunction(JSObject* funobj, JSNative call);


extern bool
JS_IsConstructor(JSFunction* fun);

extern bool
JS_DefineFunctions(JSContext* cx, JS::Handle<JSObject*> obj, const JSFunctionSpec* fs);

extern JSFunction*
JS_DefineFunction(JSContext* cx, JS::Handle<JSObject*> obj, const char* name, JSNative call,
                  unsigned nargs, unsigned attrs);

extern JSFunction*
JS_DefineUCFunction(JSContext* cx, JS::Handle<JSObject*> obj,
                    const char16_t* name, size_t namelen, JSNative call,
                    unsigned nargs, unsigned attrs);

extern JSFunction*
JS_DefineFunctionById(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JSNative call,
                      unsigned nargs, unsigned attrs);

extern bool
JS_IsFunctionBound(JSFunction* fun);

extern JSObject*
JS_GetBoundFunctionTarget(JSFunction* fun);

namespace JS {





extern JSObject*
CloneFunctionObject(JSContext* cx, HandleObject funobj);






extern JSObject*
CloneFunctionObject(JSContext* cx, HandleObject funobj, AutoObjectVector& scopeChain);

}
extern bool
JS_BufferIsCompilableUnit(JSContext* cx, JS::Handle<JSObject*> obj, const char* utf8,
                          size_t length);




extern bool
JS_CompileScript(JSContext* cx, const char* ascii, size_t length,
                 const JS::CompileOptions& options,
                 JS::MutableHandleScript script);




extern bool
JS_CompileUCScript(JSContext* cx, const char16_t* chars, size_t length,
                   const JS::CompileOptions& options,
                   JS::MutableHandleScript script);

extern JSObject*
JS_GetGlobalFromScript(JSScript* script);

extern const char*
JS_GetScriptFilename(JSScript* script);

extern unsigned
JS_GetScriptBaseLineNumber(JSContext* cx, JSScript* script);

extern JSScript*
JS_GetFunctionScript(JSContext* cx, JS::HandleFunction fun);

namespace JS {
enum class AsmJSOption : uint8_t { Enabled, Disabled, DisabledByDebugger };







class TransitiveCompileOptions
{
  protected:
    bool mutedErrors_;
    const char* filename_;
    const char* introducerFilename_;
    const char16_t* sourceMapURL_;





    TransitiveCompileOptions()
      : mutedErrors_(false),
        filename_(nullptr),
        introducerFilename_(nullptr),
        sourceMapURL_(nullptr),
        version(JSVERSION_UNKNOWN),
        versionSet(false),
        utf8(false),
        selfHostingMode(false),
        canLazilyParse(true),
        strictOption(false),
        extraWarningsOption(false),
        forEachStatementOption(false),
        werrorOption(false),
        asmJSOption(AsmJSOption::Disabled),
        throwOnAsmJSValidationFailureOption(false),
        forceAsync(false),
        sourceIsLazy(false),
        allowHTMLComments(true),
        isProbablySystemOrAddonCode(false),
        introductionType(nullptr),
        introductionLineno(0),
        introductionOffset(0),
        hasIntroductionInfo(false)
    { }



    void copyPODTransitiveOptions(const TransitiveCompileOptions& rhs);

  public:


    bool mutedErrors() const { return mutedErrors_; }
    const char* filename() const { return filename_; }
    const char* introducerFilename() const { return introducerFilename_; }
    const char16_t* sourceMapURL() const { return sourceMapURL_; }
    virtual JSObject* element() const = 0;
    virtual JSString* elementAttributeName() const = 0;
    virtual JSScript* introductionScript() const = 0;


    JSVersion version;
    bool versionSet;
    bool utf8;
    bool selfHostingMode;
    bool canLazilyParse;
    bool strictOption;
    bool extraWarningsOption;
    bool forEachStatementOption;
    bool werrorOption;
    AsmJSOption asmJSOption;
    bool throwOnAsmJSValidationFailureOption;
    bool forceAsync;
    bool sourceIsLazy;
    bool allowHTMLComments;
    bool isProbablySystemOrAddonCode;



    const char* introductionType;
    unsigned introductionLineno;
    uint32_t introductionOffset;
    bool hasIntroductionInfo;

  private:
    void operator=(const TransitiveCompileOptions&) = delete;
};
class ReadOnlyCompileOptions : public TransitiveCompileOptions
{
    friend class CompileOptions;

  protected:
    ReadOnlyCompileOptions()
      : TransitiveCompileOptions(),
        lineno(1),
        column(0),
        isRunOnce(false),
        noScriptRval(false)
    { }



    void copyPODOptions(const ReadOnlyCompileOptions& rhs);

  public:


    bool mutedErrors() const { return mutedErrors_; }
    const char* filename() const { return filename_; }
    const char* introducerFilename() const { return introducerFilename_; }
    const char16_t* sourceMapURL() const { return sourceMapURL_; }
    virtual JSObject* element() const = 0;
    virtual JSString* elementAttributeName() const = 0;
    virtual JSScript* introductionScript() const = 0;


    unsigned lineno;
    unsigned column;

    bool isRunOnce;
    bool noScriptRval;

  private:
    void operator=(const ReadOnlyCompileOptions&) = delete;
};
class OwningCompileOptions : public ReadOnlyCompileOptions
{
    PersistentRootedObject elementRoot;
    PersistentRootedString elementAttributeNameRoot;
    PersistentRootedScript introductionScriptRoot;

  public:




    explicit OwningCompileOptions(JSContext* cx);
    ~OwningCompileOptions();

    JSObject* element() const override { return elementRoot; }
    JSString* elementAttributeName() const override { return elementAttributeNameRoot; }
    JSScript* introductionScript() const override { return introductionScriptRoot; }


    bool copy(JSContext* cx, const ReadOnlyCompileOptions& rhs);


    bool setFile(JSContext* cx, const char* f);
    bool setFileAndLine(JSContext* cx, const char* f, unsigned l);
    bool setSourceMapURL(JSContext* cx, const char16_t* s);
    bool setIntroducerFilename(JSContext* cx, const char* s);


    OwningCompileOptions& setLine(unsigned l) { lineno = l; return *this; }
    OwningCompileOptions& setElement(JSObject* e) {
        elementRoot = e;
        return *this;
    }
    OwningCompileOptions& setElementAttributeName(JSString* p) {
        elementAttributeNameRoot = p;
        return *this;
    }
    OwningCompileOptions& setIntroductionScript(JSScript* s) {
        introductionScriptRoot = s;
        return *this;
    }
    OwningCompileOptions& setMutedErrors(bool mute) {
        mutedErrors_ = mute;
        return *this;
    }
    OwningCompileOptions& setVersion(JSVersion v) {
        version = v;
        versionSet = true;
        return *this;
    }
    OwningCompileOptions& setUTF8(bool u) { utf8 = u; return *this; }
    OwningCompileOptions& setColumn(unsigned c) { column = c; return *this; }
    OwningCompileOptions& setIsRunOnce(bool once) { isRunOnce = once; return *this; }
    OwningCompileOptions& setNoScriptRval(bool nsr) { noScriptRval = nsr; return *this; }
    OwningCompileOptions& setSelfHostingMode(bool shm) { selfHostingMode = shm; return *this; }
    OwningCompileOptions& setCanLazilyParse(bool clp) { canLazilyParse = clp; return *this; }
    OwningCompileOptions& setSourceIsLazy(bool l) { sourceIsLazy = l; return *this; }
    OwningCompileOptions& setIntroductionType(const char* t) { introductionType = t; return *this; }
    bool setIntroductionInfo(JSContext* cx, const char* introducerFn, const char* intro,
                             unsigned line, JSScript* script, uint32_t offset)
    {
        if (!setIntroducerFilename(cx, introducerFn))
            return false;
        introductionType = intro;
        introductionLineno = line;
        introductionScriptRoot = script;
        introductionOffset = offset;
        hasIntroductionInfo = true;
        return true;
    }

  private:
    void operator=(const CompileOptions& rhs) = delete;
};
class CompileOptions final : public ReadOnlyCompileOptions
{
    RootedObject elementRoot;
    RootedString elementAttributeNameRoot;
    RootedScript introductionScriptRoot;

  public:
    explicit CompileOptions(JSContext* cx, JSVersion version = JSVERSION_UNKNOWN);
    CompileOptions(JSContext* cx, const ReadOnlyCompileOptions& rhs)
      : ReadOnlyCompileOptions(), elementRoot(cx), elementAttributeNameRoot(cx),
        introductionScriptRoot(cx)
    {
        copyPODOptions(rhs);

        filename_ = rhs.filename();
        introducerFilename_ = rhs.introducerFilename();
        sourceMapURL_ = rhs.sourceMapURL();
        elementRoot = rhs.element();
        elementAttributeNameRoot = rhs.elementAttributeName();
        introductionScriptRoot = rhs.introductionScript();
    }

    CompileOptions(JSContext* cx, const TransitiveCompileOptions& rhs)
      : ReadOnlyCompileOptions(), elementRoot(cx), elementAttributeNameRoot(cx),
        introductionScriptRoot(cx)
    {
        copyPODTransitiveOptions(rhs);

        filename_ = rhs.filename();
        introducerFilename_ = rhs.introducerFilename();
        sourceMapURL_ = rhs.sourceMapURL();
        elementRoot = rhs.element();
        elementAttributeNameRoot = rhs.elementAttributeName();
        introductionScriptRoot = rhs.introductionScript();
    }

    JSObject* element() const override { return elementRoot; }
    JSString* elementAttributeName() const override { return elementAttributeNameRoot; }
    JSScript* introductionScript() const override { return introductionScriptRoot; }

    CompileOptions& setFile(const char* f) { filename_ = f; return *this; }
    CompileOptions& setLine(unsigned l) { lineno = l; return *this; }
    CompileOptions& setFileAndLine(const char* f, unsigned l) {
        filename_ = f; lineno = l; return *this;
    }
    CompileOptions& setSourceMapURL(const char16_t* s) { sourceMapURL_ = s; return *this; }
    CompileOptions& setElement(JSObject* e) { elementRoot = e; return *this; }
    CompileOptions& setElementAttributeName(JSString* p) {
        elementAttributeNameRoot = p;
        return *this;
    }
    CompileOptions& setIntroductionScript(JSScript* s) {
        introductionScriptRoot = s;
        return *this;
    }
    CompileOptions& setMutedErrors(bool mute) {
        mutedErrors_ = mute;
        return *this;
    }
    CompileOptions& setVersion(JSVersion v) {
        version = v;
        versionSet = true;
        return *this;
    }
    CompileOptions& setUTF8(bool u) { utf8 = u; return *this; }
    CompileOptions& setColumn(unsigned c) { column = c; return *this; }
    CompileOptions& setIsRunOnce(bool once) { isRunOnce = once; return *this; }
    CompileOptions& setNoScriptRval(bool nsr) { noScriptRval = nsr; return *this; }
    CompileOptions& setSelfHostingMode(bool shm) { selfHostingMode = shm; return *this; }
    CompileOptions& setCanLazilyParse(bool clp) { canLazilyParse = clp; return *this; }
    CompileOptions& setSourceIsLazy(bool l) { sourceIsLazy = l; return *this; }
    CompileOptions& setIntroductionType(const char* t) { introductionType = t; return *this; }
    CompileOptions& setIntroductionInfo(const char* introducerFn, const char* intro,
                                        unsigned line, JSScript* script, uint32_t offset)
    {
        introducerFilename_ = introducerFn;
        introductionType = intro;
        introductionLineno = line;
        introductionScriptRoot = script;
        introductionOffset = offset;
        hasIntroductionInfo = true;
        return *this;
    }
    CompileOptions& maybeMakeStrictMode(bool strict) {
        strictOption = strictOption || strict;
        return *this;
    }

  private:
    void operator=(const CompileOptions& rhs) = delete;
};




extern bool
Compile(JSContext* cx, const ReadOnlyCompileOptions& options,
        SourceBufferHolder& srcBuf, JS::MutableHandleScript script);

extern bool
Compile(JSContext* cx, const ReadOnlyCompileOptions& options,
        const char* bytes, size_t length, JS::MutableHandleScript script);

extern bool
Compile(JSContext* cx, const ReadOnlyCompileOptions& options,
        const char16_t* chars, size_t length, JS::MutableHandleScript script);

extern bool
Compile(JSContext* cx, const ReadOnlyCompileOptions& options,
        FILE* file, JS::MutableHandleScript script);

extern bool
Compile(JSContext* cx, const ReadOnlyCompileOptions& options,
        const char* filename, JS::MutableHandleScript script);

extern bool
CompileForNonSyntacticScope(JSContext* cx, const ReadOnlyCompileOptions& options,
                            SourceBufferHolder& srcBuf, JS::MutableHandleScript script);

extern bool
CompileForNonSyntacticScope(JSContext* cx, const ReadOnlyCompileOptions& options,
                            const char* bytes, size_t length, JS::MutableHandleScript script);

extern bool
CompileForNonSyntacticScope(JSContext* cx, const ReadOnlyCompileOptions& options,
                            const char16_t* chars, size_t length, JS::MutableHandleScript script);

extern bool
CompileForNonSyntacticScope(JSContext* cx, const ReadOnlyCompileOptions& options,
                            FILE* file, JS::MutableHandleScript script);

extern bool
CompileForNonSyntacticScope(JSContext* cx, const ReadOnlyCompileOptions& options,
                            const char* filename, JS::MutableHandleScript script);

extern bool
CanCompileOffThread(JSContext* cx, const ReadOnlyCompileOptions& options, size_t length);
extern bool
CompileOffThread(JSContext* cx, const ReadOnlyCompileOptions& options,
                 const char16_t* chars, size_t length,
                 OffThreadCompileCallback callback, void* callbackData);

extern JSScript*
FinishOffThreadScript(JSContext* cx, void* token);

extern void
CancelOffThreadScript(JSContext* cx, void* token);

extern bool
CompileOffThreadModule(JSContext* cx, const ReadOnlyCompileOptions& options,
                       const char16_t* chars, size_t length,
                       OffThreadCompileCallback callback, void* callbackData);

extern JSObject*
FinishOffThreadModule(JSContext* cx, void* token);

extern void
CancelOffThreadModule(JSContext* cx, void* token);

extern bool
DecodeOffThreadScript(JSContext* cx, const ReadOnlyCompileOptions& options,
                      mozilla::Vector<uint8_t>& buffer , size_t cursor,
                      OffThreadCompileCallback callback, void* callbackData);

extern JSScript*
FinishOffThreadScriptDecoder(JSContext* cx, void* token);

extern void
CancelOffThreadScriptDecoder(JSContext* cx, void* token);
extern bool
CompileFunction(JSContext* cx, AutoObjectVector& envChain,
                const ReadOnlyCompileOptions& options,
                const char* name, unsigned nargs, const char* const* argnames,
                const char16_t* chars, size_t length, JS::MutableHandleFunction fun);




extern bool
CompileFunction(JSContext* cx, AutoObjectVector& envChain,
                const ReadOnlyCompileOptions& options,
                const char* name, unsigned nargs, const char* const* argnames,
                SourceBufferHolder& srcBuf, JS::MutableHandleFunction fun);




extern bool
CompileFunction(JSContext* cx, AutoObjectVector& envChain,
                const ReadOnlyCompileOptions& options,
                const char* name, unsigned nargs, const char* const* argnames,
                const char* bytes, size_t length, JS::MutableHandleFunction fun);

}

extern JSString*
JS_DecompileScript(JSContext* cx, JS::Handle<JSScript*> script, const char* name, unsigned indent);







extern JSString*
JS_DecompileFunction(JSContext* cx, JS::Handle<JSFunction*> fun, unsigned indent);
extern bool
JS_ExecuteScript(JSContext* cx, JS::HandleScript script, JS::MutableHandleValue rval);

extern bool
JS_ExecuteScript(JSContext* cx, JS::HandleScript script);






extern bool
JS_ExecuteScript(JSContext* cx, JS::AutoObjectVector& envChain,
                 JS::HandleScript script, JS::MutableHandleValue rval);

extern bool
JS_ExecuteScript(JSContext* cx, JS::AutoObjectVector& envChain, JS::HandleScript script);

namespace JS {





extern bool
CloneAndExecuteScript(JSContext* cx, JS::Handle<JSScript*> script,
                      JS::MutableHandleValue rval);

}

namespace JS {




extern bool
Evaluate(JSContext* cx, const ReadOnlyCompileOptions& options,
         SourceBufferHolder& srcBuf, JS::MutableHandleValue rval);






extern bool
Evaluate(JSContext* cx, AutoObjectVector& envChain, const ReadOnlyCompileOptions& options,
         SourceBufferHolder& srcBuf, JS::MutableHandleValue rval);




extern bool
Evaluate(JSContext* cx, const ReadOnlyCompileOptions& options,
         const char16_t* chars, size_t length, JS::MutableHandleValue rval);






extern bool
Evaluate(JSContext* cx, AutoObjectVector& envChain, const ReadOnlyCompileOptions& options,
         const char16_t* chars, size_t length, JS::MutableHandleValue rval);




extern bool
Evaluate(JSContext* cx, const ReadOnlyCompileOptions& options,
         const char* bytes, size_t length, JS::MutableHandleValue rval);




extern bool
Evaluate(JSContext* cx, const ReadOnlyCompileOptions& options,
         const char* filename, JS::MutableHandleValue rval);




extern JSFunction*
GetModuleResolveHook(JSContext* cx);




extern void
SetModuleResolveHook(JSContext* cx, JS::HandleFunction func);





extern bool
CompileModule(JSContext* cx, const ReadOnlyCompileOptions& options,
              SourceBufferHolder& srcBuf, JS::MutableHandleObject moduleRecord);





extern void
SetModuleHostDefinedField(JSObject* module, const JS::Value& value);




extern JS::Value
GetModuleHostDefinedField(JSObject* module);
extern bool
ModuleDeclarationInstantiation(JSContext* cx, JS::HandleObject moduleRecord);
extern bool
ModuleEvaluation(JSContext* cx, JS::HandleObject moduleRecord);
extern JSObject*
GetRequestedModules(JSContext* cx, JS::HandleObject moduleRecord);




extern JSScript*
GetModuleScript(JSContext* cx, JS::HandleObject moduleRecord);

}

extern bool
JS_CheckForInterrupt(JSContext* cx);
extern bool
JS_AddInterruptCallback(JSContext* cx, JSInterruptCallback callback);

extern bool
JS_DisableInterruptCallback(JSContext* cx);

extern void
JS_ResetInterruptCallback(JSContext* cx, bool enable);

extern void
JS_RequestInterruptCallback(JSContext* cx);

namespace JS {
extern void
SetGetIncumbentGlobalCallback(JSContext* cx, JSGetIncumbentGlobalCallback callback);
extern void
SetEnqueuePromiseJobCallback(JSContext* cx, JSEnqueuePromiseJobCallback callback,
                             void* data = nullptr);






extern void
SetPromiseRejectionTrackerCallback(JSContext* cx, JSPromiseRejectionTrackerCallback callback,
                                   void* data = nullptr);







extern JSObject*
NewPromiseObject(JSContext* cx, JS::HandleObject executor, JS::HandleObject proto = nullptr);





extern bool
IsPromiseObject(JS::HandleObject obj);




extern JSObject*
GetPromiseConstructor(JSContext* cx);




extern JSObject*
GetPromisePrototype(JSContext* cx);


enum class PromiseState {
    Pending,
    Fulfilled,
    Rejected
};




extern PromiseState
GetPromiseState(JS::HandleObject promise);




uint64_t
GetPromiseID(JS::HandleObject promise);





extern JS::Value
GetPromiseResult(JS::HandleObject promise);





extern JSObject*
GetPromiseAllocationSite(JS::HandleObject promise);

extern JSObject*
GetPromiseResolutionSite(JS::HandleObject promise);
extern JSObject*
CallOriginalPromiseResolve(JSContext* cx, JS::HandleValue resolutionValue);





extern JSObject*
CallOriginalPromiseReject(JSContext* cx, JS::HandleValue rejectionValue);







extern bool
ResolvePromise(JSContext* cx, JS::HandleObject promiseObj, JS::HandleValue resolutionValue);







extern bool
RejectPromise(JSContext* cx, JS::HandleObject promiseObj, JS::HandleValue rejectionValue);
extern JSObject*
CallOriginalPromiseThen(JSContext* cx, JS::HandleObject promise,
                        JS::HandleObject onResolve, JS::HandleObject onReject);
extern bool
AddPromiseReactions(JSContext* cx, JS::HandleObject promise,
                    JS::HandleObject onResolve, JS::HandleObject onReject);
extern JSObject*
GetWaitForAllPromise(JSContext* cx, const JS::AutoObjectVector& promises);
struct AsyncTask
{
    AsyncTask() : user(nullptr) {}
    virtual ~AsyncTask() {}





    virtual void finish(JSContext* cx) = 0;
    virtual void cancel(JSContext* cx) = 0;


    void* user;
};
typedef bool
(*StartAsyncTaskCallback)(JSContext* cx, AsyncTask* task);
typedef bool
(*FinishAsyncTaskCallback)(AsyncTask* task);




extern void
SetAsyncTaskCallbacks(JSContext* cx, StartAsyncTaskCallback start, FinishAsyncTaskCallback finish);
class AutoSetAsyncStackForNewCalls
{
    JSContext* cx;
    RootedObject oldAsyncStack;
    const char* oldAsyncCause;
    bool oldAsyncCallIsExplicit;

  public:
    enum class AsyncCallKind {


        IMPLICIT,


        EXPLICIT
    };
    AutoSetAsyncStackForNewCalls(JSContext* cx, HandleObject stack,
                                 const char* asyncCause,
                                 AsyncCallKind kind = AsyncCallKind::IMPLICIT);
    ~AutoSetAsyncStackForNewCalls();
};

}
extern JSString*
JS_NewStringCopyN(JSContext* cx, const char* s, size_t n);

extern JSString*
JS_NewStringCopyZ(JSContext* cx, const char* s);

extern JSString*
JS_NewStringCopyUTF8Z(JSContext* cx, const JS::ConstUTF8CharsZ s);

extern JSString*
JS_NewStringCopyUTF8N(JSContext* cx, const JS::UTF8Chars s);

extern JSString*
JS_AtomizeAndPinJSString(JSContext* cx, JS::HandleString str);

extern JSString*
JS_AtomizeStringN(JSContext* cx, const char* s, size_t length);

extern JSString*
JS_AtomizeString(JSContext* cx, const char* s);

extern JSString*
JS_AtomizeAndPinStringN(JSContext* cx, const char* s, size_t length);

extern JSString*
JS_AtomizeAndPinString(JSContext* cx, const char* s);

extern JSString*
JS_NewUCString(JSContext* cx, char16_t* chars, size_t length);

extern JSString*
JS_NewUCStringCopyN(JSContext* cx, const char16_t* s, size_t n);

extern JSString*
JS_NewUCStringCopyZ(JSContext* cx, const char16_t* s);

extern JSString*
JS_AtomizeUCStringN(JSContext* cx, const char16_t* s, size_t length);

extern JSString*
JS_AtomizeUCString(JSContext* cx, const char16_t* s);

extern JSString*
JS_AtomizeAndPinUCStringN(JSContext* cx, const char16_t* s, size_t length);

extern JSString*
JS_AtomizeAndPinUCString(JSContext* cx, const char16_t* s);

extern bool
JS_CompareStrings(JSContext* cx, JSString* str1, JSString* str2, int32_t* result);

extern bool
JS_StringEqualsAscii(JSContext* cx, JSString* str, const char* asciiBytes, bool* match);

extern size_t
JS_PutEscapedString(JSContext* cx, char* buffer, size_t size, JSString* str, char quote);

extern bool
JS_FileEscapedString(FILE* fp, JSString* str, char quote);
extern size_t
JS_GetStringLength(JSString* str);

extern bool
JS_StringIsFlat(JSString* str);


extern bool
JS_StringHasLatin1Chars(JSString* str);

extern const JS::Latin1Char*
JS_GetLatin1StringCharsAndLength(JSContext* cx, const JS::AutoCheckCannotGC& nogc, JSString* str,
                                 size_t* length);

extern const char16_t*
JS_GetTwoByteStringCharsAndLength(JSContext* cx, const JS::AutoCheckCannotGC& nogc, JSString* str,
                                  size_t* length);

extern bool
JS_GetStringCharAt(JSContext* cx, JSString* str, size_t index, char16_t* res);

extern char16_t
JS_GetFlatStringCharAt(JSFlatString* str, size_t index);

extern const char16_t*
JS_GetTwoByteExternalStringChars(JSString* str);

extern bool
JS_CopyStringChars(JSContext* cx, mozilla::Range<char16_t> dest, JSString* str);

extern JSFlatString*
JS_FlattenString(JSContext* cx, JSString* str);

extern const JS::Latin1Char*
JS_GetLatin1FlatStringChars(const JS::AutoCheckCannotGC& nogc, JSFlatString* str);

extern const char16_t*
JS_GetTwoByteFlatStringChars(const JS::AutoCheckCannotGC& nogc, JSFlatString* str);

static __attribute__((always_inline)) inline JSFlatString*
JSID_TO_FLAT_STRING(jsid id)
{
    do { } while (0);
    return (JSFlatString*)((id.asBits));
}

static __attribute__((always_inline)) inline JSFlatString*
JS_ASSERT_STRING_IS_FLAT(JSString* str)
{
    do { } while (0);
    return (JSFlatString*)str;
}

static __attribute__((always_inline)) inline JSString*
JS_FORGET_STRING_FLATNESS(JSFlatString* fstr)
{
    return (JSString*)fstr;
}





extern bool
JS_FlatStringEqualsAscii(JSFlatString* str, const char* asciiBytes);

extern size_t
JS_PutEscapedFlatString(char* buffer, size_t size, JSFlatString* str, char quote);






extern JSString*
JS_NewDependentString(JSContext* cx, JS::HandleString str, size_t start,
                      size_t length);





extern JSString*
JS_ConcatStrings(JSContext* cx, JS::HandleString left, JS::HandleString right);
bool
JS_DecodeBytes(JSContext* cx, const char* src, size_t srclen, char16_t* dst,
               size_t* dstlenp);





char*
JS_EncodeString(JSContext* cx, JSString* str);




char*
JS_EncodeStringToUTF8(JSContext* cx, JS::HandleString str);






size_t
JS_GetStringEncodingLength(JSContext* cx, JSString* str);
size_t
JS_EncodeStringToBuffer(JSContext* cx, JSString* str, char* buffer, size_t length);

class JSAutoByteString
{
  public:
    JSAutoByteString(JSContext* cx, JSString* str
                                                    )
      : mBytes(JS_EncodeString(cx, str))
    {
        do { } while (0);
        do { } while (0);
    }

    explicit JSAutoByteString()
      : mBytes(nullptr)
    {
        do { } while (0);
    }

    ~JSAutoByteString() {
        JS_free(nullptr, mBytes);
    }


    void initBytes(char* bytes) {
        do { } while (0);
        mBytes = bytes;
    }

    char* encodeLatin1(JSContext* cx, JSString* str) {
        do { } while (0);
        do { } while (0);
        mBytes = JS_EncodeString(cx, str);
        return mBytes;
    }

    char* encodeUtf8(JSContext* cx, JS::HandleString str) {
        do { } while (0);
        do { } while (0);
        mBytes = JS_EncodeStringToUTF8(cx, str);
        return mBytes;
    }

    void clear() {
        js_free(mBytes);
        mBytes = nullptr;
    }

    char* ptr() const {
        return mBytes;
    }

    bool operator!() const {
        return !mBytes;
    }

    size_t length() const {
        if (!mBytes)
            return 0;
        return strlen(mBytes);
    }

  private:
    char* mBytes;



    JSAutoByteString(const JSAutoByteString& another);
    JSAutoByteString& operator=(const JSAutoByteString& another);
};

namespace JS {

extern JSAddonId*
NewAddonId(JSContext* cx, JS::HandleString str);

extern JSString*
StringOfAddonId(JSAddonId* id);

extern JSAddonId*
AddonIdOfObject(JSObject* obj);

}






namespace JS {
Symbol*
NewSymbol(JSContext* cx, HandleString description);
Symbol*
GetSymbolFor(JSContext* cx, HandleString key);







JSString*
GetSymbolDescription(HandleSymbol symbol);
enum class SymbolCode : uint32_t {


    isConcatSpreadable, iterator, match, replace, search, species, hasInstance, split, toPrimitive, toStringTag, unscopables, asyncIterator,

    Limit,
    InSymbolRegistry = 0xfffffffe,
    UniqueSymbol = 0xffffffff
};


const size_t WellKnownSymbolLimit = size_t(SymbolCode::Limit);






SymbolCode
GetSymbolCode(Handle<Symbol*> symbol);







Symbol*
GetWellKnownSymbol(JSContext* cx, SymbolCode which);





inline bool
PropertySpecNameIsSymbol(const char* name)
{
    uintptr_t u = reinterpret_cast<uintptr_t>(name);
    return u != 0 && u - 1 < WellKnownSymbolLimit;
}

bool
PropertySpecNameEqualsId(const char* name, HandleId id);
bool
PropertySpecNameToPermanentId(JSContext* cx, const char* name, jsid* idp);

}





typedef bool (* JSONWriteCallback)(const char16_t* buf, uint32_t len, void* data);




bool
JS_Stringify(JSContext* cx, JS::MutableHandleValue value, JS::HandleObject replacer,
             JS::HandleValue space, JSONWriteCallback callback, void* data);

namespace JS {
bool
ToJSONMaybeSafely(JSContext* cx, JS::HandleObject input,
                  JSONWriteCallback callback, void* data);

}




bool
JS_ParseJSON(JSContext* cx, const char16_t* chars, uint32_t len, JS::MutableHandleValue vp);

bool
JS_ParseJSON(JSContext* cx, JS::HandleString str, JS::MutableHandleValue vp);

bool
JS_ParseJSONWithReviver(JSContext* cx, const char16_t* chars, uint32_t len, JS::HandleValue reviver,
                        JS::MutableHandleValue vp);

bool
JS_ParseJSONWithReviver(JSContext* cx, JS::HandleString str, JS::HandleValue reviver,
                        JS::MutableHandleValue vp);
extern bool
JS_SetDefaultLocale(JSContext* cx, const char* locale);




extern JS::UniqueChars
JS_GetDefaultLocale(JSContext* cx);




extern void
JS_ResetDefaultLocale(JSContext* cx);




struct JSLocaleCallbacks {
    JSLocaleToUpperCase localeToUpperCase;
    JSLocaleToLowerCase localeToLowerCase;
    JSLocaleCompare localeCompare;
    JSLocaleToUnicode localeToUnicode;
};





extern void
JS_SetLocaleCallbacks(JSContext* cx, const JSLocaleCallbacks* callbacks);





extern const JSLocaleCallbacks*
JS_GetLocaleCallbacks(JSContext* cx);







namespace JS {
const uint16_t MaxNumErrorArguments = 10;
};





extern void
JS_ReportErrorASCII(JSContext* cx, const char* format, ...)
    __attribute__ ((format (printf, 2, 3)));

extern void
JS_ReportErrorLatin1(JSContext* cx, const char* format, ...)
    __attribute__ ((format (printf, 2, 3)));

extern void
JS_ReportErrorUTF8(JSContext* cx, const char* format, ...)
    __attribute__ ((format (printf, 2, 3)));




extern void
JS_ReportErrorNumberASCII(JSContext* cx, JSErrorCallback errorCallback,
                          void* userRef, const unsigned errorNumber, ...);

extern void
JS_ReportErrorNumberASCIIVA(JSContext* cx, JSErrorCallback errorCallback,
                            void* userRef, const unsigned errorNumber, va_list ap);

extern void
JS_ReportErrorNumberLatin1(JSContext* cx, JSErrorCallback errorCallback,
                           void* userRef, const unsigned errorNumber, ...);


extern void
JS_ReportErrorNumberLatin1VA(JSContext* cx, JSErrorCallback errorCallback,
                             void* userRef, const unsigned errorNumber, va_list ap);


extern void
JS_ReportErrorNumberUTF8(JSContext* cx, JSErrorCallback errorCallback,
                           void* userRef, const unsigned errorNumber, ...);


extern void
JS_ReportErrorNumberUTF8VA(JSContext* cx, JSErrorCallback errorCallback,
                           void* userRef, const unsigned errorNumber, va_list ap);





extern void
JS_ReportErrorNumberUC(JSContext* cx, JSErrorCallback errorCallback,
                     void* userRef, const unsigned errorNumber, ...);

extern void
JS_ReportErrorNumberUCArray(JSContext* cx, JSErrorCallback errorCallback,
                            void* userRef, const unsigned errorNumber,
                            const char16_t** args);







extern bool
JS_ReportWarningASCII(JSContext* cx, const char* format, ...)
    __attribute__ ((format (printf, 2, 3)));

extern bool
JS_ReportWarningLatin1(JSContext* cx, const char* format, ...)
    __attribute__ ((format (printf, 2, 3)));

extern bool
JS_ReportWarningUTF8(JSContext* cx, const char* format, ...)
    __attribute__ ((format (printf, 2, 3)));

extern bool
JS_ReportErrorFlagsAndNumberASCII(JSContext* cx, unsigned flags,
                                  JSErrorCallback errorCallback, void* userRef,
                                  const unsigned errorNumber, ...);

extern bool
JS_ReportErrorFlagsAndNumberLatin1(JSContext* cx, unsigned flags,
                                   JSErrorCallback errorCallback, void* userRef,
                                   const unsigned errorNumber, ...);

extern bool
JS_ReportErrorFlagsAndNumberUTF8(JSContext* cx, unsigned flags,
                                 JSErrorCallback errorCallback, void* userRef,
                                 const unsigned errorNumber, ...);

extern bool
JS_ReportErrorFlagsAndNumberUC(JSContext* cx, unsigned flags,
                               JSErrorCallback errorCallback, void* userRef,
                               const unsigned errorNumber, ...);




extern void
JS_ReportOutOfMemory(JSContext* cx);




extern void
JS_ReportAllocationOverflow(JSContext* cx);





class JSErrorBase
{


    JS::ConstUTF8CharsZ message_;

  public:
    JSErrorBase()
      : filename(nullptr), lineno(0), column(0),
        errorNumber(0),
        ownsMessage_(false)
    {}

    ~JSErrorBase() {
        freeMessage();
    }


    const char* filename;


    unsigned lineno;


    unsigned column;


    unsigned errorNumber;

  private:
    bool ownsMessage_ : 1;

  public:
    const JS::ConstUTF8CharsZ message() const {
        return message_;
    }

    void initOwnedMessage(const char* messageArg) {
        initBorrowedMessage(messageArg);
        ownsMessage_ = true;
    }
    void initBorrowedMessage(const char* messageArg) {
        do { } while (0);
        message_ = JS::ConstUTF8CharsZ(messageArg, strlen(messageArg));
    }

    JSString* newMessageString(JSContext* cx);

  private:
    void freeMessage();
};




class JSErrorNotes
{
  public:
    class Note : public JSErrorBase
    {};

  private:

    js::Vector<js::UniquePtr<Note>, 1, js::SystemAllocPolicy> notes_;

  public:
    JSErrorNotes();
    ~JSErrorNotes();


    bool addNoteASCII(JSContext* cx,
                      const char* filename, unsigned lineno, unsigned column,
                      JSErrorCallback errorCallback, void* userRef,
                      const unsigned errorNumber, ...);
    bool addNoteLatin1(JSContext* cx,
                       const char* filename, unsigned lineno, unsigned column,
                       JSErrorCallback errorCallback, void* userRef,
                       const unsigned errorNumber, ...);
    bool addNoteUTF8(JSContext* cx,
                     const char* filename, unsigned lineno, unsigned column,
                     JSErrorCallback errorCallback, void* userRef,
                     const unsigned errorNumber, ...);

    size_t length();


    js::UniquePtr<JSErrorNotes> copy(JSContext* cx);

    class iterator : public std::iterator<std::input_iterator_tag, js::UniquePtr<Note>>
    {
        js::UniquePtr<Note>* note_;
      public:
        explicit iterator(js::UniquePtr<Note>* note = nullptr) : note_(note)
        {}

        bool operator==(iterator other) const {
            return note_ == other.note_;
        }
        bool operator!=(iterator other) const {
            return !(*this == other);
        }
        iterator& operator++() {
            note_++;
            return *this;
        }
        reference operator*() {
            return *note_;
        }
    };
    iterator begin();
    iterator end();
};




class JSErrorReport : public JSErrorBase
{


    const char16_t* linebuf_;


    size_t linebufLength_;


    size_t tokenOffset_;

  public:
    JSErrorReport()
      : linebuf_(nullptr), linebufLength_(0), tokenOffset_(0),
        notes(nullptr),
        flags(0), exnType(0), isMuted(false),
        ownsLinebuf_(false)
    {}

    ~JSErrorReport() {
        freeLinebuf();
    }


    js::UniquePtr<JSErrorNotes> notes;


    unsigned flags;


    int16_t exnType;


    bool isMuted : 1;

  private:
    bool ownsLinebuf_ : 1;

  public:
    const char16_t* linebuf() const {
        return linebuf_;
    }
    size_t linebufLength() const {
        return linebufLength_;
    }
    size_t tokenOffset() const {
        return tokenOffset_;
    }
    void initOwnedLinebuf(const char16_t* linebufArg, size_t linebufLengthArg,
                          size_t tokenOffsetArg) {
        initBorrowedLinebuf(linebufArg, linebufLengthArg, tokenOffsetArg);
        ownsLinebuf_ = true;
    }
    void initBorrowedLinebuf(const char16_t* linebufArg, size_t linebufLengthArg,
                             size_t tokenOffsetArg);

  private:
    void freeLinebuf();
};
namespace JS {

using WarningReporter = void (*)(JSContext* cx, JSErrorReport* report);

extern WarningReporter
SetWarningReporter(JSContext* cx, WarningReporter reporter);

extern WarningReporter
GetWarningReporter(JSContext* cx);

extern bool
CreateError(JSContext* cx, JSExnType type, HandleObject stack,
            HandleString fileName, uint32_t lineNumber, uint32_t columnNumber,
            JSErrorReport* report, HandleString message, MutableHandleValue rval);







extern JSObject*
NewWeakMapObject(JSContext* cx);

extern bool
IsWeakMapObject(JSObject* obj);

extern bool
GetWeakMapEntry(JSContext* cx, JS::HandleObject mapObj, JS::HandleObject key,
                JS::MutableHandleValue val);

extern bool
SetWeakMapEntry(JSContext* cx, JS::HandleObject mapObj, JS::HandleObject key,
                JS::HandleValue val);




extern JSObject*
NewMapObject(JSContext* cx);

extern uint32_t
MapSize(JSContext* cx, HandleObject obj);

extern bool
MapGet(JSContext* cx, HandleObject obj,
       HandleValue key, MutableHandleValue rval);

extern bool
MapHas(JSContext* cx, HandleObject obj, HandleValue key, bool* rval);

extern bool
MapSet(JSContext* cx, HandleObject obj, HandleValue key, HandleValue val);

extern bool
MapDelete(JSContext *cx, HandleObject obj, HandleValue key, bool *rval);

extern bool
MapClear(JSContext* cx, HandleObject obj);

extern bool
MapKeys(JSContext* cx, HandleObject obj, MutableHandleValue rval);

extern bool
MapValues(JSContext* cx, HandleObject obj, MutableHandleValue rval);

extern bool
MapEntries(JSContext* cx, HandleObject obj, MutableHandleValue rval);

extern bool
MapForEach(JSContext *cx, HandleObject obj, HandleValue callbackFn, HandleValue thisVal);




extern JSObject *
NewSetObject(JSContext *cx);

extern uint32_t
SetSize(JSContext *cx, HandleObject obj);

extern bool
SetHas(JSContext *cx, HandleObject obj, HandleValue key, bool *rval);

extern bool
SetDelete(JSContext *cx, HandleObject obj, HandleValue key, bool *rval);

extern bool
SetAdd(JSContext *cx, HandleObject obj, HandleValue key);

extern bool
SetClear(JSContext *cx, HandleObject obj);

extern bool
SetKeys(JSContext *cx, HandleObject obj, MutableHandleValue rval);

extern bool
SetValues(JSContext *cx, HandleObject obj, MutableHandleValue rval);

extern bool
SetEntries(JSContext *cx, HandleObject obj, MutableHandleValue rval);

extern bool
SetForEach(JSContext *cx, HandleObject obj, HandleValue callbackFn, HandleValue thisVal);

}





extern JSObject*
JS_NewDateObject(JSContext* cx, int year, int mon, int mday, int hour, int min, int sec);
extern bool
JS_ObjectIsDate(JSContext* cx, JS::HandleObject obj, bool* isDate);
extern JSObject*
JS_NewRegExpObject(JSContext* cx, const char* bytes, size_t length, unsigned flags);

extern JSObject*
JS_NewUCRegExpObject(JSContext* cx, const char16_t* chars, size_t length, unsigned flags);

extern bool
JS_SetRegExpInput(JSContext* cx, JS::HandleObject obj, JS::HandleString input);

extern bool
JS_ClearRegExpStatics(JSContext* cx, JS::HandleObject obj);

extern bool
JS_ExecuteRegExp(JSContext* cx, JS::HandleObject obj, JS::HandleObject reobj,
                 char16_t* chars, size_t length, size_t* indexp, bool test,
                 JS::MutableHandleValue rval);



extern bool
JS_ExecuteRegExpNoStatics(JSContext* cx, JS::HandleObject reobj, char16_t* chars, size_t length,
                          size_t* indexp, bool test, JS::MutableHandleValue rval);
extern bool
JS_ObjectIsRegExp(JSContext* cx, JS::HandleObject obj, bool* isRegExp);

extern unsigned
JS_GetRegExpFlags(JSContext* cx, JS::HandleObject obj);

extern JSString*
JS_GetRegExpSource(JSContext* cx, JS::HandleObject obj);



extern bool
JS_IsExceptionPending(JSContext* cx);

extern bool
JS_GetPendingException(JSContext* cx, JS::MutableHandleValue vp);

extern void
JS_SetPendingException(JSContext* cx, JS::HandleValue v);

extern void
JS_ClearPendingException(JSContext* cx);

namespace JS {
class AutoSaveExceptionState
{
  private:
    JSContext* context;
    bool wasPropagatingForcedReturn;
    bool wasOverRecursed;
    bool wasThrowing;
    RootedValue exceptionValue;

  public:




    explicit AutoSaveExceptionState(JSContext* cx);





    ~AutoSaveExceptionState();





    void drop() {
        wasPropagatingForcedReturn = false;
        wasOverRecursed = false;
        wasThrowing = false;
        exceptionValue.setUndefined();
    }






    void restore();
};

}


extern JSExceptionState*
JS_SaveExceptionState(JSContext* cx);

extern void
JS_RestoreExceptionState(JSContext* cx, JSExceptionState* state);

extern void
JS_DropExceptionState(JSContext* cx, JSExceptionState* state);
extern JSErrorReport*
JS_ErrorFromException(JSContext* cx, JS::HandleObject obj);
extern JSObject*
ExceptionStackOrNull(JS::HandleObject obj);




extern bool
JS_ThrowStopIteration(JSContext* cx);

extern bool
JS_IsStopIteration(const JS::Value& v);
extern void
JS_AbortIfWrongThread(JSContext* cx);
extern JSObject*
JS_NewObjectForConstructor(JSContext* cx, const JSClass* clasp, const JS::CallArgs& args);






extern void
JS_GetGCZealBits(JSContext* cx, uint32_t* zealBits, uint32_t* frequency, uint32_t* nextScheduled);

extern void
JS_SetGCZeal(JSContext* cx, uint8_t zeal, uint32_t frequency);

extern void
JS_ScheduleGC(JSContext* cx, uint32_t count);


extern void
JS_SetParallelParsingEnabled(JSContext* cx, bool enabled);

extern void
JS_SetOffthreadIonCompilationEnabled(JSContext* cx, bool enabled);
typedef enum JSJitCompilerOption {



    JSJITCOMPILER_BASELINE_WARMUP_TRIGGER, JSJITCOMPILER_ION_WARMUP_TRIGGER, JSJITCOMPILER_ION_GVN_ENABLE, JSJITCOMPILER_ION_FORCE_IC, JSJITCOMPILER_ION_ENABLE, JSJITCOMPILER_ION_INTERRUPT_WITHOUT_SIGNAL, JSJITCOMPILER_ION_CHECK_RANGE_ANALYSIS, JSJITCOMPILER_BASELINE_ENABLE, JSJITCOMPILER_OFFTHREAD_COMPILATION_ENABLE, JSJITCOMPILER_FULL_DEBUG_CHECKS, JSJITCOMPILER_JUMP_THRESHOLD, JSJITCOMPILER_ASMJS_ATOMICS_ENABLE, JSJITCOMPILER_WASM_TEST_MODE, JSJITCOMPILER_WASM_FOLD_OFFSETS,


    JSJITCOMPILER_NOT_AN_OPTION
} JSJitCompilerOption;

extern void
JS_SetGlobalJitCompilerOption(JSContext* cx, JSJitCompilerOption opt, uint32_t value);
extern bool
JS_GetGlobalJitCompilerOption(JSContext* cx, JSJitCompilerOption opt, uint32_t* valueOut);




extern bool
JS_IndexToId(JSContext* cx, uint32_t index, JS::MutableHandleId);






extern bool
JS_CharsToId(JSContext* cx, JS::TwoByteChars chars, JS::MutableHandleId);




extern bool
JS_IsIdentifier(JSContext* cx, JS::HandleString str, bool* isIdentifier);






extern bool
JS_IsIdentifier(const char16_t* chars, size_t length);

namespace js {
class ScriptSource;
}

namespace JS {

class AutoFilename
{
  private:
    js::ScriptSource* ss_;
    mozilla::Variant<const char*, UniqueChars> filename_;

    AutoFilename(const AutoFilename&) = delete;
    AutoFilename& operator=(const AutoFilename&) = delete;

  public:
    AutoFilename()
      : ss_(nullptr),
        filename_(mozilla::AsVariant<const char*>(nullptr))
    {}

    ~AutoFilename() {
        reset();
    }

    void reset();

    void setOwned(UniqueChars&& filename);
    void setUnowned(const char* filename);
    void setScriptSource(js::ScriptSource* ss);

    const char* get() const;
};
extern bool
DescribeScriptedCaller(JSContext* cx, AutoFilename* filename = nullptr,
                       unsigned* lineno = nullptr, unsigned* column = nullptr);

extern JSObject*
GetScriptedCallerGlobal(JSContext* cx);
extern void
HideScriptedCaller(JSContext* cx);

extern void
UnhideScriptedCaller(JSContext* cx);

class AutoHideScriptedCaller
{
  public:
    explicit AutoHideScriptedCaller(JSContext* cx
                                                                   )
      : mContext(cx)
    {
        do { } while (0);
        HideScriptedCaller(mContext);
    }
    ~AutoHideScriptedCaller() {
        UnhideScriptedCaller(mContext);
    }

  protected:
    JSContext* mContext;

};





typedef mozilla::Vector<uint8_t> TranscodeBuffer;

enum TranscodeResult
{

    TranscodeResult_Ok = 0,


    TranscodeResult_Failure = 0x100,
    TranscodeResult_Failure_BadBuildId = TranscodeResult_Failure | 0x1,
    TranscodeResult_Failure_RunOnceNotSupported = TranscodeResult_Failure | 0x2,
    TranscodeResult_Failure_AsmJSNotSupported = TranscodeResult_Failure | 0x3,
    TranscodeResult_Failure_UnknownClassKind = TranscodeResult_Failure | 0x4,
    TranscodeResult_Failure_WrongCompileOption = TranscodeResult_Failure | 0x5,
    TranscodeResult_Failure_NotInterpretedFun = TranscodeResult_Failure | 0x6,


    TranscodeResult_Throw = 0x200
};

extern TranscodeResult
EncodeScript(JSContext* cx, TranscodeBuffer& buffer, JS::HandleScript script);

extern TranscodeResult
EncodeInterpretedFunction(JSContext* cx, TranscodeBuffer& buffer, JS::HandleObject funobj);

extern TranscodeResult
DecodeScript(JSContext* cx, TranscodeBuffer& buffer, JS::MutableHandleScript scriptp,
             size_t cursorIndex = 0);

extern TranscodeResult
DecodeInterpretedFunction(JSContext* cx, TranscodeBuffer& buffer, JS::MutableHandleFunction funp,
                          size_t cursorIndex = 0);
extern bool
StartIncrementalEncoding(JSContext* cx, TranscodeBuffer& buffer, JS::HandleScript script);

extern bool
FinishIncrementalEncoding(JSContext* cx, JS::HandleScript script);

}

namespace js {

enum class StackFormat { SpiderMonkey, V8, Default };
extern void
SetStackFormat(JSContext* cx, StackFormat format);

extern StackFormat
GetStackFormat(JSContext* cx);

}

namespace JS {
typedef bool
(* OpenAsmJSCacheEntryForReadOp)(HandleObject global, const char16_t* begin, const char16_t* limit,
                                 size_t* size, const uint8_t** memory, intptr_t* handle);
typedef void
(* CloseAsmJSCacheEntryForReadOp)(size_t size, const uint8_t* memory, intptr_t handle);


enum AsmJSCacheResult
{
    AsmJSCache_Success,
    AsmJSCache_MIN = AsmJSCache_Success,
    AsmJSCache_ModuleTooSmall,
    AsmJSCache_SynchronousScript,
    AsmJSCache_QuotaExceeded,
    AsmJSCache_StorageInitFailure,
    AsmJSCache_Disabled_Internal,
    AsmJSCache_Disabled_ShellFlags,
    AsmJSCache_Disabled_JitInspector,
    AsmJSCache_InternalError,
    AsmJSCache_Disabled_PrivateBrowsing,
    AsmJSCache_LIMIT
};
typedef AsmJSCacheResult
(* OpenAsmJSCacheEntryForWriteOp)(HandleObject global, const char16_t* begin,
                                  const char16_t* end, size_t size,
                                  uint8_t** memory, intptr_t* handle);
typedef void
(* CloseAsmJSCacheEntryForWriteOp)(size_t size, uint8_t* memory, intptr_t handle);

struct AsmJSCacheOps
{
    OpenAsmJSCacheEntryForReadOp openEntryForRead;
    CloseAsmJSCacheEntryForReadOp closeEntryForRead;
    OpenAsmJSCacheEntryForWriteOp openEntryForWrite;
    CloseAsmJSCacheEntryForWriteOp closeEntryForWrite;
};

extern void
SetAsmJSCacheOps(JSContext* cx, const AsmJSCacheOps* callbacks);
typedef js::Vector<char, 0, js::SystemAllocPolicy> BuildIdCharVector;

typedef bool
(* BuildIdOp)(BuildIdCharVector* buildId);

extern void
SetBuildIdOp(JSContext* cx, BuildIdOp buildIdOp);
struct WasmModule : js::AtomicRefCounted<WasmModule>
{
    virtual ~WasmModule() {}

    virtual void serializedSize(size_t* maybeBytecodeSize, size_t* maybeCompiledSize) const = 0;
    virtual void serialize(uint8_t* maybeBytecodeBegin, size_t maybeBytecodeSize,
                           uint8_t* maybeCompiledBegin, size_t maybeCompiledSize) const = 0;

    virtual JSObject* createObject(JSContext* cx) = 0;
};

extern bool
IsWasmModuleObject(HandleObject obj);

extern RefPtr<WasmModule>
GetWasmModule(HandleObject obj);

extern bool
CompiledWasmModuleAssumptionsMatch(PRFileDesc* compiled, BuildIdCharVector&& buildId);

extern RefPtr<WasmModule>
DeserializeWasmModule(PRFileDesc* bytecode, PRFileDesc* maybeCompiled, BuildIdCharVector&& buildId,
                      JS::UniqueChars filename, unsigned line, unsigned column);
class ForOfIterator {
  protected:
    JSContext* cx_;
    JS::RootedObject iterator;
    uint32_t index;

    static const uint32_t NOT_ARRAY = (4294967295U);

    ForOfIterator(const ForOfIterator&) = delete;
    ForOfIterator& operator=(const ForOfIterator&) = delete;

  public:
    explicit ForOfIterator(JSContext* cx) : cx_(cx), iterator(cx_), index(NOT_ARRAY) { }

    enum NonIterableBehavior {
        ThrowOnNonIterable,
        AllowNonIterable
    };







    bool init(JS::HandleValue iterable,
              NonIterableBehavior nonIterableBehavior = ThrowOnNonIterable);





    bool next(JS::MutableHandleValue val, bool* done);





    void closeThrow();





    bool valueIsIterable() const {
        return iterator;
    }

  private:
    inline bool nextFromOptimizedArray(MutableHandleValue val, bool* done);
    bool materializeArrayIterator();
};
typedef void
(* LargeAllocationFailureCallback)(void* data);

extern void
SetLargeAllocationFailureCallback(JSContext* cx, LargeAllocationFailureCallback afc, void* data);
typedef void
(* OutOfMemoryCallback)(JSContext* cx, void* data);

extern void
SetOutOfMemoryCallback(JSContext* cx, OutOfMemoryCallback cb, void* data);




struct AllFrames { };




struct MaxFrames
{
    uint32_t maxFrames;

    explicit MaxFrames(uint32_t max)
      : maxFrames(max)
    {
        do { } while (0);
    }
};






struct FirstSubsumedFrame
{
    JSContext* cx;
    JSPrincipals* principals;
    bool ignoreSelfHosted;




    explicit FirstSubsumedFrame(JSContext* cx, bool ignoreSelfHostedFrames = true);

    explicit FirstSubsumedFrame(JSContext* ctx, JSPrincipals* p, bool ignoreSelfHostedFrames = true)
      : cx(ctx)
      , principals(p)
      , ignoreSelfHosted(ignoreSelfHostedFrames)
    {
        if (principals)
            JS_HoldPrincipals(principals);
    }



    FirstSubsumedFrame(const FirstSubsumedFrame&) = delete;
    FirstSubsumedFrame& operator=(const FirstSubsumedFrame&) = delete;

    FirstSubsumedFrame(FirstSubsumedFrame&& rhs)
      : principals(rhs.principals)
      , ignoreSelfHosted(rhs.ignoreSelfHosted)
    {
        do { } while (0);
        rhs.principals = nullptr;
    }

    FirstSubsumedFrame& operator=(FirstSubsumedFrame&& rhs) {
        new (this) FirstSubsumedFrame(mozilla::Move(rhs));
        return *this;
    }

    ~FirstSubsumedFrame() {
        if (principals)
            JS_DropPrincipals(cx, principals);
    }
};

using StackCapture = mozilla::Variant<AllFrames, MaxFrames, FirstSubsumedFrame>;
extern bool
CaptureCurrentStack(JSContext* cx, MutableHandleObject stackp,
                    StackCapture&& capture = StackCapture(AllFrames()));
extern bool
CopyAsyncStack(JSContext* cx, HandleObject asyncStack,
               HandleString asyncCause, MutableHandleObject stackp,
               unsigned maxFrameCount);
enum class SavedFrameResult {
    Ok,
    AccessDenied
};

enum class SavedFrameSelfHosted {
    Include,
    Exclude
};





extern SavedFrameResult
GetSavedFrameSource(JSContext* cx, HandleObject savedFrame, MutableHandleString sourcep,
                    SavedFrameSelfHosted selfHosted = SavedFrameSelfHosted::Include);




extern SavedFrameResult
GetSavedFrameLine(JSContext* cx, HandleObject savedFrame, uint32_t* linep,
                  SavedFrameSelfHosted selfHosted = SavedFrameSelfHosted::Include);




extern SavedFrameResult
GetSavedFrameColumn(JSContext* cx, HandleObject savedFrame, uint32_t* columnp,
                    SavedFrameSelfHosted selfHosted = SavedFrameSelfHosted::Include);






extern SavedFrameResult
GetSavedFrameFunctionDisplayName(JSContext* cx, HandleObject savedFrame, MutableHandleString namep,
                                 SavedFrameSelfHosted selfHosted = SavedFrameSelfHosted::Include);




extern SavedFrameResult
GetSavedFrameAsyncCause(JSContext* cx, HandleObject savedFrame, MutableHandleString asyncCausep,
                        SavedFrameSelfHosted selfHosted = SavedFrameSelfHosted::Include);






extern SavedFrameResult
GetSavedFrameAsyncParent(JSContext* cx, HandleObject savedFrame, MutableHandleObject asyncParentp,
                SavedFrameSelfHosted selfHosted = SavedFrameSelfHosted::Include);






extern SavedFrameResult
GetSavedFrameParent(JSContext* cx, HandleObject savedFrame, MutableHandleObject parentp,
                    SavedFrameSelfHosted selfHosted = SavedFrameSelfHosted::Include);
extern bool
BuildStackString(JSContext* cx, HandleObject stack, MutableHandleString stringp,
                 size_t indent = 0, js::StackFormat stackFormat = js::StackFormat::Default);





extern bool
IsSavedFrame(JSObject* obj);

}




namespace js {

class AutoStopwatch;







struct PerformanceGroup {
    PerformanceGroup();


    uint64_t iteration() const;




    bool isAcquired(uint64_t it) const;




    bool isAcquired(uint64_t it, const AutoStopwatch* owner) const;



    void acquire(uint64_t it, const AutoStopwatch* owner);



    void release(uint64_t it, const AutoStopwatch* owner);





    uint64_t recentCycles(uint64_t iteration) const;
    void addRecentCycles(uint64_t iteration, uint64_t cycles);



    uint64_t recentTicks(uint64_t iteration) const;
    void addRecentTicks(uint64_t iteration, uint64_t ticks);



    uint64_t recentCPOW(uint64_t iteration) const;
    void addRecentCPOW(uint64_t iteration, uint64_t CPOW);


    void resetRecentData();



    bool isActive() const;
    void setIsActive(bool);



    bool isUsedInThisIteration() const;
    void setIsUsedInThisIteration(bool);
  protected:


    virtual void Delete() = 0;

  private:




    uint64_t recentCycles_;



    uint64_t recentTicks_;



    uint64_t recentCPOW_;



    uint64_t iteration_;



    bool isActive_;



    bool isUsedInThisIteration_;



    const AutoStopwatch* owner_;

  public:

    void AddRef();
    void Release();
    uint64_t refCount_;
};

using PerformanceGroupVector = mozilla::Vector<RefPtr<js::PerformanceGroup>, 8, SystemAllocPolicy>;







extern bool
FlushPerformanceMonitoring(JSContext*);




extern void
ResetPerformanceMonitoring(JSContext*);




extern void
DisposePerformanceMonitoring(JSContext*);
extern bool
SetStopwatchIsMonitoringCPOW(JSContext*, bool);
extern bool
GetStopwatchIsMonitoringCPOW(JSContext*);
extern bool
SetStopwatchIsMonitoringJank(JSContext*, bool);
extern bool
GetStopwatchIsMonitoringJank(JSContext*);


extern void
GetPerfMonitoringTestCpuRescheduling(JSContext*, uint64_t* stayed, uint64_t* moved);






extern void
AddCPOWPerformanceDelta(JSContext*, uint64_t delta);

typedef bool
(*StopwatchStartCallback)(uint64_t, void*);
extern bool
SetStopwatchStartCallback(JSContext*, StopwatchStartCallback, void*);

typedef bool
(*StopwatchCommitCallback)(uint64_t, PerformanceGroupVector&, void*);
extern bool
SetStopwatchCommitCallback(JSContext*, StopwatchCommitCallback, void*);

typedef bool
(*GetGroupsCallback)(JSContext*, PerformanceGroupVector&, void*);
extern bool
SetGetPerformanceGroupsCallback(JSContext*, GetGroupsCallback, void*);

}

namespace js {

enum class CompletionKind {
    Normal,
    Return,
    Throw
};

}
class nsIObjectInputStream;

class nsIObjectOutputStream;
class nsISerializable : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult Read(nsIObjectInputStream *aInputStream) = 0;


  virtual nsresult Write(nsIObjectOutputStream *aOutputStream) = 0;

};

  template<typename T> struct nsISerializable::COMTypeInfo<nsISerializable, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsISerializable::COMTypeInfo<nsISerializable, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x91cca981, 0xc26d, 0x44a8, { 0xbe, 0xbe, 0xd9, 0xed, 0x48, 0x91, 0x50, 0x3a }};
struct JSPrincipals;



namespace mozilla {
class OriginAttributes;
}
class nsIURI;

class nsIContentSecurityPolicy;

class nsIDOMDocument;
class nsIPrincipal : public nsISerializable {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult Equals(nsIPrincipal *other, bool *_retval) = 0;


  virtual nsresult EqualsConsideringDomain(nsIPrincipal *other, bool *_retval) = 0;

       inline bool Equals(nsIPrincipal* aOther) { mozilla::DebugOnly<bool> val = false; do { } while (0); bool retVal = false; return this == aOther || (((bool)(__builtin_expect(!!(!NS_FAILED_impl(Equals(aOther, &retVal))), 1))) && retVal); }
      inline bool EqualsConsideringDomain(nsIPrincipal* aOther) { mozilla::DebugOnly<bool> val = false; do { } while (0); bool retVal = false; return this == aOther || (((bool)(__builtin_expect(!!(!NS_FAILED_impl(EqualsConsideringDomain(aOther, &retVal))), 1))) && retVal); }

  virtual nsresult GetHashValue(uint32_t *aHashValue) = 0;


  virtual nsresult GetURI(nsIURI * *aURI) = 0;


  virtual nsresult GetDomain(nsIURI * *aDomain) = 0;
  virtual nsresult SetDomain(nsIURI *aDomain) = 0;


  virtual nsresult Subsumes(nsIPrincipal *other, bool *_retval) = 0;


  virtual nsresult SubsumesConsideringDomain(nsIPrincipal *other, bool *_retval) = 0;


  virtual nsresult SubsumesConsideringDomainIgnoringFPD(nsIPrincipal *other, bool *_retval) = 0;

       inline bool Subsumes(nsIPrincipal* aOther) { mozilla::DebugOnly<bool> val = false; do { } while (0); bool retVal = false; return this == aOther || (((bool)(__builtin_expect(!!(!NS_FAILED_impl(Subsumes(aOther, &retVal))), 1))) && retVal); }
      inline bool SubsumesConsideringDomain(nsIPrincipal* aOther) { mozilla::DebugOnly<bool> val = false; do { } while (0); bool retVal = false; return this == aOther || (((bool)(__builtin_expect(!!(!NS_FAILED_impl(SubsumesConsideringDomain(aOther, &retVal))), 1))) && retVal); }
      inline bool SubsumesConsideringDomainIgnoringFPD(nsIPrincipal* aOther) { mozilla::DebugOnly<bool> val = false; do { } while (0); bool retVal = false; return this == aOther || (((bool)(__builtin_expect(!!(!NS_FAILED_impl(SubsumesConsideringDomainIgnoringFPD(aOther, &retVal))), 1))) && retVal); }


  virtual nsresult CheckMayLoad(nsIURI *uri, bool report, bool allowIfInheritsPrincipal) = 0;


  virtual nsresult GetCsp(nsIContentSecurityPolicy * *aCsp) = 0;
  virtual nsresult SetCsp(nsIContentSecurityPolicy *aCsp) = 0;


  virtual nsresult EnsureCSP(nsIDOMDocument *aDocument, nsIContentSecurityPolicy * *_retval) = 0;


  virtual nsresult GetPreloadCsp(nsIContentSecurityPolicy * *aPreloadCsp) = 0;


  virtual nsresult EnsurePreloadCSP(nsIDOMDocument *aDocument, nsIContentSecurityPolicy * *_retval) = 0;


  virtual nsresult GetCspJSON(nsAString & aCspJSON) = 0;


  virtual nsresult GetOriginAttributes(JSContext* cx, JS::MutableHandleValue aOriginAttributes) = 0;


  virtual const mozilla::OriginAttributes & OriginAttributesRef(void) = 0;


  virtual nsresult GetOrigin(nsACString & aOrigin) = 0;


  virtual nsresult GetOriginNoSuffix(nsACString & aOriginNoSuffix) = 0;


  virtual nsresult GetOriginSuffix(nsACString & aOriginSuffix) = 0;


  virtual nsresult GetBaseDomain(nsACString & aBaseDomain) = 0;

  enum {
    APP_STATUS_NOT_INSTALLED = 0,
    APP_STATUS_INSTALLED = 1,
    APP_STATUS_PRIVILEGED = 2,
    APP_STATUS_CERTIFIED = 3
  };


  virtual nsresult GetAppStatus(uint16_t *aAppStatus) = 0;
  inline uint16_t GetAppStatus()
  {
    uint16_t result;
    mozilla::DebugOnly<nsresult> rv = GetAppStatus(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetAppId(uint32_t *aAppId) = 0;
  inline uint32_t GetAppId()
  {
    uint32_t result;
    mozilla::DebugOnly<nsresult> rv = GetAppId(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetAddonId(nsAString & aAddonId) = 0;


  virtual nsresult GetUserContextId(uint32_t *aUserContextId) = 0;
  inline uint32_t GetUserContextId()
  {
    uint32_t result;
    mozilla::DebugOnly<nsresult> rv = GetUserContextId(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetPrivateBrowsingId(uint32_t *aPrivateBrowsingId) = 0;
  inline uint32_t GetPrivateBrowsingId()
  {
    uint32_t result;
    mozilla::DebugOnly<nsresult> rv = GetPrivateBrowsingId(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetIsInIsolatedMozBrowserElement(bool *aIsInIsolatedMozBrowserElement) = 0;
  inline bool GetIsInIsolatedMozBrowserElement()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetIsInIsolatedMozBrowserElement(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetUnknownAppId(bool *aUnknownAppId) = 0;
  inline bool GetUnknownAppId()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetUnknownAppId(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetIsNullPrincipal(bool *aIsNullPrincipal) = 0;
  inline bool GetIsNullPrincipal()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetIsNullPrincipal(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetIsCodebasePrincipal(bool *aIsCodebasePrincipal) = 0;
  inline bool GetIsCodebasePrincipal()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetIsCodebasePrincipal(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetIsExpandedPrincipal(bool *aIsExpandedPrincipal) = 0;
  inline bool GetIsExpandedPrincipal()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetIsExpandedPrincipal(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetIsSystemPrincipal(bool *aIsSystemPrincipal) = 0;
  inline bool GetIsSystemPrincipal()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetIsSystemPrincipal(&result);
    do { } while (0);
    return result;
  }

};

  template<typename T> struct nsIPrincipal::COMTypeInfo<nsIPrincipal, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIPrincipal::COMTypeInfo<nsIPrincipal, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xf75f502d, 0x79fd, 0x48be, { 0xa0, 0x79, 0xe5, 0xa7, 0xb8, 0xf8, 0x0c, 0x8b }};
class nsIExpandedPrincipal : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetWhiteList(nsTArray<nsCOMPtr<nsIPrincipal> > **aWhiteList) = 0;

};

  template<typename T> struct nsIExpandedPrincipal::COMTypeInfo<nsIExpandedPrincipal, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIExpandedPrincipal::COMTypeInfo<nsIExpandedPrincipal, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xf3e177df, 0x6a5e, 0x489f, { 0x80, 0xa7, 0x2d, 0xd1, 0x48, 0x14, 0x71, 0xd8 }};

class nsJSPrincipals : public nsIPrincipal, public JSPrincipals
{
public:

  static bool Subsume(JSPrincipals *jsprin, JSPrincipals *other);
  static void Destroy(JSPrincipals *jsprin);


  static bool ReadPrincipals(JSContext* aCx, JSStructuredCloneReader* aReader,
                             JSPrincipals** aOutPrincipals);

  static bool ReadKnownPrincipalType(JSContext* aCx,
                                     JSStructuredCloneReader* aReader,
                                     uint32_t aTag,
                                     JSPrincipals** aOutPrincipals);

  bool write(JSContext* aCx, JSStructuredCloneWriter* aWriter) final;





  static nsJSPrincipals* get(JSPrincipals *principals) {
    nsJSPrincipals *self = static_cast<nsJSPrincipals *>(principals);
    do { } while (0);
    return self;
  }
  static nsJSPrincipals* get(nsIPrincipal *principal) {
    nsJSPrincipals *self = static_cast<nsJSPrincipals *>(principal);
    do { } while (0);
    return self;
  }

  virtual MozExternalRefCountType AddRef(void) override;
  virtual MozExternalRefCountType Release(void) override;

  nsJSPrincipals() {
    refcount = 0;
    setDebugToken(DEBUG_TOKEN);
  }




  virtual nsresult GetScriptLocation(nsACString &aStr) = 0;
  static const uint32_t DEBUG_TOKEN = 0x0bf41760;

protected:
  virtual ~nsJSPrincipals() {
    setDebugToken(0);
  }

};


namespace mozilla {
namespace dom {

class ChromeUtils;
struct ChromeUtilsAtoms;
struct CompileScriptOptionsDictionaryAtoms;
struct NativePropertyHooks;
struct OriginAttributesDictionaryAtoms;
struct OriginAttributesPatternDictionaryAtoms;
class ProtoAndIfaceCache;

}
}

namespace mozilla {
namespace dom {

struct CompileScriptOptionsDictionary : public DictionaryBase
{
                        nsString mCharset;
                        bool mHasReturnValue;
                        bool mLazilyParse;

  CompileScriptOptionsDictionary();

  explicit inline CompileScriptOptionsDictionary(const FastDictionaryInitializer& )
  {

  }

  explicit inline CompileScriptOptionsDictionary(const CompileScriptOptionsDictionary& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  CompileScriptOptionsDictionary&
  operator=(const CompileScriptOptionsDictionary& aOther);

private:
  static bool
  InitIds(JSContext* cx, CompileScriptOptionsDictionaryAtoms* atomsCache);
};

namespace binding_detail {
struct FastCompileScriptOptionsDictionary : public CompileScriptOptionsDictionary
{
  inline FastCompileScriptOptionsDictionary()
    : CompileScriptOptionsDictionary(FastDictionaryInitializer())
  {

  }
};
}


struct OriginAttributesDictionary : public DictionaryBase
{
                        uint32_t mAppId;
                        nsString mFirstPartyDomain;
                        bool mInIsolatedMozBrowser;
                        uint32_t mPrivateBrowsingId;
                        uint32_t mUserContextId;

  OriginAttributesDictionary();

  explicit inline OriginAttributesDictionary(const FastDictionaryInitializer& )
  {

  }

  explicit inline OriginAttributesDictionary(const OriginAttributesDictionary& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  OriginAttributesDictionary&
  operator=(const OriginAttributesDictionary& aOther);

private:
  static bool
  InitIds(JSContext* cx, OriginAttributesDictionaryAtoms* atomsCache);
};

namespace binding_detail {
struct FastOriginAttributesDictionary : public OriginAttributesDictionary
{
  inline FastOriginAttributesDictionary()
    : OriginAttributesDictionary(FastDictionaryInitializer())
  {

  }
};
}


struct OriginAttributesPatternDictionary : public DictionaryBase
{
                        Optional<uint32_t> mAppId;
                        Optional<nsString> mFirstPartyDomain;
                        Optional<bool> mInIsolatedMozBrowser;
                        Optional<uint32_t> mPrivateBrowsingId;
                        Optional<uint32_t> mUserContextId;

  OriginAttributesPatternDictionary();

  explicit inline OriginAttributesPatternDictionary(const FastDictionaryInitializer& )
  {

  }

  explicit inline OriginAttributesPatternDictionary(const OriginAttributesPatternDictionary& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  OriginAttributesPatternDictionary&
  operator=(const OriginAttributesPatternDictionary& aOther);

private:
  static bool
  InitIds(JSContext* cx, OriginAttributesPatternDictionaryAtoms* atomsCache);
};

namespace binding_detail {
struct FastOriginAttributesPatternDictionary : public OriginAttributesPatternDictionary
{
  inline FastOriginAttributesPatternDictionary()
    : OriginAttributesPatternDictionary(FastDictionaryInitializer())
  {

  }
};
}


namespace ChromeUtilsBinding {

  typedef mozilla::dom::ChromeUtils NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true);

  JSObject*
  GetConstructorObject(JSContext* aCx);

}



}
}
namespace mozilla {
namespace dom {

struct Base64URLDecodeOptionsAtoms;
struct Base64URLEncodeOptionsAtoms;
struct HeapSnapshotBoundariesAtoms;
struct NativePropertyHooks;
class ProtoAndIfaceCache;
class ThreadSafeChromeUtils;
struct ThreadSafeChromeUtilsAtoms;

}
}

namespace mozilla {
namespace dom {

enum class Base64URLDecodePadding : uint8_t {
  Require,
  Ignore,
  Reject,
  EndGuard_
};

namespace Base64URLDecodePaddingValues {
extern const EnumEntry strings[4];
}

bool
ToJSValue(JSContext* aCx, Base64URLDecodePadding aArgument, JS::MutableHandle<JS::Value> aValue);


struct Base64URLDecodeOptions : public DictionaryBase
{
                        Base64URLDecodePadding mPadding;

  Base64URLDecodeOptions();

  explicit inline Base64URLDecodeOptions(const FastDictionaryInitializer& )
  {

  }

  explicit inline Base64URLDecodeOptions(const Base64URLDecodeOptions& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  Base64URLDecodeOptions&
  operator=(const Base64URLDecodeOptions& aOther);

private:
  static bool
  InitIds(JSContext* cx, Base64URLDecodeOptionsAtoms* atomsCache);
};

namespace binding_detail {
struct FastBase64URLDecodeOptions : public Base64URLDecodeOptions
{
  inline FastBase64URLDecodeOptions()
    : Base64URLDecodeOptions(FastDictionaryInitializer())
  {

  }
};
}


struct Base64URLEncodeOptions : public DictionaryBase
{
                        bool mPad;

  Base64URLEncodeOptions();

  explicit inline Base64URLEncodeOptions(const FastDictionaryInitializer& )
  {

  }

  explicit inline Base64URLEncodeOptions(const Base64URLEncodeOptions& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  Base64URLEncodeOptions&
  operator=(const Base64URLEncodeOptions& aOther);

private:
  static bool
  InitIds(JSContext* cx, Base64URLEncodeOptionsAtoms* atomsCache);
};

namespace binding_detail {
struct FastBase64URLEncodeOptions : public Base64URLEncodeOptions
{
  inline FastBase64URLEncodeOptions()
    : Base64URLEncodeOptions(FastDictionaryInitializer())
  {

  }
};
}


struct HeapSnapshotBoundaries : public DictionaryBase
{
                        Optional<JSObject*> mDebugger;
                        Optional<Sequence<JSObject*>> mGlobals;
                        Optional<bool> mRuntime;

  HeapSnapshotBoundaries();

  explicit inline HeapSnapshotBoundaries(const FastDictionaryInitializer& )
  {

  }

private:
  HeapSnapshotBoundaries(const HeapSnapshotBoundaries&) = delete;
  HeapSnapshotBoundaries& operator=(const HeapSnapshotBoundaries&) = delete;

  static bool
  InitIds(JSContext* cx, HeapSnapshotBoundariesAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);
};

namespace binding_detail {
struct FastHeapSnapshotBoundaries : public HeapSnapshotBoundaries
{
  inline FastHeapSnapshotBoundaries()
    : HeapSnapshotBoundaries(FastDictionaryInitializer())
  {

  }
};
}


namespace ThreadSafeChromeUtilsBinding {

  typedef mozilla::dom::ThreadSafeChromeUtils NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true);

  JSObject*
  GetConstructorObject(JSContext* aCx);

}



}
}


namespace mozilla {

namespace devtools {
class HeapSnapshot;
}

namespace dom {

class ArrayBufferViewOrArrayBuffer;
class PrecompiledScript;
class Promise;

class ThreadSafeChromeUtils
{
private:

  static void SaveHeapSnapshotShared(GlobalObject& global,
                                     const HeapSnapshotBoundaries& boundaries,
                                     nsAString& filePath,
                                     nsAString& snapshotId,
                                     ErrorResult& rv);

public:

  static void SaveHeapSnapshot(GlobalObject& global,
                               const HeapSnapshotBoundaries& boundaries,
                               nsAString& filePath,
                               ErrorResult& rv);


  static void SaveHeapSnapshotGetId(GlobalObject& global,
                                    const HeapSnapshotBoundaries& boundaries,
                                    nsAString& snapshotId,
                                    ErrorResult& rv);


  static already_AddRefed<devtools::HeapSnapshot> ReadHeapSnapshot(GlobalObject& global,
                                                                   const nsAString& filePath,
                                                                   ErrorResult& rv);

  static void NondeterministicGetWeakMapKeys(GlobalObject& aGlobal,
                                             JS::Handle<JS::Value> aMap,
                                             JS::MutableHandle<JS::Value> aRetval,
                                             ErrorResult& aRv);

  static void NondeterministicGetWeakSetKeys(GlobalObject& aGlobal,
                                             JS::Handle<JS::Value> aSet,
                                             JS::MutableHandle<JS::Value> aRetval,
                                             ErrorResult& aRv);

  static void Base64URLEncode(GlobalObject& aGlobal,
                              const ArrayBufferViewOrArrayBuffer& aSource,
                              const Base64URLEncodeOptions& aOptions,
                              nsACString& aResult,
                              ErrorResult& aRv);

  static void Base64URLDecode(GlobalObject& aGlobal,
                              const nsACString& aString,
                              const Base64URLDecodeOptions& aOptions,
                              JS::MutableHandle<JSObject*> aRetval,
                              ErrorResult& aRv);
};

class ChromeUtils : public ThreadSafeChromeUtils
{
public:
  static void
  OriginAttributesToSuffix(GlobalObject& aGlobal,
                           const dom::OriginAttributesDictionary& aAttrs,
                           nsCString& aSuffix);

  static bool
  OriginAttributesMatchPattern(dom::GlobalObject& aGlobal,
                               const dom::OriginAttributesDictionary& aAttrs,
                               const dom::OriginAttributesPatternDictionary& aPattern);

  static void
  CreateOriginAttributesFromOrigin(dom::GlobalObject& aGlobal,
                                   const nsAString& aOrigin,
                                   dom::OriginAttributesDictionary& aAttrs,
                                   ErrorResult& aRv);

  static void
  FillNonDefaultOriginAttributes(dom::GlobalObject& aGlobal,
                                 const dom::OriginAttributesDictionary& aAttrs,
                                 dom::OriginAttributesDictionary& aNewAttrs);

  static bool
  IsOriginAttributesEqual(dom::GlobalObject& aGlobal,
                          const dom::OriginAttributesDictionary& aA,
                          const dom::OriginAttributesDictionary& aB);

  static bool
  IsOriginAttributesEqual(const dom::OriginAttributesDictionary& aA,
                          const dom::OriginAttributesDictionary& aB);

  static bool
  IsOriginAttributesEqualIgnoringFPD(const dom::OriginAttributesDictionary& aA,
                                     const dom::OriginAttributesDictionary& aB)
  {
    return aA.mAppId == aB.mAppId &&
           aA.mInIsolatedMozBrowser == aB.mInIsolatedMozBrowser &&
           aA.mUserContextId == aB.mUserContextId &&
           aA.mPrivateBrowsingId == aB.mPrivateBrowsingId;
  }


  static already_AddRefed<Promise>
  CompileScript(GlobalObject& aGlobal,
                const nsAString& aUrl,
                const dom::CompileScriptOptionsDictionary& aOptions,
                ErrorResult& aRv);
};

}
}

class nsIURI;

class nsIChannel;

class nsIClassInfo;

class nsIDocShell;

class nsIDomainPolicy;

class nsILoadContext;


namespace mozilla {
namespace dom {
class DomainPolicyClone;
}
}
class nsIScriptSecurityManager : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult CanCreateWrapper(JSContext *aJSContext, const nsIID & aIID, nsISupports *aObj, nsIClassInfo *aClassInfo) = 0;


  virtual nsresult CanCreateInstance(JSContext *aJSContext, const nsCID & aCID) = 0;


  virtual nsresult CanGetService(JSContext *aJSContext, const nsCID & aCID) = 0;


  virtual nsresult CheckLoadURIFromScript(JSContext *cx, nsIURI *uri) = 0;

  enum {
    STANDARD = 0U,
    LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT = 1U,
    ALLOW_CHROME = 2U,
    DISALLOW_INHERIT_PRINCIPAL = 4U,
    DISALLOW_SCRIPT_OR_DATA = 4U,
    DISALLOW_SCRIPT = 8U,
    DONT_REPORT_ERRORS = 16U
  };


  virtual nsresult CheckLoadURIWithPrincipal(nsIPrincipal *aPrincipal, nsIURI *uri, uint32_t flags) = 0;


  virtual nsresult CheckLoadURIStrWithPrincipal(nsIPrincipal *aPrincipal, const nsACString & uri, uint32_t flags) = 0;


  virtual nsresult GetSystemPrincipal(nsIPrincipal * *_retval) = 0;


  virtual nsresult GetAppCodebasePrincipal(nsIURI *uri, uint32_t appId, bool inMozBrowser, nsIPrincipal * *_retval) = 0;


  virtual nsresult GetLoadContextCodebasePrincipal(nsIURI *uri, nsILoadContext *loadContext, nsIPrincipal * *_retval) = 0;


  virtual nsresult GetDocShellCodebasePrincipal(nsIURI *uri, nsIDocShell *docShell, nsIPrincipal * *_retval) = 0;


  virtual nsresult GetNoAppCodebasePrincipal(nsIURI *uri, nsIPrincipal * *_retval) = 0;


  virtual nsresult GetCodebasePrincipal(nsIURI *uri, nsIPrincipal * *_retval) = 0;


  virtual nsresult CreateCodebasePrincipal(nsIURI *uri, JS::HandleValue originAttributes, JSContext* cx, nsIPrincipal * *_retval) = 0;


  virtual nsresult CreateCodebasePrincipalFromOrigin(const nsACString & origin, nsIPrincipal * *_retval) = 0;


  virtual nsresult CreateNullPrincipal(JS::HandleValue originAttributes, JSContext* cx, nsIPrincipal * *_retval) = 0;


  virtual nsresult CheckSameOriginURI(nsIURI *aSourceURI, nsIURI *aTargetURI, bool reportError) = 0;


  virtual nsresult GetChannelResultPrincipal(nsIChannel *aChannel, nsIPrincipal * *_retval) = 0;


  virtual nsresult GetChannelResultPrincipalIfNotSandboxed(nsIChannel *aChannel, nsIPrincipal * *_retval) = 0;


  virtual nsresult GetChannelURIPrincipal(nsIChannel *aChannel, nsIPrincipal * *_retval) = 0;


  virtual nsresult IsSystemPrincipal(nsIPrincipal *aPrincipal, bool *_retval) = 0;

     bool IsSystemPrincipal(nsIPrincipal* aPrincipal) {
      bool isSystem = false;
      IsSystemPrincipal(aPrincipal, &isSystem);
      return isSystem;
    }
  enum {
    NO_APP_ID = 0U,
    UNKNOWN_APP_ID = 4294967295U,
    DEFAULT_USER_CONTEXT_ID = 0U
  };


  virtual nsresult ActivateDomainPolicy(nsIDomainPolicy * *_retval) = 0;


  virtual nsresult GetDomainPolicyActive(bool *aDomainPolicyActive) = 0;


  virtual nsresult ActivateDomainPolicyInternal(nsIDomainPolicy * *_retval) = 0;


  virtual void CloneDomainPolicy(mozilla::dom::DomainPolicyClone *aClone) = 0;


  virtual nsresult PolicyAllowsScript(nsIURI *aDomain, bool *_retval) = 0;

};

  template<typename T> struct nsIScriptSecurityManager::COMTypeInfo<nsIScriptSecurityManager, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIScriptSecurityManager::COMTypeInfo<nsIScriptSecurityManager, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x51daad87, 0x3a0c, 0x44cc, { 0xb6, 0x20, 0x73, 0x56, 0x80, 0x1c, 0x90, 0x22 }};

namespace mozilla {

class OriginAttributes : public dom::OriginAttributesDictionary
{
public:
  OriginAttributes() {}

  OriginAttributes(uint32_t aAppId, bool aInIsolatedMozBrowser)
  {
    mAppId = aAppId;
    mInIsolatedMozBrowser = aInIsolatedMozBrowser;
  }

  explicit OriginAttributes(const OriginAttributesDictionary& aOther)
    : OriginAttributesDictionary(aOther)
  {}

  void SetFirstPartyDomain(const bool aIsTopLevelDocument, nsIURI* aURI);
  void SetFirstPartyDomain(const bool aIsTopLevelDocument, const nsACString& aDomain);

  enum {
    STRIP_FIRST_PARTY_DOMAIN = 0x01,
    STRIP_USER_CONTEXT_ID = 0x02,
  };

  inline void StripAttributes(uint32_t aFlags)
  {
    if (aFlags & STRIP_FIRST_PARTY_DOMAIN) {
      mFirstPartyDomain.Truncate();
    }

    if (aFlags & STRIP_USER_CONTEXT_ID) {
      mUserContextId = nsIScriptSecurityManager::DEFAULT_USER_CONTEXT_ID;
    }
  }

  bool operator==(const OriginAttributes& aOther) const
  {
    return mAppId == aOther.mAppId &&
           mInIsolatedMozBrowser == aOther.mInIsolatedMozBrowser &&
           mUserContextId == aOther.mUserContextId &&
           mPrivateBrowsingId == aOther.mPrivateBrowsingId &&
           mFirstPartyDomain == aOther.mFirstPartyDomain;
  }

  bool operator!=(const OriginAttributes& aOther) const
  {
    return !(*this == aOther);
  }




  void CreateSuffix(nsACString& aStr) const;


  void CreateAnonymizedSuffix(nsACString& aStr) const;

  __attribute__ ((warn_unused_result)) bool PopulateFromSuffix(const nsACString& aStr);



  __attribute__ ((warn_unused_result)) bool PopulateFromOrigin(const nsACString& aOrigin,
                                       nsACString& aOriginNoSuffix);



  void SyncAttributesWithPrivateBrowsing(bool aInPrivateBrowsing);


  static inline bool IsFirstPartyEnabled()
  {
    return sFirstPartyIsolation;
  }




  static inline bool IsRestrictOpenerAccessForFPI()
  {


    return !sFirstPartyIsolation || sRestrictedOpenerAccess;
  }



  static bool IsPrivateBrowsing(const nsACString& aOrigin);

  static void InitPrefs();

private:
  static bool sFirstPartyIsolation;
  static bool sRestrictedOpenerAccess;
};

class OriginAttributesPattern : public dom::OriginAttributesPatternDictionary
{
public:






  OriginAttributesPattern() {}

  explicit OriginAttributesPattern(const OriginAttributesPatternDictionary& aOther)
    : OriginAttributesPatternDictionary(aOther) {}


  bool Matches(const OriginAttributes& aAttrs) const
  {
    if (mAppId.WasPassed() && mAppId.Value() != aAttrs.mAppId) {
      return false;
    }

    if (mInIsolatedMozBrowser.WasPassed() && mInIsolatedMozBrowser.Value() != aAttrs.mInIsolatedMozBrowser) {
      return false;
    }

    if (mUserContextId.WasPassed() && mUserContextId.Value() != aAttrs.mUserContextId) {
      return false;
    }

    if (mPrivateBrowsingId.WasPassed() && mPrivateBrowsingId.Value() != aAttrs.mPrivateBrowsingId) {
      return false;
    }

    if (mFirstPartyDomain.WasPassed() && mFirstPartyDomain.Value() != aAttrs.mFirstPartyDomain) {
      return false;
    }

    return true;
  }

  bool Overlaps(const OriginAttributesPattern& aOther) const
  {
    if (mAppId.WasPassed() && aOther.mAppId.WasPassed() &&
        mAppId.Value() != aOther.mAppId.Value()) {
      return false;
    }

    if (mInIsolatedMozBrowser.WasPassed() &&
        aOther.mInIsolatedMozBrowser.WasPassed() &&
        mInIsolatedMozBrowser.Value() != aOther.mInIsolatedMozBrowser.Value()) {
      return false;
    }

    if (mUserContextId.WasPassed() && aOther.mUserContextId.WasPassed() &&
        mUserContextId.Value() != aOther.mUserContextId.Value()) {
      return false;
    }

    if (mPrivateBrowsingId.WasPassed() && aOther.mPrivateBrowsingId.WasPassed() &&
        mPrivateBrowsingId.Value() != aOther.mPrivateBrowsingId.Value()) {
      return false;
    }

    if (mFirstPartyDomain.WasPassed() && aOther.mFirstPartyDomain.WasPassed() &&
        mFirstPartyDomain.Value() != aOther.mFirstPartyDomain.Value()) {
      return false;
    }

    return true;
  }
};

}

class nsIContentSecurityPolicy;
class nsIObjectOutputStream;
class nsIObjectInputStream;
class nsIURI;

class ExpandedPrincipal;

namespace mozilla {
class BasePrincipal : public nsJSPrincipals
{
public:
  enum PrincipalKind {
    eNullPrincipal,
    eCodebasePrincipal,
    eExpandedPrincipal,
    eSystemPrincipal
  };

  explicit BasePrincipal(PrincipalKind aKind);

  enum DocumentDomainConsideration { DontConsiderDocumentDomain, ConsiderDocumentDomain};
  bool Subsumes(nsIPrincipal* aOther, DocumentDomainConsideration aConsideration);

  virtual nsresult GetOrigin(nsACString& aOrigin) final;
  virtual nsresult GetOriginNoSuffix(nsACString& aOrigin) final;
  virtual nsresult Equals(nsIPrincipal* other, bool* _retval) final;
  virtual nsresult EqualsConsideringDomain(nsIPrincipal* other, bool* _retval) final;
  virtual nsresult Subsumes(nsIPrincipal* other, bool* _retval) final;
  virtual nsresult SubsumesConsideringDomain(nsIPrincipal* other, bool* _retval) final;
  virtual nsresult SubsumesConsideringDomainIgnoringFPD(nsIPrincipal* other, bool* _retval) final;
  virtual nsresult CheckMayLoad(nsIURI* uri, bool report, bool allowIfInheritsPrincipal) final;
  virtual nsresult GetCsp(nsIContentSecurityPolicy** aCsp) override;
  virtual nsresult SetCsp(nsIContentSecurityPolicy* aCsp) override;
  virtual nsresult EnsureCSP(nsIDOMDocument* aDocument, nsIContentSecurityPolicy** aCSP) override;
  virtual nsresult GetPreloadCsp(nsIContentSecurityPolicy** aPreloadCSP) override;
  virtual nsresult EnsurePreloadCSP(nsIDOMDocument* aDocument, nsIContentSecurityPolicy** aCSP) override;
  virtual nsresult GetCspJSON(nsAString& outCSPinJSON) override;
  virtual nsresult GetIsNullPrincipal(bool* aResult) override;
  virtual nsresult GetIsCodebasePrincipal(bool* aResult) override;
  virtual nsresult GetIsExpandedPrincipal(bool* aResult) override;
  virtual nsresult GetIsSystemPrincipal(bool* aResult) override;
  virtual nsresult GetOriginAttributes(JSContext* aCx, JS::MutableHandle<JS::Value> aVal) final;
  virtual nsresult GetOriginSuffix(nsACString& aOriginSuffix) final;
  virtual nsresult GetAppStatus(uint16_t* aAppStatus) final;
  virtual nsresult GetAppId(uint32_t* aAppStatus) final;
  virtual nsresult GetIsInIsolatedMozBrowserElement(bool* aIsInIsolatedMozBrowserElement) final;
  virtual nsresult GetUnknownAppId(bool* aUnknownAppId) final;
  virtual nsresult GetUserContextId(uint32_t* aUserContextId) final;
  virtual nsresult GetPrivateBrowsingId(uint32_t* aPrivateBrowsingId) final;

  virtual bool AddonHasPermission(const nsAString& aPerm);

  virtual bool IsCodebasePrincipal() const { return false; };

  static BasePrincipal* Cast(nsIPrincipal* aPrin) { return static_cast<BasePrincipal*>(aPrin); }

  static already_AddRefed<BasePrincipal>
  CreateCodebasePrincipal(const nsACString& aOrigin);





  static already_AddRefed<BasePrincipal>
  CreateCodebasePrincipal(nsIURI* aURI, const OriginAttributes& aAttrs);

  const OriginAttributes& OriginAttributesRef() final { return mOriginAttributes; }
  uint32_t AppId() const { return mOriginAttributes.mAppId; }
  uint32_t UserContextId() const { return mOriginAttributes.mUserContextId; }
  uint32_t PrivateBrowsingId() const { return mOriginAttributes.mPrivateBrowsingId; }
  bool IsInIsolatedMozBrowserElement() const { return mOriginAttributes.mInIsolatedMozBrowser; }

  PrincipalKind Kind() const { return mKind; }

  already_AddRefed<BasePrincipal> CloneStrippingUserContextIdAndFirstPartyDomain();




  bool AddonAllowsLoad(nsIURI* aURI, bool aExplicit = false);


  inline bool FastEquals(nsIPrincipal* aOther);
  inline bool FastEqualsConsideringDomain(nsIPrincipal* aOther);
  inline bool FastSubsumes(nsIPrincipal* aOther);
  inline bool FastSubsumesConsideringDomain(nsIPrincipal* aOther);
  inline bool FastSubsumesConsideringDomainIgnoringFPD(nsIPrincipal* aOther);

protected:
  virtual ~BasePrincipal();



  virtual bool SubsumesInternal(nsIPrincipal* aOther, DocumentDomainConsideration aConsider) = 0;




  virtual bool MayLoadInternal(nsIURI* aURI) = 0;
  friend class ::ExpandedPrincipal;

  void
  SetHasExplicitDomain()
  {
    mHasExplicitDomain = true;
  }




  void FinishInit(const nsACString& aOriginNoSuffix,
                  const OriginAttributes& aOriginAttributes);

  nsCOMPtr<nsIContentSecurityPolicy> mCSP;
  nsCOMPtr<nsIContentSecurityPolicy> mPreloadCSP;

private:
  static already_AddRefed<BasePrincipal>
  CreateCodebasePrincipal(nsIURI* aURI, const OriginAttributes& aAttrs,
                          const nsACString& aOriginNoSuffix);

  nsCOMPtr<nsIAtom> mOriginNoSuffix;
  nsCOMPtr<nsIAtom> mOriginSuffix;

  OriginAttributes mOriginAttributes;
  PrincipalKind mKind;
  bool mHasExplicitDomain;
  bool mInitialized;
};

inline bool
BasePrincipal::FastEquals(nsIPrincipal* aOther)
{
  auto other = Cast(aOther);
  if (Kind() != other->Kind()) {

    return false;
  }






  if (Kind() == eNullPrincipal || Kind() == eSystemPrincipal) {
    return this == other;
  }

  if (Kind() == eCodebasePrincipal) {
    return mOriginNoSuffix == other->mOriginNoSuffix &&
           mOriginSuffix == other->mOriginSuffix;
  }

  do { } while (0);
  return mOriginNoSuffix == other->mOriginNoSuffix;
}

inline bool
BasePrincipal::FastEqualsConsideringDomain(nsIPrincipal* aOther)
{


  auto other = Cast(aOther);
  if (!mHasExplicitDomain && !other->mHasExplicitDomain) {
    return FastEquals(aOther);
  }

  return Subsumes(aOther, ConsiderDocumentDomain) &&
         other->Subsumes(this, ConsiderDocumentDomain);
}

inline bool
BasePrincipal::FastSubsumes(nsIPrincipal* aOther)
{




  auto other = Cast(aOther);
  if (Kind() == eNullPrincipal && other->Kind() == eNullPrincipal) {
    return this == other;
  }
  if (FastEquals(aOther)) {
    return true;
  }


  return Subsumes(aOther, DontConsiderDocumentDomain);
}

inline bool
BasePrincipal::FastSubsumesConsideringDomain(nsIPrincipal* aOther)
{



  if (!mHasExplicitDomain && !Cast(aOther)->mHasExplicitDomain) {
    return FastSubsumes(aOther);
  }

  return Subsumes(aOther, ConsiderDocumentDomain);
}

inline bool
BasePrincipal::FastSubsumesConsideringDomainIgnoringFPD(nsIPrincipal* aOther)
{
  if (Kind() == eCodebasePrincipal &&
      !dom::ChromeUtils::IsOriginAttributesEqualIgnoringFPD(
            mOriginAttributes, Cast(aOther)->mOriginAttributes)) {
    return false;
  }

 return SubsumesInternal(aOther, ConsiderDocumentDomain);
}

}
namespace mozilla {
enum class LoadTainting : uint8_t
{
  Basic = 0,
  CORS = 1,
  Opaque = 2
};

}
class nsCString;
typedef uint32_t nsSecurityFlags;
class nsILoadInfo : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    SEC_NORMAL = 0U,
    SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS = 1U,
    SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED = 2U,
    SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS = 4U,
    SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL = 8U,
    SEC_REQUIRE_CORS_DATA_INHERITS = 16U,
    SEC_COOKIES_DEFAULT = 0U,
    SEC_COOKIES_INCLUDE = 32U,
    SEC_COOKIES_SAME_ORIGIN = 64U,
    SEC_COOKIES_OMIT = 96U,
    SEC_FORCE_INHERIT_PRINCIPAL = 128U,
    SEC_SANDBOXED = 256U,
    SEC_ABOUT_BLANK_INHERITS = 512U,
    SEC_ALLOW_CHROME = 1024U,
    SEC_DISALLOW_SCRIPT = 2048U,
    SEC_DONT_FOLLOW_REDIRECTS = 4096U,
    SEC_LOAD_ERROR_PAGE = 8192U,
    SEC_FORCE_INHERIT_PRINCIPAL_OVERRULE_OWNER = 16384U
  };


  virtual nsresult GetLoadingPrincipal(nsIPrincipal * *aLoadingPrincipal) = 0;


  virtual nsIPrincipal * LoadingPrincipal(void) = 0;


  virtual nsresult GetTriggeringPrincipal(nsIPrincipal * *aTriggeringPrincipal) = 0;


  virtual nsIPrincipal * TriggeringPrincipal(void) = 0;


  virtual nsresult GetPrincipalToInherit(nsIPrincipal * *aPrincipalToInherit) = 0;
  virtual nsresult SetPrincipalToInherit(nsIPrincipal *aPrincipalToInherit) = 0;


  virtual nsIPrincipal * PrincipalToInherit(void) = 0;


  virtual nsresult GetLoadingDocument(nsIDOMDocument * *aLoadingDocument) = 0;


  virtual nsINode * LoadingNode(void) = 0;


  virtual nsresult GetSecurityFlags(nsSecurityFlags *aSecurityFlags) = 0;

   inline nsSecurityFlags GetSecurityFlags()
  {
    nsSecurityFlags result;
    mozilla::DebugOnly<nsresult> rv = GetSecurityFlags(&result);
    do { } while (0);
    return result;
  }

  virtual nsresult GetSecurityMode(uint32_t *aSecurityMode) = 0;
  inline uint32_t GetSecurityMode()
  {
    uint32_t result;
    mozilla::DebugOnly<nsresult> rv = GetSecurityMode(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetIsInThirdPartyContext(bool *aIsInThirdPartyContext) = 0;
  inline bool GetIsInThirdPartyContext()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetIsInThirdPartyContext(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetCookiePolicy(uint32_t *aCookiePolicy) = 0;
  inline uint32_t GetCookiePolicy()
  {
    uint32_t result;
    mozilla::DebugOnly<nsresult> rv = GetCookiePolicy(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetForceInheritPrincipal(bool *aForceInheritPrincipal) = 0;
  inline bool GetForceInheritPrincipal()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetForceInheritPrincipal(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetForceInheritPrincipalOverruleOwner(bool *aForceInheritPrincipalOverruleOwner) = 0;
  inline bool GetForceInheritPrincipalOverruleOwner()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetForceInheritPrincipalOverruleOwner(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetLoadingSandboxed(bool *aLoadingSandboxed) = 0;
  inline bool GetLoadingSandboxed()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetLoadingSandboxed(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetAboutBlankInherits(bool *aAboutBlankInherits) = 0;
  inline bool GetAboutBlankInherits()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetAboutBlankInherits(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetAllowChrome(bool *aAllowChrome) = 0;
  inline bool GetAllowChrome()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetAllowChrome(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetDisallowScript(bool *aDisallowScript) = 0;
  inline bool GetDisallowScript()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetDisallowScript(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetDontFollowRedirects(bool *aDontFollowRedirects) = 0;
  inline bool GetDontFollowRedirects()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetDontFollowRedirects(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetLoadErrorPage(bool *aLoadErrorPage) = 0;
  inline bool GetLoadErrorPage()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetLoadErrorPage(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetExternalContentPolicyType(nsContentPolicyType *aExternalContentPolicyType) = 0;

   inline nsContentPolicyType GetExternalContentPolicyType()
  {
    nsContentPolicyType result;
    mozilla::DebugOnly<nsresult> rv = GetExternalContentPolicyType(&result);
    do { } while (0);
    return result;
  }

  virtual nsContentPolicyType InternalContentPolicyType(void) = 0;


  virtual nsresult GetUpgradeInsecureRequests(bool *aUpgradeInsecureRequests) = 0;
  inline bool GetUpgradeInsecureRequests()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetUpgradeInsecureRequests(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetVerifySignedContent(bool *aVerifySignedContent) = 0;
  inline bool GetVerifySignedContent()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetVerifySignedContent(&result);
    do { } while (0);
    return result;
  }
  virtual nsresult SetVerifySignedContent(bool aVerifySignedContent) = 0;


  virtual nsresult GetEnforceSRI(bool *aEnforceSRI) = 0;
  inline bool GetEnforceSRI()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetEnforceSRI(&result);
    do { } while (0);
    return result;
  }
  virtual nsresult SetEnforceSRI(bool aEnforceSRI) = 0;


  virtual nsresult GetForceInheritPrincipalDropped(bool *aForceInheritPrincipalDropped) = 0;
  inline bool GetForceInheritPrincipalDropped()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetForceInheritPrincipalDropped(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetInnerWindowID(uint64_t *aInnerWindowID) = 0;
  inline uint64_t GetInnerWindowID()
  {
    uint64_t result;
    mozilla::DebugOnly<nsresult> rv = GetInnerWindowID(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetOuterWindowID(uint64_t *aOuterWindowID) = 0;
  inline uint64_t GetOuterWindowID()
  {
    uint64_t result;
    mozilla::DebugOnly<nsresult> rv = GetOuterWindowID(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetParentOuterWindowID(uint64_t *aParentOuterWindowID) = 0;
  inline uint64_t GetParentOuterWindowID()
  {
    uint64_t result;
    mozilla::DebugOnly<nsresult> rv = GetParentOuterWindowID(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetFrameOuterWindowID(uint64_t *aFrameOuterWindowID) = 0;
  inline uint64_t GetFrameOuterWindowID()
  {
    uint64_t result;
    mozilla::DebugOnly<nsresult> rv = GetFrameOuterWindowID(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult ResetPrincipalToInheritToNullPrincipal(void) = 0;


  virtual nsresult GetScriptableOriginAttributes(JSContext* cx, JS::MutableHandleValue aOriginAttributes) = 0;
  virtual nsresult SetScriptableOriginAttributes(JSContext* cx, JS::HandleValue aOriginAttributes) = 0;


  virtual nsresult GetOriginAttributes(mozilla::OriginAttributes *_retval) = 0;


  virtual nsresult SetOriginAttributes(const mozilla::OriginAttributes & aOriginAttrs) = 0;

   inline mozilla::OriginAttributes GetOriginAttributes()
  {
    mozilla::OriginAttributes result;
    mozilla::DebugOnly<nsresult> rv = GetOriginAttributes(&result);
    do { } while (0);
    return result;
  }

  virtual nsresult GetEnforceSecurity(bool *aEnforceSecurity) = 0;
  inline bool GetEnforceSecurity()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetEnforceSecurity(&result);
    do { } while (0);
    return result;
  }
  virtual nsresult SetEnforceSecurity(bool aEnforceSecurity) = 0;


  virtual nsresult GetInitialSecurityCheckDone(bool *aInitialSecurityCheckDone) = 0;
  inline bool GetInitialSecurityCheckDone()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetInitialSecurityCheckDone(&result);
    do { } while (0);
    return result;
  }
  virtual nsresult SetInitialSecurityCheckDone(bool aInitialSecurityCheckDone) = 0;


  virtual nsresult AppendRedirectedPrincipal(nsIPrincipal *principal, bool isInternalRedirect) = 0;


  virtual nsresult GetRedirectChainIncludingInternalRedirects(JSContext* cx, JS::MutableHandleValue aRedirectChainIncludingInternalRedirects) = 0;


  virtual const nsTArray<nsCOMPtr<nsIPrincipal>> & RedirectChainIncludingInternalRedirects(void) = 0;


  virtual nsresult GetRedirectChain(JSContext* cx, JS::MutableHandleValue aRedirectChain) = 0;


  virtual const nsTArray<nsCOMPtr<nsIPrincipal>> & RedirectChain(void) = 0;


  virtual void SetCorsPreflightInfo(const nsTArray<nsCString> & unsafeHeaders, bool forcePreflight) = 0;


  virtual const nsTArray<nsCString> & CorsUnsafeHeaders(void) = 0;


  virtual nsresult GetForcePreflight(bool *aForcePreflight) = 0;
  inline bool GetForcePreflight()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetForcePreflight(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetIsPreflight(bool *aIsPreflight) = 0;
  inline bool GetIsPreflight()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetIsPreflight(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetForceHSTSPriming(bool *aForceHSTSPriming) = 0;
  inline bool GetForceHSTSPriming()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetForceHSTSPriming(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetMixedContentWouldBlock(bool *aMixedContentWouldBlock) = 0;
  inline bool GetMixedContentWouldBlock()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetMixedContentWouldBlock(&result);
    do { } while (0);
    return result;
  }


  virtual void SetHSTSPriming(bool mixeContentWouldBlock) = 0;


  virtual void ClearHSTSPriming(void) = 0;

  enum {
    TAINTING_BASIC = 0U,
    TAINTING_CORS = 1U,
    TAINTING_OPAQUE = 2U
  };


  virtual nsresult GetTainting(uint32_t *aTainting) = 0;


  virtual nsresult MaybeIncreaseTainting(uint32_t aTainting) = 0;

   static_assert(TAINTING_BASIC == static_cast<uint32_t>(mozilla::LoadTainting::Basic),
                "basic tainting enums should match");
  static_assert(TAINTING_CORS == static_cast<uint32_t>(mozilla::LoadTainting::CORS),
                "cors tainting enums should match");
  static_assert(TAINTING_OPAQUE == static_cast<uint32_t>(mozilla::LoadTainting::Opaque),
                "opaque tainting enums should match");
  mozilla::LoadTainting GetTainting()
  {
    uint32_t tainting = TAINTING_BASIC;
    do { if ((((bool)(__builtin_expect(!!(!NS_FAILED_impl(GetTainting(&tainting))), 1))))) { } } while (0);
    return static_cast<mozilla::LoadTainting>(tainting);
  }
  void MaybeIncreaseTainting(mozilla::LoadTainting aTainting)
  {
    uint32_t tainting = static_cast<uint32_t>(aTainting);
    do { if ((((bool)(__builtin_expect(!!(!NS_FAILED_impl(MaybeIncreaseTainting(tainting))), 1))))) { } } while (0);
  }

  virtual nsresult GetIsTopLevelLoad(bool *aIsTopLevelLoad) = 0;
  inline bool GetIsTopLevelLoad()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetIsTopLevelLoad(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetSandboxedLoadingPrincipal(nsIPrincipal * *aSandboxedLoadingPrincipal) = 0;

};

  template<typename T> struct nsILoadInfo::COMTypeInfo<nsILoadInfo, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsILoadInfo::COMTypeInfo<nsILoadInfo, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xddc65bf9, 0x2f60, 0x41ab, { 0xb2, 0x2a, 0x4f, 0x1a, 0xe9, 0xef, 0xcd, 0x36 }};






class nsIURI;

class nsIInterfaceRequestor;

class nsIInputStream;

class nsIStreamListener;
class nsIChannel : public nsIRequest {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetOriginalURI(nsIURI * *aOriginalURI) = 0;
  virtual nsresult SetOriginalURI(nsIURI *aOriginalURI) = 0;


  virtual nsresult GetURI(nsIURI * *aURI) = 0;


  virtual nsresult GetOwner(nsISupports * *aOwner) = 0;
  virtual nsresult SetOwner(nsISupports *aOwner) = 0;


  virtual nsresult GetNotificationCallbacks(nsIInterfaceRequestor * *aNotificationCallbacks) = 0;
  virtual nsresult SetNotificationCallbacks(nsIInterfaceRequestor *aNotificationCallbacks) = 0;


  virtual nsresult GetSecurityInfo(nsISupports * *aSecurityInfo) = 0;


  virtual nsresult GetContentType(nsACString & aContentType) = 0;
  virtual nsresult SetContentType(const nsACString & aContentType) = 0;


  virtual nsresult GetContentCharset(nsACString & aContentCharset) = 0;
  virtual nsresult SetContentCharset(const nsACString & aContentCharset) = 0;


  virtual nsresult GetContentLength(int64_t *aContentLength) = 0;
  virtual nsresult SetContentLength(int64_t aContentLength) = 0;


  virtual nsresult Open(nsIInputStream * *_retval) = 0;


  virtual nsresult Open2(nsIInputStream * *_retval) = 0;


  virtual nsresult AsyncOpen(nsIStreamListener *aListener, nsISupports *aContext) = 0;


  virtual nsresult AsyncOpen2(nsIStreamListener *aListener) = 0;

  enum {
    LOAD_DOCUMENT_URI = 65536U,
    LOAD_RETARGETED_DOCUMENT_URI = 131072U,
    LOAD_REPLACE = 262144U,
    LOAD_INITIAL_DOCUMENT_URI = 524288U,
    LOAD_TARGETED = 1048576U,
    LOAD_CALL_CONTENT_SNIFFERS = 2097152U,
    LOAD_CLASSIFY_URI = 4194304U,
    LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE = 8388608U,
    LOAD_EXPLICIT_CREDENTIALS = 16777216U,
    LOAD_BYPASS_SERVICE_WORKER = 33554432U
  };


  virtual nsresult GetContentDisposition(uint32_t *aContentDisposition) = 0;
  virtual nsresult SetContentDisposition(uint32_t aContentDisposition) = 0;

  enum {
    DISPOSITION_INLINE = 0U,
    DISPOSITION_ATTACHMENT = 1U
  };


  virtual nsresult GetContentDispositionFilename(nsAString & aContentDispositionFilename) = 0;
  virtual nsresult SetContentDispositionFilename(const nsAString & aContentDispositionFilename) = 0;


  virtual nsresult GetContentDispositionHeader(nsACString & aContentDispositionHeader) = 0;


  virtual nsresult GetLoadInfo(nsILoadInfo * *aLoadInfo) = 0;
  virtual nsresult SetLoadInfo(nsILoadInfo *aLoadInfo) = 0;

   inline already_AddRefed<nsILoadInfo> GetLoadInfo()
  {
    nsCOMPtr<nsILoadInfo> result;
    mozilla::DebugOnly<nsresult> rv = GetLoadInfo(getter_AddRefs(result));
    do { } while (0);
    return result.forget();
  }
};

  template<typename T> struct nsIChannel::COMTypeInfo<nsIChannel, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIChannel::COMTypeInfo<nsIChannel, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x2c389865, 0x23db, 0x4aa7, { 0x9f, 0xe5, 0x60, 0xcc, 0x7b, 0x00, 0x69, 0x7e }};
class nsIHttpHeaderVisitor;
class nsIHttpChannel : public nsIChannel {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  __attribute__ ((warn_unused_result)) virtual nsresult GetRequestMethod(nsACString & aRequestMethod) = 0;
  __attribute__ ((warn_unused_result)) virtual nsresult SetRequestMethod(const nsACString & aRequestMethod) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetReferrer(nsIURI * *aReferrer) = 0;
  __attribute__ ((warn_unused_result)) virtual nsresult SetReferrer(nsIURI *aReferrer) = 0;

  enum {
    REFERRER_POLICY_UNSET = 0U,
    REFERRER_POLICY_NO_REFERRER_WHEN_DOWNGRADE = 1U,
    REFERRER_POLICY_NO_REFERRER = 2U,
    REFERRER_POLICY_ORIGIN = 3U,
    REFERRER_POLICY_ORIGIN_WHEN_XORIGIN = 4U,
    REFERRER_POLICY_UNSAFE_URL = 5U,
    REFERRER_POLICY_SAME_ORIGIN = 6U,
    REFERRER_POLICY_STRICT_ORIGIN = 7U,
    REFERRER_POLICY_STRICT_ORIGIN_WHEN_XORIGIN = 8U
  };


  __attribute__ ((warn_unused_result)) virtual nsresult GetReferrerPolicy(uint32_t *aReferrerPolicy) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult SetReferrerWithPolicy(nsIURI *referrer, uint32_t referrerPolicy) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetProtocolVersion(nsACString & aProtocolVersion) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetTransferSize(uint64_t *aTransferSize) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetDecodedBodySize(uint64_t *aDecodedBodySize) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetEncodedBodySize(uint64_t *aEncodedBodySize) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetRequestHeader(const nsACString & aHeader, nsACString & _retval) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult SetRequestHeader(const nsACString & aHeader, const nsACString & aValue, bool aMerge) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult SetEmptyRequestHeader(const nsACString & aHeader) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult VisitRequestHeaders(nsIHttpHeaderVisitor *aVisitor) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult VisitNonDefaultRequestHeaders(nsIHttpHeaderVisitor *aVisitor) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetAllowPipelining(bool *aAllowPipelining) = 0;
  __attribute__ ((warn_unused_result)) virtual nsresult SetAllowPipelining(bool aAllowPipelining) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetAllowSTS(bool *aAllowSTS) = 0;
  __attribute__ ((warn_unused_result)) virtual nsresult SetAllowSTS(bool aAllowSTS) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetRedirectionLimit(uint32_t *aRedirectionLimit) = 0;
  __attribute__ ((warn_unused_result)) virtual nsresult SetRedirectionLimit(uint32_t aRedirectionLimit) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetResponseStatus(uint32_t *aResponseStatus) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetResponseStatusText(nsACString & aResponseStatusText) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetRequestSucceeded(bool *aRequestSucceeded) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetIsMainDocumentChannel(bool *aIsMainDocumentChannel) = 0;
  __attribute__ ((warn_unused_result)) virtual nsresult SetIsMainDocumentChannel(bool aIsMainDocumentChannel) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetResponseHeader(const nsACString & header, nsACString & _retval) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult SetResponseHeader(const nsACString & header, const nsACString & value, bool merge) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult VisitResponseHeaders(nsIHttpHeaderVisitor *aVisitor) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetOriginalResponseHeader(const nsACString & aHeader, nsIHttpHeaderVisitor *aVisitor) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult VisitOriginalResponseHeaders(nsIHttpHeaderVisitor *aVisitor) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult IsNoStoreResponse(bool *_retval) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult IsNoCacheResponse(bool *_retval) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult IsPrivateResponse(bool *_retval) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult RedirectTo(nsIURI *aTargetURI) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetRequestContextID(uint64_t *aRequestContextID) = 0;
  __attribute__ ((warn_unused_result)) virtual nsresult SetRequestContextID(uint64_t aRequestContextID) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetChannelId(uint64_t *aChannelId) = 0;
  __attribute__ ((warn_unused_result)) virtual nsresult SetChannelId(uint64_t aChannelId) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetTopLevelContentWindowId(uint64_t *aTopLevelContentWindowId) = 0;
  __attribute__ ((warn_unused_result)) virtual nsresult SetTopLevelContentWindowId(uint64_t aTopLevelContentWindowId) = 0;


  virtual nsresult GetIsTrackingResource(bool *aIsTrackingResource) = 0;
  inline bool GetIsTrackingResource()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetIsTrackingResource(&result);
    do { } while (0);
    return result;
  }


  __attribute__ ((warn_unused_result)) virtual nsresult GetTopLevelOuterContentWindowId(uint64_t *aTopLevelOuterContentWindowId) = 0;
  __attribute__ ((warn_unused_result)) virtual nsresult SetTopLevelOuterContentWindowId(uint64_t aTopLevelOuterContentWindowId) = 0;

};

  template<typename T> struct nsIHttpChannel::COMTypeInfo<nsIHttpChannel, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIHttpChannel::COMTypeInfo<nsIHttpChannel, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xc5a4a073, 0x4539, 0x49c7, { 0xa3, 0xf2, 0xce, 0xc3, 0xf0, 0x61, 0x9c, 0x6c }};


namespace mozilla { namespace net {

enum ReferrerPolicy {

  RP_No_Referrer = nsIHttpChannel::REFERRER_POLICY_NO_REFERRER,


  RP_Origin = nsIHttpChannel::REFERRER_POLICY_ORIGIN,


  RP_No_Referrer_When_Downgrade = nsIHttpChannel::REFERRER_POLICY_NO_REFERRER_WHEN_DOWNGRADE,


  RP_Origin_When_Crossorigin = nsIHttpChannel::REFERRER_POLICY_ORIGIN_WHEN_XORIGIN,


  RP_Unsafe_URL = nsIHttpChannel::REFERRER_POLICY_UNSAFE_URL,


  RP_Same_Origin = nsIHttpChannel::REFERRER_POLICY_SAME_ORIGIN,


  RP_Strict_Origin = nsIHttpChannel::REFERRER_POLICY_STRICT_ORIGIN,


  RP_Strict_Origin_When_Cross_Origin = nsIHttpChannel::REFERRER_POLICY_STRICT_ORIGIN_WHEN_XORIGIN,



  RP_Unset = nsIHttpChannel::REFERRER_POLICY_UNSET,
};


const char kRPS_Never[] = "never";
const char kRPS_No_Referrer[] = "no-referrer";


const char kRPS_Origin[] = "origin";


const char kRPS_Default[] = "default";
const char kRPS_No_Referrer_When_Downgrade[] = "no-referrer-when-downgrade";


const char kRPS_Origin_When_Cross_Origin[] = "origin-when-cross-origin";
const char kRPS_Origin_When_Crossorigin[] = "origin-when-crossorigin";


const char kRPS_Same_Origin[] = "same-origin";


const char kRPS_Strict_Origin[] = "strict-origin";


const char kRPS_Strict_Origin_When_Cross_Origin[] = "strict-origin-when-cross-origin";


const char kRPS_Always[] = "always";
const char kRPS_Unsafe_URL[] = "unsafe-url";

inline ReferrerPolicy
ReferrerPolicyFromString(const nsAString& content)
{
  if (content.IsEmpty()) {
    return RP_No_Referrer;
  }

  nsString lowerContent(content);
  ToLowerCase(lowerContent);


  if (lowerContent.EqualsLiteral(kRPS_Never) ||
      lowerContent.EqualsLiteral(kRPS_No_Referrer)) {
    return RP_No_Referrer;
  }
  if (lowerContent.EqualsLiteral(kRPS_Origin)) {
    return RP_Origin;
  }
  if (lowerContent.EqualsLiteral(kRPS_Default) ||
      lowerContent.EqualsLiteral(kRPS_No_Referrer_When_Downgrade)) {
    return RP_No_Referrer_When_Downgrade;
  }
  if (lowerContent.EqualsLiteral(kRPS_Origin_When_Cross_Origin) ||
      lowerContent.EqualsLiteral(kRPS_Origin_When_Crossorigin)) {
    return RP_Origin_When_Crossorigin;
  }
  if (lowerContent.EqualsLiteral(kRPS_Same_Origin)) {
    return RP_Same_Origin;
  }
  if (lowerContent.EqualsLiteral(kRPS_Strict_Origin)) {
    return RP_Strict_Origin;
  }
  if (lowerContent.EqualsLiteral(kRPS_Strict_Origin_When_Cross_Origin)) {
    return RP_Strict_Origin_When_Cross_Origin;
  }
  if (lowerContent.EqualsLiteral(kRPS_Always) ||
      lowerContent.EqualsLiteral(kRPS_Unsafe_URL)) {
    return RP_Unsafe_URL;
  }

  return RP_Unset;

}

inline bool
IsValidReferrerPolicy(const nsAString& content)
{
  if (content.IsEmpty()) {
    return true;
  }

  nsString lowerContent(content);
  ToLowerCase(lowerContent);

  return lowerContent.EqualsLiteral(kRPS_Never)
      || lowerContent.EqualsLiteral(kRPS_No_Referrer)
      || lowerContent.EqualsLiteral(kRPS_Origin)
      || lowerContent.EqualsLiteral(kRPS_Default)
      || lowerContent.EqualsLiteral(kRPS_No_Referrer_When_Downgrade)
      || lowerContent.EqualsLiteral(kRPS_Origin_When_Cross_Origin)
      || lowerContent.EqualsLiteral(kRPS_Origin_When_Crossorigin)
      || lowerContent.EqualsLiteral(kRPS_Same_Origin)
      || lowerContent.EqualsLiteral(kRPS_Strict_Origin)
      || lowerContent.EqualsLiteral(kRPS_Strict_Origin_When_Cross_Origin)
      || lowerContent.EqualsLiteral(kRPS_Always)
      || lowerContent.EqualsLiteral(kRPS_Unsafe_URL);
}

inline ReferrerPolicy
AttributeReferrerPolicyFromString(const nsAString& content)
{


  if (content.IsEmpty()) {
    return RP_Unset;
  }

  nsString lowerContent(content);
  ToLowerCase(lowerContent);

  if (lowerContent.EqualsLiteral(kRPS_No_Referrer)) {
    return RP_No_Referrer;
  }
  if (lowerContent.EqualsLiteral(kRPS_Origin)) {
    return RP_Origin;
  }
  if (lowerContent.EqualsLiteral(kRPS_No_Referrer_When_Downgrade)) {
    return RP_No_Referrer_When_Downgrade;
  }
  if (lowerContent.EqualsLiteral(kRPS_Origin_When_Cross_Origin)) {
    return RP_Origin_When_Crossorigin;
  }
  if (lowerContent.EqualsLiteral(kRPS_Unsafe_URL)) {
    return RP_Unsafe_URL;
  }
  if (lowerContent.EqualsLiteral(kRPS_Strict_Origin)) {
    return RP_Strict_Origin;
  }
  if (lowerContent.EqualsLiteral(kRPS_Same_Origin)) {
    return RP_Same_Origin;
  }
  if (lowerContent.EqualsLiteral(kRPS_Strict_Origin_When_Cross_Origin)) {
    return RP_Strict_Origin_When_Cross_Origin;
  }



  return RP_Unset;
}

}
}

namespace mozilla {

enum CORSMode : uint8_t {



  CORS_NONE,





  CORS_ANONYMOUS,





  CORS_USE_CREDENTIALS
};

}






class nsICSSLoaderObserver : public nsISupports {
public:
  template<typename T, typename U> struct COMTypeInfo;
  virtual nsresult StyleSheetLoaded(mozilla::StyleSheet* aSheet,
                              bool aWasAlternate,
                              nsresult aStatus) = 0;
};

template<typename T> struct nsICSSLoaderObserver::COMTypeInfo<nsICSSLoaderObserver, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsICSSLoaderObserver::COMTypeInfo<nsICSSLoaderObserver, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0xf51fbf2c, 0xfe4b, 0x4a15, { 0xaf, 0x7e, 0x5e, 0x20, 0x64, 0x5f, 0xaf, 0x58 } };
class nsIDOMStyleSheet : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetType(nsAString & aType) = 0;


  virtual nsresult GetDisabled(bool *aDisabled) = 0;
  virtual nsresult SetDisabled(bool aDisabled) = 0;


  virtual nsresult GetOwnerNode(nsIDOMNode * *aOwnerNode) = 0;


  virtual nsresult GetParentStyleSheet(nsIDOMStyleSheet * *aParentStyleSheet) = 0;


  virtual nsresult GetHref(nsAString & aHref) = 0;


  virtual nsresult GetTitle(nsAString & aTitle) = 0;


  virtual nsresult GetMedia(nsIDOMMediaList * *aMedia) = 0;

};

  template<typename T> struct nsIDOMStyleSheet::COMTypeInfo<nsIDOMStyleSheet, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMStyleSheet::COMTypeInfo<nsIDOMStyleSheet, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xa6cf9080, 0x15b3, 0x11d2, { 0x93, 0x2e, 0x00, 0x80, 0x5f, 0x8a, 0xdd, 0x32 }};
class nsIDOMCSSStyleSheet : public nsIDOMStyleSheet {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetOwnerRule(nsIDOMCSSRule * *aOwnerRule) = 0;


  virtual nsresult GetCssRules(nsIDOMCSSRuleList * *aCssRules) = 0;


  virtual nsresult InsertRule(const nsAString & rule, uint32_t index, uint32_t *_retval) = 0;


  virtual nsresult DeleteRule(uint32_t index) = 0;

};

  template<typename T> struct nsIDOMCSSStyleSheet::COMTypeInfo<nsIDOMCSSStyleSheet, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMCSSStyleSheet::COMTypeInfo<nsIDOMCSSStyleSheet, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xa6cf90c2, 0x15b3, 0x11d2, { 0x93, 0x2e, 0x00, 0x80, 0x5f, 0x8a, 0xdd, 0x32 }};


class nsIDocument;
class nsINode;
class nsIPrincipal;
class nsCSSRuleProcessor;

namespace mozilla {

class CSSStyleSheet;
class ServoStyleSheet;
struct StyleSheetInfo;
struct CSSStyleSheetInner;

namespace dom {
class CSSRuleList;
class MediaList;
class SRIMetadata;
}

namespace css {
class GroupRule;
class ImportRule;
class Rule;
}




class StyleSheet : public nsIDOMCSSStyleSheet
                 , public nsICSSLoaderObserver
                 , public nsWrapperCache
{
protected:
  StyleSheet(StyleBackendType aType, css::SheetParsingMode aParsingMode);
  StyleSheet(const StyleSheet& aCopy,
             nsIDocument* aDocumentToUse,
             nsINode* aOwningNodeToUse);
  virtual ~StyleSheet();

public:
  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; virtual void DeleteCycleCollectable(void); typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:
  class cycleCollection : public nsXPCOMCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = false) : nsXPCOMCycleCollectionParticipant(aSkip) {} private: public: virtual nsresult TraverseNative(void *p, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "StyleSheet"; }; virtual void DeleteCycleCollectable(void *p) override { DowncastCCParticipant<StyleSheet>(p)->DeleteCycleCollectable(); } static StyleSheet* Downcast(nsISupports* s) { return static_cast<StyleSheet*>(static_cast<nsIDOMCSSStyleSheet*>(s)); } static nsISupports* Upcast(StyleSheet *p) { return static_cast<nsISupports*>(static_cast<nsIDOMCSSStyleSheet*>(p)); } template<typename T> friend nsISupports* ToSupports(T* p, cycleCollection* dummy); virtual void Unlink(void *p) override; virtual void Trace(void *p, const TraceCallbacks &cb, void *closure) override; static constexpr nsXPCOMCycleCollectionParticipant* GetParticipant() { return &StyleSheet::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;


  void SetOwningNode(nsINode* aOwningNode)
  {
    mOwningNode = aOwningNode;
  }

  css::SheetParsingMode ParsingMode() { return mParsingMode; }
  mozilla::dom::CSSStyleSheetParsingMode ParsingModeDOM();




  bool IsComplete() const;
  void SetComplete();
  void SetEnabled(bool aEnabled);

  bool IsGecko() const { return !IsServo(); } bool IsServo() const { return mType == StyleBackendType::Servo; } inline CSSStyleSheet* AsGecko(); inline ServoStyleSheet* AsServo(); inline const CSSStyleSheet* AsGecko() const; inline const ServoStyleSheet* AsServo() const; inline CSSStyleSheet* GetAsGecko(); inline ServoStyleSheet* GetAsServo(); inline const CSSStyleSheet* GetAsGecko() const; inline const ServoStyleSheet* GetAsServo() const;


  inline bool IsInline() const;

  inline nsIURI* GetSheetURI() const;


  inline nsIURI* GetOriginalURI() const;
  inline nsIURI* GetBaseURI() const;





  inline void SetURIs(nsIURI* aSheetURI, nsIURI* aOriginalSheetURI,
                      nsIURI* aBaseURI);







  inline bool IsApplicable() const;
  inline bool HasRules() const;

  virtual already_AddRefed<StyleSheet> Clone(StyleSheet* aCloneParent,
                                             css::ImportRule* aCloneOwnerRule,
                                             nsIDocument* aCloneDocument,
                                             nsINode* aCloneOwningNode) const = 0;

  virtual bool IsModified() const = 0;


  enum DocumentAssociationMode {


    OwnedByDocument,


    NotOwnedByDocument
  };
  nsIDocument* GetAssociatedDocument() const { return mDocument; }
  bool IsOwnedByDocument() const {
    return mDocumentAssociationMode == OwnedByDocument;
  }

  void SetAssociatedDocument(nsIDocument* aDocument,
                             DocumentAssociationMode aMode);
  void ClearAssociatedDocument();
  nsINode* GetOwnerNode() const { return mOwningNode; }
  inline StyleSheet* GetParentSheet() const { return mParent; }

  void AppendStyleSheet(StyleSheet* aSheet);

  StyleSheet* GetFirstChild() const;


  inline nsIPrincipal* Principal() const;





  inline void SetPrincipal(nsIPrincipal* aPrincipal);

  void SetTitle(const nsAString& aTitle) { mTitle = aTitle; }
  void SetMedia(dom::MediaList* aMedia);


  inline CORSMode GetCORSMode() const;

  inline net::ReferrerPolicy GetReferrerPolicy() const;

  inline void GetIntegrity(dom::SRIMetadata& aResult) const;

  virtual size_t SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const;
  inline StyleSheet* GetParentStyleSheet() const;

  dom::MediaList* Media();
  bool Disabled() const { return mDisabled; }



  virtual css::Rule* GetDOMOwnerRule() const = 0;
  dom::CSSRuleList* GetCssRules(nsIPrincipal& aSubjectPrincipal,
                                ErrorResult& aRv);
  uint32_t InsertRule(const nsAString& aRule, uint32_t aIndex,
                      nsIPrincipal& aSubjectPrincipal,
                      ErrorResult& aRv);
  void DeleteRule(uint32_t aIndex,
                  nsIPrincipal& aSubjectPrincipal,
                  ErrorResult& aRv);


  inline dom::ParentObject GetParentObject() const;
  JSObject* WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) final;


  virtual nsresult GetType(nsAString& aType) final;
  virtual nsresult GetDisabled(bool* aDisabled) final;
  virtual nsresult SetDisabled(bool aDisabled) final;
  virtual nsresult GetOwnerNode(nsIDOMNode** aOwnerNode) final;
  virtual nsresult GetParentStyleSheet(nsIDOMStyleSheet** aParentStyleSheet) final;
  virtual nsresult GetHref(nsAString& aHref) final;
  virtual nsresult GetTitle(nsAString& aTitle) final;
  virtual nsresult GetMedia(nsIDOMMediaList** aMedia) final;


  virtual nsresult GetOwnerRule(nsIDOMCSSRule** aOwnerRule) final;
  virtual nsresult GetCssRules(nsIDOMCSSRuleList** aCssRules) final;
  virtual nsresult InsertRule(const nsAString& aRule, uint32_t aIndex,
                      uint32_t* aReturn) final;
  virtual nsresult DeleteRule(uint32_t aIndex) final;




  inline void WillDirty();
  inline void DidDirty();

  nsresult DeleteRuleFromGroup(css::GroupRule* aGroup, uint32_t aIndex);
  nsresult InsertRuleIntoGroup(const nsAString& aRule,
                               css::GroupRule* aGroup, uint32_t aIndex);

private:


  inline StyleSheetInfo& SheetInfo();
  inline const StyleSheetInfo& SheetInfo() const;





  bool AreRulesAvailable(nsIPrincipal& aSubjectPrincipal,
                         ErrorResult& aRv);

protected:
  struct ChildSheetListBuilder {
    RefPtr<StyleSheet>* sheetSlot;
    StyleSheet* parent;

    void SetParentLinks(StyleSheet* aSheet);

    static void ReparentChildList(StyleSheet* aPrimarySheet,
                                  StyleSheet* aFirstChild);
  };

  void UnparentChildren();





  void SubjectSubsumesInnerPrincipal(nsIPrincipal& aSubjectPrincipal,
                                     ErrorResult& aRv);


  void DropMedia();


  void EnabledStateChanged();


  virtual void UnlinkInner();

  virtual void TraverseInner(nsCycleCollectionTraversalCallback &);

  StyleSheet* mParent;

  nsString mTitle;
  nsIDocument* mDocument;
  nsINode* mOwningNode;

  RefPtr<dom::MediaList> mMedia;

  RefPtr<StyleSheet> mNext;




  css::SheetParsingMode mParsingMode;

  const StyleBackendType mType;
  bool mDisabled;




  DocumentAssociationMode mDocumentAssociationMode;



  StyleSheetInfo* mInner;

  friend class ::nsCSSRuleProcessor;




  friend class mozilla::CSSStyleSheet;
  friend class mozilla::ServoStyleSheet;



  friend struct mozilla::StyleSheetInfo;
  friend struct mozilla::CSSStyleSheetInner;
};

}

namespace mozilla {

enum class CSSEnabledState
{


  eForAllContent = 0,

  eInUASheets = 0x01,

  eInChrome = 0x02,




  eIgnoreEnabledState = 0xff
};

inline constexpr mozilla::CastableTypedEnumResult<CSSEnabledState> operator |(CSSEnabledState a, CSSEnabledState b) { typedef mozilla::CastableTypedEnumResult<CSSEnabledState> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<CSSEnabledState>::Type U; return Result(CSSEnabledState(U(a) | U(b))); } inline CSSEnabledState& operator |=(CSSEnabledState& a, CSSEnabledState b) { return a = a | b; } inline constexpr mozilla::CastableTypedEnumResult<CSSEnabledState> operator &(CSSEnabledState a, CSSEnabledState b) { typedef mozilla::CastableTypedEnumResult<CSSEnabledState> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<CSSEnabledState>::Type U; return Result(CSSEnabledState(U(a) & U(b))); } inline CSSEnabledState& operator &=(CSSEnabledState& a, CSSEnabledState b) { return a = a & b; } inline constexpr mozilla::CastableTypedEnumResult<CSSEnabledState> operator ^(CSSEnabledState a, CSSEnabledState b) { typedef mozilla::CastableTypedEnumResult<CSSEnabledState> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<CSSEnabledState>::Type U; return Result(CSSEnabledState(U(a) ^ U(b))); } inline CSSEnabledState& operator ^=(CSSEnabledState& a, CSSEnabledState b) { return a = a ^ b; } inline constexpr mozilla::CastableTypedEnumResult<CSSEnabledState> operator~(CSSEnabledState a) { typedef mozilla::CastableTypedEnumResult<CSSEnabledState> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<CSSEnabledState>::Type U; return Result(CSSEnabledState(~(U(a)))); }

}
namespace mozilla {



typedef uint8_t CSSPseudoElementTypeBase;
enum class CSSPseudoElementType : CSSPseudoElementTypeBase {





after,
before,

backdrop,

cue,


firstLetter,


firstLine,



mozSelection,




mozFocusInner,
mozFocusOuter,



mozListBullet,
mozListNumber,

mozMathAnonymous,


mozNumberWrapper,


mozNumberText,


mozNumberSpinBox,


mozNumberSpinUp,


mozNumberSpinDown,


mozProgressBar,

mozRangeTrack,

mozRangeProgress,

mozRangeThumb,

mozMeterBar,

mozPlaceholder,

placeholder,

mozColorSwatch,

  Count,
  InheritingAnonBox = Count,

  NonInheritingAnonBox,

  XULTree,

  NotPseudo,
  MAX
};

}



class nsICSSPseudoElement : public nsIAtom {};

class nsCSSPseudoElements
{
  typedef mozilla::CSSPseudoElementType Type;
  typedef mozilla::CSSEnabledState EnabledState;

public:
  static void AddRefAtoms();

  static bool IsPseudoElement(nsIAtom *aAtom);

  static bool IsCSS2PseudoElement(nsIAtom *aAtom);




static nsICSSPseudoElement* after;
static nsICSSPseudoElement* before;

static nsICSSPseudoElement* backdrop;

static nsICSSPseudoElement* cue;


static nsICSSPseudoElement* firstLetter;


static nsICSSPseudoElement* firstLine;



static nsICSSPseudoElement* mozSelection;




static nsICSSPseudoElement* mozFocusInner;
static nsICSSPseudoElement* mozFocusOuter;



static nsICSSPseudoElement* mozListBullet;
static nsICSSPseudoElement* mozListNumber;

static nsICSSPseudoElement* mozMathAnonymous;


static nsICSSPseudoElement* mozNumberWrapper;


static nsICSSPseudoElement* mozNumberText;


static nsICSSPseudoElement* mozNumberSpinBox;


static nsICSSPseudoElement* mozNumberSpinUp;


static nsICSSPseudoElement* mozNumberSpinDown;


static nsICSSPseudoElement* mozProgressBar;

static nsICSSPseudoElement* mozRangeTrack;

static nsICSSPseudoElement* mozRangeProgress;

static nsICSSPseudoElement* mozRangeThumb;

static nsICSSPseudoElement* mozMeterBar;

static nsICSSPseudoElement* mozPlaceholder;

static nsICSSPseudoElement* placeholder;

static nsICSSPseudoElement* mozColorSwatch;


  static Type GetPseudoType(nsIAtom* aAtom, EnabledState aEnabledState);


  static nsIAtom* GetPseudoAtom(Type aType);

  static bool PseudoElementContainsElements(const Type aType) {
    return PseudoElementHasFlags(aType, (1<<1));
  }

  static bool PseudoElementSupportsStyleAttribute(const Type aType) {
    do { } while (0);
    return PseudoElementHasFlags(aType,
                                 (1<<2));
  }

  static bool PseudoElementSupportsUserActionState(const Type aType);

  static bool PseudoElementIsJSCreatedNAC(Type aType)
  {
    return PseudoElementHasFlags(aType, (1<<5));
  }

  static bool IsEnabled(Type aType, EnabledState aEnabledState)
  {
    return !PseudoElementHasFlags(aType, (1<<4)) ||
           (aEnabledState & EnabledState::eInUASheets);
  }

private:
  static bool PseudoElementHasFlags(const Type aType, uint32_t aFlags)
  {
    do { } while (0);
    return (kPseudoElementFlags[size_t(aType)] & aFlags) == aFlags;
  }

  static const uint32_t kPseudoElementFlags[size_t(Type::Count)];
};


namespace mozilla {
class CSSStyleSheet;
class ServoStyleSet;
namespace dom {
class Element;
}
}
struct nsFontFaceRuleContainer;
class nsIAtom;
class nsIContent;
class nsIDocument;
class nsStyleContext;
class nsStyleSet;
class nsPresContext;
struct TreeMatchContext;

namespace mozilla {







class StyleSetHandle
{
public:




  class Ptr
  {
  public:
    friend class ::mozilla::StyleSetHandle;

    bool IsGecko() const { return !IsServo(); }
    bool IsServo() const
    {
      do { } while (0);

      return mValue & 0x1;



    }

    StyleBackendType BackendType() const
    {
      return IsGecko() ? StyleBackendType::Gecko :
                         StyleBackendType::Servo;
    }

    nsStyleSet* AsGecko()
    {
      do { } while (0);
      return reinterpret_cast<nsStyleSet*>(mValue);
    }

    ServoStyleSet* AsServo()
    {
      do { } while (0);
      return reinterpret_cast<ServoStyleSet*>(mValue & ~0x1);
    }

    nsStyleSet* GetAsGecko() { return IsGecko() ? AsGecko() : nullptr; }
    ServoStyleSet* GetAsServo() { return IsServo() ? AsServo() : nullptr; }

    const nsStyleSet* AsGecko() const
    {
      return const_cast<Ptr*>(this)->AsGecko();
    }

    const ServoStyleSet* AsServo() const
    {
      do { } while (0);
      return const_cast<Ptr*>(this)->AsServo();
    }

    const nsStyleSet* GetAsGecko() const { return IsGecko() ? AsGecko() : nullptr; }
    const ServoStyleSet* GetAsServo() const { return IsServo() ? AsServo() : nullptr; }


    inline void Delete();






    inline void Init(nsPresContext* aPresContext);
    inline void BeginShutdown();
    inline void Shutdown();
    inline bool GetAuthorStyleDisabled() const;
    inline nsresult SetAuthorStyleDisabled(bool aStyleDisabled);
    inline void BeginUpdate();
    inline nsresult EndUpdate();
    inline already_AddRefed<nsStyleContext>
    ResolveStyleFor(dom::Element* aElement,
                    nsStyleContext* aParentContext,
                    LazyComputeBehavior aMayCompute);
    inline already_AddRefed<nsStyleContext>
    ResolveStyleFor(dom::Element* aElement,
                    nsStyleContext* aParentContext,
                    LazyComputeBehavior aMayCompute,
                    TreeMatchContext& aTreeMatchContext);
    inline already_AddRefed<nsStyleContext>
    ResolveStyleForText(nsIContent* aTextNode,
                        nsStyleContext* aParentContext);
    inline already_AddRefed<nsStyleContext>
    ResolveStyleForFirstLetterContinuation(nsStyleContext* aParentContext);
    inline already_AddRefed<nsStyleContext>
    ResolveStyleForPlaceholder();
    inline already_AddRefed<nsStyleContext>
    ResolvePseudoElementStyle(dom::Element* aParentElement,
                              mozilla::CSSPseudoElementType aType,
                              nsStyleContext* aParentContext,
                              dom::Element* aPseudoElement);
    inline already_AddRefed<nsStyleContext>
    ResolveInheritingAnonymousBoxStyle(nsIAtom* aPseudoTag,
                                       nsStyleContext* aParentContext,
                                       uint32_t aFlags = 0);
    inline already_AddRefed<nsStyleContext>
    ResolveNonInheritingAnonymousBoxStyle(nsIAtom* aPseudoTag);
    inline nsresult AppendStyleSheet(SheetType aType, StyleSheet* aSheet);
    inline nsresult PrependStyleSheet(SheetType aType, StyleSheet* aSheet);
    inline nsresult RemoveStyleSheet(SheetType aType, StyleSheet* aSheet);
    inline nsresult ReplaceSheets(SheetType aType,
                           const nsTArray<RefPtr<StyleSheet>>& aNewSheets);
    inline nsresult InsertStyleSheetBefore(SheetType aType,
                                    StyleSheet* aNewSheet,
                                    StyleSheet* aReferenceSheet);
    inline int32_t SheetCount(SheetType aType) const;
    inline StyleSheet* StyleSheetAt(SheetType aType, int32_t aIndex) const;
    inline nsresult RemoveDocStyleSheet(StyleSheet* aSheet);
    inline nsresult AddDocStyleSheet(StyleSheet* aSheet, nsIDocument* aDocument);
    inline already_AddRefed<nsStyleContext>
    ProbePseudoElementStyle(dom::Element* aParentElement,
                            mozilla::CSSPseudoElementType aType,
                            nsStyleContext* aParentContext);
    inline already_AddRefed<nsStyleContext>
    ProbePseudoElementStyle(dom::Element* aParentElement,
                            mozilla::CSSPseudoElementType aType,
                            nsStyleContext* aParentContext,
                            TreeMatchContext& aTreeMatchContext,
                            dom::Element* aPseudoElement = nullptr);
    inline nsRestyleHint HasStateDependentStyle(dom::Element* aElement,
                                                EventStates aStateMask);
    inline nsRestyleHint HasStateDependentStyle(
        dom::Element* aElement,
        mozilla::CSSPseudoElementType aPseudoType,
        dom::Element* aPseudoElement,
        EventStates aStateMask);

    inline void RootStyleContextAdded();
    inline void RootStyleContextRemoved();

    inline bool AppendFontFaceRules(nsTArray<nsFontFaceRuleContainer>& aArray);

  private:




    uintptr_t mValue;
  };

  StyleSetHandle() { mPtr.mValue = 0; }
  StyleSetHandle(const StyleSetHandle& aOth) { mPtr.mValue = aOth.mPtr.mValue; }
               StyleSetHandle(nsStyleSet* aSet) { *this = aSet; }
               StyleSetHandle(ServoStyleSet* aSet) { *this = aSet; }

  StyleSetHandle& operator=(nsStyleSet* aStyleSet)
  {
    do { } while (0);

    mPtr.mValue = reinterpret_cast<uintptr_t>(aStyleSet);
    return *this;
  }

  StyleSetHandle& operator=(ServoStyleSet* aStyleSet)
  {

    do { } while (0);

    mPtr.mValue =
      aStyleSet ? (reinterpret_cast<uintptr_t>(aStyleSet) | 0x1) : 0;
    return *this;




  }


  explicit operator bool() const { return !!mPtr.mValue; }
  bool operator!() const { return !mPtr.mValue; }


  Ptr* operator->() { return &mPtr; }
  const Ptr* operator->() const { return &mPtr; }

private:
  Ptr mPtr;
};



}


namespace mozilla {
namespace gfx {




template<class Units, class F = Float>
struct TriangleTyped
{
  PointTyped<Units, F> p1, p2, p3;
  F width, height;

  TriangleTyped()
    : p1(), p2(), p3() {}

  TriangleTyped(PointTyped<Units, F> aP1,
                PointTyped<Units, F> aP2,
                PointTyped<Units, F> aP3)
    : p1(aP1), p2(aP2), p3(aP3) {}

  RectTyped<Units, F> BoundingBox() const
  {
    F minX = std::min(std::min(p1.x, p2.x), p3.x);
    F maxX = std::max(std::max(p1.x, p2.x), p3.x);

    F minY = std::min(std::min(p1.y, p2.y), p3.y);
    F maxY = std::max(std::max(p1.y, p2.y), p3.y);

    return RectTyped<Units, F>(minX, minY, maxX - minX, maxY - minY);
  }
};

typedef TriangleTyped<UnknownUnits, Float> Triangle;

template<class Units, class F = Float>
struct TexturedTriangleTyped : public TriangleTyped<Units, F>
{
  explicit TexturedTriangleTyped(const TriangleTyped<Units, F>& aTriangle)
    : TriangleTyped<Units, F>(aTriangle) {}

  explicit TexturedTriangleTyped(TriangleTyped<Units, F>&& aTriangle)
    : TriangleTyped<Units, F>(Move(aTriangle)) {}

  TriangleTyped<Units, F> textureCoords;
};

typedef TexturedTriangleTyped<UnknownUnits, Float> TexturedTriangle;

}
}





namespace mozilla {
namespace gfx {

struct UnknownUnits;

template<class SourceUnits, class TargetUnits>
class Matrix4x4Typed;

typedef Matrix4x4Typed<UnknownUnits, UnknownUnits> Matrix4x4;

}
}


namespace mozilla {
namespace gfx {

class Quaternion
{
public:
  Quaternion()
    : x(0.0f), y(0.0f), z(0.0f), w(1.0f)
  {}

  Quaternion(Float aX, Float aY, Float aZ, Float aW)
    : x(aX), y(aY), z(aZ), w(aW)
  {}


  Quaternion(const Quaternion& aOther)
  {
    memcpy(this, &aOther, sizeof(*this));
  }

  Float x, y, z, w;

  friend std::ostream& operator<<(std::ostream& aStream, const Quaternion& aQuat);

  void Set(Float aX, Float aY, Float aZ, Float aW)
  {
    x = aX; y = aY; z = aZ; w = aW;
  }


  void SetFromRotationMatrix(const Matrix4x4& aMatrix);


  Quaternion operator*(const Quaternion &aQuat) const
  {
    Quaternion o;
    const Float bx = aQuat.x, by = aQuat.y, bz = aQuat.z, bw = aQuat.w;

    o.x = x*bw + w*bx + y*bz - z*by;
    o.y = y*bw + w*by + z*bx - x*bz;
    o.z = z*bw + w*bz + x*by - y*bx;
    o.w = w*bw - x*bx - y*by - z*bz;
    return o;
  }

  Quaternion& operator*=(const Quaternion &aQuat)
  {
    *this = *this * aQuat;
    return *this;
  }

  Float Length() const
  {
    return sqrt(x*x + y*y + z*z + w*w);
  }

  Quaternion& Conjugate()
  {
    x *= -1.f; y *= -1.f; z *= -1.f;
    return *this;
  }

  Quaternion& Normalize()
  {
    Float l = Length();
    if (l) {
      l = 1.0f / l;
      x *= l; y *= l; z *= l; w *= l;
    } else {
      x = y = z = 0.f;
      w = 1.f;
    }
    return *this;
  }

  Quaternion& Invert()
  {
    return Conjugate().Normalize();
  }

  Point3D RotatePoint(const Point3D& aPoint) {
    Float uvx = Float(2.0) * (y*aPoint.z - z*aPoint.y);
    Float uvy = Float(2.0) * (z*aPoint.x - x*aPoint.z);
    Float uvz = Float(2.0) * (x*aPoint.y - y*aPoint.x);

    return Point3D(aPoint.x + w*uvx + y*uvz - z*uvy,
                   aPoint.y + w*uvy + z*uvx - x*uvz,
                   aPoint.z + w*uvz + x*uvy - y*uvx);
  }
};

}
}





namespace mozilla {
namespace gfx {

static bool FuzzyEqual(Float aV1, Float aV2) {

  return fabs(aV2 - aV1) < 1e-6;
}

class Matrix
{
public:
  Matrix()
    : _11(1.0f), _12(0)
    , _21(0), _22(1.0f)
    , _31(0), _32(0)
  {}
  Matrix(Float a11, Float a12, Float a21, Float a22, Float a31, Float a32)
    : _11(a11), _12(a12)
    , _21(a21), _22(a22)
    , _31(a31), _32(a32)
  {}
  union {
    struct {
      Float _11, _12;
      Float _21, _22;
      Float _31, _32;
    };
    Float components[6];
  };

  __attribute__((always_inline)) inline Matrix Copy() const
  {
    return Matrix(*this);
  }

  friend std::ostream& operator<<(std::ostream& aStream, const Matrix& aMatrix);

  Point TransformPoint(const Point &aPoint) const
  {
    Point retPoint;

    retPoint.x = aPoint.x * _11 + aPoint.y * _21 + _31;
    retPoint.y = aPoint.x * _12 + aPoint.y * _22 + _32;

    return retPoint;
  }

  Size TransformSize(const Size &aSize) const
  {
    Size retSize;

    retSize.width = aSize.width * _11 + aSize.height * _21;
    retSize.height = aSize.width * _12 + aSize.height * _22;

    return retSize;
  }

            Rect TransformBounds(const Rect& rect) const;

  static Matrix Translation(Float aX, Float aY)
  {
    return Matrix(1.0f, 0.0f, 0.0f, 1.0f, aX, aY);
  }

  static Matrix Translation(Point aPoint)
  {
    return Translation(aPoint.x, aPoint.y);
  }
  Matrix &PreTranslate(Float aX, Float aY)
  {
    _31 += _11 * aX + _21 * aY;
    _32 += _12 * aX + _22 * aY;

    return *this;
  }

  Matrix &PreTranslate(const Point &aPoint)
  {
    return PreTranslate(aPoint.x, aPoint.y);
  }
  Matrix &PostTranslate(Float aX, Float aY)
  {
    _31 += aX;
    _32 += aY;
    return *this;
  }

  Matrix &PostTranslate(const Point &aPoint)
  {
    return PostTranslate(aPoint.x, aPoint.y);
  }

  static Matrix Scaling(Float aScaleX, Float aScaleY)
  {
    return Matrix(aScaleX, 0.0f, 0.0f, aScaleY, 0.0f, 0.0f);
  }




  Matrix &PreScale(Float aX, Float aY)
  {
    _11 *= aX;
    _12 *= aX;
    _21 *= aY;
    _22 *= aY;

    return *this;
  }




  Matrix &PostScale(Float aScaleX, Float aScaleY)
  {
    _11 *= aScaleX;
    _12 *= aScaleY;
    _21 *= aScaleX;
    _22 *= aScaleY;
    _31 *= aScaleX;
    _32 *= aScaleY;

    return *this;
  }

            static Matrix Rotation(Float aAngle);




  Matrix &PreRotate(Float aAngle)
  {
    return *this = Matrix::Rotation(aAngle) * *this;
  }

  bool Invert()
  {

    Float A = _22;
    Float B = -_21;
    Float C = _21 * _32 - _22 * _31;
    Float D = -_12;
    Float E = _11;
    Float F = _31 * _12 - _11 * _32;

    Float det = Determinant();

    if (!det) {
      return false;
    }

    Float inv_det = 1 / det;

    _11 = inv_det * A;
    _12 = inv_det * D;
    _21 = inv_det * B;
    _22 = inv_det * E;
    _31 = inv_det * C;
    _32 = inv_det * F;

    return true;
  }

  Matrix Inverse() const
  {
    Matrix clone = *this;
    DebugOnly<bool> inverted = clone.Invert();
    do { } while (0);
    return clone;
  }

  Float Determinant() const
  {
    return _11 * _22 - _12 * _21;
  }

  Matrix operator*(const Matrix &aMatrix) const
  {
    Matrix resultMatrix;

    resultMatrix._11 = this->_11 * aMatrix._11 + this->_12 * aMatrix._21;
    resultMatrix._12 = this->_11 * aMatrix._12 + this->_12 * aMatrix._22;
    resultMatrix._21 = this->_21 * aMatrix._11 + this->_22 * aMatrix._21;
    resultMatrix._22 = this->_21 * aMatrix._12 + this->_22 * aMatrix._22;
    resultMatrix._31 = this->_31 * aMatrix._11 + this->_32 * aMatrix._21 + aMatrix._31;
    resultMatrix._32 = this->_31 * aMatrix._12 + this->_32 * aMatrix._22 + aMatrix._32;

    return resultMatrix;
  }

  Matrix& operator*=(const Matrix &aMatrix)
  {
    *this = *this * aMatrix;
    return *this;
  }




  Matrix &PreMultiply(const Matrix &aMatrix)
  {
    *this = aMatrix * *this;
    return *this;
  }




  bool operator==(const Matrix& other) const
  {
    return FuzzyEqual(_11, other._11) && FuzzyEqual(_12, other._12) &&
           FuzzyEqual(_21, other._21) && FuzzyEqual(_22, other._22) &&
           FuzzyEqual(_31, other._31) && FuzzyEqual(_32, other._32);
  }

  bool operator!=(const Matrix& other) const
  {
    return !(*this == other);
  }

  bool ExactlyEquals(const Matrix& o) const
  {
    return _11 == o._11 && _12 == o._12 &&
           _21 == o._21 && _22 == o._22 &&
           _31 == o._31 && _32 == o._32;
  }


  bool IsFinite() const
  {
    return mozilla::IsFinite(_11) && mozilla::IsFinite(_12) &&
           mozilla::IsFinite(_21) && mozilla::IsFinite(_22) &&
           mozilla::IsFinite(_31) && mozilla::IsFinite(_32);
  }




  bool IsRectilinear() const {
    if (FuzzyEqual(_12, 0) && FuzzyEqual(_21, 0)) {
      return true;
    } else if (FuzzyEqual(_22, 0) && FuzzyEqual(_11, 0)) {
      return true;
    }

    return false;
  }





  bool HasNonIntegerTranslation() const {
    return HasNonTranslation() ||
      !FuzzyEqual(_31, floor(_31 + Float(0.5))) ||
      !FuzzyEqual(_32, floor(_32 + Float(0.5)));
  }




  bool HasOnlyIntegerTranslation() const {
    return !HasNonIntegerTranslation();
  }





  bool HasNonTranslation() const {
    return !FuzzyEqual(_11, 1.0) || !FuzzyEqual(_22, 1.0) ||
           !FuzzyEqual(_12, 0.0) || !FuzzyEqual(_21, 0.0);
  }





  bool HasNonTranslationOrFlip() const {
      return !FuzzyEqual(_11, 1.0) ||
             (!FuzzyEqual(_22, 1.0) && !FuzzyEqual(_22, -1.0)) ||
             !FuzzyEqual(_21, 0.0) || !FuzzyEqual(_12, 0.0);
  }



  bool IsIdentity() const
  {
    return _11 == 1.0f && _12 == 0.0f &&
           _21 == 0.0f && _22 == 1.0f &&
           _31 == 0.0f && _32 == 0.0f;
  }



  bool IsSingular() const
  {
    Float det = Determinant();
    return !mozilla::IsFinite(det) || det == 0;
  }

            Matrix &NudgeToIntegers();

  bool IsTranslation() const
  {
    return FuzzyEqual(_11, 1.0f) && FuzzyEqual(_12, 0.0f) &&
           FuzzyEqual(_21, 0.0f) && FuzzyEqual(_22, 1.0f);
  }

  static bool FuzzyIsInteger(Float aValue)
  {
    return FuzzyEqual(aValue, floorf(aValue + 0.5f));
  }

  bool IsIntegerTranslation() const
  {
    return IsTranslation() && FuzzyIsInteger(_31) && FuzzyIsInteger(_32);
  }

  bool IsAllIntegers() const
  {
    return FuzzyIsInteger(_11) && FuzzyIsInteger(_12) &&
           FuzzyIsInteger(_21) && FuzzyIsInteger(_22) &&
           FuzzyIsInteger(_31) && FuzzyIsInteger(_32);
  }

  Point GetTranslation() const {
    return Point(_31, _32);
  }





  bool PreservesAxisAlignedRectangles() const {
      return ((FuzzyEqual(_11, 0.0) && FuzzyEqual(_22, 0.0))
          || (FuzzyEqual(_12, 0.0) && FuzzyEqual(_21, 0.0)));
  }






  bool HasNonAxisAlignedTransform() const {
      return !FuzzyEqual(_21, 0.0) || !FuzzyEqual(_12, 0.0);
  }




  bool HasNegativeScaling() const {
      return (_11 < 0.0) || (_22 < 0.0);
  }
};


double
SafeTangent(double aTheta);
double
FlushToZero(double aVal);

template<class Units, class F>
Point4DTyped<Units, F>
ComputePerspectivePlaneIntercept(const Point4DTyped<Units, F>& aFirst,
                                 const Point4DTyped<Units, F>& aSecond)
{
  float t = -aFirst.w / (aSecond.w - aFirst.w);


  return aFirst + (aSecond - aFirst) * t;
}


template <typename SourceUnits, typename TargetUnits>
class Matrix4x4Typed
{
public:
  typedef PointTyped<SourceUnits> SourcePoint;
  typedef PointTyped<TargetUnits> TargetPoint;
  typedef Point3DTyped<SourceUnits> SourcePoint3D;
  typedef Point3DTyped<TargetUnits> TargetPoint3D;
  typedef Point4DTyped<SourceUnits> SourcePoint4D;
  typedef Point4DTyped<TargetUnits> TargetPoint4D;
  typedef RectTyped<SourceUnits> SourceRect;
  typedef RectTyped<TargetUnits> TargetRect;

  Matrix4x4Typed()
    : _11(1.0f), _12(0.0f), _13(0.0f), _14(0.0f)
    , _21(0.0f), _22(1.0f), _23(0.0f), _24(0.0f)
    , _31(0.0f), _32(0.0f), _33(1.0f), _34(0.0f)
    , _41(0.0f), _42(0.0f), _43(0.0f), _44(1.0f)
  {}

  Matrix4x4Typed(Float a11, Float a12, Float a13, Float a14,
                 Float a21, Float a22, Float a23, Float a24,
                 Float a31, Float a32, Float a33, Float a34,
                 Float a41, Float a42, Float a43, Float a44)
    : _11(a11), _12(a12), _13(a13), _14(a14)
    , _21(a21), _22(a22), _23(a23), _24(a24)
    , _31(a31), _32(a32), _33(a33), _34(a34)
    , _41(a41), _42(a42), _43(a43), _44(a44)
  {}

  explicit Matrix4x4Typed(const Float aArray[16])
  {
    memcpy(components, aArray, sizeof(components));
  }

  Matrix4x4Typed(const Matrix4x4Typed& aOther)
  {
    memcpy(this, &aOther, sizeof(*this));
  }

  union {
    struct {
      Float _11, _12, _13, _14;
      Float _21, _22, _23, _24;
      Float _31, _32, _33, _34;
      Float _41, _42, _43, _44;
    };
    Float components[16];
  };

  friend std::ostream& operator<<(std::ostream& aStream, const Matrix4x4Typed& aMatrix)
  {
    const Float *f = &aMatrix._11;
    aStream << "[ " << f[0] << " " << f[1] << " " << f[2] << " " << f[3] << " ;" << std::endl; f += 4;
    aStream << "  " << f[0] << " " << f[1] << " " << f[2] << " " << f[3] << " ;" << std::endl; f += 4;
    aStream << "  " << f[0] << " " << f[1] << " " << f[2] << " " << f[3] << " ;" << std::endl; f += 4;
    aStream << "  " << f[0] << " " << f[1] << " " << f[2] << " " << f[3] << " ]" << std::endl;
    return aStream;
  }

  Point4D& operator[](int aIndex)
  {
      do { } while (0);
      return *reinterpret_cast<Point4D*>((&_11)+4*aIndex);
  }
  const Point4D& operator[](int aIndex) const
  {
      do { } while (0);
      return *reinterpret_cast<const Point4D*>((&_11)+4*aIndex);
  }




  bool Is2D() const
  {
    if (_13 != 0.0f || _14 != 0.0f ||
        _23 != 0.0f || _24 != 0.0f ||
        _31 != 0.0f || _32 != 0.0f || _33 != 1.0f || _34 != 0.0f ||
        _43 != 0.0f || _44 != 1.0f) {
      return false;
    }
    return true;
  }

  bool Is2D(Matrix* aMatrix) const {
    if (!Is2D()) {
      return false;
    }
    if (aMatrix) {
      aMatrix->_11 = _11;
      aMatrix->_12 = _12;
      aMatrix->_21 = _21;
      aMatrix->_22 = _22;
      aMatrix->_31 = _41;
      aMatrix->_32 = _42;
    }
    return true;
  }

  Matrix As2D() const
  {
    do { } while (0);

    return Matrix(_11, _12, _21, _22, _41, _42);
  }

  bool CanDraw2D(Matrix* aMatrix = nullptr) const {
    if (_14 != 0.0f ||
        _24 != 0.0f ||
        _44 != 1.0f) {
      return false;
    }
    if (aMatrix) {
      aMatrix->_11 = _11;
      aMatrix->_12 = _12;
      aMatrix->_21 = _21;
      aMatrix->_22 = _22;
      aMatrix->_31 = _41;
      aMatrix->_32 = _42;
    }
    return true;
  }

  Matrix4x4Typed& ProjectTo2D() {
    _31 = 0.0f;
    _32 = 0.0f;
    _13 = 0.0f;
    _23 = 0.0f;
    _33 = 1.0f;
    _43 = 0.0f;
    _34 = 0.0f;







    if (_14 == 0.0f && _24 == 0.0f &&
        _44 != 1.0f && _44 != 0.0f) {
      Float scale = 1.0f / _44;
      _11 *= scale;
      _12 *= scale;
      _21 *= scale;
      _22 *= scale;
      _41 *= scale;
      _42 *= scale;
      _44 = 1.0f;
    }
    return *this;
  }

  template<class F>
  Point4DTyped<TargetUnits, F>
  ProjectPoint(const PointTyped<SourceUnits, F>& aPoint) const {






    F z = -(aPoint.x * _13 + aPoint.y * _23 + _43) / _33;


    return this->TransformPoint(Point4DTyped<SourceUnits, F>(aPoint.x, aPoint.y, z, 1));
  }

  template<class F>
  RectTyped<TargetUnits, F>
  ProjectRectBounds(const RectTyped<SourceUnits, F>& aRect, const RectTyped<TargetUnits, F>& aClip) const
  {
    Point4DTyped<TargetUnits, F> points[4];

    points[0] = ProjectPoint(aRect.TopLeft());
    points[1] = ProjectPoint(aRect.TopRight());
    points[2] = ProjectPoint(aRect.BottomRight());
    points[3] = ProjectPoint(aRect.BottomLeft());

    F min_x = std::numeric_limits<F>::max();
    F min_y = std::numeric_limits<F>::max();
    F max_x = -std::numeric_limits<F>::max();
    F max_y = -std::numeric_limits<F>::max();

    for (int i=0; i<4; i++) {

      if (points[i].HasPositiveWCoord()) {
        PointTyped<TargetUnits, F> point2d = aClip.ClampPoint(points[i].As2DPoint());
        min_x = std::min<F>(point2d.x, min_x);
        max_x = std::max<F>(point2d.x, max_x);
        min_y = std::min<F>(point2d.y, min_y);
        max_y = std::max<F>(point2d.y, max_y);
      }

      int next = (i == 3) ? 0 : i + 1;
      if (points[i].HasPositiveWCoord() != points[next].HasPositiveWCoord()) {



        Point4DTyped<TargetUnits, F> intercept =
          ComputePerspectivePlaneIntercept(points[i], points[next]);


        if (intercept.x < 0.0f) {
          min_x = aClip.x;
        } else if (intercept.x > 0.0f) {
          max_x = aClip.XMost();
        }
        if (intercept.y < 0.0f) {
          min_y = aClip.y;
        } else if (intercept.y > 0.0f) {
          max_y = aClip.YMost();
        }
      }
    }

    if (max_x < min_x || max_y < min_y) {
      return RectTyped<TargetUnits, F>(0, 0, 0, 0);
    }

    return RectTyped<TargetUnits, F>(min_x, min_y, max_x - min_x, max_y - min_y);
  }





  template<class F>
  RectTyped<TargetUnits, F> TransformAndClipBounds(const RectTyped<SourceUnits, F>& aRect,
                                                   const RectTyped<TargetUnits, F>& aClip) const
  {
    PointTyped<UnknownUnits, F> verts[kTransformAndClipRectMaxVerts];
    size_t vertCount = TransformAndClipRect(aRect, aClip, verts);

    F min_x = std::numeric_limits<F>::max();
    F min_y = std::numeric_limits<F>::max();
    F max_x = -std::numeric_limits<F>::max();
    F max_y = -std::numeric_limits<F>::max();
    for (size_t i=0; i < vertCount; i++) {
      min_x = std::min(min_x, verts[i].x);
      max_x = std::max(max_x, verts[i].x);
      min_y = std::min(min_y, verts[i].y);
      max_y = std::max(max_y, verts[i].y);
    }

    if (max_x < min_x || max_y < min_y) {
      return RectTyped<TargetUnits, F>(0, 0, 0, 0);
    }

    return RectTyped<TargetUnits, F>(min_x, min_y, max_x - min_x, max_y - min_y);
  }

  template<class F>
  RectTyped<TargetUnits, F> TransformAndClipBounds(const TriangleTyped<SourceUnits, F>& aTriangle,
                                                   const RectTyped<TargetUnits, F>& aClip) const
  {
    return TransformAndClipBounds(aTriangle.BoundingBox(), aClip);
  }
  template<class F>
  size_t TransformAndClipRect(const RectTyped<SourceUnits, F>& aRect,
                              const RectTyped<TargetUnits, F>& aClip,
                              PointTyped<TargetUnits, F>* aVerts) const
  {


    Point4DTyped<UnknownUnits, F> points[2][kTransformAndClipRectMaxVerts];
    Point4DTyped<UnknownUnits, F>* dstPoint = points[0];

    *dstPoint++ = TransformPoint(Point4DTyped<UnknownUnits, F>(aRect.x, aRect.y, 0, 1));
    *dstPoint++ = TransformPoint(Point4DTyped<UnknownUnits, F>(aRect.XMost(), aRect.y, 0, 1));
    *dstPoint++ = TransformPoint(Point4DTyped<UnknownUnits, F>(aRect.XMost(), aRect.YMost(), 0, 1));
    *dstPoint++ = TransformPoint(Point4DTyped<UnknownUnits, F>(aRect.x, aRect.YMost(), 0, 1));



    Point4DTyped<UnknownUnits, F> planeNormals[4];
    planeNormals[0] = Point4DTyped<UnknownUnits, F>(1.0, 0.0, 0.0, -aClip.x);
    planeNormals[1] = Point4DTyped<UnknownUnits, F>(-1.0, 0.0, 0.0, aClip.XMost());
    planeNormals[2] = Point4DTyped<UnknownUnits, F>(0.0, 1.0, 0.0, -aClip.y);
    planeNormals[3] = Point4DTyped<UnknownUnits, F>(0.0, -1.0, 0.0, aClip.YMost());




    for (int plane=0; plane < 4; plane++) {
      planeNormals[plane].Normalize();
      Point4DTyped<UnknownUnits, F>* srcPoint = points[plane & 1];
      Point4DTyped<UnknownUnits, F>* srcPointEnd = dstPoint;

      dstPoint = points[~plane & 1];
      Point4DTyped<UnknownUnits, F>* dstPointStart = dstPoint;

      Point4DTyped<UnknownUnits, F>* prevPoint = srcPointEnd - 1;
      F prevDot = planeNormals[plane].DotProduct(*prevPoint);
      while (srcPoint < srcPointEnd && ((dstPoint - dstPointStart) < kTransformAndClipRectMaxVerts)) {
        F nextDot = planeNormals[plane].DotProduct(*srcPoint);

        if ((nextDot >= 0.0) != (prevDot >= 0.0)) {


          F t = -prevDot / (nextDot - prevDot);
          *dstPoint++ = *srcPoint * t + *prevPoint * (1.0 - t);
        }

        if (nextDot >= 0.0) {


          *dstPoint++ = *srcPoint;
        }

        prevPoint = srcPoint++;
        prevDot = nextDot;
      }

      if (dstPoint == dstPointStart) {
        break;
      }
    }

    size_t dstPointCount = 0;
    size_t srcPointCount = dstPoint - points[0];
    for (Point4DTyped<UnknownUnits, F>* srcPoint = points[0]; srcPoint < points[0] + srcPointCount; srcPoint++) {

      PointTyped<TargetUnits, F> p;
      if (srcPoint->w == 0.0) {


        p = PointTyped<TargetUnits, F>(0.0, 0.0);
      } else {
        p = srcPoint->As2DPoint();
      }

      if (dstPointCount == 0 || p != aVerts[dstPointCount - 1]) {
        aVerts[dstPointCount++] = p;
      }
    }

    return dstPointCount;
  }

  static const int kTransformAndClipRectMaxVerts = 32;

  static Matrix4x4Typed From2D(const Matrix &aMatrix) {
    Matrix4x4Typed matrix;
    matrix._11 = aMatrix._11;
    matrix._12 = aMatrix._12;
    matrix._21 = aMatrix._21;
    matrix._22 = aMatrix._22;
    matrix._41 = aMatrix._31;
    matrix._42 = aMatrix._32;
    return matrix;
  }

  bool Is2DIntegerTranslation() const
  {
    return Is2D() && As2D().IsIntegerTranslation();
  }

  TargetPoint4D TransposeTransform4D(const SourcePoint4D& aPoint) const
  {
      Float x = aPoint.x * _11 + aPoint.y * _12 + aPoint.z * _13 + aPoint.w * _14;
      Float y = aPoint.x * _21 + aPoint.y * _22 + aPoint.z * _23 + aPoint.w * _24;
      Float z = aPoint.x * _31 + aPoint.y * _32 + aPoint.z * _33 + aPoint.w * _34;
      Float w = aPoint.x * _41 + aPoint.y * _42 + aPoint.z * _43 + aPoint.w * _44;

      return TargetPoint4D(x, y, z, w);
  }

  template<class F>
  Point4DTyped<TargetUnits, F> TransformPoint(const Point4DTyped<SourceUnits, F>& aPoint) const
  {
    Point4DTyped<TargetUnits, F> retPoint;

    retPoint.x = aPoint.x * _11 + aPoint.y * _21 + aPoint.z * _31 + aPoint.w * _41;
    retPoint.y = aPoint.x * _12 + aPoint.y * _22 + aPoint.z * _32 + aPoint.w * _42;
    retPoint.z = aPoint.x * _13 + aPoint.y * _23 + aPoint.z * _33 + aPoint.w * _43;
    retPoint.w = aPoint.x * _14 + aPoint.y * _24 + aPoint.z * _34 + aPoint.w * _44;

    return retPoint;
  }

  template<class F>
  Point3DTyped<TargetUnits, F> TransformPoint(const Point3DTyped<SourceUnits, F>& aPoint) const
  {
    Point3DTyped<TargetUnits, F> result;
    result.x = aPoint.x * _11 + aPoint.y * _21 + aPoint.z * _31 + _41;
    result.y = aPoint.x * _12 + aPoint.y * _22 + aPoint.z * _32 + _42;
    result.z = aPoint.x * _13 + aPoint.y * _23 + aPoint.z * _33 + _43;

    result /= (aPoint.x * _14 + aPoint.y * _24 + aPoint.z * _34 + _44);

    return result;
  }

  template<class F>
  PointTyped<TargetUnits, F> TransformPoint(const PointTyped<SourceUnits, F> &aPoint) const
  {
    Point4DTyped<SourceUnits, F> temp(aPoint.x, aPoint.y, 0, 1);
    return TransformPoint(temp).As2DPoint();
  }

  template<class F>
            RectTyped<TargetUnits, F> TransformBounds(const RectTyped<SourceUnits, F>& aRect) const
  {
    Point4DTyped<TargetUnits, F> verts[4];
    verts[0] = TransformPoint(Point4DTyped<SourceUnits, F>(aRect.x, aRect.y, 0.0, 1.0));
    verts[1] = TransformPoint(Point4DTyped<SourceUnits, F>(aRect.XMost(), aRect.y, 0.0, 1.0));
    verts[2] = TransformPoint(Point4DTyped<SourceUnits, F>(aRect.XMost(), aRect.YMost(), 0.0, 1.0));
    verts[3] = TransformPoint(Point4DTyped<SourceUnits, F>(aRect.x, aRect.YMost(), 0.0, 1.0));

    PointTyped<TargetUnits, F> quad[4];
    F min_x, max_x;
    F min_y, max_y;

    quad[0] = TransformPoint(aRect.TopLeft());
    quad[1] = TransformPoint(aRect.TopRight());
    quad[2] = TransformPoint(aRect.BottomLeft());
    quad[3] = TransformPoint(aRect.BottomRight());

    min_x = max_x = quad[0].x;
    min_y = max_y = quad[0].y;

    for (int i = 1; i < 4; i++) {
      if (quad[i].x < min_x) {
        min_x = quad[i].x;
      }
      if (quad[i].x > max_x) {
        max_x = quad[i].x;
      }

      if (quad[i].y < min_y) {
        min_y = quad[i].y;
      }
      if (quad[i].y > max_y) {
        max_y = quad[i].y;
      }
    }

    return RectTyped<TargetUnits, F>(min_x, min_y, max_x - min_x, max_y - min_y);
  }

  static Matrix4x4Typed Translation(Float aX, Float aY, Float aZ)
  {
    return Matrix4x4Typed(1.0f, 0.0f, 0.0f, 0.0f,
                          0.0f, 1.0f, 0.0f, 0.0f,
                          0.0f, 0.0f, 1.0f, 0.0f,
                          aX, aY, aZ, 1.0f);
  }

  static Matrix4x4Typed Translation(const TargetPoint3D& aP)
  {
    return Translation(aP.x, aP.y, aP.z);
  }

  static Matrix4x4Typed Translation(const TargetPoint& aP)
  {
    return Translation(aP.x, aP.y, 0);
  }
  Matrix4x4Typed &PreTranslate(Float aX, Float aY, Float aZ)
  {
    _41 += aX * _11 + aY * _21 + aZ * _31;
    _42 += aX * _12 + aY * _22 + aZ * _32;
    _43 += aX * _13 + aY * _23 + aZ * _33;
    _44 += aX * _14 + aY * _24 + aZ * _34;

    return *this;
  }

  Matrix4x4Typed &PreTranslate(const Point3D& aPoint) {
    return PreTranslate(aPoint.x, aPoint.y, aPoint.z);
  }
  Matrix4x4Typed &PostTranslate(Float aX, Float aY, Float aZ)
  {
    _11 += _14 * aX;
    _21 += _24 * aX;
    _31 += _34 * aX;
    _41 += _44 * aX;
    _12 += _14 * aY;
    _22 += _24 * aY;
    _32 += _34 * aY;
    _42 += _44 * aY;
    _13 += _14 * aZ;
    _23 += _24 * aZ;
    _33 += _34 * aZ;
    _43 += _44 * aZ;

    return *this;
  }

  Matrix4x4Typed &PostTranslate(const TargetPoint3D& aPoint) {
    return PostTranslate(aPoint.x, aPoint.y, aPoint.z);
  }

  Matrix4x4Typed &PostTranslate(const TargetPoint& aPoint) {
    return PostTranslate(aPoint.x, aPoint.y, 0);
  }

  static Matrix4x4Typed Scaling(Float aScaleX, Float aScaleY, float aScaleZ)
  {
    return Matrix4x4Typed(aScaleX, 0.0f, 0.0f, 0.0f,
                          0.0f, aScaleY, 0.0f, 0.0f,
                          0.0f, 0.0f, aScaleZ, 0.0f,
                          0.0f, 0.0f, 0.0f, 1.0f);
  }




  Matrix4x4Typed &PreScale(Float aX, Float aY, Float aZ)
  {
    _11 *= aX;
    _12 *= aX;
    _13 *= aX;
    _14 *= aX;
    _21 *= aY;
    _22 *= aY;
    _23 *= aY;
    _24 *= aY;
    _31 *= aZ;
    _32 *= aZ;
    _33 *= aZ;
    _34 *= aZ;

    return *this;
  }




  Matrix4x4Typed &PostScale(Float aScaleX, Float aScaleY, Float aScaleZ)
  {
    _11 *= aScaleX;
    _21 *= aScaleX;
    _31 *= aScaleX;
    _41 *= aScaleX;
    _12 *= aScaleY;
    _22 *= aScaleY;
    _32 *= aScaleY;
    _42 *= aScaleY;
    _13 *= aScaleZ;
    _23 *= aScaleZ;
    _33 *= aScaleZ;
    _43 *= aScaleZ;

    return *this;
  }

  void SkewXY(Float aSkew)
  {
    (*this)[1] += (*this)[0] * aSkew;
  }

  void SkewXZ(Float aSkew)
  {
      (*this)[2] += (*this)[0] * aSkew;
  }

  void SkewYZ(Float aSkew)
  {
      (*this)[2] += (*this)[1] * aSkew;
  }

  Matrix4x4Typed &ChangeBasis(const Point3D& aOrigin)
  {
    return ChangeBasis(aOrigin.x, aOrigin.y, aOrigin.z);
  }

  Matrix4x4Typed &ChangeBasis(Float aX, Float aY, Float aZ)
  {

    PreTranslate(-aX, -aY, -aZ);


    PostTranslate(aX, aY, aZ);

    return *this;
  }

  Matrix4x4Typed& Transpose() {
    std::swap(_12, _21);
    std::swap(_13, _31);
    std::swap(_14, _41);

    std::swap(_23, _32);
    std::swap(_24, _42);

    std::swap(_34, _43);

    return *this;
  }

  bool operator==(const Matrix4x4Typed& o) const
  {

    return _11 == o._11 && _12 == o._12 && _13 == o._13 && _14 == o._14 &&
           _21 == o._21 && _22 == o._22 && _23 == o._23 && _24 == o._24 &&
           _31 == o._31 && _32 == o._32 && _33 == o._33 && _34 == o._34 &&
           _41 == o._41 && _42 == o._42 && _43 == o._43 && _44 == o._44;
  }

  bool operator!=(const Matrix4x4Typed& o) const
  {
    return !((*this) == o);
  }

  template <typename NewTargetUnits>
  Matrix4x4Typed<SourceUnits, NewTargetUnits> operator*(const Matrix4x4Typed<TargetUnits, NewTargetUnits> &aMatrix) const
  {
    Matrix4x4Typed<SourceUnits, NewTargetUnits> matrix;

    matrix._11 = _11 * aMatrix._11 + _12 * aMatrix._21 + _13 * aMatrix._31 + _14 * aMatrix._41;
    matrix._21 = _21 * aMatrix._11 + _22 * aMatrix._21 + _23 * aMatrix._31 + _24 * aMatrix._41;
    matrix._31 = _31 * aMatrix._11 + _32 * aMatrix._21 + _33 * aMatrix._31 + _34 * aMatrix._41;
    matrix._41 = _41 * aMatrix._11 + _42 * aMatrix._21 + _43 * aMatrix._31 + _44 * aMatrix._41;
    matrix._12 = _11 * aMatrix._12 + _12 * aMatrix._22 + _13 * aMatrix._32 + _14 * aMatrix._42;
    matrix._22 = _21 * aMatrix._12 + _22 * aMatrix._22 + _23 * aMatrix._32 + _24 * aMatrix._42;
    matrix._32 = _31 * aMatrix._12 + _32 * aMatrix._22 + _33 * aMatrix._32 + _34 * aMatrix._42;
    matrix._42 = _41 * aMatrix._12 + _42 * aMatrix._22 + _43 * aMatrix._32 + _44 * aMatrix._42;
    matrix._13 = _11 * aMatrix._13 + _12 * aMatrix._23 + _13 * aMatrix._33 + _14 * aMatrix._43;
    matrix._23 = _21 * aMatrix._13 + _22 * aMatrix._23 + _23 * aMatrix._33 + _24 * aMatrix._43;
    matrix._33 = _31 * aMatrix._13 + _32 * aMatrix._23 + _33 * aMatrix._33 + _34 * aMatrix._43;
    matrix._43 = _41 * aMatrix._13 + _42 * aMatrix._23 + _43 * aMatrix._33 + _44 * aMatrix._43;
    matrix._14 = _11 * aMatrix._14 + _12 * aMatrix._24 + _13 * aMatrix._34 + _14 * aMatrix._44;
    matrix._24 = _21 * aMatrix._14 + _22 * aMatrix._24 + _23 * aMatrix._34 + _24 * aMatrix._44;
    matrix._34 = _31 * aMatrix._14 + _32 * aMatrix._24 + _33 * aMatrix._34 + _34 * aMatrix._44;
    matrix._44 = _41 * aMatrix._14 + _42 * aMatrix._24 + _43 * aMatrix._34 + _44 * aMatrix._44;

    return matrix;
  }

  Matrix4x4Typed& operator*=(const Matrix4x4Typed<TargetUnits, TargetUnits> &aMatrix)
  {
    *this = *this * aMatrix;
    return *this;
  }



  bool IsIdentity() const
  {
    return _11 == 1.0f && _12 == 0.0f && _13 == 0.0f && _14 == 0.0f &&
           _21 == 0.0f && _22 == 1.0f && _23 == 0.0f && _24 == 0.0f &&
           _31 == 0.0f && _32 == 0.0f && _33 == 1.0f && _34 == 0.0f &&
           _41 == 0.0f && _42 == 0.0f && _43 == 0.0f && _44 == 1.0f;
  }

  bool IsSingular() const
  {
    return Determinant() == 0.0;
  }

  Float Determinant() const
  {
    return _14 * _23 * _32 * _41
         - _13 * _24 * _32 * _41
         - _14 * _22 * _33 * _41
         + _12 * _24 * _33 * _41
         + _13 * _22 * _34 * _41
         - _12 * _23 * _34 * _41
         - _14 * _23 * _31 * _42
         + _13 * _24 * _31 * _42
         + _14 * _21 * _33 * _42
         - _11 * _24 * _33 * _42
         - _13 * _21 * _34 * _42
         + _11 * _23 * _34 * _42
         + _14 * _22 * _31 * _43
         - _12 * _24 * _31 * _43
         - _14 * _21 * _32 * _43
         + _11 * _24 * _32 * _43
         + _12 * _21 * _34 * _43
         - _11 * _22 * _34 * _43
         - _13 * _22 * _31 * _44
         + _12 * _23 * _31 * _44
         + _13 * _21 * _32 * _44
         - _11 * _23 * _32 * _44
         - _12 * _21 * _33 * _44
         + _11 * _22 * _33 * _44;
  }


  bool Invert()
  {
    Float det = Determinant();
    if (!det) {
      return false;
    }

    Matrix4x4Typed<SourceUnits, TargetUnits> result;
    result._11 = _23 * _34 * _42 - _24 * _33 * _42 + _24 * _32 * _43 - _22 * _34 * _43 - _23 * _32 * _44 + _22 * _33 * _44;
    result._12 = _14 * _33 * _42 - _13 * _34 * _42 - _14 * _32 * _43 + _12 * _34 * _43 + _13 * _32 * _44 - _12 * _33 * _44;
    result._13 = _13 * _24 * _42 - _14 * _23 * _42 + _14 * _22 * _43 - _12 * _24 * _43 - _13 * _22 * _44 + _12 * _23 * _44;
    result._14 = _14 * _23 * _32 - _13 * _24 * _32 - _14 * _22 * _33 + _12 * _24 * _33 + _13 * _22 * _34 - _12 * _23 * _34;
    result._21 = _24 * _33 * _41 - _23 * _34 * _41 - _24 * _31 * _43 + _21 * _34 * _43 + _23 * _31 * _44 - _21 * _33 * _44;
    result._22 = _13 * _34 * _41 - _14 * _33 * _41 + _14 * _31 * _43 - _11 * _34 * _43 - _13 * _31 * _44 + _11 * _33 * _44;
    result._23 = _14 * _23 * _41 - _13 * _24 * _41 - _14 * _21 * _43 + _11 * _24 * _43 + _13 * _21 * _44 - _11 * _23 * _44;
    result._24 = _13 * _24 * _31 - _14 * _23 * _31 + _14 * _21 * _33 - _11 * _24 * _33 - _13 * _21 * _34 + _11 * _23 * _34;
    result._31 = _22 * _34 * _41 - _24 * _32 * _41 + _24 * _31 * _42 - _21 * _34 * _42 - _22 * _31 * _44 + _21 * _32 * _44;
    result._32 = _14 * _32 * _41 - _12 * _34 * _41 - _14 * _31 * _42 + _11 * _34 * _42 + _12 * _31 * _44 - _11 * _32 * _44;
    result._33 = _12 * _24 * _41 - _14 * _22 * _41 + _14 * _21 * _42 - _11 * _24 * _42 - _12 * _21 * _44 + _11 * _22 * _44;
    result._34 = _14 * _22 * _31 - _12 * _24 * _31 - _14 * _21 * _32 + _11 * _24 * _32 + _12 * _21 * _34 - _11 * _22 * _34;
    result._41 = _23 * _32 * _41 - _22 * _33 * _41 - _23 * _31 * _42 + _21 * _33 * _42 + _22 * _31 * _43 - _21 * _32 * _43;
    result._42 = _12 * _33 * _41 - _13 * _32 * _41 + _13 * _31 * _42 - _11 * _33 * _42 - _12 * _31 * _43 + _11 * _32 * _43;
    result._43 = _13 * _22 * _41 - _12 * _23 * _41 - _13 * _21 * _42 + _11 * _23 * _42 + _12 * _21 * _43 - _11 * _22 * _43;
    result._44 = _12 * _23 * _31 - _13 * _22 * _31 + _13 * _21 * _32 - _11 * _23 * _32 - _12 * _21 * _33 + _11 * _22 * _33;

    result._11 /= det;
    result._12 /= det;
    result._13 /= det;
    result._14 /= det;
    result._21 /= det;
    result._22 /= det;
    result._23 /= det;
    result._24 /= det;
    result._31 /= det;
    result._32 /= det;
    result._33 /= det;
    result._34 /= det;
    result._41 /= det;
    result._42 /= det;
    result._43 /= det;
    result._44 /= det;
    *this = result;

    return true;
  }

  Matrix4x4Typed<TargetUnits, SourceUnits> Inverse() const
  {
    typedef Matrix4x4Typed<TargetUnits, SourceUnits> InvertedMatrix;
    InvertedMatrix clone = InvertedMatrix::FromUnknownMatrix(ToUnknownMatrix());
    DebugOnly<bool> inverted = clone.Invert();
    do { } while (0);
    return clone;
  }

  Maybe<Matrix4x4Typed<TargetUnits, SourceUnits>> MaybeInverse() const
  {
    typedef Matrix4x4Typed<TargetUnits, SourceUnits> InvertedMatrix;
    InvertedMatrix clone = InvertedMatrix::FromUnknownMatrix(ToUnknownMatrix());
    if (clone.Invert()) {
      return Some(clone);
    }
    return Nothing();
  }

  void Normalize()
  {
      for (int i = 0; i < 4; i++) {
          for (int j = 0; j < 4; j++) {
              (*this)[i][j] /= (*this)[3][3];
         }
      }
  }

  bool FuzzyEqual(const Matrix4x4Typed& o) const
  {
    return gfx::FuzzyEqual(_11, o._11) && gfx::FuzzyEqual(_12, o._12) &&
           gfx::FuzzyEqual(_13, o._13) && gfx::FuzzyEqual(_14, o._14) &&
           gfx::FuzzyEqual(_21, o._21) && gfx::FuzzyEqual(_22, o._22) &&
           gfx::FuzzyEqual(_23, o._23) && gfx::FuzzyEqual(_24, o._24) &&
           gfx::FuzzyEqual(_31, o._31) && gfx::FuzzyEqual(_32, o._32) &&
           gfx::FuzzyEqual(_33, o._33) && gfx::FuzzyEqual(_34, o._34) &&
           gfx::FuzzyEqual(_41, o._41) && gfx::FuzzyEqual(_42, o._42) &&
           gfx::FuzzyEqual(_43, o._43) && gfx::FuzzyEqual(_44, o._44);
  }

  bool FuzzyEqualsMultiplicative(const Matrix4x4Typed& o) const
  {
    return ::mozilla::FuzzyEqualsMultiplicative(_11, o._11) &&
           ::mozilla::FuzzyEqualsMultiplicative(_12, o._12) &&
           ::mozilla::FuzzyEqualsMultiplicative(_13, o._13) &&
           ::mozilla::FuzzyEqualsMultiplicative(_14, o._14) &&
           ::mozilla::FuzzyEqualsMultiplicative(_21, o._21) &&
           ::mozilla::FuzzyEqualsMultiplicative(_22, o._22) &&
           ::mozilla::FuzzyEqualsMultiplicative(_23, o._23) &&
           ::mozilla::FuzzyEqualsMultiplicative(_24, o._24) &&
           ::mozilla::FuzzyEqualsMultiplicative(_31, o._31) &&
           ::mozilla::FuzzyEqualsMultiplicative(_32, o._32) &&
           ::mozilla::FuzzyEqualsMultiplicative(_33, o._33) &&
           ::mozilla::FuzzyEqualsMultiplicative(_34, o._34) &&
           ::mozilla::FuzzyEqualsMultiplicative(_41, o._41) &&
           ::mozilla::FuzzyEqualsMultiplicative(_42, o._42) &&
           ::mozilla::FuzzyEqualsMultiplicative(_43, o._43) &&
           ::mozilla::FuzzyEqualsMultiplicative(_44, o._44);
  }

  bool IsBackfaceVisible() const
  {

    Float det = Determinant();
    Float __33 = _12*_24*_41 - _14*_22*_41 +
                _14*_21*_42 - _11*_24*_42 -
                _12*_21*_44 + _11*_22*_44;
    return (__33 * det) < 0;
  }

  Matrix4x4Typed &NudgeToIntegersFixedEpsilon()
  {
    NudgeToInteger(&_11);
    NudgeToInteger(&_12);
    NudgeToInteger(&_13);
    NudgeToInteger(&_14);
    NudgeToInteger(&_21);
    NudgeToInteger(&_22);
    NudgeToInteger(&_23);
    NudgeToInteger(&_24);
    NudgeToInteger(&_31);
    NudgeToInteger(&_32);
    NudgeToInteger(&_33);
    NudgeToInteger(&_34);
    static const float error = 1e-5f;
    NudgeToInteger(&_41, error);
    NudgeToInteger(&_42, error);
    NudgeToInteger(&_43, error);
    NudgeToInteger(&_44, error);
    return *this;
  }

  Point4D TransposedVector(int aIndex) const
  {
      do { } while (0);
      return Point4D(*((&_11)+aIndex), *((&_21)+aIndex), *((&_31)+aIndex), *((&_41)+aIndex));
  }

  void SetTransposedVector(int aIndex, Point4D &aVector)
  {
      do { } while (0);
      *((&_11)+aIndex) = aVector.x;
      *((&_21)+aIndex) = aVector.y;
      *((&_31)+aIndex) = aVector.z;
      *((&_41)+aIndex) = aVector.w;
  }




  void SetRotationFromQuaternion(const Quaternion& q)
  {
    const Float x2 = q.x + q.x, y2 = q.y + q.y, z2 = q.z + q.z;
    const Float xx = q.x * x2, xy = q.x * y2, xz = q.x * z2;
    const Float yy = q.y * y2, yz = q.y * z2, zz = q.z * z2;
    const Float wx = q.w * x2, wy = q.w * y2, wz = q.w * z2;

    _11 = 1.0f - (yy + zz);
    _21 = xy + wz;
    _31 = xz - wy;
    _41 = 0.0f;

    _12 = xy - wz;
    _22 = 1.0f - (xx + zz);
    _32 = yz + wx;
    _42 = 0.0f;

    _13 = xz + wy;
    _23 = yz - wx;
    _33 = 1.0f - (xx + yy);
    _43 = 0.0f;

    _14 = _42 = _43 = 0.0f;
    _44 = 1.0f;
  }


  void SetNAN()
  {
    _11 = UnspecifiedNaN<Float>();
    _21 = UnspecifiedNaN<Float>();
    _31 = UnspecifiedNaN<Float>();
    _41 = UnspecifiedNaN<Float>();
    _12 = UnspecifiedNaN<Float>();
    _22 = UnspecifiedNaN<Float>();
    _32 = UnspecifiedNaN<Float>();
    _42 = UnspecifiedNaN<Float>();
    _13 = UnspecifiedNaN<Float>();
    _23 = UnspecifiedNaN<Float>();
    _33 = UnspecifiedNaN<Float>();
    _43 = UnspecifiedNaN<Float>();
    _14 = UnspecifiedNaN<Float>();
    _24 = UnspecifiedNaN<Float>();
    _34 = UnspecifiedNaN<Float>();
    _44 = UnspecifiedNaN<Float>();
  }

  void SkewXY(double aXSkew, double aYSkew)
  {

    float tanX = SafeTangent(aXSkew);
    float tanY = SafeTangent(aYSkew);
    float temp;

    temp = _11;
    _11 += tanY * _21;
    _21 += tanX * temp;

    temp = _12;
    _12 += tanY * _22;
    _22 += tanX * temp;

    temp = _13;
    _13 += tanY * _23;
    _23 += tanX * temp;

    temp = _14;
    _14 += tanY * _24;
    _24 += tanX * temp;
  }

  void RotateX(double aTheta)
  {

    double cosTheta = FlushToZero(cos(aTheta));
    double sinTheta = FlushToZero(sin(aTheta));

    float temp;

    temp = _21;
    _21 = cosTheta * _21 + sinTheta * _31;
    _31 = -sinTheta * temp + cosTheta * _31;

    temp = _22;
    _22 = cosTheta * _22 + sinTheta * _32;
    _32 = -sinTheta * temp + cosTheta * _32;

    temp = _23;
    _23 = cosTheta * _23 + sinTheta * _33;
    _33 = -sinTheta * temp + cosTheta * _33;

    temp = _24;
    _24 = cosTheta * _24 + sinTheta * _34;
    _34 = -sinTheta * temp + cosTheta * _34;
  }

  void RotateY(double aTheta)
  {

    double cosTheta = FlushToZero(cos(aTheta));
    double sinTheta = FlushToZero(sin(aTheta));

    float temp;

    temp = _11;
    _11 = cosTheta * _11 + -sinTheta * _31;
    _31 = sinTheta * temp + cosTheta * _31;

    temp = _12;
    _12 = cosTheta * _12 + -sinTheta * _32;
    _32 = sinTheta * temp + cosTheta * _32;

    temp = _13;
    _13 = cosTheta * _13 + -sinTheta * _33;
    _33 = sinTheta * temp + cosTheta * _33;

    temp = _14;
    _14 = cosTheta * _14 + -sinTheta * _34;
    _34 = sinTheta * temp + cosTheta * _34;
  }

  void RotateZ(double aTheta)
  {

    double cosTheta = FlushToZero(cos(aTheta));
    double sinTheta = FlushToZero(sin(aTheta));

    float temp;

    temp = _11;
    _11 = cosTheta * _11 + sinTheta * _21;
    _21 = -sinTheta * temp + cosTheta * _21;

    temp = _12;
    _12 = cosTheta * _12 + sinTheta * _22;
    _22 = -sinTheta * temp + cosTheta * _22;

    temp = _13;
    _13 = cosTheta * _13 + sinTheta * _23;
    _23 = -sinTheta * temp + cosTheta * _23;

    temp = _14;
    _14 = cosTheta * _14 + sinTheta * _24;
    _24 = -sinTheta * temp + cosTheta * _24;
  }





  void SetRotateAxisAngle(double aX, double aY, double aZ, double aTheta)
  {
    Point3D vector(aX, aY, aZ);
    if (!vector.Length()) {
      return;
    }
    vector.Normalize();

    double x = vector.x;
    double y = vector.y;
    double z = vector.z;

    double cosTheta = FlushToZero(cos(aTheta));
    double sinTheta = FlushToZero(sin(aTheta));


    double sc = sinTheta / 2;

    double sq = (1 - cosTheta) / 2;

    _11 = 1 - 2 * (y * y + z * z) * sq;
    _12 = 2 * (x * y * sq + z * sc);
    _13 = 2 * (x * z * sq - y * sc);
    _14 = 0.0f;
    _21 = 2 * (x * y * sq - z * sc);
    _22 = 1 - 2 * (x * x + z * z) * sq;
    _23 = 2 * (y * z * sq + x * sc);
    _24 = 0.0f;
    _31 = 2 * (x * z * sq + y * sc);
    _32 = 2 * (y * z * sq - x * sc);
    _33 = 1 - 2 * (x * x + y * y) * sq;
    _34 = 0.0f;
    _41 = 0.0f;
    _42 = 0.0f;
    _43 = 0.0f;
    _44 = 1.0f;
  }

  void Perspective(float aDepth)
  {
    do { } while (0);
    _31 += -1.0/aDepth * _41;
    _32 += -1.0/aDepth * _42;
    _33 += -1.0/aDepth * _43;
    _34 += -1.0/aDepth * _44;
  }

  Point3D GetNormalVector() const
  {


    Point3D a = TransformPoint(Point3D(0, 0, 0));
    Point3D b = TransformPoint(Point3D(0, 1, 0));
    Point3D c = TransformPoint(Point3D(1, 0, 0));


    Point3D ab = b - a;
    Point3D ac = c - a;

    return ac.CrossProduct(ab);
  }





  bool HasNonTranslation() const {
    return !gfx::FuzzyEqual(_11, 1.0) || !gfx::FuzzyEqual(_22, 1.0) ||
           !gfx::FuzzyEqual(_12, 0.0) || !gfx::FuzzyEqual(_21, 0.0) ||
           !gfx::FuzzyEqual(_13, 0.0) || !gfx::FuzzyEqual(_23, 0.0) ||
           !gfx::FuzzyEqual(_31, 0.0) || !gfx::FuzzyEqual(_32, 0.0) ||
           !gfx::FuzzyEqual(_33, 1.0);
  }





  bool HasNonIntegerTranslation() const {
    return HasNonTranslation() ||
      !gfx::FuzzyEqual(_41, floor(_41 + 0.5)) ||
      !gfx::FuzzyEqual(_42, floor(_42 + 0.5)) ||
      !gfx::FuzzyEqual(_43, floor(_43 + 0.5));
  }




  bool HasPerspectiveComponent() const {
    return _14 != 0 || _24 != 0 || _34 != 0 || _44 != 1;
  }




  Matrix4x4 ToUnknownMatrix() const {
    return Matrix4x4{_11, _12, _13, _14,
                     _21, _22, _23, _24,
                     _31, _32, _33, _34,
                     _41, _42, _43, _44};
  }
  static Matrix4x4Typed FromUnknownMatrix(const Matrix4x4& aUnknown) {
    return Matrix4x4Typed{aUnknown._11, aUnknown._12, aUnknown._13, aUnknown._14,
                          aUnknown._21, aUnknown._22, aUnknown._23, aUnknown._24,
                          aUnknown._31, aUnknown._32, aUnknown._33, aUnknown._34,
                          aUnknown._41, aUnknown._42, aUnknown._43, aUnknown._44};
  }
};

typedef Matrix4x4Typed<UnknownUnits, UnknownUnits> Matrix4x4;

class Matrix5x4
{
public:
  Matrix5x4()
    : _11(1.0f), _12(0), _13(0), _14(0)
    , _21(0), _22(1.0f), _23(0), _24(0)
    , _31(0), _32(0), _33(1.0f), _34(0)
    , _41(0), _42(0), _43(0), _44(1.0f)
    , _51(0), _52(0), _53(0), _54(0)
  {}
  Matrix5x4(Float a11, Float a12, Float a13, Float a14,
         Float a21, Float a22, Float a23, Float a24,
         Float a31, Float a32, Float a33, Float a34,
         Float a41, Float a42, Float a43, Float a44,
         Float a51, Float a52, Float a53, Float a54)
    : _11(a11), _12(a12), _13(a13), _14(a14)
    , _21(a21), _22(a22), _23(a23), _24(a24)
    , _31(a31), _32(a32), _33(a33), _34(a34)
    , _41(a41), _42(a42), _43(a43), _44(a44)
    , _51(a51), _52(a52), _53(a53), _54(a54)
  {}

  bool operator==(const Matrix5x4 &o) const
  {
    return _11 == o._11 && _12 == o._12 && _13 == o._13 && _14 == o._14 &&
           _21 == o._21 && _22 == o._22 && _23 == o._23 && _24 == o._24 &&
           _31 == o._31 && _32 == o._32 && _33 == o._33 && _34 == o._34 &&
           _41 == o._41 && _42 == o._42 && _43 == o._43 && _44 == o._44 &&
           _51 == o._51 && _52 == o._52 && _53 == o._53 && _54 == o._54;
  }

  bool operator!=(const Matrix5x4 &aMatrix) const
  {
    return !(*this == aMatrix);
  }

  Matrix5x4 operator*(const Matrix5x4 &aMatrix) const
  {
    Matrix5x4 resultMatrix;

    resultMatrix._11 = this->_11 * aMatrix._11 + this->_12 * aMatrix._21 + this->_13 * aMatrix._31 + this->_14 * aMatrix._41;
    resultMatrix._12 = this->_11 * aMatrix._12 + this->_12 * aMatrix._22 + this->_13 * aMatrix._32 + this->_14 * aMatrix._42;
    resultMatrix._13 = this->_11 * aMatrix._13 + this->_12 * aMatrix._23 + this->_13 * aMatrix._33 + this->_14 * aMatrix._43;
    resultMatrix._14 = this->_11 * aMatrix._14 + this->_12 * aMatrix._24 + this->_13 * aMatrix._34 + this->_14 * aMatrix._44;
    resultMatrix._21 = this->_21 * aMatrix._11 + this->_22 * aMatrix._21 + this->_23 * aMatrix._31 + this->_24 * aMatrix._41;
    resultMatrix._22 = this->_21 * aMatrix._12 + this->_22 * aMatrix._22 + this->_23 * aMatrix._32 + this->_24 * aMatrix._42;
    resultMatrix._23 = this->_21 * aMatrix._13 + this->_22 * aMatrix._23 + this->_23 * aMatrix._33 + this->_24 * aMatrix._43;
    resultMatrix._24 = this->_21 * aMatrix._14 + this->_22 * aMatrix._24 + this->_23 * aMatrix._34 + this->_24 * aMatrix._44;
    resultMatrix._31 = this->_31 * aMatrix._11 + this->_32 * aMatrix._21 + this->_33 * aMatrix._31 + this->_34 * aMatrix._41;
    resultMatrix._32 = this->_31 * aMatrix._12 + this->_32 * aMatrix._22 + this->_33 * aMatrix._32 + this->_34 * aMatrix._42;
    resultMatrix._33 = this->_31 * aMatrix._13 + this->_32 * aMatrix._23 + this->_33 * aMatrix._33 + this->_34 * aMatrix._43;
    resultMatrix._34 = this->_31 * aMatrix._14 + this->_32 * aMatrix._24 + this->_33 * aMatrix._34 + this->_34 * aMatrix._44;
    resultMatrix._41 = this->_41 * aMatrix._11 + this->_42 * aMatrix._21 + this->_43 * aMatrix._31 + this->_44 * aMatrix._41;
    resultMatrix._42 = this->_41 * aMatrix._12 + this->_42 * aMatrix._22 + this->_43 * aMatrix._32 + this->_44 * aMatrix._42;
    resultMatrix._43 = this->_41 * aMatrix._13 + this->_42 * aMatrix._23 + this->_43 * aMatrix._33 + this->_44 * aMatrix._43;
    resultMatrix._44 = this->_41 * aMatrix._14 + this->_42 * aMatrix._24 + this->_43 * aMatrix._34 + this->_44 * aMatrix._44;
    resultMatrix._51 = this->_51 * aMatrix._11 + this->_52 * aMatrix._21 + this->_53 * aMatrix._31 + this->_54 * aMatrix._41 + aMatrix._51;
    resultMatrix._52 = this->_51 * aMatrix._12 + this->_52 * aMatrix._22 + this->_53 * aMatrix._32 + this->_54 * aMatrix._42 + aMatrix._52;
    resultMatrix._53 = this->_51 * aMatrix._13 + this->_52 * aMatrix._23 + this->_53 * aMatrix._33 + this->_54 * aMatrix._43 + aMatrix._53;
    resultMatrix._54 = this->_51 * aMatrix._14 + this->_52 * aMatrix._24 + this->_53 * aMatrix._34 + this->_54 * aMatrix._44 + aMatrix._54;

    return resultMatrix;
  }

  Matrix5x4& operator*=(const Matrix5x4 &aMatrix)
  {
    *this = *this * aMatrix;
    return *this;
  }

  union {
    struct {
      Float _11, _12, _13, _14;
      Float _21, _22, _23, _24;
      Float _31, _32, _33, _34;
      Float _41, _42, _43, _44;
      Float _51, _52, _53, _54;
    };
    Float components[20];
  };
};

}
}



typedef struct _cairo_surface cairo_surface_t;
typedef struct _cairo_user_data_key cairo_user_data_key_t;

typedef void (*thebes_destroy_func_t) (void *data);





typedef double gfxFloat;
enum class gfxBreakPriority {
  eNoBreak = 0,
  eWordWrapBreak,
  eNormalBreak
};

enum class gfxSurfaceType {
  Image,
  PDF,
  PS,
  Xlib,
  Xcb,
  Glitz,
  Quartz,
  Win32,
  BeOS,
  DirectFB,
  SVG,
  OS2,
  Win32Printing,
  QuartzImage,
  Script,
  QPainter,
  Recording,
  VG,
  GL,
  DRM,
  Tee,
  XML,
  Skia,
  Subsurface,
  Max
};

enum class gfxContentType {
  COLOR = 0x1000,
  ALPHA = 0x2000,
  COLOR_ALPHA = 0x3000,
  SENTINEL = 0xffff
};

struct gfxSize : public mozilla::gfx::BaseSize<gfxFloat, gfxSize> {
    typedef mozilla::gfx::BaseSize<gfxFloat, gfxSize> Super;

    gfxSize() : Super() {}
    gfxSize(gfxFloat aWidth, gfxFloat aHeight) : Super(aWidth, aHeight) {}
                 gfxSize(const mozilla::gfx::IntSize& aSize) : Super(aSize.width, aSize.height) {}
};

struct gfxPoint : public mozilla::gfx::BasePoint<gfxFloat, gfxPoint> {
    typedef mozilla::gfx::BasePoint<gfxFloat, gfxPoint> Super;

    gfxPoint() : Super() {}
    gfxPoint(gfxFloat aX, gfxFloat aY) : Super(aX, aY) {}
                 gfxPoint(const nsIntPoint& aPoint) : Super(aPoint.x, aPoint.y) {}

    bool WithinEpsilonOf(const gfxPoint& aPoint, gfxFloat aEpsilon) {
        return fabs(aPoint.x - x) < aEpsilon && fabs(aPoint.y - y) < aEpsilon;
    }

    void Transform(const mozilla::gfx::Matrix4x4 &aMatrix)
    {

      double px = x;
      double py = y;

      x = px * aMatrix._11 + py * aMatrix._21 + aMatrix._41;
      y = px * aMatrix._12 + py * aMatrix._22 + aMatrix._42;

      double w = px * aMatrix._14 + py * aMatrix._24 + aMatrix._44;
      x /= w;
      y /= w;
    }
};

inline gfxPoint
operator*(const gfxPoint& aPoint, const gfxSize& aSize)
{
  return gfxPoint(aPoint.x * aSize.width, aPoint.y * aSize.height);
}

inline gfxPoint
operator/(const gfxPoint& aPoint, const gfxSize& aSize)
{
  return gfxPoint(aPoint.x / aSize.width, aPoint.y / aSize.height);
}

inline gfxSize
operator/(gfxFloat aValue, const gfxSize& aSize)
{
  return gfxSize(aValue / aSize.width, aValue / aSize.height);
}




class nsISelectionDisplay : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    DISPLAY_TEXT = 1,
    DISPLAY_IMAGES = 2,
    DISPLAY_FRAMES = 4,
    DISPLAY_ALL = 7
  };


  virtual nsresult SetSelectionFlags(int16_t toggle) = 0;


  virtual nsresult GetSelectionFlags(int16_t *_retval) = 0;

};

  template<typename T> struct nsISelectionDisplay::COMTypeInfo<nsISelectionDisplay, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsISelectionDisplay::COMTypeInfo<nsISelectionDisplay, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x0ddf9e1c, 0x1dd2, 0x11b2, { 0xa1, 0x83, 0x90, 0x8a, 0x08, 0xaa, 0x75, 0xae }};






typedef short SelectionRegion;
class nsIContent;

class nsIDOMNode;

class nsISelection;

class nsISelectionDisplay;
class nsISelectionController : public nsISelectionDisplay {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    SELECTION_NONE = 0,
    SELECTION_NORMAL = 1,
    SELECTION_SPELLCHECK = 2,
    SELECTION_IME_RAWINPUT = 4,
    SELECTION_IME_SELECTEDRAWTEXT = 8,
    SELECTION_IME_CONVERTEDTEXT = 16,
    SELECTION_IME_SELECTEDCONVERTEDTEXT = 32,
    SELECTION_ACCESSIBILITY = 64,
    SELECTION_FIND = 128,
    SELECTION_URLSECONDARY = 256,
    SELECTION_URLSTRIKEOUT = 512,
    NUM_SELECTIONTYPES = 11,
    SELECTION_ANCHOR_REGION = 0,
    SELECTION_FOCUS_REGION = 1,
    SELECTION_WHOLE_SELECTION = 2,
    NUM_SELECTION_REGIONS = 3,
    SELECTION_OFF = 0,
    SELECTION_HIDDEN = 1,
    SELECTION_ON = 2,
    SELECTION_DISABLED = 3,
    SELECTION_ATTENTION = 4
  };


  virtual nsresult SetDisplaySelection(int16_t toggle) = 0;


  virtual nsresult GetDisplaySelection(int16_t *_retval) = 0;


  virtual nsresult GetSelection(int16_t type, nsISelection * *_retval) = 0;

  enum {
    SCROLL_SYNCHRONOUS = 2,
    SCROLL_FIRST_ANCESTOR_ONLY = 4,
    SCROLL_CENTER_VERTICALLY = 16,
    SCROLL_OVERFLOW_HIDDEN = 32,
    SCROLL_FOR_CARET_MOVE = 64
  };


  virtual nsresult ScrollSelectionIntoView(int16_t type, int16_t region, int16_t flags) = 0;


  virtual nsresult RepaintSelection(int16_t type) = 0;


  virtual nsresult SetCaretEnabled(bool enabled) = 0;


  virtual nsresult SetCaretReadOnly(bool readOnly) = 0;


  virtual nsresult GetCaretEnabled(bool *_retval) = 0;


  virtual nsresult GetCaretVisible(bool *aCaretVisible) = 0;


  virtual nsresult SetCaretVisibilityDuringSelection(bool visibility) = 0;


  virtual nsresult CharacterMove(bool forward, bool extend) = 0;


  virtual nsresult PhysicalMove(int16_t direction, int16_t amount, bool extend) = 0;

  enum {
    MOVE_LEFT = 0,
    MOVE_RIGHT = 1,
    MOVE_UP = 2,
    MOVE_DOWN = 3
  };


  virtual nsresult CharacterExtendForDelete(void) = 0;


  virtual nsresult CharacterExtendForBackspace(void) = 0;


  virtual nsresult WordMove(bool forward, bool extend) = 0;


  virtual nsresult WordExtendForDelete(bool forward) = 0;


  virtual nsresult LineMove(bool forward, bool extend) = 0;


  virtual nsresult IntraLineMove(bool forward, bool extend) = 0;


  virtual nsresult PageMove(bool forward, bool extend) = 0;


  virtual nsresult CompleteScroll(bool forward) = 0;


  virtual nsresult CompleteMove(bool forward, bool extend) = 0;


  virtual nsresult ScrollPage(bool forward) = 0;


  virtual nsresult ScrollLine(bool forward) = 0;


  virtual nsresult ScrollCharacter(bool right) = 0;


  virtual nsresult SelectAll(void) = 0;


  virtual nsresult CheckVisibility(nsIDOMNode *node, int16_t startOffset, int16_t endOffset, bool *_retval) = 0;


  virtual nsresult CheckVisibilityContent(nsIContent *node, int16_t startOffset, int16_t endOffset, bool *_retval) = 0;

};

  template<typename T> struct nsISelectionController::COMTypeInfo<nsISelectionController, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsISelectionController::COMTypeInfo<nsISelectionController, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x3801c9d4, 0x8e69, 0x4bfc, { 0x9e, 0xdb, 0xb5, 0x82, 0x78, 0x62, 0x1f, 0x8f }};
namespace mozilla {
typedef short RawSelectionType;
enum class SelectionType : RawSelectionType
{
  eInvalid = -1,
  eNone = nsISelectionController::SELECTION_NONE,
  eNormal = nsISelectionController::SELECTION_NORMAL,
  eSpellCheck = nsISelectionController::SELECTION_SPELLCHECK,
  eIMERawClause = nsISelectionController::SELECTION_IME_RAWINPUT,
  eIMESelectedRawClause = nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT,
  eIMEConvertedClause = nsISelectionController::SELECTION_IME_CONVERTEDTEXT,
  eIMESelectedClause =
    nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT,
  eAccessibility = nsISelectionController::SELECTION_ACCESSIBILITY,
  eFind = nsISelectionController::SELECTION_FIND,
  eURLSecondary = nsISelectionController::SELECTION_URLSECONDARY,
  eURLStrikeout = nsISelectionController::SELECTION_URLSTRIKEOUT,
};





enum : size_t
{

  kSelectionTypeCount = nsISelectionController::NUM_SELECTIONTYPES,

  kPresentSelectionTypeCount = kSelectionTypeCount - 1
};
const char* ToChar(SelectionType aSelectionType);
SelectionType ToSelectionType(RawSelectionType aRawSelectionType);
RawSelectionType ToRawSelectionType(SelectionType aSelectionType);
bool operator &(SelectionType aSelectionType,
                RawSelectionType aRawSelectionTypes);
}



class nsIFrame;
class nsIPresShell;

class nsFrameManagerBase
{
public:
  nsFrameManagerBase();

  bool IsDestroyingFrames() { return mIsDestroyingFrames; }






  nsIFrame* GetRootFrame() const { return mRootFrame; }
  void SetRootFrame(nsIFrame* aRootFrame)
  {
    do { } while(0);
    mRootFrame = aRootFrame;
  }

protected:
  class UndisplayedMap;


  nsIPresShell* mPresShell;
  nsIFrame* mRootFrame;
  PLDHashTable mPlaceholderMap;
  UndisplayedMap* mUndisplayedMap;
  UndisplayedMap* mDisplayContentsMap;
  bool mIsDestroyingFrames;
};
typedef mozilla::gfx::IntRect nsIntRect;

struct nsRect :
  public mozilla::gfx::BaseRect<nscoord, nsRect, nsPoint, nsSize, nsMargin> {
  typedef mozilla::gfx::BaseRect<nscoord, nsRect, nsPoint, nsSize, nsMargin> Super;

  static void VERIFY_COORD(nscoord aValue) { ::VERIFY_COORD(aValue); }


  nsRect() : Super()
  {
                          ;
  }
  nsRect(const nsRect& aRect) : Super(aRect)
  {
                          ;
  }
  nsRect(const nsPoint& aOrigin, const nsSize &aSize) : Super(aOrigin, aSize)
  {
                          ;
  }
  nsRect(nscoord aX, nscoord aY, nscoord aWidth, nscoord aHeight) :
      Super(aX, aY, aWidth, aHeight)
  {
                          ;
  }
  __attribute__ ((warn_unused_result)) nsRect SaturatingUnion(const nsRect& aRect) const
  {
    if (IsEmpty()) {
      return aRect;
    } else if (aRect.IsEmpty()) {
      return *static_cast<const nsRect*>(this);
    } else {
      return SaturatingUnionEdges(aRect);
    }
  }

  __attribute__ ((warn_unused_result)) nsRect SaturatingUnionEdges(const nsRect& aRect) const
  {



    nsRect result;
    result.x = std::min(aRect.x, x);
    int64_t w = std::max(int64_t(aRect.x) + aRect.width, int64_t(x) + width) - result.x;
    if ((__builtin_expect(!!(w > nscoord(1 << 30)), 0))) {

      result.x = std::max(result.x, (-nscoord(1 << 30)) / 2);
      w = std::max(int64_t(aRect.x) + aRect.width, int64_t(x) + width) - result.x;
      if ((__builtin_expect(!!(w > nscoord(1 << 30)), 0))) {
        w = nscoord(1 << 30);
      }
    }
    result.width = nscoord(w);

    result.y = std::min(aRect.y, y);
    int64_t h = std::max(int64_t(aRect.y) + aRect.height, int64_t(y) + height) - result.y;
    if ((__builtin_expect(!!(h > nscoord(1 << 30)), 0))) {

      result.y = std::max(result.y, (-nscoord(1 << 30)) / 2);
      h = std::max(int64_t(aRect.y) + aRect.height, int64_t(y) + height) - result.y;
      if ((__builtin_expect(!!(h > nscoord(1 << 30)), 0))) {
        h = nscoord(1 << 30);
      }
    }
    result.height = nscoord(h);
    return result;

  }



  __attribute__ ((warn_unused_result)) nsRect UnionEdges(const nsRect& aRect) const
  {
    return SaturatingUnionEdges(aRect);
  }
  void UnionRectEdges(const nsRect& aRect1, const nsRect& aRect2)
  {
    *this = aRect1.UnionEdges(aRect2);
  }
  __attribute__ ((warn_unused_result)) nsRect Union(const nsRect& aRect) const
  {
    return SaturatingUnion(aRect);
  }
  void UnionRect(const nsRect& aRect1, const nsRect& aRect2)
  {
    *this = aRect1.Union(aRect2);
  }


  void SaturatingUnionRect(const nsRect& aRect1, const nsRect& aRect2)
  {
    *this = aRect1.SaturatingUnion(aRect2);
  }
  void SaturatingUnionRectEdges(const nsRect& aRect1, const nsRect& aRect2)
  {
    *this = aRect1.SaturatingUnionEdges(aRect2);
  }


  bool Overflows() const;
  __attribute__ ((warn_unused_result)) inline nsRect
    ScaleToOtherAppUnitsRoundOut(int32_t aFromAPP, int32_t aToAPP) const;
  __attribute__ ((warn_unused_result)) inline nsRect
    ScaleToOtherAppUnitsRoundIn(int32_t aFromAPP, int32_t aToAPP) const;

  __attribute__ ((warn_unused_result)) inline mozilla::gfx::IntRect
  ScaleToNearestPixels(float aXScale, float aYScale,
                       nscoord aAppUnitsPerPixel) const;

  __attribute__ ((warn_unused_result)) inline mozilla::gfx::IntRect
  ToNearestPixels(nscoord aAppUnitsPerPixel) const;


  __attribute__ ((warn_unused_result)) inline mozilla::gfx::IntRect
  ScaleToOutsidePixels(float aXScale, float aYScale,
                       nscoord aAppUnitsPerPixel) const;


  __attribute__ ((warn_unused_result)) inline mozilla::gfx::IntRect
  ToOutsidePixels(nscoord aAppUnitsPerPixel) const;

  __attribute__ ((warn_unused_result)) inline mozilla::gfx::IntRect
  ScaleToInsidePixels(float aXScale, float aYScale,
                      nscoord aAppUnitsPerPixel) const;

  __attribute__ ((warn_unused_result)) inline mozilla::gfx::IntRect
  ToInsidePixels(nscoord aAppUnitsPerPixel) const;


  bool operator==(const nsRect& aRect) const
  {
    return IsEqualEdges(aRect);
  }

  __attribute__ ((warn_unused_result)) inline nsRect RemoveResolution(const float aResolution) const;
};





inline nsRect
nsRect::ScaleToOtherAppUnitsRoundOut(int32_t aFromAPP, int32_t aToAPP) const
{
  if (aFromAPP == aToAPP) {
    return *this;
  }

  nsRect rect;
  nscoord right = NSToCoordCeil(NSCoordScale(XMost(), aFromAPP, aToAPP));
  nscoord bottom = NSToCoordCeil(NSCoordScale(YMost(), aFromAPP, aToAPP));
  rect.x = NSToCoordFloor(NSCoordScale(x, aFromAPP, aToAPP));
  rect.y = NSToCoordFloor(NSCoordScale(y, aFromAPP, aToAPP));
  rect.width = (right - rect.x);
  rect.height = (bottom - rect.y);

  return rect;
}

inline nsRect
nsRect::ScaleToOtherAppUnitsRoundIn(int32_t aFromAPP, int32_t aToAPP) const
{
  if (aFromAPP == aToAPP) {
    return *this;
  }

  nsRect rect;
  nscoord right = NSToCoordFloor(NSCoordScale(XMost(), aFromAPP, aToAPP));
  nscoord bottom = NSToCoordFloor(NSCoordScale(YMost(), aFromAPP, aToAPP));
  rect.x = NSToCoordCeil(NSCoordScale(x, aFromAPP, aToAPP));
  rect.y = NSToCoordCeil(NSCoordScale(y, aFromAPP, aToAPP));
  rect.width = (right - rect.x);
  rect.height = (bottom - rect.y);

  return rect;
}


inline mozilla::gfx::IntRect
nsRect::ScaleToNearestPixels(float aXScale, float aYScale,
                             nscoord aAppUnitsPerPixel) const
{
  mozilla::gfx::IntRect rect;
  rect.x = NSToIntRoundUp(NSAppUnitsToDoublePixels(x, aAppUnitsPerPixel) * aXScale);
  rect.y = NSToIntRoundUp(NSAppUnitsToDoublePixels(y, aAppUnitsPerPixel) * aYScale);

  rect.width = std::max(0, NSToIntRoundUp(NSAppUnitsToDoublePixels(XMost(),
                               aAppUnitsPerPixel) * aXScale) - rect.x);
  rect.height = std::max(0, NSToIntRoundUp(NSAppUnitsToDoublePixels(YMost(),
                               aAppUnitsPerPixel) * aYScale) - rect.y);
  return rect;
}


inline mozilla::gfx::IntRect
nsRect::ScaleToOutsidePixels(float aXScale, float aYScale,
                             nscoord aAppUnitsPerPixel) const
{
  mozilla::gfx::IntRect rect;
  rect.x = NSToIntFloor(NSAppUnitsToFloatPixels(x, float(aAppUnitsPerPixel)) * aXScale);
  rect.y = NSToIntFloor(NSAppUnitsToFloatPixels(y, float(aAppUnitsPerPixel)) * aYScale);

  rect.width = std::max(0, NSToIntCeil(NSAppUnitsToFloatPixels(XMost(),
                            float(aAppUnitsPerPixel)) * aXScale) - rect.x);
  rect.height = std::max(0, NSToIntCeil(NSAppUnitsToFloatPixels(YMost(),
                            float(aAppUnitsPerPixel)) * aYScale) - rect.y);
  return rect;
}


inline mozilla::gfx::IntRect
nsRect::ScaleToInsidePixels(float aXScale, float aYScale,
                            nscoord aAppUnitsPerPixel) const
{
  mozilla::gfx::IntRect rect;
  rect.x = NSToIntCeil(NSAppUnitsToFloatPixels(x, float(aAppUnitsPerPixel)) * aXScale);
  rect.y = NSToIntCeil(NSAppUnitsToFloatPixels(y, float(aAppUnitsPerPixel)) * aYScale);

  rect.width = std::max(0, NSToIntFloor(NSAppUnitsToFloatPixels(XMost(),
                             float(aAppUnitsPerPixel)) * aXScale) - rect.x);
  rect.height = std::max(0, NSToIntFloor(NSAppUnitsToFloatPixels(YMost(),
                             float(aAppUnitsPerPixel)) * aYScale) - rect.y);
  return rect;
}

inline mozilla::gfx::IntRect
nsRect::ToNearestPixels(nscoord aAppUnitsPerPixel) const
{
  return ScaleToNearestPixels(1.0f, 1.0f, aAppUnitsPerPixel);
}

inline mozilla::gfx::IntRect
nsRect::ToOutsidePixels(nscoord aAppUnitsPerPixel) const
{
  return ScaleToOutsidePixels(1.0f, 1.0f, aAppUnitsPerPixel);
}

inline mozilla::gfx::IntRect
nsRect::ToInsidePixels(nscoord aAppUnitsPerPixel) const
{
  return ScaleToInsidePixels(1.0f, 1.0f, aAppUnitsPerPixel);
}

inline nsRect
nsRect::RemoveResolution(const float aResolution) const
{
  do { } while (0);
  nsRect rect;
  rect.x = NSToCoordRound(NSCoordToFloat(x) / aResolution);
  rect.y = NSToCoordRound(NSCoordToFloat(y) / aResolution);


  if (width == 1 && height == 1) {
    rect.width = rect.height = 1;
  } else {
    rect.width = NSToCoordCeil(NSCoordToFloat(width) / aResolution);
    rect.height = NSToCoordCeil(NSCoordToFloat(height) / aResolution);
  }

  return rect;
}

const mozilla::gfx::IntRect& GetMaxSizedIntRect();


template<class units>
nsRect
ToAppUnits(const mozilla::gfx::IntRectTyped<units>& aRect, nscoord aAppUnitsPerPixel)
{
  return nsRect(NSIntPixelsToAppUnits(aRect.x, aAppUnitsPerPixel),
                NSIntPixelsToAppUnits(aRect.y, aAppUnitsPerPixel),
                NSIntPixelsToAppUnits(aRect.width, aAppUnitsPerPixel),
                NSIntPixelsToAppUnits(aRect.height, aAppUnitsPerPixel));
}

class nsWeakReference;

class nsSupportsWeakReference : public nsISupportsWeakReference
{
public:
  nsSupportsWeakReference() : mProxy(0) {}

  virtual nsresult GetWeakReference(nsIWeakReference * *_retval) override;

protected:
  inline ~nsSupportsWeakReference();

private:
  friend class nsWeakReference;



  void NoticeProxyDestruction() { mProxy = nullptr; }

  nsWeakReference* mProxy;

protected:

  void ClearWeakReferences();
  bool HasWeakReferences() const { return !!mProxy; }
};

inline
nsSupportsWeakReference::~nsSupportsWeakReference()
{
  ClearWeakReferences();
}



template<class KeyClass, class T>
class nsClassHashtable
  : public nsBaseHashtable<KeyClass, nsAutoPtr<T>, T*>
{
public:
  typedef typename KeyClass::KeyType KeyType;
  typedef T* UserDataType;
  typedef nsBaseHashtable<KeyClass, nsAutoPtr<T>, T*> base_type;

  using base_type::IsEmpty;

  nsClassHashtable() {}
  explicit nsClassHashtable(uint32_t aInitLength)
    : nsBaseHashtable<KeyClass, nsAutoPtr<T>, T*>(aInitLength)
  {
  }





  template<typename... Args>
  UserDataType LookupOrAdd(KeyType aKey, Args&&... aConstructionArgs);





  bool Get(KeyType aKey, UserDataType* aData) const;





  UserDataType Get(KeyType aKey) const;
  void RemoveAndForget(KeyType aKey, nsAutoPtr<T>& aOut);
};





template<class KeyClass, class T>
template<typename... Args>
T*
nsClassHashtable<KeyClass, T>::LookupOrAdd(KeyType aKey,
                                           Args&&... aConstructionArgs)
{
  typename base_type::EntryType* ent = this->PutEntry(aKey);
  if (!ent->mData) {
    ent->mData = new T(mozilla::Forward<Args>(aConstructionArgs)...);
  }
  return ent->mData;
}

template<class KeyClass, class T>
bool
nsClassHashtable<KeyClass, T>::Get(KeyType aKey, T** aRetVal) const
{
  typename base_type::EntryType* ent = this->GetEntry(aKey);

  if (ent) {
    if (aRetVal) {
      *aRetVal = ent->mData;
    }

    return true;
  }

  if (aRetVal) {
    *aRetVal = nullptr;
  }

  return false;
}

template<class KeyClass, class T>
T*
nsClassHashtable<KeyClass, T>::Get(KeyType aKey) const
{
  typename base_type::EntryType* ent = this->GetEntry(aKey);
  if (!ent) {
    return nullptr;
  }

  return ent->mData;
}

template<class KeyClass, class T>
void
nsClassHashtable<KeyClass, T>::RemoveAndForget(KeyType aKey, nsAutoPtr<T>& aOut)
{
  aOut = nullptr;

  typename base_type::EntryType* ent = this->GetEntry(aKey);
  if (!ent) {
    return;
  }


  aOut = mozilla::Move(ent->mData);

  this->Remove(aKey);
}
namespace mozilla {
template<size_t ArenaSize, size_t Alignment=1>
class ArenaAllocator
{
public:
  constexpr ArenaAllocator()
    : mHead()
    , mCurrent(nullptr)
  {
     static_assert(mozilla::tl::FloorLog2<Alignment>::value ==
                   mozilla::tl::CeilingLog2<Alignment>::value,
                  "ArenaAllocator alignment must be a power of two");
  }

  ArenaAllocator(const ArenaAllocator&) = delete;
  ArenaAllocator& operator=(const ArenaAllocator&) = delete;





  ~ArenaAllocator()
  {
    Clear();
  }






  __attribute__((always_inline)) inline void* Allocate(size_t aSize, const fallible_t&)
  {
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(aSize)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(aSize))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "aSize" ") (" "Allocation size must be non-zero" ")"); do { *((volatile int*) __null) = 71; ::abort(); } while (0); } } while (0);
    return InternalAllocate(AlignedSize(aSize));
  }

  void* Allocate(size_t aSize)
  {
    void* p = Allocate(aSize, fallible);
    if ((__builtin_expect(!!(!p), 0))) {
      NS_ABORT_OOM(std::max(aSize, ArenaSize));
    }

    return p;
  }







  void Clear()
  {

    auto a = mHead.next;
    while (a) {
      auto tmp = a;
      a = a->next;
      free(tmp);
    }


    mHead.next = nullptr;
    mCurrent = nullptr;
  }




  static constexpr size_t AlignedSize(size_t aSize)
  {
    return (aSize + (Alignment - 1)) & ~(Alignment - 1);
  }

  size_t SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const
  {
    size_t s = 0;
    for (auto arena = mHead.next; arena; arena = arena->next) {
      s += aMallocSizeOf(arena);
    }

    return s;
  }

private:
  struct ArenaHeader
  {



    uintptr_t offset;



    uintptr_t tail;
  };

  struct ArenaChunk
  {
    constexpr ArenaChunk() : header{0, 0}, next(nullptr) {}

    explicit ArenaChunk(size_t aSize)
      : header{AlignedSize(uintptr_t(this + 1)), uintptr_t(this) + aSize}
      , next(nullptr)
    {
    }

    ArenaHeader header;
    ArenaChunk* next;




    void* Allocate(size_t aSize)
    {
      do { } while (0);
      char* p = reinterpret_cast<char*>(header.offset);
      header.offset += aSize;
      do {} while (0);
      return p;
    }




    size_t Available() const {
      return header.tail - header.offset;
    }
  };




  ArenaChunk* AllocateChunk(size_t aSize)
  {
    static const size_t kOffset = AlignedSize(sizeof(ArenaChunk));
    do { } while (0);

    const size_t chunkSize = aSize + kOffset;
    void* p = malloc(chunkSize);
    if (!p) {
      return nullptr;
    }

    ArenaChunk* arena = new (KnownNotNull, p) ArenaChunk(chunkSize);
    do {} while (0);



    arena->next = mHead.next;
    mHead.next = arena;




    if (aSize == ArenaSize - kOffset) {
      mCurrent = arena;
    }

    return arena;
  }

  __attribute__((always_inline)) inline void* InternalAllocate(size_t aSize)
  {
    static_assert(ArenaSize > AlignedSize(sizeof(ArenaChunk)),
                  "Arena size must be greater than the header size");

    static const size_t kMaxArenaCapacity =
        ArenaSize - AlignedSize(sizeof(ArenaChunk));

    if (mCurrent && aSize <= mCurrent->Available()) {
      return mCurrent->Allocate(aSize);
    }

    ArenaChunk* arena = AllocateChunk(std::max(kMaxArenaCapacity, aSize));
    return arena ? arena->Allocate(aSize) : nullptr;
  }

  ArenaChunk mHead;
  ArenaChunk* mCurrent;
};

}

class nsPresArena;

namespace mozilla {
template<typename T>
class ArenaRefPtr
{
  friend class ::nsPresArena;

public:
  ArenaRefPtr()
  {
    AssertValidType();
  }

  template<typename I>
               ArenaRefPtr(already_AddRefed<I>& aRhs)
  {
    AssertValidType();
    assign(aRhs);
  }

  template<typename I>
               ArenaRefPtr(already_AddRefed<I>&& aRhs)
  {
    AssertValidType();
    assign(aRhs);
  }

               ArenaRefPtr(T* aRhs)
  {
    AssertValidType();
    assign(aRhs);
  }

  template<typename I>
  ArenaRefPtr<T>& operator=(already_AddRefed<I>& aRhs)
  {
    assign(aRhs);
    return *this;
  }

  template<typename I>
  ArenaRefPtr<T>& operator=(already_AddRefed<I>&& aRhs)
  {
    assign(aRhs);
    return *this;
  }

  ArenaRefPtr<T>& operator=(T* aRhs)
  {
    assign(aRhs);
    return *this;
  }

  ~ArenaRefPtr() { assign(nullptr); }

  operator T*() const & { return get(); }
  operator T*() const && = delete;
  explicit operator bool() const { return !!mPtr; }
  bool operator!() const { return !mPtr; }
  T* operator->() const { return mPtr.operator->(); }
  T& operator*() const { return *get(); }

  T* get() const { return mPtr; }

private:
  void AssertValidType();







  void ClearWithoutDeregistering()
  {
    mPtr = nullptr;
  }

  template<typename I>
  void assign(already_AddRefed<I>& aSmartPtr)
  {
    RefPtr<T> newPtr(aSmartPtr);
    assignFrom(newPtr);
  }

  template<typename I>
  void assign(already_AddRefed<I>&& aSmartPtr)
  {
    RefPtr<T> newPtr(aSmartPtr);
    assignFrom(newPtr);
  }

  void assign(T* aPtr) { assignFrom(aPtr); }

  template<typename I>
  void assignFrom(I& aPtr)
  {
    if (aPtr == mPtr) {
      return;
    }
    bool sameArena = mPtr && aPtr && mPtr->Arena() == aPtr->Arena();
    if (mPtr && !sameArena) {
      do { } while (0);
      mPtr->Arena()->DeregisterArenaRefPtr(this);
    }
    mPtr = Move(aPtr);
    if (mPtr && !sameArena) {
      do { } while (0);
      mPtr->Arena()->RegisterArenaRefPtr(this);
    }
  }

  RefPtr<T> mPtr;
};

}
struct nsArenaMemoryStats;

class nsPresArena {
public:
  nsPresArena();
  ~nsPresArena();




  void* AllocateBySize(size_t aSize)
  {
    return Allocate(uint32_t(aSize) |
                    uint32_t(mozilla::eArenaObjectID_NON_OBJECT_MARKER), aSize);
  }
  void FreeBySize(size_t aSize, void* aPtr)
  {
    Free(uint32_t(aSize) |
         uint32_t(mozilla::eArenaObjectID_NON_OBJECT_MARKER), aPtr);
  }





  void* AllocateByFrameID(nsQueryFrame::FrameIID aID, size_t aSize)
  {
    return Allocate(aID, aSize);
  }
  void FreeByFrameID(nsQueryFrame::FrameIID aID, void* aPtr)
  {
    Free(aID, aPtr);
  }





  void* AllocateByObjectID(mozilla::ArenaObjectID aID, size_t aSize)
  {
    return Allocate(aID, aSize);
  }
  void FreeByObjectID(mozilla::ArenaObjectID aID, void* aPtr)
  {
    Free(aID, aPtr);
  }
  template<typename T>
  void RegisterArenaRefPtr(mozilla::ArenaRefPtr<T>* aPtr);





  template<typename T>
  void DeregisterArenaRefPtr(mozilla::ArenaRefPtr<T>* aPtr)
  {
    do { } while (0);
    mArenaRefPtrs.Remove(aPtr);
  }






  void ClearArenaRefPtrs();







  void ClearArenaRefPtrs(mozilla::ArenaObjectID aObjectID);





  void AddSizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf,
                              nsArenaMemoryStats* aArenaStats);

private:
  void* Allocate(uint32_t aCode, size_t aSize);
  void Free(uint32_t aCode, void* aPtr);

  inline void ClearArenaRefPtrWithoutDeregistering(
      void* aPtr,
      mozilla::ArenaObjectID aObjectID);



  class FreeList : public PLDHashEntryHdr
  {
  public:
    typedef uint32_t KeyType;
    nsTArray<void *> mEntries;
    size_t mEntrySize;
    size_t mEntriesEverAllocated;

    typedef const void* KeyTypePointer;
    KeyTypePointer mKey;

    explicit FreeList(KeyTypePointer aKey)
    : mEntrySize(0), mEntriesEverAllocated(0), mKey(aKey) {}


    bool KeyEquals(KeyTypePointer const aKey) const
    { return mKey == aKey; }

    static KeyTypePointer KeyToPointer(KeyType aKey)
    { return ((void*)(intptr_t)(aKey)); }

    static PLDHashNumber HashKey(KeyTypePointer aKey)
    { return ((int32_t)(intptr_t)(aKey)); }

    size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
    { return mEntries.ShallowSizeOfExcludingThis(aMallocSizeOf); }

    enum { ALLOW_MEMMOVE = false };
  };

  nsTHashtable<FreeList> mFreeLists;
  mozilla::ArenaAllocator<8192, 8> mPool;
  nsDataHashtable<nsPtrHashKey<void>, mozilla::ArenaObjectID> mArenaRefPtrs;
};
class imgIRequest;
class imgINotificationObserver : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    SIZE_AVAILABLE = 1,
    FRAME_UPDATE = 2,
    FRAME_COMPLETE = 3,
    LOAD_COMPLETE = 4,
    DECODE_COMPLETE = 5,
    DISCARD = 6,
    UNLOCKED_DRAW = 7,
    IS_ANIMATED = 8,
    HAS_TRANSPARENCY = 9
  };


  virtual nsresult Notify(imgIRequest *aProxy, int32_t aType, const nsIntRect *aRect) = 0;

};

  template<typename T> struct imgINotificationObserver::COMTypeInfo<imgINotificationObserver, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID imgINotificationObserver::COMTypeInfo<imgINotificationObserver, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x03da5641, 0xa333, 0x454a, { 0xa8, 0x59, 0x03, 0x6d, 0x0b, 0xb6, 0x83, 0xb7 }};







namespace mozilla {


enum class Visibility : uint8_t
{

  UNTRACKED,






  APPROXIMATELY_NONVISIBLE,





  APPROXIMATELY_VISIBLE
};


enum class OnNonvisible : uint8_t
{
  DISCARD_IMAGES
};

}
class imgIRequest;

class nsIChannel;

class nsIStreamListener;

class nsIURI;

class nsIDocument;

class nsIFrame;
class nsIImageLoadingContent : public imgINotificationObserver {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    UNKNOWN_REQUEST = -1,
    CURRENT_REQUEST = 0,
    PENDING_REQUEST = 1
  };


  virtual nsresult GetLoadingEnabled(bool *aLoadingEnabled) = 0;
  virtual nsresult SetLoadingEnabled(bool aLoadingEnabled) = 0;


  virtual nsresult GetImageBlockingStatus(int16_t *aImageBlockingStatus) = 0;


  virtual nsresult AddObserver(imgINotificationObserver *aObserver) = 0;


  virtual nsresult RemoveObserver(imgINotificationObserver *aObserver) = 0;


  virtual nsresult GetRequest(int32_t aRequestType, imgIRequest * *_retval) = 0;


  virtual bool CurrentRequestHasSize(void) = 0;


  virtual void FrameCreated(nsIFrame *aFrame) = 0;


  virtual void FrameDestroyed(nsIFrame *aFrame) = 0;


  virtual nsresult GetRequestType(imgIRequest *aRequest, int32_t *_retval) = 0;


  virtual nsresult GetCurrentURI(nsIURI * *aCurrentURI) = 0;


  virtual nsresult LoadImageWithChannel(nsIChannel *aChannel, nsIStreamListener * *_retval) = 0;


  virtual nsresult ForceReload(bool aNotify, uint8_t _argc) = 0;


  virtual nsresult ForceImageState(bool aForce, uint64_t aState) = 0;


  virtual nsresult GetNaturalWidth(uint32_t *aNaturalWidth) = 0;


  virtual nsresult GetNaturalHeight(uint32_t *aNaturalHeight) = 0;


  virtual void OnVisibilityChange(mozilla::Visibility aNewVisibility, const mozilla::Maybe<mozilla::OnNonvisible> & aNonvisibleAction) = 0;

};

  template<typename T> struct nsIImageLoadingContent::COMTypeInfo<nsIImageLoadingContent, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIImageLoadingContent::COMTypeInfo<nsIImageLoadingContent, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x0357123d, 0x9224, 0x4d12, { 0xa4, 0x7e, 0x86, 0x8c, 0x32, 0x68, 0x97, 0x77 }};

typedef uint64_t nsFrameState_size_t;



enum nsFrameState : nsFrameState_size_t {



NS_FRAME_IN_REFLOW = (nsFrameState(nsFrameState_size_t(1) << (0))),




NS_FRAME_FIRST_REFLOW = (nsFrameState(nsFrameState_size_t(1) << (1))),




NS_FRAME_IS_FLUID_CONTINUATION = (nsFrameState(nsFrameState_size_t(1) << (2))),


NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT = (nsFrameState(nsFrameState_size_t(1) << (3))),




NS_FRAME_EXTERNAL_REFERENCE = (nsFrameState(nsFrameState_size_t(1) << (4))),





NS_FRAME_CONTAINS_RELATIVE_BSIZE = (nsFrameState(nsFrameState_size_t(1) << (5))),


NS_FRAME_GENERATED_CONTENT = (nsFrameState(nsFrameState_size_t(1) << (6))),






NS_FRAME_IS_OVERFLOW_CONTAINER = (nsFrameState(nsFrameState_size_t(1) << (7))),



NS_FRAME_OUT_OF_FLOW = (nsFrameState(nsFrameState_size_t(1) << (8))),




NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN = (nsFrameState(nsFrameState_size_t(1) << (9))),
NS_FRAME_IS_DIRTY = (nsFrameState(nsFrameState_size_t(1) << (10))),




NS_FRAME_TOO_DEEP_IN_FRAME_TREE = (nsFrameState(nsFrameState_size_t(1) << (11))),
NS_FRAME_HAS_DIRTY_CHILDREN = (nsFrameState(nsFrameState_size_t(1) << (12))),


NS_FRAME_HAS_VIEW = (nsFrameState(nsFrameState_size_t(1) << (13))),


NS_FRAME_INDEPENDENT_SELECTION = (nsFrameState(nsFrameState_size_t(1) << (14))),





NS_FRAME_PART_OF_IBSPLIT = (nsFrameState(nsFrameState_size_t(1) << (15))),






NS_FRAME_MAY_BE_TRANSFORMED = (nsFrameState(nsFrameState_size_t(1) << (16))),



NS_FRAME_IS_BIDI = (nsFrameState(nsFrameState_size_t(1) << (17))),


NS_FRAME_HAS_CHILD_WITH_VIEW = (nsFrameState(nsFrameState_size_t(1) << (18))),



NS_FRAME_REFLOW_ROOT = (nsFrameState(nsFrameState_size_t(1) << (19))),
NS_FRAME_IS_PUSHED_FLOAT = (nsFrameState(nsFrameState_size_t(1) << (32))),


NS_FRAME_DRAWING_AS_PAINTSERVER = (nsFrameState(nsFrameState_size_t(1) << (33))),




NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE = (nsFrameState(nsFrameState_size_t(1) << (34))),





NS_FRAME_SIMPLE_EVENT_REGIONS = (nsFrameState(nsFrameState_size_t(1) << (35))),





NS_FRAME_UPDATE_LAYER_TREE = (nsFrameState(nsFrameState_size_t(1) << (36))),


NS_FRAME_HAS_ABSPOS_CHILDREN = (nsFrameState(nsFrameState_size_t(1) << (37))),


NS_FRAME_PAINTED_THEBES = (nsFrameState(nsFrameState_size_t(1) << (38))),




NS_FRAME_IN_CONSTRAINED_BSIZE = (nsFrameState(nsFrameState_size_t(1) << (39))),


NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO = (nsFrameState(nsFrameState_size_t(1) << (40))),




NS_FRAME_FONT_INFLATION_CONTAINER = (nsFrameState(nsFrameState_size_t(1) << (41))),




NS_FRAME_FONT_INFLATION_FLOW_ROOT = (nsFrameState(nsFrameState_size_t(1) << (42))),




NS_FRAME_SVG_LAYOUT = (nsFrameState(nsFrameState_size_t(1) << (43))),


NS_FRAME_MAY_HAVE_GENERATED_CONTENT = (nsFrameState(nsFrameState_size_t(1) << (44))),




NS_FRAME_NO_COMPONENT_ALPHA = (nsFrameState(nsFrameState_size_t(1) << (45))),



NS_FRAME_VISIBILITY_IS_TRACKED = (nsFrameState(nsFrameState_size_t(1) << (46))),



NS_FRAME_IS_SVG_TEXT = (nsFrameState(nsFrameState_size_t(1) << (47))),


NS_FRAME_NEEDS_PAINT = (nsFrameState(nsFrameState_size_t(1) << (48))),



NS_FRAME_DESCENDANT_NEEDS_PAINT = (nsFrameState(nsFrameState_size_t(1) << (49))),


NS_FRAME_IN_POPUP = (nsFrameState(nsFrameState_size_t(1) << (50))),





NS_FRAME_ALL_DESCENDANTS_NEED_PAINT = (nsFrameState(nsFrameState_size_t(1) << (51))),



NS_FRAME_HAS_INVALID_RECT = (nsFrameState(nsFrameState_size_t(1) << (52))),



NS_FRAME_IS_NONDISPLAY = (nsFrameState(nsFrameState_size_t(1) << (53))),


NS_FRAME_HAS_LAYER_ACTIVITY_PROPERTY = (nsFrameState(nsFrameState_size_t(1) << (54))),



NS_FRAME_OWNS_ANON_BOXES = (nsFrameState(nsFrameState_size_t(1) << (55))),


NS_FRAME_HAS_PROPERTIES = (nsFrameState(nsFrameState_size_t(1) << (56))),



NS_FRAME_MATHML_SCRIPT_DESCENDANT = (nsFrameState(nsFrameState_size_t(1) << (58))),




NS_FRAME_IS_IN_SINGLE_CHAR_MI = (nsFrameState(nsFrameState_size_t(1) << (59))),
NS_STATE_BOX_CHILD_RESERVED = (nsFrameState(nsFrameState_size_t(1) << (20))),
NS_STATE_STACK_NOT_POSITIONED = (nsFrameState(nsFrameState_size_t(1) << (21))),
NS_STATE_IS_HORIZONTAL = (nsFrameState(nsFrameState_size_t(1) << (22))),
NS_STATE_AUTO_STRETCH = (nsFrameState(nsFrameState_size_t(1) << (23))),
NS_STATE_IS_ROOT = (nsFrameState(nsFrameState_size_t(1) << (24))),
NS_STATE_CURRENTLY_IN_DEBUG = (nsFrameState(nsFrameState_size_t(1) << (25))),
NS_STATE_SET_TO_DEBUG = (nsFrameState(nsFrameState_size_t(1) << (26))),
NS_STATE_DEBUG_WAS_SET = (nsFrameState(nsFrameState_size_t(1) << (27))),
NS_STATE_MENU_HAS_POPUP_LIST = (nsFrameState(nsFrameState_size_t(1) << (28))),
NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK = (nsFrameState(nsFrameState_size_t(1) << (29))),
NS_STATE_EQUAL_SIZE = (nsFrameState(nsFrameState_size_t(1) << (30))),
NS_STATE_IS_DIRECTION_NORMAL = (nsFrameState(nsFrameState_size_t(1) << (31))),
NS_FRAME_MOUSE_THROUGH_ALWAYS = (nsFrameState(nsFrameState_size_t(1) << (60))),
NS_FRAME_MOUSE_THROUGH_NEVER = (nsFrameState(nsFrameState_size_t(1) << (61))),
NS_STATE_FLEX_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER = (nsFrameState(nsFrameState_size_t(1) << (20))),



NS_STATE_FLEX_IS_LEGACY_WEBKIT_BOX = (nsFrameState(nsFrameState_size_t(1) << (21))),


NS_STATE_FLEX_SYNTHESIZE_BASELINE = (nsFrameState(nsFrameState_size_t(1) << (22))),







NS_STATE_GRID_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER = (nsFrameState(nsFrameState_size_t(1) << (20))),





NS_STATE_GRID_DID_PUSH_ITEMS = (nsFrameState(nsFrameState_size_t(1) << (21))),


NS_STATE_GRID_GENERATE_COMPUTED_VALUES = (nsFrameState(nsFrameState_size_t(1) << (22))),


NS_STATE_GRID_SYNTHESIZE_BASELINE = (nsFrameState(nsFrameState_size_t(1) << (23))),






NS_STATE_IS_OUTER_SVG = (nsFrameState(nsFrameState_size_t(1) << (20))),


NS_STATE_SVG_CLIPPATH_CHILD = (nsFrameState(nsFrameState_size_t(1) << (21))),
NS_STATE_SVG_POSITIONING_DIRTY = (nsFrameState(nsFrameState_size_t(1) << (22))),
NS_STATE_SVG_POSITIONING_MAY_USE_PERCENTAGES = (nsFrameState(nsFrameState_size_t(1) << (23))),

NS_STATE_SVG_TEXT_IN_REFLOW = (nsFrameState(nsFrameState_size_t(1) << (24))),
TEXT_FIRST_LETTER = (nsFrameState(nsFrameState_size_t(1) << (20))),



TEXT_START_OF_LINE = (nsFrameState(nsFrameState_size_t(1) << (21))),



TEXT_END_OF_LINE = (nsFrameState(nsFrameState_size_t(1) << (22))),


TEXT_HYPHEN_BREAK = (nsFrameState(nsFrameState_size_t(1) << (23))),



TEXT_TRIMMED_TRAILING_WHITESPACE = (nsFrameState(nsFrameState_size_t(1) << (24))),




TEXT_JUSTIFICATION_ENABLED = (nsFrameState(nsFrameState_size_t(1) << (25))),


TEXT_SELECTION_UNDERLINE_OVERFLOWED = (nsFrameState(nsFrameState_size_t(1) << (26))),






TEXT_IS_ONLY_WHITESPACE = (nsFrameState(nsFrameState_size_t(1) << (27))),


TEXT_ISNOT_ONLY_WHITESPACE = (nsFrameState(nsFrameState_size_t(1) << (28))),




TEXT_IN_TEXTRUN_USER_DATA = (nsFrameState(nsFrameState_size_t(1) << (29))),



TEXT_OFFSETS_NEED_FIXING = (nsFrameState(nsFrameState_size_t(1) << (30))),



TEXT_HAS_NONCOLLAPSED_CHARACTERS = (nsFrameState(nsFrameState_size_t(1) << (31))),




TEXT_IS_IN_TOKEN_MATHML = (nsFrameState(nsFrameState_size_t(1) << (32))),



TEXT_IN_UNINFLATED_TEXTRUN_USER_DATA = (nsFrameState(nsFrameState_size_t(1) << (60))),

TEXT_HAS_FONT_INFLATION = (nsFrameState(nsFrameState_size_t(1) << (61))),


TEXT_NO_RENDERED_GLYPHS = (nsFrameState(nsFrameState_size_t(1) << (62))),



TEXT_IN_OFFSET_CACHE = (nsFrameState(nsFrameState_size_t(1) << (63))),
NS_BLOCK_NEEDS_BIDI_RESOLUTION = (nsFrameState(nsFrameState_size_t(1) << (20))),

NS_BLOCK_HAS_PUSHED_FLOATS = (nsFrameState(nsFrameState_size_t(1) << (21))),
NS_BLOCK_MARGIN_ROOT = (nsFrameState(nsFrameState_size_t(1) << (22))),




NS_BLOCK_FLOAT_MGR = (nsFrameState(nsFrameState_size_t(1) << (23))),




NS_BLOCK_HAS_LINE_CURSOR = (nsFrameState(nsFrameState_size_t(1) << (24))),

NS_BLOCK_HAS_OVERFLOW_LINES = (nsFrameState(nsFrameState_size_t(1) << (25))),

NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS = (nsFrameState(nsFrameState_size_t(1) << (26))),




NS_BLOCK_HAS_CLEAR_CHILDREN = (nsFrameState(nsFrameState_size_t(1) << (27))),




NS_BLOCK_CLIP_PAGINATED_OVERFLOW = (nsFrameState(nsFrameState_size_t(1) << (28))),



NS_BLOCK_HAS_FIRST_LETTER_STYLE = (nsFrameState(nsFrameState_size_t(1) << (29))),



NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET = (nsFrameState(nsFrameState_size_t(1) << (30))),
NS_BLOCK_FRAME_HAS_INSIDE_BULLET = (nsFrameState(nsFrameState_size_t(1) << (31))),




NS_BLOCK_LOOK_FOR_DIRTY_FRAMES = (nsFrameState(nsFrameState_size_t(1) << (61))),
NS_BLOCK_FRAME_INTRINSICS_INFLATED = (nsFrameState(nsFrameState_size_t(1) << (62))),





NS_BLOCK_HAS_FIRST_LETTER_CHILD = (nsFrameState(nsFrameState_size_t(1) << (63))),






BULLET_FRAME_HAS_FONT_INFLATION = (nsFrameState(nsFrameState_size_t(1) << (62))),
BULLET_FRAME_IMAGE_LOADING = (nsFrameState(nsFrameState_size_t(1) << (63))),
NS_SCROLLFRAME_INVALIDATE_CONTENTS_ON_SCROLL = (nsFrameState(nsFrameState_size_t(1) << (20))),






IMAGE_SIZECONSTRAINED = (nsFrameState(nsFrameState_size_t(1) << (20))),
IMAGE_GOTINITIALREFLOW = (nsFrameState(nsFrameState_size_t(1) << (21))),
NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET = (nsFrameState(nsFrameState_size_t(1) << (21))),
NS_INLINE_FRAME_BIDI_VISUAL_IS_FIRST = (nsFrameState(nsFrameState_size_t(1) << (22))),
NS_INLINE_FRAME_BIDI_VISUAL_IS_LAST = (nsFrameState(nsFrameState_size_t(1) << (23))),
NS_RUBY_TEXT_FRAME_AUTOHIDE = (nsFrameState(nsFrameState_size_t(1) << (24))),






NS_RUBY_TEXT_CONTAINER_IS_SPAN = (nsFrameState(nsFrameState_size_t(1) << (20))),
PLACEHOLDER_FOR_FLOAT = (nsFrameState(nsFrameState_size_t(1) << (20))),
PLACEHOLDER_FOR_ABSPOS = (nsFrameState(nsFrameState_size_t(1) << (21))),
PLACEHOLDER_FOR_FIXEDPOS = (nsFrameState(nsFrameState_size_t(1) << (22))),
PLACEHOLDER_FOR_POPUP = (nsFrameState(nsFrameState_size_t(1) << (23))),
PLACEHOLDER_FOR_TOPLAYER = (nsFrameState(nsFrameState_size_t(1) << (24))),
PLACEHOLDER_STATICPOS_NEEDS_CSSALIGN = (nsFrameState(nsFrameState_size_t(1) << (25))),






NS_TABLE_CELL_HAS_PCT_OVER_BSIZE = (nsFrameState(nsFrameState_size_t(1) << (28))),
NS_TABLE_CELL_HAD_SPECIAL_REFLOW = (nsFrameState(nsFrameState_size_t(1) << (29))),
NS_TABLE_CELL_CONTENT_EMPTY = (nsFrameState(nsFrameState_size_t(1) << (31))),
NS_REPEATED_ROW_OR_ROWGROUP = (nsFrameState(nsFrameState_size_t(1) << (28))),
NS_ROW_HAS_CELL_WITH_STYLE_BSIZE = (nsFrameState(nsFrameState_size_t(1) << (29))),

NS_TABLE_ROW_HAS_UNPAGINATED_BSIZE = (nsFrameState(nsFrameState_size_t(1) << (30))),






NS_ROWGROUP_HAS_ROW_CURSOR = (nsFrameState(nsFrameState_size_t(1) << (27))),
NS_ROWGROUP_HAS_STYLE_BSIZE = (nsFrameState(nsFrameState_size_t(1) << (30))),


NS_ROWGROUP_REPEATABLE = (nsFrameState(nsFrameState_size_t(1) << (31))),



NS_TABLE_PART_HAS_FIXED_BACKGROUND = (nsFrameState(nsFrameState_size_t(1) << (28))),

};

inline nsFrameState operator|(nsFrameState aLeft, nsFrameState aRight)
{
  return nsFrameState(nsFrameState_size_t(aLeft) | nsFrameState_size_t(aRight));
}

inline nsFrameState operator&(nsFrameState aLeft, nsFrameState aRight)
{
  return nsFrameState(nsFrameState_size_t(aLeft) & nsFrameState_size_t(aRight));
}

inline nsFrameState& operator|=(nsFrameState& aLeft, nsFrameState aRight)
{
  aLeft = aLeft | aRight;
  return aLeft;
}

inline nsFrameState& operator&=(nsFrameState& aLeft, nsFrameState aRight)
{
  aLeft = aLeft & aRight;
  return aLeft;
}

inline nsFrameState operator~(nsFrameState aRight)
{
  return nsFrameState(~nsFrameState_size_t(aRight));
}

inline nsFrameState operator^(nsFrameState aLeft, nsFrameState aRight)
{
  return nsFrameState(nsFrameState_size_t(aLeft) ^ nsFrameState_size_t(aRight));
}

inline nsFrameState& operator^=(nsFrameState& aLeft, nsFrameState aRight)
{
  aLeft = aLeft ^ aRight;
  return aLeft;
}





namespace mozilla {




}
namespace mozilla {
namespace gfx {
template<class src, class dst>
struct ScaleFactor {
  float scale;

  constexpr ScaleFactor() : scale(1.0) {}
  constexpr ScaleFactor(const ScaleFactor<src, dst>& aCopy) : scale(aCopy.scale) {}
  explicit constexpr ScaleFactor(float aScale) : scale(aScale) {}

  ScaleFactor<dst, src> Inverse() {
    return ScaleFactor<dst, src>(1 / scale);
  }

  bool operator==(const ScaleFactor<src, dst>& aOther) const {
    return scale == aOther.scale;
  }

  bool operator!=(const ScaleFactor<src, dst>& aOther) const {
    return !(*this == aOther);
  }

  bool operator<(const ScaleFactor<src, dst>& aOther) const {
    return scale < aOther.scale;
  }

  bool operator<=(const ScaleFactor<src, dst>& aOther) const {
    return scale <= aOther.scale;
  }

  bool operator>(const ScaleFactor<src, dst>& aOther) const {
    return scale > aOther.scale;
  }

  bool operator>=(const ScaleFactor<src, dst>& aOther) const {
    return scale >= aOther.scale;
  }

  template<class other>
  ScaleFactor<other, dst> operator/(const ScaleFactor<src, other>& aOther) const {
    return ScaleFactor<other, dst>(scale / aOther.scale);
  }

  template<class other>
  ScaleFactor<src, other> operator/(const ScaleFactor<other, dst>& aOther) const {
    return ScaleFactor<src, other>(scale / aOther.scale);
  }

  template<class other>
  ScaleFactor<src, other> operator*(const ScaleFactor<dst, other>& aOther) const {
    return ScaleFactor<src, other>(scale * aOther.scale);
  }

  template<class other>
  ScaleFactor<other, dst> operator*(const ScaleFactor<other, src>& aOther) const {
    return ScaleFactor<other, dst>(scale * aOther.scale);
  }
};

}
}
namespace mozilla {
namespace gfx {





template<class src, class dst>
struct ScaleFactors2D {
  float xScale;
  float yScale;

  constexpr ScaleFactors2D() : xScale(1.0), yScale(1.0) {}
  constexpr ScaleFactors2D(const ScaleFactors2D<src, dst>& aCopy)
    : xScale(aCopy.xScale), yScale(aCopy.yScale) {}
  constexpr ScaleFactors2D(float aXScale, float aYScale)
    : xScale(aXScale), yScale(aYScale) {}

  explicit constexpr ScaleFactors2D(const gfxSize& aSize)
    : xScale(aSize.width), yScale(aSize.height) {}





  explicit constexpr ScaleFactors2D(const ScaleFactor<src, dst>& aScale)
    : xScale(aScale.scale), yScale(aScale.scale) {}

  bool AreScalesSame() const {
    return FuzzyEqualsMultiplicative(xScale, yScale);
  }


  ScaleFactor<src, dst> ToScaleFactor() const {
    do { } while (0);
    return ScaleFactor<src, dst>(xScale);
  }

  bool operator==(const ScaleFactors2D<src, dst>& aOther) const {
    return xScale == aOther.xScale && yScale == aOther.yScale;
  }

  bool operator!=(const ScaleFactors2D<src, dst>& aOther) const {
    return !(*this == aOther);
  }

  friend std::ostream& operator<<(std::ostream& aStream,
                                  const ScaleFactors2D<src, dst>& aScale) {
    if (aScale.AreScalesSame()) {
      return aStream << aScale.xScale;
    } else {
      return aStream << '(' << aScale.xScale << ',' << aScale.yScale << ')';
    }
  }

  template<class other>
  ScaleFactors2D<other, dst> operator/(const ScaleFactors2D<src, other>& aOther) const {
    return ScaleFactors2D<other, dst>(xScale / aOther.xScale, yScale / aOther.yScale);
  }

  template<class other>
  ScaleFactors2D<src, other> operator/(const ScaleFactors2D<other, dst>& aOther) const {
    return ScaleFactors2D<src, other>(xScale / aOther.xScale, yScale / aOther.yScale);
  }

  template<class other>
  ScaleFactors2D<src, other> operator*(const ScaleFactors2D<dst, other>& aOther) const {
    return ScaleFactors2D<src, other>(xScale * aOther.xScale, yScale * aOther.yScale);
  }

  template<class other>
  ScaleFactors2D<other, dst> operator*(const ScaleFactors2D<other, src>& aOther) const {
    return ScaleFactors2D<other, dst>(xScale * aOther.xScale, yScale * aOther.yScale);
  }

  template<class other>
  ScaleFactors2D<src, other> operator*(const ScaleFactor<dst, other>& aOther) const {
    return *this * ScaleFactors2D<dst, other>(aOther);
  }

  template<class other>
  ScaleFactors2D<other, dst> operator*(const ScaleFactor<other, src>& aOther) const {
    return *this * ScaleFactors2D<other, src>(aOther);
  }

  template<class other>
  ScaleFactors2D<src, other> operator/(const ScaleFactor<other, dst>& aOther) const {
    return *this / ScaleFactors2D<other, dst>(aOther);
  }

  template<class other>
  ScaleFactors2D<other, dst> operator/(const ScaleFactor<src, other>& aOther) const {
    return *this / ScaleFactors2D<src, other>(aOther);
  }

  template<class other>
  friend ScaleFactors2D<other, dst> operator*(const ScaleFactor<other, src>& aA,
                                              const ScaleFactors2D<src, dst>& aB) {
    return ScaleFactors2D<other, src>(aA) * aB;
  }

  template<class other>
  friend ScaleFactors2D<other, src> operator/(const ScaleFactor<other, dst>& aA,
                                              const ScaleFactors2D<src, dst>& aB) {
    return ScaleFactors2D<other, src>(aA) / aB;
  }




  gfxSize operator/(const ScaleFactors2D& aOther) const {
    return gfxSize(xScale / aOther.xScale, yScale / aOther.yScale);
  }
};

}
}


namespace mozilla {
namespace gfx {

template<typename T>
class ArrayView
{
    public:
                     ArrayView(const nsTArray<T>& aData) :
            mData(aData.Elements()), mLength(aData.Length())
        {
        }
        ArrayView(const T* aData, const size_t aLength) :
            mData(aData), mLength(aLength)
        {
        }
        const T& operator[](const size_t aIdx) const
        {
            return mData[aIdx];
        }
        size_t Length() const
        {
            return mLength;
        }
        const T* Data() const
        {
            return mData;
        }
    private:
        const T* mData;
        const size_t mLength;
};

}
}






extern "C" {
typedef int pixman_bool_t;




typedef int64_t pixman_fixed_32_32_t;
typedef pixman_fixed_32_32_t pixman_fixed_48_16_t;
typedef uint32_t pixman_fixed_1_31_t;
typedef uint32_t pixman_fixed_1_16_t;
typedef int32_t pixman_fixed_16_16_t;
typedef pixman_fixed_16_16_t pixman_fixed_t;
typedef struct pixman_color pixman_color_t;
typedef struct pixman_point_fixed pixman_point_fixed_t;
typedef struct pixman_line_fixed pixman_line_fixed_t;
typedef struct pixman_vector pixman_vector_t;
typedef struct pixman_transform pixman_transform_t;

struct pixman_color
{
    uint16_t red;
    uint16_t green;
    uint16_t blue;
    uint16_t alpha;
};

struct pixman_point_fixed
{
    pixman_fixed_t x;
    pixman_fixed_t y;
};

struct pixman_line_fixed
{
    pixman_point_fixed_t p1, p2;
};





struct pixman_vector
{
    pixman_fixed_t vector[3];
};

struct pixman_transform
{
    pixman_fixed_t matrix[3][3];
};


struct pixman_box16;
typedef union pixman_image pixman_image_t;

void _moz_pixman_transform_init_identity (struct pixman_transform *matrix);
pixman_bool_t _moz_pixman_transform_point_3d (const struct pixman_transform *transform,
       struct pixman_vector *vector);
pixman_bool_t _moz_pixman_transform_point (const struct pixman_transform *transform,
       struct pixman_vector *vector);
pixman_bool_t _moz_pixman_transform_multiply (struct pixman_transform *dst,
       const struct pixman_transform *l,
       const struct pixman_transform *r);
void _moz_pixman_transform_init_scale (struct pixman_transform *t,
       pixman_fixed_t sx,
       pixman_fixed_t sy);
pixman_bool_t _moz_pixman_transform_scale (struct pixman_transform *forward,
       struct pixman_transform *reverse,
       pixman_fixed_t sx,
       pixman_fixed_t sy);
void _moz_pixman_transform_init_rotate (struct pixman_transform *t,
       pixman_fixed_t cos,
       pixman_fixed_t sin);
pixman_bool_t _moz_pixman_transform_rotate (struct pixman_transform *forward,
       struct pixman_transform *reverse,
       pixman_fixed_t c,
       pixman_fixed_t s);
void _moz_pixman_transform_init_translate (struct pixman_transform *t,
       pixman_fixed_t tx,
       pixman_fixed_t ty);
pixman_bool_t _moz_pixman_transform_translate (struct pixman_transform *forward,
       struct pixman_transform *reverse,
       pixman_fixed_t tx,
       pixman_fixed_t ty);
pixman_bool_t _moz_pixman_transform_bounds (const struct pixman_transform *matrix,
       struct pixman_box16 *b);
pixman_bool_t _moz_pixman_transform_invert (struct pixman_transform *dst,
       const struct pixman_transform *src);
pixman_bool_t _moz_pixman_transform_is_identity (const struct pixman_transform *t);
pixman_bool_t _moz_pixman_transform_is_scale (const struct pixman_transform *t);
pixman_bool_t _moz_pixman_transform_is_int_translate (const struct pixman_transform *t);
pixman_bool_t _moz_pixman_transform_is_inverse (const struct pixman_transform *a,
       const struct pixman_transform *b);




typedef struct pixman_f_transform pixman_f_transform_t;
typedef struct pixman_f_vector pixman_f_vector_t;

struct pixman_f_vector
{
    double v[3];
};

struct pixman_f_transform
{
    double m[3][3];
};

pixman_bool_t _moz_pixman_transform_from_pixman_f_transform (struct pixman_transform *t,
       const struct pixman_f_transform *ft);
void _moz_pixman_f_transform_from_pixman_transform (struct pixman_f_transform *ft,
       const struct pixman_transform *t);
pixman_bool_t _moz_pixman_f_transform_invert (struct pixman_f_transform *dst,
       const struct pixman_f_transform *src);
pixman_bool_t _moz_pixman_f_transform_point (const struct pixman_f_transform *t,
       struct pixman_f_vector *v);
void _moz_pixman_f_transform_point_3d (const struct pixman_f_transform *t,
       struct pixman_f_vector *v);
void _moz_pixman_f_transform_multiply (struct pixman_f_transform *dst,
       const struct pixman_f_transform *l,
       const struct pixman_f_transform *r);
void _moz_pixman_f_transform_init_scale (struct pixman_f_transform *t,
       double sx,
       double sy);
pixman_bool_t _moz_pixman_f_transform_scale (struct pixman_f_transform *forward,
       struct pixman_f_transform *reverse,
       double sx,
       double sy);
void _moz_pixman_f_transform_init_rotate (struct pixman_f_transform *t,
       double cos,
       double sin);
pixman_bool_t _moz_pixman_f_transform_rotate (struct pixman_f_transform *forward,
       struct pixman_f_transform *reverse,
       double c,
       double s);
void _moz_pixman_f_transform_init_translate (struct pixman_f_transform *t,
       double tx,
       double ty);
pixman_bool_t _moz_pixman_f_transform_translate (struct pixman_f_transform *forward,
       struct pixman_f_transform *reverse,
       double tx,
       double ty);
pixman_bool_t _moz_pixman_f_transform_bounds (const struct pixman_f_transform *t,
       struct pixman_box16 *b);
void _moz_pixman_f_transform_init_identity (struct pixman_f_transform *t);

typedef enum
{
    PIXMAN_REPEAT_NONE,
    PIXMAN_REPEAT_NORMAL,
    PIXMAN_REPEAT_PAD,
    PIXMAN_REPEAT_REFLECT
} pixman_repeat_t;

typedef enum
{
    PIXMAN_FILTER_FAST,
    PIXMAN_FILTER_GOOD,
    PIXMAN_FILTER_BEST,
    PIXMAN_FILTER_NEAREST,
    PIXMAN_FILTER_BILINEAR,
    PIXMAN_FILTER_CONVOLUTION,
    PIXMAN_FILTER_SEPARABLE_CONVOLUTION
} pixman_filter_t;

typedef enum
{
    PIXMAN_OP_CLEAR = 0x00,
    PIXMAN_OP_SRC = 0x01,
    PIXMAN_OP_DST = 0x02,
    PIXMAN_OP_OVER = 0x03,
    PIXMAN_OP_OVER_REVERSE = 0x04,
    PIXMAN_OP_IN = 0x05,
    PIXMAN_OP_IN_REVERSE = 0x06,
    PIXMAN_OP_OUT = 0x07,
    PIXMAN_OP_OUT_REVERSE = 0x08,
    PIXMAN_OP_ATOP = 0x09,
    PIXMAN_OP_ATOP_REVERSE = 0x0a,
    PIXMAN_OP_XOR = 0x0b,
    PIXMAN_OP_ADD = 0x0c,
    PIXMAN_OP_SATURATE = 0x0d,

    PIXMAN_OP_DISJOINT_CLEAR = 0x10,
    PIXMAN_OP_DISJOINT_SRC = 0x11,
    PIXMAN_OP_DISJOINT_DST = 0x12,
    PIXMAN_OP_DISJOINT_OVER = 0x13,
    PIXMAN_OP_DISJOINT_OVER_REVERSE = 0x14,
    PIXMAN_OP_DISJOINT_IN = 0x15,
    PIXMAN_OP_DISJOINT_IN_REVERSE = 0x16,
    PIXMAN_OP_DISJOINT_OUT = 0x17,
    PIXMAN_OP_DISJOINT_OUT_REVERSE = 0x18,
    PIXMAN_OP_DISJOINT_ATOP = 0x19,
    PIXMAN_OP_DISJOINT_ATOP_REVERSE = 0x1a,
    PIXMAN_OP_DISJOINT_XOR = 0x1b,

    PIXMAN_OP_CONJOINT_CLEAR = 0x20,
    PIXMAN_OP_CONJOINT_SRC = 0x21,
    PIXMAN_OP_CONJOINT_DST = 0x22,
    PIXMAN_OP_CONJOINT_OVER = 0x23,
    PIXMAN_OP_CONJOINT_OVER_REVERSE = 0x24,
    PIXMAN_OP_CONJOINT_IN = 0x25,
    PIXMAN_OP_CONJOINT_IN_REVERSE = 0x26,
    PIXMAN_OP_CONJOINT_OUT = 0x27,
    PIXMAN_OP_CONJOINT_OUT_REVERSE = 0x28,
    PIXMAN_OP_CONJOINT_ATOP = 0x29,
    PIXMAN_OP_CONJOINT_ATOP_REVERSE = 0x2a,
    PIXMAN_OP_CONJOINT_XOR = 0x2b,

    PIXMAN_OP_MULTIPLY = 0x30,
    PIXMAN_OP_SCREEN = 0x31,
    PIXMAN_OP_OVERLAY = 0x32,
    PIXMAN_OP_DARKEN = 0x33,
    PIXMAN_OP_LIGHTEN = 0x34,
    PIXMAN_OP_COLOR_DODGE = 0x35,
    PIXMAN_OP_COLOR_BURN = 0x36,
    PIXMAN_OP_HARD_LIGHT = 0x37,
    PIXMAN_OP_SOFT_LIGHT = 0x38,
    PIXMAN_OP_DIFFERENCE = 0x39,
    PIXMAN_OP_EXCLUSION = 0x3a,
    PIXMAN_OP_HSL_HUE = 0x3b,
    PIXMAN_OP_HSL_SATURATION = 0x3c,
    PIXMAN_OP_HSL_COLOR = 0x3d,
    PIXMAN_OP_HSL_LUMINOSITY = 0x3e






} pixman_op_t;




typedef struct pixman_region16_data pixman_region16_data_t;
typedef struct pixman_box16 pixman_box16_t;
typedef struct pixman_rectangle16 pixman_rectangle16_t;
typedef struct pixman_region16 pixman_region16_t;

struct pixman_region16_data {
    long size;
    long numRects;

};

struct pixman_rectangle16
{
    int16_t x, y;
    uint16_t width, height;
};

struct pixman_box16
{
    int16_t x1, y1, x2, y2;
};

struct pixman_region16
{
    pixman_box16_t extents;
    pixman_region16_data_t *data;
};

typedef enum
{
    PIXMAN_REGION_OUT,
    PIXMAN_REGION_IN,
    PIXMAN_REGION_PART
} pixman_region_overlap_t;




void _moz_pixman_region_set_static_pointers (pixman_box16_t *empty_box,
     pixman_region16_data_t *empty_data,
     pixman_region16_data_t *broken_data);


void _moz_pixman_region_init (pixman_region16_t *region);
void _moz_pixman_region_init_rect (pixman_region16_t *region,
         int x,
         int y,
         unsigned int width,
         unsigned int height);
pixman_bool_t _moz_pixman_region_init_rects (pixman_region16_t *region,
         const pixman_box16_t *boxes,
         int count);
void _moz_pixman_region_init_with_extents (pixman_region16_t *region,
         pixman_box16_t *extents);
void _moz_pixman_region_init_from_image (pixman_region16_t *region,
         pixman_image_t *image);
void _moz_pixman_region_fini (pixman_region16_t *region);



void _moz_pixman_region_translate (pixman_region16_t *region,
         int x,
         int y);
pixman_bool_t _moz_pixman_region_copy (pixman_region16_t *dest,
         pixman_region16_t *source);
pixman_bool_t _moz_pixman_region_intersect (pixman_region16_t *new_reg,
         pixman_region16_t *reg1,
         pixman_region16_t *reg2);
pixman_bool_t _moz_pixman_region_union (pixman_region16_t *new_reg,
         pixman_region16_t *reg1,
         pixman_region16_t *reg2);
pixman_bool_t _moz_pixman_region_union_rect (pixman_region16_t *dest,
         pixman_region16_t *source,
         int x,
         int y,
         unsigned int width,
         unsigned int height);
pixman_bool_t _moz_pixman_region_intersect_rect (pixman_region16_t *dest,
         pixman_region16_t *source,
         int x,
         int y,
         unsigned int width,
         unsigned int height);
pixman_bool_t _moz_pixman_region_subtract (pixman_region16_t *reg_d,
         pixman_region16_t *reg_m,
         pixman_region16_t *reg_s);
pixman_bool_t _moz_pixman_region_inverse (pixman_region16_t *new_reg,
         pixman_region16_t *reg1,
         pixman_box16_t *inv_rect);
pixman_bool_t _moz_pixman_region_contains_point (pixman_region16_t *region,
         int x,
         int y,
         pixman_box16_t *box);
pixman_region_overlap_t _moz_pixman_region_contains_rectangle (pixman_region16_t *region,
         pixman_box16_t *prect);
pixman_bool_t _moz_pixman_region_not_empty (pixman_region16_t *region);
pixman_box16_t * _moz_pixman_region_extents (pixman_region16_t *region);
int _moz_pixman_region_n_rects (pixman_region16_t *region);
pixman_box16_t * _moz_pixman_region_rectangles (pixman_region16_t *region,
         int *n_rects);
pixman_bool_t _moz_pixman_region_equal (pixman_region16_t *region1,
         pixman_region16_t *region2);
pixman_bool_t _moz_pixman_region_selfcheck (pixman_region16_t *region);
void _moz_pixman_region_reset (pixman_region16_t *region,
         pixman_box16_t *box);
void _moz_pixman_region_clear (pixman_region16_t *region);



typedef struct pixman_region32_data pixman_region32_data_t;
typedef struct pixman_box32 pixman_box32_t;
typedef struct pixman_rectangle32 pixman_rectangle32_t;
typedef struct pixman_region32 pixman_region32_t;

struct pixman_region32_data {
    long size;
    long numRects;

};

struct pixman_rectangle32
{
    int32_t x, y;
    uint32_t width, height;
};

struct pixman_box32
{
    int32_t x1, y1, x2, y2;
};

struct pixman_region32
{
    pixman_box32_t extents;
    pixman_region32_data_t *data;
};


void _moz_pixman_region32_init (pixman_region32_t *region);
void _moz_pixman_region32_init_rect (pixman_region32_t *region,
           int x,
           int y,
           unsigned int width,
           unsigned int height);
pixman_bool_t _moz_pixman_region32_init_rects (pixman_region32_t *region,
           const pixman_box32_t *boxes,
           int count);
void _moz_pixman_region32_init_with_extents (pixman_region32_t *region,
           pixman_box32_t *extents);
void _moz_pixman_region32_init_from_image (pixman_region32_t *region,
           pixman_image_t *image);
void _moz_pixman_region32_fini (pixman_region32_t *region);



void _moz_pixman_region32_translate (pixman_region32_t *region,
           int x,
           int y);
pixman_bool_t _moz_pixman_region32_copy (pixman_region32_t *dest,
           pixman_region32_t *source);
pixman_bool_t _moz_pixman_region32_intersect (pixman_region32_t *new_reg,
           pixman_region32_t *reg1,
           pixman_region32_t *reg2);
pixman_bool_t _moz_pixman_region32_union (pixman_region32_t *new_reg,
           pixman_region32_t *reg1,
           pixman_region32_t *reg2);
pixman_bool_t _moz_pixman_region32_intersect_rect (pixman_region32_t *dest,
           pixman_region32_t *source,
           int x,
           int y,
           unsigned int width,
           unsigned int height);
pixman_bool_t _moz_pixman_region32_union_rect (pixman_region32_t *dest,
           pixman_region32_t *source,
           int x,
           int y,
           unsigned int width,
           unsigned int height);
pixman_bool_t _moz_pixman_region32_subtract (pixman_region32_t *reg_d,
           pixman_region32_t *reg_m,
           pixman_region32_t *reg_s);
pixman_bool_t _moz_pixman_region32_inverse (pixman_region32_t *new_reg,
           pixman_region32_t *reg1,
           pixman_box32_t *inv_rect);
pixman_bool_t _moz_pixman_region32_contains_point (pixman_region32_t *region,
           int x,
           int y,
           pixman_box32_t *box);
pixman_region_overlap_t _moz_pixman_region32_contains_rectangle (pixman_region32_t *region,
           pixman_box32_t *prect);
pixman_bool_t _moz_pixman_region32_not_empty (pixman_region32_t *region);
pixman_box32_t * _moz_pixman_region32_extents (pixman_region32_t *region);
int _moz_pixman_region32_n_rects (pixman_region32_t *region);
pixman_box32_t * _moz_pixman_region32_rectangles (pixman_region32_t *region,
           int *n_rects);
pixman_bool_t _moz_pixman_region32_equal (pixman_region32_t *region1,
           pixman_region32_t *region2);
pixman_bool_t _moz_pixman_region32_selfcheck (pixman_region32_t *region);
void _moz_pixman_region32_reset (pixman_region32_t *region,
           pixman_box32_t *box);
void _moz_pixman_region32_clear (pixman_region32_t *region);



pixman_bool_t _moz_pixman_blt (uint32_t *src_bits,
      uint32_t *dst_bits,
      int src_stride,
      int dst_stride,
      int src_bpp,
      int dst_bpp,
      int src_x,
      int src_y,
      int dest_x,
      int dest_y,
      int width,
      int height);
pixman_bool_t _moz_pixman_fill (uint32_t *bits,
      int stride,
      int bpp,
      int x,
      int y,
      int width,
      int height,
      uint32_t _xor);

int _moz_pixman_version (void);
const char* _moz_pixman_version_string (void);




typedef struct pixman_indexed pixman_indexed_t;
typedef struct pixman_gradient_stop pixman_gradient_stop_t;

typedef uint32_t (* pixman_read_memory_func_t) (const void *src, int size);
typedef void (* pixman_write_memory_func_t) (void *dst, uint32_t value, int size);

typedef void (* pixman_image_destroy_func_t) (pixman_image_t *image, void *data);

struct pixman_gradient_stop {
    pixman_fixed_t x;
    pixman_color_t color;
};




typedef uint8_t pixman_index_type;


struct pixman_indexed
{
    pixman_bool_t color;
    uint32_t rgba[256];
    pixman_index_type ent[32768];
};
typedef enum {
    PIXMAN_a8r8g8b8 = (((32) << 24) | ((2) << 16) | ((8) << 12) | ((8) << 8) | ((8) << 4) | ((8))),
    PIXMAN_x8r8g8b8 = (((32) << 24) | ((2) << 16) | ((0) << 12) | ((8) << 8) | ((8) << 4) | ((8))),
    PIXMAN_a8b8g8r8 = (((32) << 24) | ((3) << 16) | ((8) << 12) | ((8) << 8) | ((8) << 4) | ((8))),
    PIXMAN_x8b8g8r8 = (((32) << 24) | ((3) << 16) | ((0) << 12) | ((8) << 8) | ((8) << 4) | ((8))),
    PIXMAN_b8g8r8a8 = (((32) << 24) | ((8) << 16) | ((8) << 12) | ((8) << 8) | ((8) << 4) | ((8))),
    PIXMAN_b8g8r8x8 = (((32) << 24) | ((8) << 16) | ((0) << 12) | ((8) << 8) | ((8) << 4) | ((8))),
    PIXMAN_r8g8b8a8 = (((32) << 24) | ((9) << 16) | ((8) << 12) | ((8) << 8) | ((8) << 4) | ((8))),
    PIXMAN_r8g8b8x8 = (((32) << 24) | ((9) << 16) | ((0) << 12) | ((8) << 8) | ((8) << 4) | ((8))),
    PIXMAN_x14r6g6b6 = (((32) << 24) | ((2) << 16) | ((0) << 12) | ((6) << 8) | ((6) << 4) | ((6))),
    PIXMAN_x2r10g10b10 = (((32) << 24) | ((2) << 16) | ((0) << 12) | ((10) << 8) | ((10) << 4) | ((10))),
    PIXMAN_a2r10g10b10 = (((32) << 24) | ((2) << 16) | ((2) << 12) | ((10) << 8) | ((10) << 4) | ((10))),
    PIXMAN_x2b10g10r10 = (((32) << 24) | ((3) << 16) | ((0) << 12) | ((10) << 8) | ((10) << 4) | ((10))),
    PIXMAN_a2b10g10r10 = (((32) << 24) | ((3) << 16) | ((2) << 12) | ((10) << 8) | ((10) << 4) | ((10))),


    PIXMAN_a8r8g8b8_sRGB = (((32) << 24) | ((10) << 16) | ((8) << 12) | ((8) << 8) | ((8) << 4) | ((8))),


    PIXMAN_r8g8b8 = (((24) << 24) | ((2) << 16) | ((0) << 12) | ((8) << 8) | ((8) << 4) | ((8))),
    PIXMAN_b8g8r8 = (((24) << 24) | ((3) << 16) | ((0) << 12) | ((8) << 8) | ((8) << 4) | ((8))),


    PIXMAN_r5g6b5 = (((16) << 24) | ((2) << 16) | ((0) << 12) | ((5) << 8) | ((6) << 4) | ((5))),
    PIXMAN_b5g6r5 = (((16) << 24) | ((3) << 16) | ((0) << 12) | ((5) << 8) | ((6) << 4) | ((5))),

    PIXMAN_a1r5g5b5 = (((16) << 24) | ((2) << 16) | ((1) << 12) | ((5) << 8) | ((5) << 4) | ((5))),
    PIXMAN_x1r5g5b5 = (((16) << 24) | ((2) << 16) | ((0) << 12) | ((5) << 8) | ((5) << 4) | ((5))),
    PIXMAN_a1b5g5r5 = (((16) << 24) | ((3) << 16) | ((1) << 12) | ((5) << 8) | ((5) << 4) | ((5))),
    PIXMAN_x1b5g5r5 = (((16) << 24) | ((3) << 16) | ((0) << 12) | ((5) << 8) | ((5) << 4) | ((5))),
    PIXMAN_a4r4g4b4 = (((16) << 24) | ((2) << 16) | ((4) << 12) | ((4) << 8) | ((4) << 4) | ((4))),
    PIXMAN_x4r4g4b4 = (((16) << 24) | ((2) << 16) | ((0) << 12) | ((4) << 8) | ((4) << 4) | ((4))),
    PIXMAN_a4b4g4r4 = (((16) << 24) | ((3) << 16) | ((4) << 12) | ((4) << 8) | ((4) << 4) | ((4))),
    PIXMAN_x4b4g4r4 = (((16) << 24) | ((3) << 16) | ((0) << 12) | ((4) << 8) | ((4) << 4) | ((4))),


    PIXMAN_a8 = (((8) << 24) | ((1) << 16) | ((8) << 12) | ((0) << 8) | ((0) << 4) | ((0))),
    PIXMAN_r3g3b2 = (((8) << 24) | ((2) << 16) | ((0) << 12) | ((3) << 8) | ((3) << 4) | ((2))),
    PIXMAN_b2g3r3 = (((8) << 24) | ((3) << 16) | ((0) << 12) | ((3) << 8) | ((3) << 4) | ((2))),
    PIXMAN_a2r2g2b2 = (((8) << 24) | ((2) << 16) | ((2) << 12) | ((2) << 8) | ((2) << 4) | ((2))),
    PIXMAN_a2b2g2r2 = (((8) << 24) | ((3) << 16) | ((2) << 12) | ((2) << 8) | ((2) << 4) | ((2))),

    PIXMAN_c8 = (((8) << 24) | ((4) << 16) | ((0) << 12) | ((0) << 8) | ((0) << 4) | ((0))),
    PIXMAN_g8 = (((8) << 24) | ((5) << 16) | ((0) << 12) | ((0) << 8) | ((0) << 4) | ((0))),

    PIXMAN_x4a4 = (((8) << 24) | ((1) << 16) | ((4) << 12) | ((0) << 8) | ((0) << 4) | ((0))),

    PIXMAN_x4c4 = (((8) << 24) | ((4) << 16) | ((0) << 12) | ((0) << 8) | ((0) << 4) | ((0))),
    PIXMAN_x4g4 = (((8) << 24) | ((5) << 16) | ((0) << 12) | ((0) << 8) | ((0) << 4) | ((0))),


    PIXMAN_a4 = (((4) << 24) | ((1) << 16) | ((4) << 12) | ((0) << 8) | ((0) << 4) | ((0))),
    PIXMAN_r1g2b1 = (((4) << 24) | ((2) << 16) | ((0) << 12) | ((1) << 8) | ((2) << 4) | ((1))),
    PIXMAN_b1g2r1 = (((4) << 24) | ((3) << 16) | ((0) << 12) | ((1) << 8) | ((2) << 4) | ((1))),
    PIXMAN_a1r1g1b1 = (((4) << 24) | ((2) << 16) | ((1) << 12) | ((1) << 8) | ((1) << 4) | ((1))),
    PIXMAN_a1b1g1r1 = (((4) << 24) | ((3) << 16) | ((1) << 12) | ((1) << 8) | ((1) << 4) | ((1))),

    PIXMAN_c4 = (((4) << 24) | ((4) << 16) | ((0) << 12) | ((0) << 8) | ((0) << 4) | ((0))),
    PIXMAN_g4 = (((4) << 24) | ((5) << 16) | ((0) << 12) | ((0) << 8) | ((0) << 4) | ((0))),


    PIXMAN_a1 = (((1) << 24) | ((1) << 16) | ((1) << 12) | ((0) << 8) | ((0) << 4) | ((0))),

    PIXMAN_g1 = (((1) << 24) | ((5) << 16) | ((0) << 12) | ((0) << 8) | ((0) << 4) | ((0))),


    PIXMAN_yuy2 = (((16) << 24) | ((6) << 16) | ((0) << 12) | ((0) << 8) | ((0) << 4) | ((0))),
    PIXMAN_yv12 = (((12) << 24) | ((7) << 16) | ((0) << 12) | ((0) << 8) | ((0) << 4) | ((0)))
} pixman_format_code_t;


pixman_bool_t _moz_pixman_format_supported_destination (pixman_format_code_t format);
pixman_bool_t _moz_pixman_format_supported_source (pixman_format_code_t format);


pixman_image_t *_moz_pixman_image_create_solid_fill (const pixman_color_t *color);
pixman_image_t *_moz_pixman_image_create_linear_gradient (const pixman_point_fixed_t *p1,
            const pixman_point_fixed_t *p2,
            const pixman_gradient_stop_t *stops,
            int n_stops);
pixman_image_t *_moz_pixman_image_create_radial_gradient (const pixman_point_fixed_t *inner,
            const pixman_point_fixed_t *outer,
            pixman_fixed_t inner_radius,
            pixman_fixed_t outer_radius,
            const pixman_gradient_stop_t *stops,
            int n_stops);
pixman_image_t *_moz_pixman_image_create_conical_gradient (const pixman_point_fixed_t *center,
            pixman_fixed_t angle,
            const pixman_gradient_stop_t *stops,
            int n_stops);
pixman_image_t *_moz_pixman_image_create_bits (pixman_format_code_t format,
            int width,
            int height,
            uint32_t *bits,
            int rowstride_bytes);
pixman_image_t *pixman_image_create_bits_no_clear (pixman_format_code_t format,
            int width,
            int height,
            uint32_t * bits,
            int rowstride_bytes);


pixman_image_t *_moz_pixman_image_ref (pixman_image_t *image);
pixman_bool_t _moz_pixman_image_unref (pixman_image_t *image);

void _moz_pixman_image_set_destroy_function (pixman_image_t *image,
            pixman_image_destroy_func_t function,
            void *data);
void * _moz_pixman_image_get_destroy_data (pixman_image_t *image);


pixman_bool_t _moz_pixman_image_set_clip_region (pixman_image_t *image,
            pixman_region16_t *region);
pixman_bool_t _moz_pixman_image_set_clip_region32 (pixman_image_t *image,
            pixman_region32_t *region);
void _moz_pixman_image_set_has_client_clip (pixman_image_t *image,
            pixman_bool_t clien_clip);
pixman_bool_t _moz_pixman_image_set_transform (pixman_image_t *image,
            const pixman_transform_t *transform);
void _moz_pixman_image_set_repeat (pixman_image_t *image,
            pixman_repeat_t repeat);
pixman_bool_t _moz_pixman_image_set_filter (pixman_image_t *image,
            pixman_filter_t filter,
            const pixman_fixed_t *filter_params,
            int n_filter_params);
void _moz_pixman_image_set_source_clipping (pixman_image_t *image,
            pixman_bool_t source_clipping);
void _moz_pixman_image_set_alpha_map (pixman_image_t *image,
            pixman_image_t *alpha_map,
            int16_t x,
            int16_t y);
void _moz_pixman_image_set_component_alpha (pixman_image_t *image,
            pixman_bool_t component_alpha);
pixman_bool_t _moz_pixman_image_get_component_alpha (pixman_image_t *image);
void _moz_pixman_image_set_accessors (pixman_image_t *image,
            pixman_read_memory_func_t read_func,
            pixman_write_memory_func_t write_func);
void _moz_pixman_image_set_indexed (pixman_image_t *image,
            const pixman_indexed_t *indexed);
uint32_t *_moz_pixman_image_get_data (pixman_image_t *image);
int _moz_pixman_image_get_width (pixman_image_t *image);
int _moz_pixman_image_get_height (pixman_image_t *image);
int _moz_pixman_image_get_stride (pixman_image_t *image);
int _moz_pixman_image_get_depth (pixman_image_t *image);
pixman_format_code_t _moz_pixman_image_get_format (pixman_image_t *image);

typedef enum
{
    PIXMAN_KERNEL_IMPULSE,
    PIXMAN_KERNEL_BOX,
    PIXMAN_KERNEL_LINEAR,
    PIXMAN_KERNEL_CUBIC,
    PIXMAN_KERNEL_GAUSSIAN,
    PIXMAN_KERNEL_LANCZOS2,
    PIXMAN_KERNEL_LANCZOS3,
    PIXMAN_KERNEL_LANCZOS3_STRETCHED
} pixman_kernel_t;




pixman_fixed_t *
pixman_filter_create_separable_convolution (int *n_values,
         pixman_fixed_t scale_x,
         pixman_fixed_t scale_y,
         pixman_kernel_t reconstruct_x,
         pixman_kernel_t reconstruct_y,
         pixman_kernel_t sample_x,
         pixman_kernel_t sample_y,
         int subsample_bits_x,
         int subsample_bits_y);

pixman_bool_t _moz_pixman_image_fill_rectangles (pixman_op_t op,
            pixman_image_t *image,
            const pixman_color_t *color,
            int n_rects,
            const pixman_rectangle16_t *rects);
pixman_bool_t _moz_pixman_image_fill_boxes (pixman_op_t op,
                                                      pixman_image_t *dest,
                                                      const pixman_color_t *color,
                                                      int n_boxes,
                                                      const pixman_box32_t *boxes);


pixman_bool_t _moz_pixman_compute_composite_region (pixman_region16_t *region,
            pixman_image_t *src_image,
            pixman_image_t *mask_image,
            pixman_image_t *dest_image,
            int16_t src_x,
            int16_t src_y,
            int16_t mask_x,
            int16_t mask_y,
            int16_t dest_x,
            int16_t dest_y,
            uint16_t width,
            uint16_t height);
void _moz_pixman_image_composite (pixman_op_t op,
            pixman_image_t *src,
            pixman_image_t *mask,
            pixman_image_t *dest,
            int16_t src_x,
            int16_t src_y,
            int16_t mask_x,
            int16_t mask_y,
            int16_t dest_x,
            int16_t dest_y,
            uint16_t width,
            uint16_t height);
void _moz_pixman_image_composite32 (pixman_op_t op,
            pixman_image_t *src,
            pixman_image_t *mask,
            pixman_image_t *dest,
            int32_t src_x,
            int32_t src_y,
            int32_t mask_x,
            int32_t mask_y,
            int32_t dest_x,
            int32_t dest_y,
            int32_t width,
            int32_t height);
void _moz_pixman_disable_out_of_bounds_workaround (void);




typedef struct pixman_glyph_cache_t pixman_glyph_cache_t;
typedef struct
{
    int x, y;
    const void *glyph;
} pixman_glyph_t;

pixman_glyph_cache_t *_moz_pixman_glyph_cache_create (void);
void _moz_pixman_glyph_cache_destroy (pixman_glyph_cache_t *cache);
void _moz_pixman_glyph_cache_freeze (pixman_glyph_cache_t *cache);
void _moz_pixman_glyph_cache_thaw (pixman_glyph_cache_t *cache);
const void * _moz_pixman_glyph_cache_lookup (pixman_glyph_cache_t *cache,
             void *font_key,
             void *glyph_key);
const void * _moz_pixman_glyph_cache_insert (pixman_glyph_cache_t *cache,
             void *font_key,
             void *glyph_key,
             int origin_x,
             int origin_y,
             pixman_image_t *glyph_image);
void _moz_pixman_glyph_cache_remove (pixman_glyph_cache_t *cache,
             void *font_key,
             void *glyph_key);
void _moz_pixman_glyph_get_extents (pixman_glyph_cache_t *cache,
             int n_glyphs,
             pixman_glyph_t *glyphs,
             pixman_box32_t *extents);
pixman_format_code_t _moz_pixman_glyph_get_mask_format (pixman_glyph_cache_t *cache,
             int n_glyphs,
             const pixman_glyph_t *glyphs);
void _moz_pixman_composite_glyphs (pixman_op_t op,
             pixman_image_t *src,
             pixman_image_t *dest,
             pixman_format_code_t mask_format,
             int32_t src_x,
             int32_t src_y,
             int32_t mask_x,
             int32_t mask_y,
             int32_t dest_x,
             int32_t dest_y,
             int32_t width,
             int32_t height,
             pixman_glyph_cache_t *cache,
             int n_glyphs,
             const pixman_glyph_t *glyphs);
void _moz_pixman_composite_glyphs_no_mask (pixman_op_t op,
             pixman_image_t *src,
             pixman_image_t *dest,
             int32_t src_x,
             int32_t src_y,
             int32_t dest_x,
             int32_t dest_y,
             pixman_glyph_cache_t *cache,
             int n_glyphs,
             const pixman_glyph_t *glyphs);




typedef struct pixman_edge pixman_edge_t;
typedef struct pixman_trapezoid pixman_trapezoid_t;
typedef struct pixman_trap pixman_trap_t;
typedef struct pixman_span_fix pixman_span_fix_t;
typedef struct pixman_triangle pixman_triangle_t;






struct pixman_edge
{
    pixman_fixed_t x;
    pixman_fixed_t e;
    pixman_fixed_t stepx;
    pixman_fixed_t signdx;
    pixman_fixed_t dy;
    pixman_fixed_t dx;

    pixman_fixed_t stepx_small;
    pixman_fixed_t stepx_big;
    pixman_fixed_t dx_small;
    pixman_fixed_t dx_big;
};

struct pixman_trapezoid
{
    pixman_fixed_t top, bottom;
    pixman_line_fixed_t left, right;
};

struct pixman_triangle
{
    pixman_point_fixed_t p1, p2, p3;
};







struct pixman_span_fix
{
    pixman_fixed_t l, r, y;
};

struct pixman_trap
{
    pixman_span_fix_t top, bot;
};

pixman_fixed_t _moz_pixman_sample_ceil_y (pixman_fixed_t y,
         int bpp);
pixman_fixed_t _moz_pixman_sample_floor_y (pixman_fixed_t y,
         int bpp);
void _moz_pixman_edge_step (pixman_edge_t *e,
         int n);
void _moz_pixman_edge_init (pixman_edge_t *e,
         int bpp,
         pixman_fixed_t y_start,
         pixman_fixed_t x_top,
         pixman_fixed_t y_top,
         pixman_fixed_t x_bot,
         pixman_fixed_t y_bot);
void _moz_pixman_line_fixed_edge_init (pixman_edge_t *e,
         int bpp,
         pixman_fixed_t y,
         const pixman_line_fixed_t *line,
         int x_off,
         int y_off);
void _moz_pixman_rasterize_edges (pixman_image_t *image,
         pixman_edge_t *l,
         pixman_edge_t *r,
         pixman_fixed_t t,
         pixman_fixed_t b);
void _moz_pixman_add_traps (pixman_image_t *image,
         int16_t x_off,
         int16_t y_off,
         int ntrap,
         const pixman_trap_t *traps);
void _moz_pixman_add_trapezoids (pixman_image_t *image,
         int16_t x_off,
         int y_off,
         int ntraps,
         const pixman_trapezoid_t *traps);
void _moz_pixman_rasterize_trapezoid (pixman_image_t *image,
         const pixman_trapezoid_t *trap,
         int x_off,
         int y_off);
void _moz_pixman_composite_trapezoids (pixman_op_t op,
        pixman_image_t * src,
        pixman_image_t * dst,
        pixman_format_code_t mask_format,
        int x_src,
        int y_src,
        int x_dst,
        int y_dst,
        int n_traps,
        const pixman_trapezoid_t * traps);
void _moz_pixman_composite_triangles (pixman_op_t op,
       pixman_image_t * src,
       pixman_image_t * dst,
       pixman_format_code_t mask_format,
       int x_src,
       int y_src,
       int x_dst,
       int y_dst,
       int n_tris,
       const pixman_triangle_t * tris);
void _moz_pixman_add_triangles (pixman_image_t *image,
       int32_t x_off,
       int32_t y_off,
       int n_tris,
       const pixman_triangle_t *tris);

}
enum class VisitSide {
 TOP,
 BOTTOM,
 LEFT,
 RIGHT
};

class nsRegion
{
public:
  typedef nsRect RectType;
  typedef nsPoint PointType;
  typedef nsMargin MarginType;

  nsRegion () { _moz_pixman_region32_init(&mImpl); }
               nsRegion (const nsRect& aRect) { _moz_pixman_region32_init_rect(&mImpl,
                                                                          aRect.x,
                                                                          aRect.y,
                                                                          aRect.width,
                                                                          aRect.height); }
  explicit nsRegion (mozilla::gfx::ArrayView<pixman_box32_t> aRects)
  {
    _moz_pixman_region32_init_rects(&mImpl, aRects.Data(), aRects.Length());
  }
  nsRegion (const nsRegion& aRegion) { _moz_pixman_region32_init(&mImpl); _moz_pixman_region32_copy(&mImpl,aRegion.Impl()); }
  nsRegion (nsRegion&& aRegion) { mImpl = aRegion.mImpl; _moz_pixman_region32_init(&aRegion.mImpl); }
  nsRegion& operator = (nsRegion&& aRegion) {
      _moz_pixman_region32_fini(&mImpl);
      mImpl = aRegion.mImpl;
      _moz_pixman_region32_init(&aRegion.mImpl);
      return *this;
  }
 ~nsRegion () { _moz_pixman_region32_fini(&mImpl); }
  nsRegion& operator = (const nsRect& aRect) { Copy (aRect); return *this; }
  nsRegion& operator = (const nsRegion& aRegion) { Copy (aRegion); return *this; }
  bool operator==(const nsRegion& aRgn) const
  {
    return IsEqual(aRgn);
  }
  bool operator!=(const nsRegion& aRgn) const
  {
    return !(*this == aRgn);
  }

  friend std::ostream& operator<<(std::ostream& stream, const nsRegion& m);

  void Swap(nsRegion* aOther)
  {
    pixman_region32_t tmp = mImpl;
    mImpl = aOther->mImpl;
    aOther->mImpl = tmp;
  }

  static
  nsresult InitStatic()
  {
    return NS_OK;
  }

  static
  void ShutdownStatic() {}

  void AndWith(const nsRegion& aOther)
  {
    And(*this, aOther);
  }
  void AndWith(const nsRect& aOther)
  {
    And(*this, aOther);
  }
  nsRegion& And(const nsRegion& aRgn1, const nsRegion& aRgn2)
  {
    _moz_pixman_region32_intersect(&mImpl, aRgn1.Impl(), aRgn2.Impl());
    return *this;
  }
  nsRegion& And(const nsRect& aRect, const nsRegion& aRegion)
  {
    return And(aRegion, aRect);
  }
  nsRegion& And(const nsRegion& aRegion, const nsRect& aRect)
  {
    _moz_pixman_region32_intersect_rect(&mImpl, aRegion.Impl(), aRect.x, aRect.y, aRect.width, aRect.height);
    return *this;
  }
  nsRegion& And(const nsRect& aRect1, const nsRect& aRect2)
  {
    nsRect TmpRect;

    TmpRect.IntersectRect(aRect1, aRect2);
    return Copy(TmpRect);
  }

  nsRegion& OrWith(const nsRegion& aOther)
  {
    return Or(*this, aOther);
  }
  nsRegion& OrWith(const nsRect& aOther)
  {
    return Or(*this, aOther);
  }
  nsRegion& Or(const nsRegion& aRgn1, const nsRegion& aRgn2)
  {
    _moz_pixman_region32_union(&mImpl, aRgn1.Impl(), aRgn2.Impl());
    return *this;
  }
  nsRegion& Or(const nsRegion& aRegion, const nsRect& aRect)
  {
    _moz_pixman_region32_union_rect(&mImpl, aRegion.Impl(), aRect.x, aRect.y, aRect.width, aRect.height);
    return *this;
  }
  nsRegion& Or(const nsRect& aRect, const nsRegion& aRegion)
  {
    return Or(aRegion, aRect);
  }
  nsRegion& Or(const nsRect& aRect1, const nsRect& aRect2)
  {
    Copy (aRect1);
    return Or (*this, aRect2);
  }

  nsRegion& XorWith(const nsRegion& aOther)
  {
    return Xor(*this, aOther);
  }
  nsRegion& XorWith(const nsRect& aOther)
  {
    return Xor(*this, aOther);
  }
  nsRegion& Xor(const nsRegion& aRgn1, const nsRegion& aRgn2)
  {


    nsRegion p;
    p.Sub(aRgn1, aRgn2);
    nsRegion q;
    q.Sub(aRgn2, aRgn1);
    return Or(p, q);
  }
  nsRegion& Xor(const nsRegion& aRegion, const nsRect& aRect)
  {
    return Xor(aRegion, nsRegion(aRect));
  }
  nsRegion& Xor(const nsRect& aRect, const nsRegion& aRegion)
  {
    return Xor(nsRegion(aRect), aRegion);
  }
  nsRegion& Xor(const nsRect& aRect1, const nsRect& aRect2)
  {
    return Xor(nsRegion(aRect1), nsRegion(aRect2));
  }

  nsRegion ToAppUnits (nscoord aAppUnitsPerPixel) const;

  nsRegion& SubOut(const nsRegion& aOther)
  {
    return Sub(*this, aOther);
  }
  nsRegion& SubOut(const nsRect& aOther)
  {
    return Sub(*this, aOther);
  }
  nsRegion& Sub(const nsRegion& aRgn1, const nsRegion& aRgn2)
  {
    _moz_pixman_region32_subtract(&mImpl, aRgn1.Impl(), aRgn2.Impl());
    return *this;
  }
  nsRegion& Sub(const nsRegion& aRegion, const nsRect& aRect)
  {
    return Sub(aRegion, nsRegion(aRect));
  }
  nsRegion& Sub(const nsRect& aRect, const nsRegion& aRegion)
  {
    return Sub(nsRegion(aRect), aRegion);
  }
  nsRegion& Sub(const nsRect& aRect1, const nsRect& aRect2)
  {
    Copy(aRect1);
    return Sub(*this, aRect2);
  }






  bool Contains (int aX, int aY) const
  {
    return _moz_pixman_region32_contains_point(Impl(), aX, aY, nullptr);
  }
  bool Contains (const nsRect& aRect) const
  {
    pixman_box32_t box = RectToBox(aRect);
    return _moz_pixman_region32_contains_rectangle(Impl(), &box) == PIXMAN_REGION_IN;
  }
  bool Contains (const nsRegion& aRgn) const;
  bool Intersects (const nsRect& aRect) const;

  void MoveBy (int32_t aXOffset, int32_t aYOffset)
  {
    MoveBy (nsPoint (aXOffset, aYOffset));
  }
  void MoveBy (nsPoint aPt) { _moz_pixman_region32_translate(&mImpl, aPt.x, aPt.y); }
  void SetEmpty ()
  {
    _moz_pixman_region32_clear(&mImpl);
  }

  nsRegion MovedBy(int32_t aXOffset, int32_t aYOffset) const
  {
    return MovedBy(nsPoint(aXOffset, aYOffset));
  }
  nsRegion MovedBy(const nsPoint& aPt) const
  {
    nsRegion copy(*this);
    copy.MoveBy(aPt);
    return copy;
  }

  nsRegion Intersect(const nsRegion& aOther) const
  {
    nsRegion intersection;
    intersection.And(*this, aOther);
    return intersection;
  }

  void Inflate(const nsMargin& aMargin);

  nsRegion Inflated(const nsMargin& aMargin) const
  {
    nsRegion copy(*this);
    copy.Inflate(aMargin);
    return copy;
  }

  bool IsEmpty () const { return !_moz_pixman_region32_not_empty(Impl()); }
  bool IsComplex () const { return GetNumRects() > 1; }
  bool IsEqual (const nsRegion& aRegion) const
  {
    return _moz_pixman_region32_equal(Impl(), aRegion.Impl());
  }
  uint32_t GetNumRects () const
  {


    uint32_t result = _moz_pixman_region32_n_rects(Impl());
    return (result == 1 && GetBounds().IsEmpty()) ? 0 : result;
  }
  const nsRect GetBounds () const { return BoxToRect(mImpl.extents); }
  uint64_t Area () const;
  __attribute__ ((warn_unused_result)) nsRegion
    ScaleToOtherAppUnitsRoundOut (int32_t aFromAPP, int32_t aToAPP) const;
  __attribute__ ((warn_unused_result)) nsRegion
    ScaleToOtherAppUnitsRoundIn (int32_t aFromAPP, int32_t aToAPP) const;
  nsRegion& ScaleRoundOut(float aXScale, float aYScale);
  nsRegion& ScaleInverseRoundOut(float aXScale, float aYScale);
  nsRegion& Transform (const mozilla::gfx::Matrix4x4 &aTransform);
  nsIntRegion ScaleToOutsidePixels (float aXScale, float aYScale, nscoord aAppUnitsPerPixel) const;
  nsIntRegion ScaleToInsidePixels (float aXScale, float aYScale, nscoord aAppUnitsPerPixel) const;
  nsIntRegion ScaleToNearestPixels (float aXScale, float aYScale, nscoord aAppUnitsPerPixel) const;
  nsIntRegion ToOutsidePixels (nscoord aAppUnitsPerPixel) const;
  nsIntRegion ToNearestPixels (nscoord aAppUnitsPerPixel) const;







  nsRect GetLargestRectangle (const nsRect& aContainingRect = nsRect()) const;







  void SimplifyOutward (uint32_t aMaxRects);






  void SimplifyOutwardByArea(uint32_t aThreshold);





  void SimplifyInward (uint32_t aMaxRects);
  typedef void (*visitFn)(void *closure, VisitSide side, int x1, int y1, int x2, int y2);
  void VisitEdges(visitFn, void *closure);

  nsCString ToString() const;

  class RectIterator
  {
    int mCurrent;
    int mLimit;
    mutable nsRect mTmp;
    pixman_box32_t *mBoxes;

  public:
    explicit RectIterator(const nsRegion& aRegion)
    {
      mCurrent = 0;
      mBoxes = _moz_pixman_region32_rectangles(aRegion.Impl(), &mLimit);


      if (mLimit == 1 && nsRegion::BoxToRect(mBoxes[0]).IsEmpty()) {
        mLimit = 0;
      }
    }

    bool Done() const { return mCurrent == mLimit; }

    const nsRect& Get() const
    {
      do { } while (0);
      mTmp = nsRegion::BoxToRect(mBoxes[mCurrent]);
      do { } while(0);
      return mTmp;
    }

    void Next()
    {
      do { } while (0);
      mCurrent++;
    }
  };

  RectIterator RectIter() const { return RectIterator(*this); }

private:
  pixman_region32_t mImpl;
  nsIntRegion ToPixels(nscoord aAppUnitsPerPixel, bool aOutsidePixels) const;

  nsRegion& Copy (const nsRegion& aRegion)
  {
    _moz_pixman_region32_copy(&mImpl, aRegion.Impl());
    return *this;
  }

  nsRegion& Copy (const nsRect& aRect)
  {





    if (aRect.IsEmpty()) {
      _moz_pixman_region32_clear(&mImpl);
    } else {
      pixman_box32_t box = RectToBox(aRect);
      _moz_pixman_region32_reset(&mImpl, &box);
    }
    return *this;
  }

  static inline pixman_box32_t RectToBox(const nsRect &aRect)
  {
    pixman_box32_t box = { aRect.x, aRect.y, aRect.XMost(), aRect.YMost() };
    return box;
  }

  static inline pixman_box32_t RectToBox(const mozilla::gfx::IntRect &aRect)
  {
    pixman_box32_t box = { aRect.x, aRect.y, aRect.XMost(), aRect.YMost() };
    return box;
  }


  static inline nsRect BoxToRect(const pixman_box32_t &aBox)
  {
    return nsRect(aBox.x1, aBox.y1,
                  aBox.x2 - aBox.x1,
                  aBox.y2 - aBox.y1);
  }

  pixman_region32_t* Impl() const
  {
    return const_cast<pixman_region32_t*>(&mImpl);
  }
};

namespace mozilla {
namespace gfx {




template <typename Derived, typename Rect, typename Point, typename Margin>
class BaseIntRegion
{
  friend class ::nsRegion;



  template <typename units>
  friend class IntRegionTyped;

public:
  typedef Rect RectType;
  typedef Point PointType;
  typedef Margin MarginType;

  BaseIntRegion () {}
               BaseIntRegion (const Rect& aRect) : mImpl (ToRect(aRect)) {}
  explicit BaseIntRegion (mozilla::gfx::ArrayView<pixman_box32_t> aRects) : mImpl (aRects) {}
  BaseIntRegion (const BaseIntRegion& aRegion) : mImpl (aRegion.mImpl) {}
  BaseIntRegion (BaseIntRegion&& aRegion) : mImpl (mozilla::Move(aRegion.mImpl)) {}
  Derived& operator = (const Rect& aRect) { mImpl = ToRect (aRect); return This(); }
  Derived& operator = (const Derived& aRegion) { mImpl = aRegion.mImpl; return This(); }
  Derived& operator = (Derived&& aRegion) { mImpl = mozilla::Move(aRegion.mImpl); return This(); }

  bool operator==(const Derived& aRgn) const
  {
    return IsEqual(aRgn);
  }
  bool operator!=(const Derived& aRgn) const
  {
    return !(*this == aRgn);
  }

  friend std::ostream& operator<<(std::ostream& stream, const Derived& m) {
    return stream << m.mImpl;
  }

  void Swap(Derived* aOther)
  {
    mImpl.Swap(&aOther->mImpl);
  }

  void AndWith(const Derived& aOther)
  {
    And(This(), aOther);
  }
  void AndWith(const Rect& aOther)
  {
    And(This(), aOther);
  }
  Derived& And (const Derived& aRgn1, const Derived& aRgn2)
  {
    mImpl.And (aRgn1.mImpl, aRgn2.mImpl);
    return This();
  }
  Derived& And (const Derived& aRegion, const Rect& aRect)
  {
    mImpl.And (aRegion.mImpl, ToRect (aRect));
    return This();
  }
  Derived& And (const Rect& aRect, const Derived& aRegion)
  {
    return And (aRegion, aRect);
  }
  Derived& And (const Rect& aRect1, const Rect& aRect2)
  {
    Rect TmpRect;

    TmpRect.IntersectRect (aRect1, aRect2);
    mImpl = ToRect (TmpRect);
    return This();
  }

  Derived& OrWith(const Derived& aOther)
  {
    return Or(This(), aOther);
  }
  Derived& OrWith(const Rect& aOther)
  {
    return Or(This(), aOther);
  }
  Derived& Or (const Derived& aRgn1, const Derived& aRgn2)
  {
    mImpl.Or (aRgn1.mImpl, aRgn2.mImpl);
    return This();
  }
  Derived& Or (const Derived& aRegion, const Rect& aRect)
  {
    mImpl.Or (aRegion.mImpl, ToRect (aRect));
    return This();
  }
  Derived& Or (const Rect& aRect, const Derived& aRegion)
  {
    return Or (aRegion, aRect);
  }
  Derived& Or (const Rect& aRect1, const Rect& aRect2)
  {
    mImpl = ToRect (aRect1);
    return Or (This(), aRect2);
  }

  Derived& XorWith(const Derived& aOther)
  {
    return Xor(This(), aOther);
  }
  Derived& XorWith(const Rect& aOther)
  {
    return Xor(This(), aOther);
  }
  Derived& Xor (const Derived& aRgn1, const Derived& aRgn2)
  {
    mImpl.Xor (aRgn1.mImpl, aRgn2.mImpl);
    return This();
  }
  Derived& Xor (const Derived& aRegion, const Rect& aRect)
  {
    mImpl.Xor (aRegion.mImpl, ToRect (aRect));
    return This();
  }
  Derived& Xor (const Rect& aRect, const Derived& aRegion)
  {
    return Xor (aRegion, aRect);
  }
  Derived& Xor (const Rect& aRect1, const Rect& aRect2)
  {
    mImpl = ToRect (aRect1);
    return Xor (This(), aRect2);
  }

  Derived& SubOut(const Derived& aOther)
  {
    return Sub(This(), aOther);
  }
  Derived& SubOut(const Rect& aOther)
  {
    return Sub(This(), aOther);
  }
  Derived& Sub (const Derived& aRgn1, const Derived& aRgn2)
  {
    mImpl.Sub (aRgn1.mImpl, aRgn2.mImpl);
    return This();
  }
  Derived& Sub (const Derived& aRegion, const Rect& aRect)
  {
    mImpl.Sub (aRegion.mImpl, ToRect (aRect));
    return This();
  }
  Derived& Sub (const Rect& aRect, const Derived& aRegion)
  {
    return Sub (Derived (aRect), aRegion);
  }
  Derived& Sub (const Rect& aRect1, const Rect& aRect2)
  {
    mImpl = ToRect (aRect1);
    return Sub (This(), aRect2);
  }






  bool Contains (int aX, int aY) const
  {
    return mImpl.Contains(aX, aY);
  }
  bool Contains (const Rect& aRect) const
  {
    return mImpl.Contains (ToRect (aRect));
  }
  bool Contains (const Derived& aRgn) const
  {
    return mImpl.Contains (aRgn.mImpl);
  }
  bool Intersects (const Rect& aRect) const
  {
    return mImpl.Intersects (ToRect (aRect));
  }

  void MoveBy (int32_t aXOffset, int32_t aYOffset)
  {
    MoveBy (Point (aXOffset, aYOffset));
  }
  void MoveBy (Point aPt)
  {
    mImpl.MoveBy (aPt.x, aPt.y);
  }
  Derived MovedBy(int32_t aXOffset, int32_t aYOffset) const
  {
    return MovedBy(Point(aXOffset, aYOffset));
  }
  Derived MovedBy(const Point& aPt) const
  {
    Derived copy(This());
    copy.MoveBy(aPt);
    return copy;
  }

  Derived Intersect(const Derived& aOther) const
  {
    Derived intersection;
    intersection.And(This(), aOther);
    return intersection;
  }

  void Inflate(const Margin& aMargin)
  {
    mImpl.Inflate(nsMargin(aMargin.top, aMargin.right, aMargin.bottom, aMargin.left));
  }
  Derived Inflated(const Margin& aMargin) const
  {
    Derived copy(This());
    copy.Inflate(aMargin);
    return copy;
  }

  void SetEmpty ()
  {
    mImpl.SetEmpty ();
  }

  bool IsEmpty () const { return mImpl.IsEmpty (); }
  bool IsComplex () const { return mImpl.IsComplex (); }
  bool IsEqual (const Derived& aRegion) const
  {
    return mImpl.IsEqual (aRegion.mImpl);
  }
  uint32_t GetNumRects () const { return mImpl.GetNumRects (); }
  Rect GetBounds () const { return FromRect (mImpl.GetBounds ()); }
  uint64_t Area () const { return mImpl.Area(); }
  nsRegion ToAppUnits (nscoord aAppUnitsPerPixel) const
  {
    nsRegion result;
    for (auto iter = RectIter(); !iter.Done(); iter.Next()) {
      nsRect appRect = ::ToAppUnits(iter.Get(), aAppUnitsPerPixel);
      result.Or(result, appRect);
    }
    return result;
  }
  Rect GetLargestRectangle (const Rect& aContainingRect = Rect()) const
  {
    return FromRect (mImpl.GetLargestRectangle( ToRect(aContainingRect) ));
  }

  Derived& ScaleRoundOut (float aXScale, float aYScale)
  {
    mImpl.ScaleRoundOut(aXScale, aYScale);
    return This();
  }

  Derived& ScaleInverseRoundOut (float aXScale, float aYScale)
  {
    mImpl.ScaleInverseRoundOut(aXScale, aYScale);
    return This();
  }





  Derived& Transform (const mozilla::gfx::Matrix4x4 &aTransform)
  {
    mImpl.Transform(aTransform);
    return This();
  }







  void SimplifyOutward (uint32_t aMaxRects)
  {
    mImpl.SimplifyOutward (aMaxRects);
  }
  void SimplifyOutwardByArea (uint32_t aThreshold)
  {
    mImpl.SimplifyOutwardByArea (aThreshold);
  }





  void SimplifyInward (uint32_t aMaxRects)
  {
    mImpl.SimplifyInward (aMaxRects);
  }

  typedef void (*visitFn)(void *closure, VisitSide side, int x1, int y1, int x2, int y2);
  void VisitEdges (visitFn visit, void *closure)
  {
    mImpl.VisitEdges (visit, closure);
  }

  nsCString ToString() const { return mImpl.ToString(); }

  class RectIterator
  {
    nsRegion::RectIterator mImpl;
    mutable Rect mTmp;

  public:
    explicit RectIterator(const BaseIntRegion& aRegion)
      : mImpl(aRegion.mImpl)
    {}

    bool Done() const { return mImpl.Done(); }

    const Rect& Get() const
    {
      mTmp = FromRect(mImpl.Get());
      return mTmp;
    }

    void Next() { mImpl.Next(); }
  };

  RectIterator RectIter() const { return RectIterator(*this); }

protected:


  explicit BaseIntRegion(const nsRegion& aImpl) : mImpl(aImpl) {}
  const nsRegion& Impl() const { return mImpl; }
private:
  nsRegion mImpl;

  static nsRect ToRect(const Rect& aRect)
  {
    return nsRect (aRect.x, aRect.y, aRect.width, aRect.height);
  }
  static Rect FromRect(const nsRect& aRect)
  {
    return Rect (aRect.x, aRect.y, aRect.width, aRect.height);
  }

  Derived& This()
  {
    return *static_cast<Derived*>(this);
  }
  const Derived& This() const
  {
    return *static_cast<const Derived*>(this);
  }
};

template <class units>
class IntRegionTyped :
    public BaseIntRegion<IntRegionTyped<units>, IntRectTyped<units>, IntPointTyped<units>, IntMarginTyped<units>>
{
  typedef BaseIntRegion<IntRegionTyped<units>, IntRectTyped<units>, IntPointTyped<units>, IntMarginTyped<units>> Super;


  template <typename OtherUnits>
  friend class IntRegionTyped;

  static_assert(IsPixel<units>::value, "'units' must be a coordinate system tag");

public:
  typedef IntRectTyped<units> RectType;
  typedef IntPointTyped<units> PointType;
  typedef IntMarginTyped<units> MarginType;


  IntRegionTyped() {}
               IntRegionTyped(const IntRectTyped<units>& aRect) : Super(aRect) {}
  IntRegionTyped(const IntRegionTyped& aRegion) : Super(aRegion) {}
  explicit IntRegionTyped(mozilla::gfx::ArrayView<pixman_box32_t> aRects) : Super(aRects) {}
  IntRegionTyped(IntRegionTyped&& aRegion) : Super(mozilla::Move(aRegion)) {}



  IntRegionTyped& operator=(const IntRegionTyped& aRegion)
  {
    return Super::operator=(aRegion);
  }
  IntRegionTyped& operator=(IntRegionTyped&& aRegion)
  {
    return Super::operator=(mozilla::Move(aRegion));
  }

  static IntRegionTyped FromUnknownRegion(const IntRegion& aRegion)
  {
    return IntRegionTyped(aRegion.Impl());
  }
  IntRegion ToUnknownRegion() const
  {

    return IntRegion(this->Impl());
  }
private:

  explicit IntRegionTyped(const nsRegion& aRegion) : Super(aRegion) {}
};

}
}

typedef mozilla::gfx::IntRegion nsIntRegion;
namespace mozilla {
inline int32_t AppUnitsPerCSSPixel() { return 60; }
inline int32_t AppUnitsPerCSSInch() { return 96 * AppUnitsPerCSSPixel(); }
}


namespace mozilla {

template <typename T>
struct IsPixel : FalseType {};


struct CSSPixel;
struct LayoutDevicePixel;
struct LayerPixel;
struct CSSTransformedLayerPixel;
struct RenderTargetPixel;
struct ScreenPixel;
struct ParentLayerPixel;
struct DesktopPixel;

template<> struct IsPixel<CSSPixel> : TrueType {};
template<> struct IsPixel<LayoutDevicePixel> : TrueType {};
template<> struct IsPixel<LayerPixel> : TrueType {};
template<> struct IsPixel<CSSTransformedLayerPixel> : TrueType {};
template<> struct IsPixel<RenderTargetPixel> : TrueType {};
template<> struct IsPixel<ScreenPixel> : TrueType {};
template<> struct IsPixel<ParentLayerPixel> : TrueType {};
template<> struct IsPixel<DesktopPixel> : TrueType {};

typedef gfx::CoordTyped<CSSPixel> CSSCoord;
typedef gfx::IntCoordTyped<CSSPixel> CSSIntCoord;
typedef gfx::PointTyped<CSSPixel> CSSPoint;
typedef gfx::IntPointTyped<CSSPixel> CSSIntPoint;
typedef gfx::SizeTyped<CSSPixel> CSSSize;
typedef gfx::IntSizeTyped<CSSPixel> CSSIntSize;
typedef gfx::RectTyped<CSSPixel> CSSRect;
typedef gfx::IntRectTyped<CSSPixel> CSSIntRect;
typedef gfx::MarginTyped<CSSPixel> CSSMargin;
typedef gfx::IntMarginTyped<CSSPixel> CSSIntMargin;
typedef gfx::IntRegionTyped<CSSPixel> CSSIntRegion;

typedef gfx::CoordTyped<LayoutDevicePixel> LayoutDeviceCoord;
typedef gfx::IntCoordTyped<LayoutDevicePixel> LayoutDeviceIntCoord;
typedef gfx::PointTyped<LayoutDevicePixel> LayoutDevicePoint;
typedef gfx::IntPointTyped<LayoutDevicePixel> LayoutDeviceIntPoint;
typedef gfx::SizeTyped<LayoutDevicePixel> LayoutDeviceSize;
typedef gfx::IntSizeTyped<LayoutDevicePixel> LayoutDeviceIntSize;
typedef gfx::RectTyped<LayoutDevicePixel> LayoutDeviceRect;
typedef gfx::IntRectTyped<LayoutDevicePixel> LayoutDeviceIntRect;
typedef gfx::MarginTyped<LayoutDevicePixel> LayoutDeviceMargin;
typedef gfx::IntMarginTyped<LayoutDevicePixel> LayoutDeviceIntMargin;
typedef gfx::IntRegionTyped<LayoutDevicePixel> LayoutDeviceIntRegion;

typedef gfx::CoordTyped<LayerPixel> LayerCoord;
typedef gfx::IntCoordTyped<LayerPixel> LayerIntCoord;
typedef gfx::PointTyped<LayerPixel> LayerPoint;
typedef gfx::IntPointTyped<LayerPixel> LayerIntPoint;
typedef gfx::SizeTyped<LayerPixel> LayerSize;
typedef gfx::IntSizeTyped<LayerPixel> LayerIntSize;
typedef gfx::RectTyped<LayerPixel> LayerRect;
typedef gfx::IntRectTyped<LayerPixel> LayerIntRect;
typedef gfx::MarginTyped<LayerPixel> LayerMargin;
typedef gfx::IntMarginTyped<LayerPixel> LayerIntMargin;
typedef gfx::IntRegionTyped<LayerPixel> LayerIntRegion;

typedef gfx::CoordTyped<CSSTransformedLayerPixel> CSSTransformedLayerCoord;
typedef gfx::IntCoordTyped<CSSTransformedLayerPixel> CSSTransformedLayerIntCoord;
typedef gfx::PointTyped<CSSTransformedLayerPixel> CSSTransformedLayerPoint;
typedef gfx::IntPointTyped<CSSTransformedLayerPixel> CSSTransformedLayerIntPoint;
typedef gfx::SizeTyped<CSSTransformedLayerPixel> CSSTransformedLayerSize;
typedef gfx::IntSizeTyped<CSSTransformedLayerPixel> CSSTransformedLayerIntSize;
typedef gfx::RectTyped<CSSTransformedLayerPixel> CSSTransformedLayerRect;
typedef gfx::IntRectTyped<CSSTransformedLayerPixel> CSSTransformedLayerIntRect;
typedef gfx::MarginTyped<CSSTransformedLayerPixel> CSSTransformedLayerMargin;
typedef gfx::IntMarginTyped<CSSTransformedLayerPixel> CSSTransformedLayerIntMargin;
typedef gfx::IntRegionTyped<CSSTransformedLayerPixel> CSSTransformedLayerIntRegion;

typedef gfx::PointTyped<RenderTargetPixel> RenderTargetPoint;
typedef gfx::IntPointTyped<RenderTargetPixel> RenderTargetIntPoint;
typedef gfx::SizeTyped<RenderTargetPixel> RenderTargetSize;
typedef gfx::IntSizeTyped<RenderTargetPixel> RenderTargetIntSize;
typedef gfx::RectTyped<RenderTargetPixel> RenderTargetRect;
typedef gfx::IntRectTyped<RenderTargetPixel> RenderTargetIntRect;
typedef gfx::MarginTyped<RenderTargetPixel> RenderTargetMargin;
typedef gfx::IntMarginTyped<RenderTargetPixel> RenderTargetIntMargin;
typedef gfx::IntRegionTyped<RenderTargetPixel> RenderTargetIntRegion;

typedef gfx::CoordTyped<ScreenPixel> ScreenCoord;
typedef gfx::IntCoordTyped<ScreenPixel> ScreenIntCoord;
typedef gfx::PointTyped<ScreenPixel> ScreenPoint;
typedef gfx::IntPointTyped<ScreenPixel> ScreenIntPoint;
typedef gfx::SizeTyped<ScreenPixel> ScreenSize;
typedef gfx::IntSizeTyped<ScreenPixel> ScreenIntSize;
typedef gfx::RectTyped<ScreenPixel> ScreenRect;
typedef gfx::IntRectTyped<ScreenPixel> ScreenIntRect;
typedef gfx::MarginTyped<ScreenPixel> ScreenMargin;
typedef gfx::IntMarginTyped<ScreenPixel> ScreenIntMargin;
typedef gfx::IntRegionTyped<ScreenPixel> ScreenIntRegion;

typedef gfx::CoordTyped<ParentLayerPixel> ParentLayerCoord;
typedef gfx::IntCoordTyped<ParentLayerPixel> ParentLayerIntCoord;
typedef gfx::PointTyped<ParentLayerPixel> ParentLayerPoint;
typedef gfx::IntPointTyped<ParentLayerPixel> ParentLayerIntPoint;
typedef gfx::SizeTyped<ParentLayerPixel> ParentLayerSize;
typedef gfx::IntSizeTyped<ParentLayerPixel> ParentLayerIntSize;
typedef gfx::RectTyped<ParentLayerPixel> ParentLayerRect;
typedef gfx::IntRectTyped<ParentLayerPixel> ParentLayerIntRect;
typedef gfx::MarginTyped<ParentLayerPixel> ParentLayerMargin;
typedef gfx::IntMarginTyped<ParentLayerPixel> ParentLayerIntMargin;
typedef gfx::IntRegionTyped<ParentLayerPixel> ParentLayerIntRegion;

typedef gfx::CoordTyped<DesktopPixel> DesktopCoord;
typedef gfx::IntCoordTyped<DesktopPixel> DesktopIntCoord;
typedef gfx::PointTyped<DesktopPixel> DesktopPoint;
typedef gfx::IntPointTyped<DesktopPixel> DesktopIntPoint;
typedef gfx::SizeTyped<DesktopPixel> DesktopSize;
typedef gfx::IntSizeTyped<DesktopPixel> DesktopIntSize;
typedef gfx::RectTyped<DesktopPixel> DesktopRect;
typedef gfx::IntRectTyped<DesktopPixel> DesktopIntRect;

typedef gfx::ScaleFactor<CSSPixel, LayoutDevicePixel> CSSToLayoutDeviceScale;
typedef gfx::ScaleFactor<CSSPixel, LayerPixel> CSSToLayerScale;
typedef gfx::ScaleFactor<CSSPixel, ScreenPixel> CSSToScreenScale;
typedef gfx::ScaleFactor<CSSPixel, ParentLayerPixel> CSSToParentLayerScale;
typedef gfx::ScaleFactor<LayoutDevicePixel, CSSPixel> LayoutDeviceToCSSScale;
typedef gfx::ScaleFactor<LayoutDevicePixel, LayerPixel> LayoutDeviceToLayerScale;
typedef gfx::ScaleFactor<LayoutDevicePixel, ScreenPixel> LayoutDeviceToScreenScale;
typedef gfx::ScaleFactor<LayoutDevicePixel, ParentLayerPixel> LayoutDeviceToParentLayerScale;
typedef gfx::ScaleFactor<LayerPixel, CSSPixel> LayerToCSSScale;
typedef gfx::ScaleFactor<LayerPixel, LayoutDevicePixel> LayerToLayoutDeviceScale;
typedef gfx::ScaleFactor<LayerPixel, RenderTargetPixel> LayerToRenderTargetScale;
typedef gfx::ScaleFactor<LayerPixel, ScreenPixel> LayerToScreenScale;
typedef gfx::ScaleFactor<LayerPixel, ParentLayerPixel> LayerToParentLayerScale;
typedef gfx::ScaleFactor<RenderTargetPixel, ScreenPixel> RenderTargetToScreenScale;
typedef gfx::ScaleFactor<ScreenPixel, CSSPixel> ScreenToCSSScale;
typedef gfx::ScaleFactor<ScreenPixel, LayoutDevicePixel> ScreenToLayoutDeviceScale;
typedef gfx::ScaleFactor<ScreenPixel, LayerPixel> ScreenToLayerScale;
typedef gfx::ScaleFactor<ScreenPixel, ParentLayerPixel> ScreenToParentLayerScale;
typedef gfx::ScaleFactor<ParentLayerPixel, LayerPixel> ParentLayerToLayerScale;
typedef gfx::ScaleFactor<ParentLayerPixel, ScreenPixel> ParentLayerToScreenScale;
typedef gfx::ScaleFactor<ParentLayerPixel, ParentLayerPixel> ParentLayerToParentLayerScale;
typedef gfx::ScaleFactor<DesktopPixel, LayoutDevicePixel> DesktopToLayoutDeviceScale;

typedef gfx::ScaleFactors2D<CSSPixel, LayoutDevicePixel> CSSToLayoutDeviceScale2D;
typedef gfx::ScaleFactors2D<CSSPixel, LayerPixel> CSSToLayerScale2D;
typedef gfx::ScaleFactors2D<CSSPixel, ScreenPixel> CSSToScreenScale2D;
typedef gfx::ScaleFactors2D<CSSPixel, ParentLayerPixel> CSSToParentLayerScale2D;
typedef gfx::ScaleFactors2D<LayoutDevicePixel, CSSPixel> LayoutDeviceToCSSScale2D;
typedef gfx::ScaleFactors2D<LayoutDevicePixel, LayerPixel> LayoutDeviceToLayerScale2D;
typedef gfx::ScaleFactors2D<LayoutDevicePixel, ScreenPixel> LayoutDeviceToScreenScale2D;
typedef gfx::ScaleFactors2D<LayoutDevicePixel, ParentLayerPixel> LayoutDeviceToParentLayerScale2D;
typedef gfx::ScaleFactors2D<LayerPixel, CSSPixel> LayerToCSSScale2D;
typedef gfx::ScaleFactors2D<LayerPixel, LayoutDevicePixel> LayerToLayoutDeviceScale2D;
typedef gfx::ScaleFactors2D<LayerPixel, RenderTargetPixel> LayerToRenderTargetScale2D;
typedef gfx::ScaleFactors2D<LayerPixel, ScreenPixel> LayerToScreenScale2D;
typedef gfx::ScaleFactors2D<LayerPixel, ParentLayerPixel> LayerToParentLayerScale2D;
typedef gfx::ScaleFactors2D<RenderTargetPixel, ScreenPixel> RenderTargetToScreenScale2D;
typedef gfx::ScaleFactors2D<ScreenPixel, CSSPixel> ScreenToCSSScale2D;
typedef gfx::ScaleFactors2D<ScreenPixel, LayoutDevicePixel> ScreenToLayoutDeviceScale2D;
typedef gfx::ScaleFactors2D<ScreenPixel, LayerPixel> ScreenToLayerScale2D;
typedef gfx::ScaleFactors2D<ScreenPixel, ParentLayerPixel> ScreenToParentLayerScale2D;
typedef gfx::ScaleFactors2D<ParentLayerPixel, LayerPixel> ParentLayerToLayerScale2D;
typedef gfx::ScaleFactors2D<ParentLayerPixel, ScreenPixel> ParentLayerToScreenScale2D;
typedef gfx::ScaleFactors2D<ParentLayerPixel, ParentLayerPixel> ParentLayerToParentLayerScale2D;

typedef gfx::Matrix4x4Typed<LayoutDevicePixel, LayoutDevicePixel> LayoutDeviceToLayoutDeviceMatrix4x4;
typedef gfx::Matrix4x4Typed<LayerPixel, ParentLayerPixel> LayerToParentLayerMatrix4x4;
typedef gfx::Matrix4x4Typed<ScreenPixel, ScreenPixel> ScreenToScreenMatrix4x4;
typedef gfx::Matrix4x4Typed<ScreenPixel, ParentLayerPixel> ScreenToParentLayerMatrix4x4;
typedef gfx::Matrix4x4Typed<ParentLayerPixel, LayerPixel> ParentLayerToLayerMatrix4x4;
typedef gfx::Matrix4x4Typed<ParentLayerPixel, ScreenPixel> ParentLayerToScreenMatrix4x4;
typedef gfx::Matrix4x4Typed<ParentLayerPixel, ParentLayerPixel> ParentLayerToParentLayerMatrix4x4;




struct CSSPixel {



  static CSSCoord FromAppUnits(nscoord aCoord) {
    return NSAppUnitsToFloatPixels(aCoord, float(AppUnitsPerCSSPixel()));
  }

  static CSSPoint FromAppUnits(const nsPoint& aPoint) {
    return CSSPoint(NSAppUnitsToFloatPixels(aPoint.x, float(AppUnitsPerCSSPixel())),
                    NSAppUnitsToFloatPixels(aPoint.y, float(AppUnitsPerCSSPixel())));
  }

  static CSSSize FromAppUnits(const nsSize& aSize) {
    return CSSSize(NSAppUnitsToFloatPixels(aSize.width, float(AppUnitsPerCSSPixel())),
                   NSAppUnitsToFloatPixels(aSize.height, float(AppUnitsPerCSSPixel())));
  }

  static CSSRect FromAppUnits(const nsRect& aRect) {
    return CSSRect(NSAppUnitsToFloatPixels(aRect.x, float(AppUnitsPerCSSPixel())),
                   NSAppUnitsToFloatPixels(aRect.y, float(AppUnitsPerCSSPixel())),
                   NSAppUnitsToFloatPixels(aRect.width, float(AppUnitsPerCSSPixel())),
                   NSAppUnitsToFloatPixels(aRect.height, float(AppUnitsPerCSSPixel())));
  }

  static CSSMargin FromAppUnits(const nsMargin& aMargin) {
    return CSSMargin(NSAppUnitsToFloatPixels(aMargin.top, float(AppUnitsPerCSSPixel())),
                     NSAppUnitsToFloatPixels(aMargin.right, float(AppUnitsPerCSSPixel())),
                     NSAppUnitsToFloatPixels(aMargin.bottom, float(AppUnitsPerCSSPixel())),
                     NSAppUnitsToFloatPixels(aMargin.left, float(AppUnitsPerCSSPixel())));
  }

  static CSSIntPoint FromAppUnitsRounded(const nsPoint& aPoint) {
    return CSSIntPoint(NSAppUnitsToIntPixels(aPoint.x, float(AppUnitsPerCSSPixel())),
                       NSAppUnitsToIntPixels(aPoint.y, float(AppUnitsPerCSSPixel())));
  }

  static CSSIntSize FromAppUnitsRounded(const nsSize& aSize)
  {
    return CSSIntSize(NSAppUnitsToIntPixels(aSize.width, float(AppUnitsPerCSSPixel())),
                      NSAppUnitsToIntPixels(aSize.height, float(AppUnitsPerCSSPixel())));
  }

  static CSSIntRect FromAppUnitsRounded(const nsRect& aRect) {
    return CSSIntRect(NSAppUnitsToIntPixels(aRect.x, float(AppUnitsPerCSSPixel())),
                      NSAppUnitsToIntPixels(aRect.y, float(AppUnitsPerCSSPixel())),
                      NSAppUnitsToIntPixels(aRect.width, float(AppUnitsPerCSSPixel())),
                      NSAppUnitsToIntPixels(aRect.height, float(AppUnitsPerCSSPixel())));
  }



  static nscoord ToAppUnits(CSSCoord aCoord) {
    return NSToCoordRoundWithClamp(aCoord * float(AppUnitsPerCSSPixel()));
  }

  static nsPoint ToAppUnits(const CSSPoint& aPoint) {
    return nsPoint(NSToCoordRoundWithClamp(aPoint.x * float(AppUnitsPerCSSPixel())),
                   NSToCoordRoundWithClamp(aPoint.y * float(AppUnitsPerCSSPixel())));
  }

  static nsPoint ToAppUnits(const CSSIntPoint& aPoint) {
    return nsPoint(NSToCoordRoundWithClamp(float(aPoint.x) * float(AppUnitsPerCSSPixel())),
                   NSToCoordRoundWithClamp(float(aPoint.y) * float(AppUnitsPerCSSPixel())));
  }

  static nsSize ToAppUnits(const CSSSize& aSize) {
    return nsSize(NSToCoordRoundWithClamp(aSize.width * float(AppUnitsPerCSSPixel())),
                  NSToCoordRoundWithClamp(aSize.height * float(AppUnitsPerCSSPixel())));
  }

  static nsSize ToAppUnits(const CSSIntSize& aSize) {
    return nsSize(NSToCoordRoundWithClamp(float(aSize.width) * float(AppUnitsPerCSSPixel())),
                  NSToCoordRoundWithClamp(float(aSize.height) * float(AppUnitsPerCSSPixel())));
  }

  static nsRect ToAppUnits(const CSSRect& aRect) {
    return nsRect(NSToCoordRoundWithClamp(aRect.x * float(AppUnitsPerCSSPixel())),
                  NSToCoordRoundWithClamp(aRect.y * float(AppUnitsPerCSSPixel())),
                  NSToCoordRoundWithClamp(aRect.width * float(AppUnitsPerCSSPixel())),
                  NSToCoordRoundWithClamp(aRect.height * float(AppUnitsPerCSSPixel())));
  }

  static nsRect ToAppUnits(const CSSIntRect& aRect) {
    return nsRect(NSToCoordRoundWithClamp(float(aRect.x) * float(AppUnitsPerCSSPixel())),
                  NSToCoordRoundWithClamp(float(aRect.y) * float(AppUnitsPerCSSPixel())),
                  NSToCoordRoundWithClamp(float(aRect.width) * float(AppUnitsPerCSSPixel())),
                  NSToCoordRoundWithClamp(float(aRect.height) * float(AppUnitsPerCSSPixel())));
  }
};
struct LayoutDevicePixel {
  static LayoutDeviceRect FromAppUnits(const nsRect& aRect, nscoord aAppUnitsPerDevPixel) {
    return LayoutDeviceRect(NSAppUnitsToFloatPixels(aRect.x, float(aAppUnitsPerDevPixel)),
                            NSAppUnitsToFloatPixels(aRect.y, float(aAppUnitsPerDevPixel)),
                            NSAppUnitsToFloatPixels(aRect.width, float(aAppUnitsPerDevPixel)),
                            NSAppUnitsToFloatPixels(aRect.height, float(aAppUnitsPerDevPixel)));
  }

  static LayoutDevicePoint FromAppUnits(const nsPoint& aPoint, nscoord aAppUnitsPerDevPixel) {
    return LayoutDevicePoint(NSAppUnitsToFloatPixels(aPoint.x, aAppUnitsPerDevPixel),
                             NSAppUnitsToFloatPixels(aPoint.y, aAppUnitsPerDevPixel));
  }

  static LayoutDeviceMargin FromAppUnits(const nsMargin& aMargin, nscoord aAppUnitsPerDevPixel) {
    return LayoutDeviceMargin(NSAppUnitsToFloatPixels(aMargin.top, aAppUnitsPerDevPixel),
                              NSAppUnitsToFloatPixels(aMargin.right, aAppUnitsPerDevPixel),
                              NSAppUnitsToFloatPixels(aMargin.bottom, aAppUnitsPerDevPixel),
                              NSAppUnitsToFloatPixels(aMargin.left, aAppUnitsPerDevPixel));
  }

  static LayoutDeviceIntPoint FromAppUnitsRounded(const nsPoint& aPoint, nscoord aAppUnitsPerDevPixel) {
    return LayoutDeviceIntPoint(NSAppUnitsToIntPixels(aPoint.x, aAppUnitsPerDevPixel),
                                NSAppUnitsToIntPixels(aPoint.y, aAppUnitsPerDevPixel));
  }

  static LayoutDeviceIntPoint FromAppUnitsToNearest(const nsPoint& aPoint, nscoord aAppUnitsPerDevPixel) {
    return LayoutDeviceIntPoint::FromUnknownPoint(aPoint.ToNearestPixels(aAppUnitsPerDevPixel));
  }

  static LayoutDeviceIntRect FromAppUnitsToNearest(const nsRect& aRect, nscoord aAppUnitsPerDevPixel) {
    return LayoutDeviceIntRect::FromUnknownRect(aRect.ToNearestPixels(aAppUnitsPerDevPixel));
  }

  static LayoutDeviceIntRect FromAppUnitsToInside(const nsRect& aRect, nscoord aAppUnitsPerDevPixel) {
    return LayoutDeviceIntRect::FromUnknownRect(aRect.ToInsidePixels(aAppUnitsPerDevPixel));
  }

  static LayoutDeviceIntRect FromAppUnitsToOutside(const nsRect& aRect, nscoord aAppUnitsPerDevPixel) {
    return LayoutDeviceIntRect::FromUnknownRect(aRect.ToOutsidePixels(aAppUnitsPerDevPixel));
  }

  static LayoutDeviceIntSize FromAppUnitsRounded(const nsSize& aSize, nscoord aAppUnitsPerDevPixel) {
    return LayoutDeviceIntSize(
      NSAppUnitsToIntPixels(aSize.width, aAppUnitsPerDevPixel),
      NSAppUnitsToIntPixels(aSize.height, aAppUnitsPerDevPixel));
  }

  static nsPoint ToAppUnits(const LayoutDeviceIntPoint& aPoint, nscoord aAppUnitsPerDevPixel) {
    return nsPoint(aPoint.x * aAppUnitsPerDevPixel,
                   aPoint.y * aAppUnitsPerDevPixel);
  }

  static nsSize ToAppUnits(const LayoutDeviceIntSize& aSize, nscoord aAppUnitsPerDevPixel) {
    return nsSize(aSize.width * aAppUnitsPerDevPixel,
                  aSize.height * aAppUnitsPerDevPixel);
  }

  static nsSize ToAppUnits(const LayoutDeviceSize& aSize, nscoord aAppUnitsPerDevPixel) {
    return nsSize(NSFloatPixelsToAppUnits(aSize.width, aAppUnitsPerDevPixel),
                  NSFloatPixelsToAppUnits(aSize.height, aAppUnitsPerDevPixel));
  }

  static nsRect ToAppUnits(const LayoutDeviceIntRect& aRect, nscoord aAppUnitsPerDevPixel) {
    return nsRect(aRect.x * aAppUnitsPerDevPixel,
                  aRect.y * aAppUnitsPerDevPixel,
                  aRect.width * aAppUnitsPerDevPixel,
                  aRect.height * aAppUnitsPerDevPixel);
  }

  static nsRect ToAppUnits(const LayoutDeviceRect& aRect, nscoord aAppUnitsPerDevPixel) {
    return nsRect(NSFloatPixelsToAppUnits(aRect.x, aAppUnitsPerDevPixel),
                  NSFloatPixelsToAppUnits(aRect.y, aAppUnitsPerDevPixel),
                  NSFloatPixelsToAppUnits(aRect.width, aAppUnitsPerDevPixel),
                  NSFloatPixelsToAppUnits(aRect.height, aAppUnitsPerDevPixel));
  }
};
struct LayerPixel {
};







struct CSSTransformedLayerPixel {

};
struct RenderTargetPixel {
};
struct ScreenPixel {
};
struct ParentLayerPixel {
};
struct DesktopPixel {
};



template<class src, class dst>
gfx::CoordTyped<dst> operator*(const gfx::CoordTyped<src>& aCoord, const gfx::ScaleFactor<src, dst>& aScale) {
  return gfx::CoordTyped<dst>(aCoord.value * aScale.scale);
}

template<class src, class dst>
gfx::CoordTyped<dst> operator/(const gfx::CoordTyped<src>& aCoord, const gfx::ScaleFactor<dst, src>& aScale) {
  return gfx::CoordTyped<dst>(aCoord.value / aScale.scale);
}

template<class src, class dst>
gfx::PointTyped<dst> operator*(const gfx::PointTyped<src>& aPoint, const gfx::ScaleFactor<src, dst>& aScale) {
  return gfx::PointTyped<dst>(aPoint.x * aScale.scale,
                              aPoint.y * aScale.scale);
}

template<class src, class dst>
gfx::PointTyped<dst> operator/(const gfx::PointTyped<src>& aPoint, const gfx::ScaleFactor<dst, src>& aScale) {
  return gfx::PointTyped<dst>(aPoint.x / aScale.scale,
                              aPoint.y / aScale.scale);
}

template<class src, class dst>
gfx::PointTyped<dst> operator*(const gfx::PointTyped<src>& aPoint, const gfx::ScaleFactors2D<src, dst>& aScale) {
  return gfx::PointTyped<dst>(aPoint.x * aScale.xScale,
                              aPoint.y * aScale.yScale);
}

template<class src, class dst>
gfx::PointTyped<dst> operator/(const gfx::PointTyped<src>& aPoint, const gfx::ScaleFactors2D<dst, src>& aScale) {
  return gfx::PointTyped<dst>(aPoint.x / aScale.xScale,
                              aPoint.y / aScale.yScale);
}

template<class src, class dst>
gfx::PointTyped<dst> operator*(const gfx::IntPointTyped<src>& aPoint, const gfx::ScaleFactor<src, dst>& aScale) {
  return gfx::PointTyped<dst>(float(aPoint.x) * aScale.scale,
                              float(aPoint.y) * aScale.scale);
}

template<class src, class dst>
gfx::PointTyped<dst> operator/(const gfx::IntPointTyped<src>& aPoint, const gfx::ScaleFactor<dst, src>& aScale) {
  return gfx::PointTyped<dst>(float(aPoint.x) / aScale.scale,
                              float(aPoint.y) / aScale.scale);
}

template<class src, class dst>
gfx::PointTyped<dst> operator*(const gfx::IntPointTyped<src>& aPoint, const gfx::ScaleFactors2D<src, dst>& aScale) {
  return gfx::PointTyped<dst>(float(aPoint.x) * aScale.xScale,
                              float(aPoint.y) * aScale.yScale);
}

template<class src, class dst>
gfx::PointTyped<dst> operator/(const gfx::IntPointTyped<src>& aPoint, const gfx::ScaleFactors2D<dst, src>& aScale) {
  return gfx::PointTyped<dst>(float(aPoint.x) / aScale.xScale,
                              float(aPoint.y) / aScale.yScale);
}

template<class src, class dst>
gfx::RectTyped<dst> operator*(const gfx::RectTyped<src>& aRect, const gfx::ScaleFactor<src, dst>& aScale) {
  return gfx::RectTyped<dst>(aRect.x * aScale.scale,
                             aRect.y * aScale.scale,
                             aRect.width * aScale.scale,
                             aRect.height * aScale.scale);
}

template<class src, class dst>
gfx::RectTyped<dst> operator/(const gfx::RectTyped<src>& aRect, const gfx::ScaleFactor<dst, src>& aScale) {
  return gfx::RectTyped<dst>(aRect.x / aScale.scale,
                             aRect.y / aScale.scale,
                             aRect.width / aScale.scale,
                             aRect.height / aScale.scale);
}

template<class src, class dst>
gfx::RectTyped<dst> operator*(const gfx::RectTyped<src>& aRect, const gfx::ScaleFactors2D<src, dst>& aScale) {
  return gfx::RectTyped<dst>(aRect.x * aScale.xScale,
                             aRect.y * aScale.yScale,
                             aRect.width * aScale.xScale,
                             aRect.height * aScale.yScale);
}

template<class src, class dst>
gfx::RectTyped<dst> operator/(const gfx::RectTyped<src>& aRect, const gfx::ScaleFactors2D<dst, src>& aScale) {
  return gfx::RectTyped<dst>(aRect.x / aScale.xScale,
                             aRect.y / aScale.yScale,
                             aRect.width / aScale.xScale,
                             aRect.height / aScale.yScale);
}

template<class src, class dst>
gfx::RectTyped<dst> operator*(const gfx::IntRectTyped<src>& aRect, const gfx::ScaleFactor<src, dst>& aScale) {
  return gfx::RectTyped<dst>(float(aRect.x) * aScale.scale,
                             float(aRect.y) * aScale.scale,
                             float(aRect.width) * aScale.scale,
                             float(aRect.height) * aScale.scale);
}

template<class src, class dst>
gfx::RectTyped<dst> operator/(const gfx::IntRectTyped<src>& aRect, const gfx::ScaleFactor<dst, src>& aScale) {
  return gfx::RectTyped<dst>(float(aRect.x) / aScale.scale,
                             float(aRect.y) / aScale.scale,
                             float(aRect.width) / aScale.scale,
                             float(aRect.height) / aScale.scale);
}

template<class src, class dst>
gfx::RectTyped<dst> operator*(const gfx::IntRectTyped<src>& aRect, const gfx::ScaleFactors2D<src, dst>& aScale) {
  return gfx::RectTyped<dst>(float(aRect.x) * aScale.xScale,
                             float(aRect.y) * aScale.yScale,
                             float(aRect.width) * aScale.xScale,
                             float(aRect.height) * aScale.yScale);
}

template<class src, class dst>
gfx::RectTyped<dst> operator/(const gfx::IntRectTyped<src>& aRect, const gfx::ScaleFactors2D<dst, src>& aScale) {
  return gfx::RectTyped<dst>(float(aRect.x) / aScale.xScale,
                             float(aRect.y) / aScale.yScale,
                             float(aRect.width) / aScale.xScale,
                             float(aRect.height) / aScale.yScale);
}

template<class src, class dst>
gfx::SizeTyped<dst> operator*(const gfx::SizeTyped<src>& aSize, const gfx::ScaleFactor<src, dst>& aScale) {
  return gfx::SizeTyped<dst>(aSize.width * aScale.scale,
                             aSize.height * aScale.scale);
}

template<class src, class dst>
gfx::SizeTyped<dst> operator/(const gfx::SizeTyped<src>& aSize, const gfx::ScaleFactor<dst, src>& aScale) {
  return gfx::SizeTyped<dst>(aSize.width / aScale.scale,
                              aSize.height / aScale.scale);
}

template<class src, class dst>
gfx::SizeTyped<dst> operator*(const gfx::SizeTyped<src>& aSize, const gfx::ScaleFactors2D<src, dst>& aScale) {
  return gfx::SizeTyped<dst>(aSize.width * aScale.xScale,
                             aSize.height * aScale.yScale);
}

template<class src, class dst>
gfx::SizeTyped<dst> operator/(const gfx::SizeTyped<src>& aSize, const gfx::ScaleFactors2D<dst, src>& aScale) {
  return gfx::SizeTyped<dst>(aSize.width / aScale.xScale,
                             aSize.height / aScale.yScale);
}

template<class src, class dst>
gfx::SizeTyped<dst> operator*(const gfx::IntSizeTyped<src>& aSize, const gfx::ScaleFactor<src, dst>& aScale) {
  return gfx::SizeTyped<dst>(float(aSize.width) * aScale.scale,
                             float(aSize.height) * aScale.scale);
}

template<class src, class dst>
gfx::SizeTyped<dst> operator/(const gfx::IntSizeTyped<src>& aSize, const gfx::ScaleFactor<dst, src>& aScale) {
  return gfx::SizeTyped<dst>(float(aSize.width) / aScale.scale,
                             float(aSize.height) / aScale.scale);
}

template<class src, class dst>
gfx::SizeTyped<dst> operator*(const gfx::IntSizeTyped<src>& aSize, const gfx::ScaleFactors2D<src, dst>& aScale) {
  return gfx::SizeTyped<dst>(float(aSize.width) * aScale.xScale,
                             float(aSize.height) * aScale.yScale);
}

template<class src, class dst>
gfx::SizeTyped<dst> operator/(const gfx::IntSizeTyped<src>& aSize, const gfx::ScaleFactors2D<dst, src>& aScale) {
  return gfx::SizeTyped<dst>(float(aSize.width) / aScale.xScale,
                             float(aSize.height) / aScale.yScale);
}

template<class src, class dst>
gfx::MarginTyped<dst> operator*(const gfx::MarginTyped<src>& aMargin, const gfx::ScaleFactor<src, dst>& aScale) {
  return gfx::MarginTyped<dst>(aMargin.top * aScale.scale,
                               aMargin.right * aScale.scale,
                               aMargin.bottom * aScale.scale,
                               aMargin.left * aScale.scale);
}

template<class src, class dst>
gfx::MarginTyped<dst> operator/(const gfx::MarginTyped<src>& aMargin, const gfx::ScaleFactor<dst, src>& aScale) {
  return gfx::MarginTyped<dst>(aMargin.top / aScale.scale,
                               aMargin.right / aScale.scale,
                               aMargin.bottom / aScale.scale,
                               aMargin.left / aScale.scale);
}

template<class src, class dst>
gfx::MarginTyped<dst> operator*(const gfx::MarginTyped<src>& aMargin, const gfx::ScaleFactors2D<src, dst>& aScale) {
  return gfx::MarginTyped<dst>(aMargin.top * aScale.yScale,
                               aMargin.right * aScale.xScale,
                               aMargin.bottom * aScale.yScale,
                               aMargin.left * aScale.xScale);
}

template<class src, class dst>
gfx::MarginTyped<dst> operator/(const gfx::MarginTyped<src>& aMargin, const gfx::ScaleFactors2D<dst, src>& aScale) {
  return gfx::MarginTyped<dst>(aMargin.top / aScale.yScale,
                               aMargin.right / aScale.xScale,
                               aMargin.bottom / aScale.yScale,
                               aMargin.left / aScale.xScale);
}




template<class src, class dst>
gfx::ScaleFactor<src, dst> MaxScaleRatio(const gfx::SizeTyped<dst>& aDestSize, const gfx::SizeTyped<src>& aSrcSize) {
  return gfx::ScaleFactor<src, dst>(std::max(aDestSize.width / aSrcSize.width,
                                             aDestSize.height / aSrcSize.height));
}

template<class src, class dst>
gfx::ScaleFactor<src, dst> MinScaleRatio(const gfx::SizeTyped<dst>& aDestSize, const gfx::SizeTyped<src>& aSrcSize) {
  return gfx::ScaleFactor<src, dst>(std::min(aDestSize.width / aSrcSize.width,
                                             aDestSize.height / aSrcSize.height));
}

}





class nsDocShell;
class nsIDocument;
class nsIFrame;
class nsPresContext;
class nsViewManager;
class nsView;
class nsRenderingContext;
class nsIPageSequenceFrame;
class nsCanvasFrame;
class nsAString;
class nsCaret;
namespace mozilla {
class AccessibleCaretEventHub;
class CSSStyleSheet;
}
class nsFrameSelection;
class nsFrameManager;
class nsILayoutHistoryState;
class nsIReflowCallback;
class nsIDOMNode;
class nsCSSFrameConstructor;
class nsISelection;
template<class E> class nsCOMArray;
class AutoWeakFrame;
class WeakFrame;
class nsIScrollableFrame;
class gfxContext;
class nsIDOMEvent;
class nsDisplayList;
class nsDisplayListBuilder;
class nsPIDOMWindowOuter;
struct nsPoint;
class nsINode;
struct nsRect;
class nsRegion;
class nsRefreshDriver;
class nsARefreshObserver;
class nsAPostRefreshObserver;

class nsAccessibilityService;
namespace mozilla {
namespace a11y {
class DocAccessible;
}
}

struct nsArenaMemoryStats;
class nsITimer;

namespace mozilla {
class EventStates;

namespace dom {
class Element;
class Touch;
class Selection;
class ShadowRoot;
}

namespace layers {
class LayerManager;
}

namespace gfx {
class SourceSurface;
}
}
typedef struct CapturingContentInfo {

  bool mAllowed;
  bool mPointerLock;
  bool mRetargetToElement;
  bool mPreventDrag;
  mozilla::StaticRefPtr<nsIContent> mContent;
} CapturingContentInfo;
enum nsRectVisibility {
  nsRectVisibility_kVisible,
  nsRectVisibility_kAboveViewport,
  nsRectVisibility_kBelowViewport,
  nsRectVisibility_kLeftOfViewport,
  nsRectVisibility_kRightOfViewport
};
class nsIPresShell : public nsISupports
{
public:
  template<typename T, typename U> struct COMTypeInfo;

protected:
  typedef mozilla::layers::LayerManager LayerManager;
  typedef mozilla::gfx::SourceSurface SourceSurface;

  enum eRenderFlag {
    STATE_IGNORING_VIEWPORT_SCROLLING = 0x1,
    STATE_DRAWWINDOW_NOT_FLUSHING = 0x2
  };
  typedef uint8_t RenderFlags;

public:
  nsIPresShell();
  virtual void Destroy() = 0;

  bool IsDestroying() { return mIsDestroying; }
  void* AllocateFrame(nsQueryFrame::FrameIID aID, size_t aSize)
  {
    void* result = mFrameArena.AllocateByFrameID(aID, aSize);
    RecordAlloc(result);
    return result;
  }

  void FreeFrame(nsQueryFrame::FrameIID aID, void* aPtr)
  {
    RecordFree(aPtr);
    if (!mIsDestroying)
      mFrameArena.FreeByFrameID(aID, aPtr);
  }







  void* AllocateByObjectID(mozilla::ArenaObjectID aID, size_t aSize)
  {
    void* result = mFrameArena.AllocateByObjectID(aID, aSize);
    RecordAlloc(result);
    return result;
  }

  void FreeByObjectID(mozilla::ArenaObjectID aID, void* aPtr)
  {
    RecordFree(aPtr);
    if (!mIsDestroying)
      mFrameArena.FreeByObjectID(aID, aPtr);
  }
  void* AllocateMisc(size_t aSize)
  {
    void* result = mFrameArena.AllocateBySize(aSize);
    RecordAlloc(result);
    return result;
  }

  void FreeMisc(size_t aSize, void* aPtr)
  {
    RecordFree(aPtr);
    if (!mIsDestroying)
      mFrameArena.FreeBySize(aSize, aPtr);
  }

  template<typename T>
  void RegisterArenaRefPtr(mozilla::ArenaRefPtr<T>* aPtr)
  {
    mFrameArena.RegisterArenaRefPtr(aPtr);
  }

  template<typename T>
  void DeregisterArenaRefPtr(mozilla::ArenaRefPtr<T>* aPtr)
  {
    mFrameArena.DeregisterArenaRefPtr(aPtr);
  }

  void ClearArenaRefPtrs(mozilla::ArenaObjectID aObjectID)
  {
    mFrameArena.ClearArenaRefPtrs(aObjectID);
  }

  nsIDocument* GetDocument() const { return mDocument; }

  nsPresContext* GetPresContext() const { return mPresContext; }

  nsViewManager* GetViewManager() const { return mViewManager; }

  nsRefreshDriver* GetRefreshDriver() const;





  mozilla::a11y::DocAccessible* GetDocAccessible() const
  {
    return mDocAccessible;
  }




  void SetDocAccessible(mozilla::a11y::DocAccessible* aDocAccessible)
  {
    mDocAccessible = aDocAccessible;
  }



  mozilla::StyleSetHandle StyleSet() const { return mStyleSet; }

  nsCSSFrameConstructor* FrameConstructor() const { return mFrameConstructor; }

  nsFrameManager* FrameManager() const {


    return reinterpret_cast<nsFrameManager*>
                           (const_cast<nsIPresShell*>(this)->mFrameManager);
  }
  void SetAuthorStyleDisabled(bool aDisabled);
  bool GetAuthorStyleDisabled() const;
  void RestyleForCSSRuleChanges();





  virtual void UpdatePreferenceStyles() = 0;






  already_AddRefed<nsFrameSelection> FrameSelection();





  const nsFrameSelection* ConstFrameSelection() const { return mSelection; }



  virtual void BeginObservingDocument() = 0;


  virtual void EndObservingDocument() = 0;




  bool DidInitialize() const { return mDidInitialize; }
  virtual nsresult Initialize(nscoord aWidth, nscoord aHeight) = 0;





  virtual nsresult ResizeReflow(nscoord aWidth, nscoord aHeight, nscoord aOldWidth = 0, nscoord aOldHeight = 0) = 0;




  virtual nsresult ResizeReflowIgnoreOverride(nscoord aWidth, nscoord aHeight, nscoord aOldWidth, nscoord aOldHeight) = 0;




  virtual bool GetIsViewportOverridden() = 0;




  virtual bool IsLayoutFlushObserver() = 0;




  virtual void LoadComplete() = 0;




  virtual nsIFrame* GetRootFrameExternal() const;
  nsIFrame* GetRootFrame() const {

    return mFrameManager->GetRootFrame();



  }




  nsIFrame* GetRootScrollFrame() const;




  nsIScrollableFrame* GetRootScrollFrameAsScrollable() const;





  virtual nsIScrollableFrame* GetRootScrollFrameAsScrollableExternal() const;
  enum ScrollDirection { eHorizontal, eVertical, eEither };
  nsIScrollableFrame* GetFrameToScrollAsScrollable(ScrollDirection aDirection);





  virtual nsIPageSequenceFrame* GetPageSequenceFrame() const = 0;





  virtual nsCanvasFrame* GetCanvasFrame() const = 0;





  virtual nsIFrame* GetPlaceholderFrameFor(nsIFrame* aFrame) const = 0;
  enum IntrinsicDirty {

    eResize,
    eTreeChange,
    eStyleChange
  };
  enum ReflowRootHandling {
    ePositionOrSizeChange,
    eNoPositionOrSizeChange,
    eInferFromBitToAdd



  };
  virtual void FrameNeedsReflow(nsIFrame *aFrame,
                                IntrinsicDirty aIntrinsicDirty,
                                nsFrameState aBitToAdd,
                                ReflowRootHandling aRootHandling =
                                  eInferFromBitToAdd) = 0;




  virtual void MarkFixedFramesForReflow(IntrinsicDirty aIntrinsicDirty);
  virtual void FrameNeedsToContinueReflow(nsIFrame *aFrame) = 0;

  virtual void CancelAllPendingReflows() = 0;

  virtual void NotifyCounterStylesAreDirty() = 0;
  virtual void DestroyFramesFor(nsIContent* aContent,
                                nsIContent** aDestroyedFramesFor) = 0;





  virtual void CreateFramesFor(nsIContent* aContent) = 0;




  virtual nsresult RecreateFramesFor(nsIContent* aContent) = 0;

  void PostRecreateFramesFor(mozilla::dom::Element* aElement);
  void RestyleForAnimation(mozilla::dom::Element* aElement,
                           nsRestyleHint aHint);




  virtual void RecordShadowStyleChange(mozilla::dom::ShadowRoot* aShadowRoot) = 0;






  virtual bool IsSafeToFlush() const = 0;
public:
  void FlushPendingNotifications(mozilla::FlushType aType)
  {
    if (!NeedFlush(aType)) {
      return;
    }

    DoFlushPendingNotifications(aType);
  }

  void FlushPendingNotifications(mozilla::ChangesToFlush aType)
  {
    if (!NeedFlush(aType.mFlushType)) {
      return;
    }

    DoFlushPendingNotifications(aType);
  }

protected:



  virtual void DoFlushPendingNotifications(mozilla::FlushType aType) = 0;
  virtual void DoFlushPendingNotifications(mozilla::ChangesToFlush aType) = 0;

public:
  bool NeedFlush(mozilla::FlushType aType) const
  {




    do { } while (0);
    return mNeedStyleFlush ||
           (mNeedLayoutFlush &&
            aType >= mozilla::FlushType::InterruptibleLayout) ||
           aType >= mozilla::FlushType::Display ||
           mNeedThrottledAnimationFlush ||
           mInFlush;
  }

  inline void SetNeedStyleFlush();
  inline void SetNeedLayoutFlush();
  inline void SetNeedThrottledAnimationFlush();

  bool ObservingStyleFlushes() const { return mObservingStyleFlushes; }
  bool ObservingLayoutFlushes() const { return mObservingLayoutFlushes; }

  void ObserveStyleFlushes()
  {
    if (!ObservingStyleFlushes())
      DoObserveStyleFlushes();
  }

  bool NeedStyleFlush() const { return mNeedStyleFlush; }





  virtual nsresult PostReflowCallback(nsIReflowCallback* aCallback) = 0;
  virtual void CancelReflowCallback(nsIReflowCallback* aCallback) = 0;

  virtual void ClearFrameRefs(nsIFrame* aFrame) = 0;






  virtual already_AddRefed<gfxContext> CreateReferenceRenderingContext() = 0;
  virtual nsresult GoToAnchor(const nsAString& aAnchorName, bool aScroll,
                              uint32_t aAdditionalScrollFlags = 0) = 0;
  virtual nsresult ScrollToAnchor() = 0;

  enum {
    SCROLL_TOP = 0,
    SCROLL_BOTTOM = 100,
    SCROLL_LEFT = 0,
    SCROLL_RIGHT = 100,
    SCROLL_CENTER = 50,
    SCROLL_MINIMUM = -1
  };

  enum WhenToScroll {
    SCROLL_ALWAYS,
    SCROLL_IF_NOT_VISIBLE,
    SCROLL_IF_NOT_FULLY_VISIBLE
  };
  typedef struct ScrollAxis {
    int16_t mWhereToScroll;
    WhenToScroll mWhenToScroll : 8;
    bool mOnlyIfPerceivedScrollableDirection : 1;
    explicit ScrollAxis(int16_t aWhere = SCROLL_MINIMUM,
                        WhenToScroll aWhen = SCROLL_IF_NOT_FULLY_VISIBLE,
                        bool aOnlyIfPerceivedScrollableDirection = false) :
      mWhereToScroll(aWhere), mWhenToScroll(aWhen),
      mOnlyIfPerceivedScrollableDirection(aOnlyIfPerceivedScrollableDirection)
    {}
  } ScrollAxis;
  virtual nsresult ScrollContentIntoView(nsIContent* aContent,
                                                     ScrollAxis aVertical,
                                                     ScrollAxis aHorizontal,
                                                     uint32_t aFlags) = 0;

  enum {
    SCROLL_FIRST_ANCESTOR_ONLY = 0x01,
    SCROLL_OVERFLOW_HIDDEN = 0x02,
    SCROLL_NO_PARENT_FRAMES = 0x04,
    SCROLL_SMOOTH = 0x08,
    SCROLL_SMOOTH_AUTO = 0x10
  };
  virtual bool ScrollFrameRectIntoView(nsIFrame* aFrame,
                                       const nsRect& aRect,
                                       ScrollAxis aVertical,
                                       ScrollAxis aHorizontal,
                                       uint32_t aFlags) = 0;
  virtual nsRectVisibility GetRectVisibility(nsIFrame *aFrame,
                                             const nsRect &aRect,
                                             nscoord aMinTwips) const = 0;





  virtual void SetIgnoreFrameDestruction(bool aIgnore) = 0;






  virtual void NotifyDestroyingFrame(nsIFrame* aFrame) = 0;




  virtual already_AddRefed<mozilla::AccessibleCaretEventHub> GetAccessibleCaretEventHub() const = 0;




  virtual already_AddRefed<nsCaret> GetCaret() const = 0;




  virtual void SetCaret(nsCaret *aNewCaret) = 0;





  virtual void RestoreCaret() = 0;
  virtual nsresult SetSelectionFlags(int16_t aInEnable) = 0;






  int16_t GetSelectionFlags() const { return mSelectionFlags; }

  virtual mozilla::dom::Selection*
    GetCurrentSelection(mozilla::SelectionType aSelectionType) = 0;
  virtual already_AddRefed<nsISelectionController>
            GetSelectionControllerForFocusedContent(
              nsIContent** aFocusedContent = nullptr) = 0;





  virtual nsresult HandleEventWithTarget(
                                 mozilla::WidgetEvent* aEvent,
                                 nsIFrame* aFrame,
                                 nsIContent* aContent,
                                 nsEventStatus* aStatus) = 0;





  virtual nsresult HandleDOMEventWithTarget(
                                 nsIContent* aTargetContent,
                                 mozilla::WidgetEvent* aEvent,
                                 nsEventStatus* aStatus) = 0;





  virtual nsresult HandleDOMEventWithTarget(nsIContent* aTargetContent,
                                                        nsIDOMEvent* aEvent,
                                                        nsEventStatus* aStatus) = 0;




  virtual bool CanDispatchEvent(
      const mozilla::WidgetGUIEvent* aEvent = nullptr) const = 0;




  virtual nsIFrame* GetEventTargetFrame() = 0;




  virtual already_AddRefed<nsIContent> GetEventTargetContent(
                                                     mozilla::WidgetEvent* aEvent) = 0;





  virtual nsresult CaptureHistoryState(nsILayoutHistoryState** aLayoutHistoryState) = 0;





  bool IsReflowLocked() const { return mIsReflowing; }






  bool IsPaintingSuppressed() const { return mPaintingSuppressed; }






  virtual void PausePainting() = 0;






  virtual void ResumePainting() = 0;




  virtual void UnsuppressPainting() = 0;




  void DisableThemeSupport()
  {

    mIsThemeSupportDisabled = true;
  }




  bool IsThemeSupportEnabled() const { return !mIsThemeSupportDisabled; }




  virtual nsresult GetAgentStyleSheets(
      nsTArray<RefPtr<mozilla::StyleSheet>>& aSheets) = 0;




  virtual nsresult SetAgentStyleSheets(
      const nsTArray<RefPtr<mozilla::StyleSheet>>& aSheets) = 0;




  virtual nsresult AddOverrideStyleSheet(mozilla::StyleSheet* aSheet) = 0;




  virtual nsresult RemoveOverrideStyleSheet(mozilla::StyleSheet* aSheet) = 0;




  virtual void ReconstructFrames() = 0;




  virtual void ContentStateChanged(nsIDocument* aDocument,
                                   nsIContent* aContent,
                                   mozilla::EventStates aStateMask) = 0;






  static bool GetVerifyReflowEnable();




  static void SetVerifyReflowEnable(bool aEnabled);

  virtual nsIFrame* GetAbsoluteContainingBlock(nsIFrame* aFrame);


  virtual void DumpReflows() = 0;
  virtual void CountReflows(const char * aName, nsIFrame * aFrame) = 0;
  virtual void PaintCount(const char * aName,
                                      nsRenderingContext* aRenderingContext,
                                      nsPresContext * aPresContext,
                                      nsIFrame * aFrame,
                                      const nsPoint& aOffset,
                                      uint32_t aColor) = 0;
  virtual void SetPaintFrameCount(bool aOn) = 0;
  virtual bool IsPaintingFrameCounts() = 0;
  static bool IsAccessibilityActive();




  static nsAccessibilityService* AccService();







  virtual void Freeze() = 0;
  bool IsFrozen() { return mFrozen; }





  virtual void Thaw() = 0;

  virtual void FireOrClearDelayedEvents(bool aFireEvents) = 0;







  void SetForwardingContainer(const mozilla::WeakPtr<nsDocShell> &aContainer);
  enum {
    RENDER_IS_UNTRUSTED = 0x01,
    RENDER_IGNORE_VIEWPORT_SCROLLING = 0x02,
    RENDER_CARET = 0x04,
    RENDER_USE_WIDGET_LAYERS = 0x08,
    RENDER_ASYNC_DECODE_IMAGES = 0x10,
    RENDER_DOCUMENT_RELATIVE = 0x20,
    RENDER_DRAWWINDOW_NOT_FLUSHING = 0x40
  };
  virtual nsresult RenderDocument(const nsRect& aRect, uint32_t aFlags,
                                  nscolor aBackgroundColor,
                                  gfxContext* aRenderedContext) = 0;

  enum {
    RENDER_IS_IMAGE = 0x100,
    RENDER_AUTO_SCALE = 0x80
  };







  virtual already_AddRefed<mozilla::gfx::SourceSurface>
  RenderNode(nsIDOMNode* aNode,
             nsIntRegion* aRegion,
             const mozilla::LayoutDeviceIntPoint aPoint,
             mozilla::LayoutDeviceIntRect* aScreenRect,
             uint32_t aFlags) = 0;
  virtual already_AddRefed<mozilla::gfx::SourceSurface>
  RenderSelection(nsISelection* aSelection,
                  const mozilla::LayoutDeviceIntPoint aPoint,
                  mozilla::LayoutDeviceIntRect* aScreenRect,
                  uint32_t aFlags) = 0;

  void AddAutoWeakFrameInternal(AutoWeakFrame* aWeakFrame);
  virtual void AddAutoWeakFrameExternal(AutoWeakFrame* aWeakFrame);
  void AddWeakFrameInternal(WeakFrame* aWeakFrame);
  virtual void AddWeakFrameExternal(WeakFrame* aWeakFrame);

  void AddAutoWeakFrame(AutoWeakFrame* aWeakFrame)
  {

    AddAutoWeakFrameInternal(aWeakFrame);



  }
  void AddWeakFrame(WeakFrame* aWeakFrame)
  {

    AddWeakFrameInternal(aWeakFrame);



  }

  void RemoveAutoWeakFrameInternal(AutoWeakFrame* aWeakFrame);
  virtual void RemoveAutoWeakFrameExternal(AutoWeakFrame* aWeakFrame);
  void RemoveWeakFrameInternal(WeakFrame* aWeakFrame);
  virtual void RemoveWeakFrameExternal(WeakFrame* aWeakFrame);

  void RemoveAutoWeakFrame(AutoWeakFrame* aWeakFrame)
  {

    RemoveAutoWeakFrameInternal(aWeakFrame);



  }
  void RemoveWeakFrame(WeakFrame* aWeakFrame)
  {

    RemoveWeakFrameInternal(aWeakFrame);



  }
  virtual void DisableNonTestMouseEvents(bool aDisable) = 0;
  void SetCanvasBackground(nscolor aColor) { mCanvasBackgroundColor = aColor; }
  nscolor GetCanvasBackground() { return mCanvasBackgroundColor; }





  virtual void UpdateCanvasBackground() = 0;
  enum {
    FORCE_DRAW = 0x01
  };
  virtual void AddCanvasBackgroundColorItem(nsDisplayListBuilder& aBuilder,
                                            nsDisplayList& aList,
                                            nsIFrame* aFrame,
                                            const nsRect& aBounds,
                                            nscolor aBackstopColor = ((nscolor) (((0) << 24) | ((0)<<16) | ((0)<<8) | (0))),
                                            uint32_t aFlags = 0) = 0;







  virtual void AddPrintPreviewBackgroundItem(nsDisplayListBuilder& aBuilder,
                                             nsDisplayList& aList,
                                             nsIFrame* aFrame,
                                             const nsRect& aBounds) = 0;






  virtual nscolor ComputeBackstopColor(nsView* aDisplayRoot) = 0;

  void ObserveNativeAnonMutationsForPrint(bool aObserve)
  {
    mObservesMutationsForPrint = aObserve;
  }
  bool ObservesNativeAnonMutationsForPrint()
  {
    return mObservesMutationsForPrint;
  }

  virtual nsresult SetIsActive(bool aIsActive) = 0;

  bool IsActive()
  {
    return mIsActive;
  }


  static CapturingContentInfo gCaptureInfo;

  class PointerCaptureInfo final
  {
  public:
    nsCOMPtr<nsIContent> mPendingContent;
    nsCOMPtr<nsIContent> mOverrideContent;

    explicit PointerCaptureInfo(nsIContent* aPendingContent)
      : mPendingContent(aPendingContent)
    {
                                        ;
    }

    ~PointerCaptureInfo()
    {
                                        ;
    }

    bool Empty()
    {
      return !(mPendingContent || mOverrideContent);
    }
  };

  class PointerInfo final
  {
  public:
    uint16_t mPointerType;
    bool mActiveState;
    bool mPrimaryState;
    bool mPreventMouseEventByContent;
    explicit PointerInfo(bool aActiveState, uint16_t aPointerType,
                         bool aPrimaryState)
      : mPointerType(aPointerType)
      , mActiveState(aActiveState)
      , mPrimaryState(aPrimaryState)
      , mPreventMouseEventByContent(false)
    {
    }
  };

  static void DispatchGotOrLostPointerCaptureEvent(
                bool aIsGotCapture,
                const mozilla::WidgetPointerEvent* aPointerEvent,
                nsIContent* aCaptureTarget);

  static PointerCaptureInfo* GetPointerCaptureInfo(uint32_t aPointerId);
  static void SetPointerCapturingContent(uint32_t aPointerId,
                                         nsIContent* aContent);
  static void ReleasePointerCapturingContent(uint32_t aPointerId);
  static nsIContent* GetPointerCapturingContent(uint32_t aPointerId);



  static void CheckPointerCaptureState(
                const mozilla::WidgetPointerEvent* aPointerEvent);





  static bool GetPointerInfo(uint32_t aPointerId, bool& aActiveState);



  static uint16_t GetPointerType(uint32_t aPointerId);



  static bool GetPointerPrimaryState(uint32_t aPointerId);
  static void SetCapturingContent(nsIContent* aContent, uint8_t aFlags);




  static nsIContent* GetCapturingContent()
  {
    return gCaptureInfo.mContent;
  }




  static void AllowMouseCapture(bool aAllowed)
  {
    gCaptureInfo.mAllowed = aAllowed;
  }





  static bool IsMouseCapturePreventingDrag()
  {
    return gCaptureInfo.mPreventDrag && gCaptureInfo.mContent;
  }





  uint64_t GetPaintCount() { return mPaintCount; }
  void IncrementPaintCount() { ++mPaintCount; }




  virtual already_AddRefed<nsPIDOMWindowOuter> GetRootWindow() = 0;





  virtual LayerManager* GetLayerManager() = 0;





  virtual bool AsyncPanZoomEnabled() = 0;






  virtual void SetIgnoreViewportScrolling(bool aIgnore) = 0;
  bool IgnoringViewportScrolling() const
  { return mRenderFlags & STATE_IGNORING_VIEWPORT_SCROLLING; }
  virtual nsresult SetResolution(float aResolution) = 0;
  float GetResolution() const { return mResolution.valueOr(1.0); }
  virtual float GetCumulativeResolution() = 0;





  virtual float GetCumulativeNonRootScaleResolution() = 0;




  bool IsResolutionSet() { return mResolution.isSome(); }





  virtual nsresult SetResolutionAndScaleTo(float aResolution) = 0;






  virtual bool ScaleToResolution() const = 0;





  virtual void SetRestoreResolution(float aResolution,
                                    mozilla::LayoutDeviceIntSize aDisplaySize) = 0;





  bool InDrawWindowNotFlushing() const
  { return mRenderFlags & STATE_DRAWWINDOW_NOT_FLUSHING; }




  void SetIsFirstPaint(bool aIsFirstPaint) { mIsFirstPaint = aIsFirstPaint; }




  bool GetIsFirstPaint() const { return mIsFirstPaint; }

  uint32_t GetPresShellId() { return mPresShellId; }






  virtual void SynthesizeMouseMove(bool aFromScroll) = 0;

  enum PaintFlags {



    PAINT_LAYERS = 0x01,

    PAINT_COMPOSITE = 0x02,

    PAINT_SYNC_DECODE_IMAGES = 0x04
  };
  virtual void Paint(nsView* aViewToPaint, const nsRegion& aDirtyRegion,
                     uint32_t aFlags) = 0;
  virtual nsresult HandleEvent(nsIFrame* aFrame,
                               mozilla::WidgetGUIEvent* aEvent,
                               bool aDontRetargetEvents,
                               nsEventStatus* aEventStatus,
                               nsIContent** aTargetContent = nullptr) = 0;
  virtual bool ShouldIgnoreInvalidation() = 0;







  virtual void WillPaint() = 0;





  virtual void WillPaintWindow() = 0;





  virtual void DidPaintWindow() = 0;
  enum PaintType {
    PAINT_DEFAULT,
    PAINT_DELAYED_COMPRESS
  };
  virtual void ScheduleViewManagerFlush(PaintType aType = PAINT_DEFAULT) = 0;
  virtual void ClearMouseCaptureOnView(nsView* aView) = 0;
  virtual bool IsVisible() = 0;
  virtual void DispatchSynthMouseMove(mozilla::WidgetGUIEvent* aEvent,
                                      bool aFlushOnHoverChange) = 0;

  virtual void AddSizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf,
                                      nsArenaMemoryStats *aArenaObjectsSize,
                                      size_t *aPresShellSize,
                                      size_t *aStyleSetsSize,
                                      size_t *aTextRunsSize,
                                      size_t *aPresContextSize) = 0;




  uint32_t FontSizeInflationEmPerLine() const {
    return mFontSizeInflationEmPerLine;
  }

  uint32_t FontSizeInflationMinTwips() const {
    return mFontSizeInflationMinTwips;
  }

  uint32_t FontSizeInflationLineThreshold() const {
    return mFontSizeInflationLineThreshold;
  }

  bool FontSizeInflationForceEnabled() const {
    return mFontSizeInflationForceEnabled;
  }

  bool FontSizeInflationDisabledInMasterProcess() const {
    return mFontSizeInflationDisabledInMasterProcess;
  }







  bool FontSizeInflationEnabled();







  void NotifyFontSizeInflationEnabledIsDirty()
  {
    mFontSizeInflationEnabledIsDirty = true;
  }
  virtual void ScheduleApproximateFrameVisibilityUpdateSoon() = 0;





  virtual void ScheduleApproximateFrameVisibilityUpdateNow() = 0;



  virtual void RebuildApproximateFrameVisibilityDisplayList(const nsDisplayList& aList) = 0;
  virtual void RebuildApproximateFrameVisibility(nsRect* aRect = nullptr,
                                                 bool aRemoveOnly = false) = 0;


  virtual void EnsureFrameInApproximatelyVisibleList(nsIFrame* aFrame) = 0;


  virtual void RemoveFrameFromApproximatelyVisibleList(nsIFrame* aFrame) = 0;


  virtual bool AssumeAllFramesVisible() = 0;
  nsresult HasRuleProcessorUsedByMultipleStyleSets(uint32_t aSheetType,
                                                   bool* aRetVal);




protected:
  virtual bool AddRefreshObserverExternal(nsARefreshObserver* aObserver,
                                          mozilla::FlushType aFlushType);
  bool AddRefreshObserverInternal(nsARefreshObserver* aObserver,
                                  mozilla::FlushType aFlushType);
  virtual bool RemoveRefreshObserverExternal(nsARefreshObserver* aObserver,
                                             mozilla::FlushType aFlushType);
  bool RemoveRefreshObserverInternal(nsARefreshObserver* aObserver,
                                     mozilla::FlushType aFlushType);

  void DoObserveStyleFlushes();
  void DoObserveLayoutFlushes();






  void RecomputeFontSizeInflationEnabled();




  bool DetermineFontSizeInflationState();





  void HandleSystemFontScale();

  void RecordAlloc(void* aPtr) {




  }

  void RecordFree(void* aPtr) {




  }

public:
  bool AddRefreshObserver(nsARefreshObserver* aObserver,
                          mozilla::FlushType aFlushType) {

    return AddRefreshObserverInternal(aObserver, aFlushType);



  }

  bool RemoveRefreshObserver(nsARefreshObserver* aObserver,
                             mozilla::FlushType aFlushType) {

    return RemoveRefreshObserverInternal(aObserver, aFlushType);



  }

  virtual bool AddPostRefreshObserver(nsAPostRefreshObserver* aObserver);
  virtual bool RemovePostRefreshObserver(nsAPostRefreshObserver* aObserver);




  static void InitializeStatics();
  static void ReleaseStatics();



  static void ClearMouseCapture(nsIFrame* aFrame);

  void SetScrollPositionClampingScrollPortSize(nscoord aWidth, nscoord aHeight);
  bool IsScrollPositionClampingScrollPortSizeSet() {
    return mScrollPositionClampingScrollPortSizeSet;
  }
  nsSize GetScrollPositionClampingScrollPortSize() {
    do { } while(0);
    return mScrollPositionClampingScrollPortSize;
  }

  virtual void WindowSizeMoveDone() = 0;
  virtual void SysColorChanged() = 0;
  virtual void ThemeChanged() = 0;
  virtual void BackingScaleFactorChanged() = 0;




  bool IsNeverPainting() {
    return mIsNeverPainting;
  }

  void SetNeverPainting(bool aNeverPainting) {
    mIsNeverPainting = aNeverPainting;
  }

  bool HasPendingReflow() const
    { return mObservingLayoutFlushes || mReflowContinueTimer; }

  void SyncWindowProperties(nsView* aView);

  virtual nsIDocument* GetPrimaryContentDocument() = 0;


  virtual void NotifyStyleSheetServiceSheetAdded(mozilla::StyleSheet* aSheet,
                                                 uint32_t aSheetType) = 0;
  virtual void NotifyStyleSheetServiceSheetRemoved(mozilla::StyleSheet* aSheet,
                                                   uint32_t aSheetType) = 0;

protected:
  friend class nsRefreshDriver;







  nsCOMPtr<nsIDocument> mDocument;
  RefPtr<nsPresContext> mPresContext;
  mozilla::StyleSetHandle mStyleSet;
  nsCSSFrameConstructor* mFrameConstructor;
  nsViewManager* mViewManager;
  nsPresArena mFrameArena;
  RefPtr<nsFrameSelection> mSelection;


  nsFrameManagerBase* mFrameManager;
  mozilla::WeakPtr<nsDocShell> mForwardingContainer;

  mozilla::a11y::DocAccessible* mDocAccessible;






  nsCOMPtr<nsITimer> mReflowContinueTimer;
  uint64_t mPaintCount;

  nsSize mScrollPositionClampingScrollPortSize;


  AutoWeakFrame* mAutoWeakFrames;


  nsTHashtable<nsPtrHashKey<WeakFrame>> mWeakFrames;


  nscolor mCanvasBackgroundColor;



  mozilla::Maybe<float> mResolution;

  int16_t mSelectionFlags;






  RenderFlags mRenderFlags;




  bool mStylesHaveChanged : 1;
  bool mDidInitialize : 1;
  bool mIsDestroying : 1;
  bool mIsReflowing : 1;


  bool mPaintingSuppressed : 1;


  bool mIsThemeSupportDisabled : 1;

  bool mIsActive : 1;
  bool mFrozen : 1;
  bool mIsFirstPaint : 1;
  bool mObservesMutationsForPrint : 1;

  bool mSuppressInterruptibleReflows : 1;
  bool mScrollPositionClampingScrollPortSizeSet : 1;


  bool mNeedLayoutFlush : 1;


  bool mNeedStyleFlush : 1;


  bool mObservingStyleFlushes: 1;





  bool mObservingLayoutFlushes: 1;



  bool mNeedThrottledAnimationFlush : 1;

  uint32_t mPresShellId;
  AutoTArray<RefPtr<mozilla::dom::Element>,1> mChangedScopeStyleRoots;

  static nsIContent* gKeyDownTarget;



  uint32_t mFontSizeInflationEmPerLine;
  uint32_t mFontSizeInflationMinTwips;
  uint32_t mFontSizeInflationLineThreshold;
  bool mFontSizeInflationForceEnabled;
  bool mFontSizeInflationDisabledInMasterProcess;
  bool mFontSizeInflationEnabled;


  bool mFontSizeInflationEnabledIsDirty;

  bool mPaintingIsFrozen;




  bool mIsNeverPainting;



  bool mInFlush;
};

template<typename T> struct nsIPresShell::COMTypeInfo<nsIPresShell, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIPresShell::COMTypeInfo<nsIPresShell, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0xa75573d6, 0x34c8, 0x4485, { 0x8f, 0xb7, 0xed, 0xcb, 0x6f, 0xc7, 0x0e, 0x12 } };

namespace mozilla {







enum FontFamilyType : uint32_t {
  eFamily_none = 0,


  eFamily_named,
  eFamily_named_quoted,


  eFamily_serif,
  eFamily_sans_serif,
  eFamily_monospace,
  eFamily_cursive,
  eFamily_fantasy,


  eFamily_moz_variable,
  eFamily_moz_fixed,

  eFamily_generic_first = eFamily_serif,
  eFamily_generic_last = eFamily_fantasy,
  eFamily_generic_count = (eFamily_fantasy - eFamily_serif + 1)
};

enum QuotedName { eQuotedName, eUnquotedName };






struct FontFamilyName final {
    FontFamilyName()
        : mType(eFamily_named)
    {}


    explicit FontFamilyName(const nsAString& aFamilyName,
                            QuotedName aQuoted = eUnquotedName) {
        mType = (aQuoted == eQuotedName) ? eFamily_named_quoted : eFamily_named;
        mName = aFamilyName;
    }


    explicit FontFamilyName(FontFamilyType aType) {
        do { } while(0);



        mName.Truncate();
        mType = aType;
    }

    FontFamilyName(const FontFamilyName& aCopy) {
        mType = aCopy.mType;
        mName = aCopy.mName;
    }

    bool IsNamed() const {
        return mType == eFamily_named || mType == eFamily_named_quoted;
    }

    bool IsGeneric() const {
        return !IsNamed();
    }

    void AppendToString(nsAString& aFamilyList, bool aQuotes = true) const {
        switch (mType) {
            case eFamily_named:
                aFamilyList.Append(mName);
                break;
            case eFamily_named_quoted:
                if (aQuotes) {
                    aFamilyList.Append('"');
                }
                aFamilyList.Append(mName);
                if (aQuotes) {
                    aFamilyList.Append('"');
                }
                break;
            case eFamily_serif:
                aFamilyList.AppendLiteral("serif");
                break;
            case eFamily_sans_serif:
                aFamilyList.AppendLiteral("sans-serif");
                break;
            case eFamily_monospace:
                aFamilyList.AppendLiteral("monospace");
                break;
            case eFamily_cursive:
                aFamilyList.AppendLiteral("cursive");
                break;
            case eFamily_fantasy:
                aFamilyList.AppendLiteral("fantasy");
                break;
            case eFamily_moz_fixed:
                aFamilyList.AppendLiteral("-moz-fixed");
                break;
            default:
                break;
        }
    }


    static FontFamilyName
    Convert(const nsAString& aFamilyOrGenericName) {



        do { } while(0);


        FontFamilyType genericType = eFamily_none;
        if (aFamilyOrGenericName.LowerCaseEqualsLiteral("serif")) {
            genericType = eFamily_serif;
        } else if (aFamilyOrGenericName.LowerCaseEqualsLiteral("sans-serif")) {
            genericType = eFamily_sans_serif;
        } else if (aFamilyOrGenericName.LowerCaseEqualsLiteral("monospace")) {
            genericType = eFamily_monospace;
        } else if (aFamilyOrGenericName.LowerCaseEqualsLiteral("cursive")) {
            genericType = eFamily_cursive;
        } else if (aFamilyOrGenericName.LowerCaseEqualsLiteral("fantasy")) {
            genericType = eFamily_fantasy;
        } else if (aFamilyOrGenericName.LowerCaseEqualsLiteral("-moz-fixed")) {
            genericType = eFamily_moz_fixed;
        } else {
            return FontFamilyName(aFamilyOrGenericName, eUnquotedName);
        }

        return FontFamilyName(genericType);
    }


    size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const {
        return mName.SizeOfExcludingThisIfUnshared(aMallocSizeOf);
    }

    FontFamilyType mType;
    nsString mName;
};

inline bool
operator==(const FontFamilyName& a, const FontFamilyName& b) {
    return a.mType == b.mType && a.mName == b.mName;
}







class FontFamilyList {
public:
    FontFamilyList()
        : mDefaultFontType(eFamily_none)
    {
    }

    explicit FontFamilyList(FontFamilyType aGenericType)
        : mDefaultFontType(eFamily_none)
    {
        Append(FontFamilyName(aGenericType));
    }

    FontFamilyList(const nsAString& aFamilyName,
                   QuotedName aQuoted)
        : mDefaultFontType(eFamily_none)
    {
        Append(FontFamilyName(aFamilyName, aQuoted));
    }

    FontFamilyList(const FontFamilyList& aOther)
        : mFontlist(aOther.mFontlist)
        , mDefaultFontType(aOther.mDefaultFontType)
    {
    }

    void Append(const FontFamilyName& aFamilyName) {
        mFontlist.AppendElement(aFamilyName);
    }

    void Append(const nsTArray<nsString>& aFamilyNameList) {
        uint32_t len = aFamilyNameList.Length();
        for (uint32_t i = 0; i < len; i++) {
            mFontlist.AppendElement(FontFamilyName(aFamilyNameList[i],
                                                   eUnquotedName));
        }
    }

    void Clear() {
        mFontlist.Clear();
    }

    uint32_t Length() const {
        return mFontlist.Length();
    }

    bool IsEmpty() const {
      return mFontlist.IsEmpty();
    }

    const nsTArray<FontFamilyName>& GetFontlist() const {
        return mFontlist;
    }

    bool Equals(const FontFamilyList& aFontlist) const {
        return mFontlist == aFontlist.mFontlist &&
               mDefaultFontType == aFontlist.mDefaultFontType;
    }

    FontFamilyType FirstGeneric() const {
        uint32_t len = mFontlist.Length();
        for (uint32_t i = 0; i < len; i++) {
            const FontFamilyName& name = mFontlist[i];
            if (name.IsGeneric()) {
                return name.mType;
            }
        }
        return eFamily_none;
    }

    bool HasGeneric() const {
        return FirstGeneric() != eFamily_none;
    }

    bool HasDefaultGeneric() const {
        uint32_t len = mFontlist.Length();
        for (uint32_t i = 0; i < len; i++) {
            const FontFamilyName& name = mFontlist[i];
            if (name.mType == mDefaultFontType) {
                return true;
            }
        }
        return false;
    }




    bool PrioritizeFirstGeneric() {
        uint32_t len = mFontlist.Length();
        for (uint32_t i = 0; i < len; i++) {
            const FontFamilyName name = mFontlist[i];
            if (name.IsGeneric()) {
                if (name.mType == eFamily_cursive ||
                    name.mType == eFamily_fantasy) {
                    continue;
                }
                if (i > 0) {
                    mFontlist.RemoveElementAt(i);
                    mFontlist.InsertElementAt(0, name);
                }
                return true;
            }
        }
        return false;
    }

    void PrependGeneric(FontFamilyType aType) {
        mFontlist.InsertElementAt(0, FontFamilyName(aType));
    }

    void ToString(nsAString& aFamilyList,
                  bool aQuotes = true,
                  bool aIncludeDefault = false) const {
        aFamilyList.Truncate();
        uint32_t len = mFontlist.Length();
        for (uint32_t i = 0; i < len; i++) {
            if (i != 0) {
                aFamilyList.Append(',');
            }
            const FontFamilyName& name = mFontlist[i];
            name.AppendToString(aFamilyList, aQuotes);
        }
        if (aIncludeDefault && mDefaultFontType != eFamily_none) {
            if (!aFamilyList.IsEmpty()) {
                aFamilyList.Append(',');
            }
            if (mDefaultFontType == eFamily_serif) {
                aFamilyList.AppendLiteral("serif");
            } else {
                aFamilyList.AppendLiteral("sans-serif");
            }
        }
    }


    bool Contains(const nsAString& aFamilyName) const {
        uint32_t len = mFontlist.Length();
        nsAutoString fam(aFamilyName);
        ToLowerCase(fam);
        for (uint32_t i = 0; i < len; i++) {
            const FontFamilyName& name = mFontlist[i];
            if (name.mType != eFamily_named &&
                name.mType != eFamily_named_quoted) {
                continue;
            }
            nsAutoString listname(name.mName);
            ToLowerCase(listname);
            if (listname.Equals(fam)) {
                return true;
            }
        }
        return false;
    }

    FontFamilyType GetDefaultFontType() const { return mDefaultFontType; }
    void SetDefaultFontType(FontFamilyType aType) {
        do { } while(0);


        mDefaultFontType = aType;
    }


    size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const {
        size_t n = 0;
        n += mFontlist.ShallowSizeOfExcludingThis(aMallocSizeOf);
        for (size_t i = 0; i < mFontlist.Length(); i++) {
            n += mFontlist[i].SizeOfExcludingThis(aMallocSizeOf);
        }
        return n;
    }

    size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const {
        return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
    }

private:
    nsTArray<FontFamilyName> mFontlist;
    FontFamilyType mDefaultFontType;
};

inline bool
operator==(const FontFamilyList& a, const FontFamilyList& b) {
    return a.Equals(b);
}

}
enum {
    eFeatureAlternates_historical,
    eFeatureAlternates_stylistic,
    eFeatureAlternates_styleset,
    eFeatureAlternates_character_variant,
    eFeatureAlternates_swash,
    eFeatureAlternates_ornaments,
    eFeatureAlternates_annotation,

    eFeatureAlternates_numFeatures
};
enum {
    eFeatureEastAsian_jis78,
    eFeatureEastAsian_jis83,
    eFeatureEastAsian_jis90,
    eFeatureEastAsian_jis04,
    eFeatureEastAsian_simplified,
    eFeatureEastAsian_traditional,
    eFeatureEastAsian_full_width,
    eFeatureEastAsian_prop_width,
    eFeatureEastAsian_ruby,

    eFeatureEastAsian_numFeatures
};
enum {
    eFeatureLigatures_none,
    eFeatureLigatures_common,
    eFeatureLigatures_no_common,
    eFeatureLigatures_discretionary,
    eFeatureLigatures_no_discretionary,
    eFeatureLigatures_historical,
    eFeatureLigatures_no_historical,
    eFeatureLigatures_contextual,
    eFeatureLigatures_no_contextual,

    eFeatureLigatures_numFeatures
};
enum {
    eFeatureNumeric_lining,
    eFeatureNumeric_oldstyle,
    eFeatureNumeric_proportional,
    eFeatureNumeric_tabular,
    eFeatureNumeric_diagonal_fractions,
    eFeatureNumeric_stacked_fractions,
    eFeatureNumeric_slashedzero,
    eFeatureNumeric_ordinal,

    eFeatureNumeric_numFeatures
};
enum eFontPrefLang {









eFontPrefLang_Western,
eFontPrefLang_Japanese,
eFontPrefLang_ChineseTW,
eFontPrefLang_ChineseCN,
eFontPrefLang_ChineseHK,
eFontPrefLang_Korean,
eFontPrefLang_Cyrillic,
eFontPrefLang_Greek,
eFontPrefLang_Thai,
eFontPrefLang_Hebrew,
eFontPrefLang_Arabic,
eFontPrefLang_Devanagari,
eFontPrefLang_Tamil,
eFontPrefLang_Armenian,
eFontPrefLang_Bengali,
eFontPrefLang_Canadian,
eFontPrefLang_Ethiopic,
eFontPrefLang_Georgian,
eFontPrefLang_Gujarati,
eFontPrefLang_Gurmukhi,
eFontPrefLang_Khmer,
eFontPrefLang_Malayalam,
eFontPrefLang_Mathematics,
eFontPrefLang_Oriya,
eFontPrefLang_Telugu,
eFontPrefLang_Kannada,
eFontPrefLang_Sinhala,
eFontPrefLang_Tibetan,
eFontPrefLang_Others


    , eFontPrefLang_CJKSet
    , eFontPrefLang_First = eFontPrefLang_Western
    , eFontPrefLang_Last = eFontPrefLang_Others
    , eFontPrefLang_Count = (eFontPrefLang_Last - eFontPrefLang_First + 1)
};
struct gfxFontFeature {
    uint32_t mTag;
    uint32_t mValue;

};

inline bool
operator<(const gfxFontFeature& a, const gfxFontFeature& b)
{
    return (a.mTag < b.mTag) || ((a.mTag == b.mTag) && (a.mValue < b.mValue));
}

inline bool
operator==(const gfxFontFeature& a, const gfxFontFeature& b)
{
    return (a.mTag == b.mTag) && (a.mValue == b.mValue);
}

struct gfxAlternateValue {
    uint32_t alternate;
    nsString value;
};

inline bool
operator<(const gfxAlternateValue& a, const gfxAlternateValue& b)
{
    return (a.alternate < b.alternate) ||
        ((a.alternate == b.alternate) && (a.value < b.value));
}

inline bool
operator==(const gfxAlternateValue& a, const gfxAlternateValue& b)
{
    return (a.alternate == b.alternate) && (a.value == b.value);
}

class gfxFontFeatureValueSet final {
public:
    public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<gfxFontFeatureValueSet>::value, "Reference-counted class " "gfxFontFeatureValueSet" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); ++mRefCnt; ; return mRefCnt; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); --mRefCnt; ; if (mRefCnt == 0) { mRefCnt = 1; delete(this); return 0; } return mRefCnt; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:

    gfxFontFeatureValueSet();

    struct ValueList {
        ValueList(const nsAString& aName, const nsTArray<uint32_t>& aSelectors)
          : name(aName), featureSelectors(aSelectors)
        {}
        nsString name;
        nsTArray<uint32_t> featureSelectors;
    };

    struct FeatureValues {
        uint32_t alternate;
        nsTArray<ValueList> valuelist;
    };


    bool
    GetFontFeatureValuesFor(const nsAString& aFamily,
                            uint32_t aVariantProperty,
                            const nsAString& aName,
                            nsTArray<uint32_t>& aValues);
    void
    AddFontFeatureValues(const nsAString& aFamily,
                const nsTArray<gfxFontFeatureValueSet::FeatureValues>& aValues);

private:

    ~gfxFontFeatureValueSet() {}

    struct FeatureValueHashKey {
        nsString mFamily;
        uint32_t mPropVal;
        nsString mName;

        FeatureValueHashKey()
            : mPropVal(0)
        { }
        FeatureValueHashKey(const nsAString& aFamily,
                            uint32_t aPropVal,
                            const nsAString& aName)
            : mFamily(aFamily), mPropVal(aPropVal), mName(aName)
        { }
        FeatureValueHashKey(const FeatureValueHashKey& aKey)
            : mFamily(aKey.mFamily), mPropVal(aKey.mPropVal), mName(aKey.mName)
        { }
    };

    class FeatureValueHashEntry : public PLDHashEntryHdr {
    public:
        typedef const FeatureValueHashKey &KeyType;
        typedef const FeatureValueHashKey *KeyTypePointer;

        explicit FeatureValueHashEntry(KeyTypePointer aKey) { }
        FeatureValueHashEntry(const FeatureValueHashEntry& toCopy)
        {
            do { } while(0);
        }
        ~FeatureValueHashEntry() { }

        bool KeyEquals(const KeyTypePointer aKey) const;
        static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
        static PLDHashNumber HashKey(const KeyTypePointer aKey);
        enum { ALLOW_MEMMOVE = true };

        FeatureValueHashKey mKey;
        nsTArray<uint32_t> mValues;
    };

    nsTHashtable<FeatureValueHashEntry> mFontFeatureValues;
  };
struct gfxFontVariation {
    uint32_t mTag;
    float mValue;
};

inline bool
operator==(const gfxFontVariation& a, const gfxFontVariation& b)
{
    return (a.mTag == b.mTag) && (a.mValue == b.mValue);
}






struct gfxFontStyle;





typedef bool (*nsFontFamilyEnumFunc)(const nsString& aFamily, bool aGeneric, void *aData);




const uint8_t kGenericFont_NONE = 0x00;

const uint8_t kGenericFont_moz_variable = 0x00;
const uint8_t kGenericFont_moz_fixed = 0x01;

const uint8_t kGenericFont_serif = 0x02;
const uint8_t kGenericFont_sans_serif = 0x04;
const uint8_t kGenericFont_monospace = 0x08;
const uint8_t kGenericFont_cursive = 0x10;
const uint8_t kGenericFont_fantasy = 0x20;


struct nsFont {


  mozilla::FontFamilyList fontlist;


  uint8_t style = 0;



  bool systemFont = false;


  uint8_t variantCaps = 0;
  uint8_t variantNumeric = 0;
  uint8_t variantPosition = 0;
  uint8_t variantWidth = 0;

  uint16_t variantLigatures = 0;
  uint16_t variantEastAsian = 0;






  uint16_t variantAlternates = 0;


  uint8_t smoothing = 0;


  uint16_t weight = 400;



  int16_t stretch = 0;


  uint8_t kerning = 0;


  uint8_t synthesis = 0x1 | 0x2;


  nscoord size = 0;





  float sizeAdjust = -1.0f;


  nsTArray<gfxAlternateValue> alternateValues;


  RefPtr<gfxFontFeatureValueSet> featureValueLookup;


  nsTArray<gfxFontFeature> fontFeatureSettings;


  nsTArray<gfxFontVariation> fontVariationSettings;




  uint32_t languageOverride = 0;


  nsFont(const mozilla::FontFamilyList& aFontlist, nscoord aSize);


  nsFont(mozilla::FontFamilyType aGenericType, nscoord aSize);


  nsFont(const nsFont& aFont);


  nsFont();

  ~nsFont();

  bool operator==(const nsFont& aOther) const {
    return Equals(aOther);
  }

  bool operator!=(const nsFont& aOther) const {
    return !Equals(aOther);
  }

  bool Equals(const nsFont& aOther) const;

  nsFont& operator=(const nsFont& aOther);

  void CopyAlternates(const nsFont& aOther);


  void AddFontFeaturesToStyle(gfxFontStyle *aStyle) const;

  void AddFontVariationsToStyle(gfxFontStyle *aStyle) const;
};


class nsIObserver : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult Observe(nsISupports *aSubject, const char * aTopic, const char16_t * aData) = 0;

};

  template<typename T> struct nsIObserver::COMTypeInfo<nsIObserver, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIObserver::COMTypeInfo<nsIObserver, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xdb242e01, 0xe4d9, 0x11d2, { 0x9d, 0xde, 0x00, 0x00, 0x64, 0x65, 0x73, 0x74 }};
class nsIObserver;

class nsIEventTarget;
class nsITimer;
typedef void (*nsTimerCallbackFunc) (nsITimer *aTimer, void *aClosure);
typedef void (*nsTimerNameCallbackFunc) (nsITimer *aTimer,
                                         bool aAnonymize,
                                         void *aClosure,
                                         char *aBuf, size_t aLen);
class nsITimer;
class nsITimerCallback : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult Notify(nsITimer *timer) = 0;

};

  template<typename T> struct nsITimerCallback::COMTypeInfo<nsITimerCallback, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsITimerCallback::COMTypeInfo<nsITimerCallback, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xa796816d, 0x7d47, 0x4348, { 0x9a, 0xb8, 0xc7, 0xae, 0xb3, 0x21, 0x6a, 0x7d }};
class nsITimer : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    TYPE_ONE_SHOT = 0,
    TYPE_REPEATING_SLACK = 1,
    TYPE_REPEATING_PRECISE = 2,
    TYPE_REPEATING_PRECISE_CAN_SKIP = 3
  };


  virtual nsresult Init(nsIObserver *aObserver, uint32_t aDelay, uint32_t aType) = 0;


  virtual nsresult InitWithFuncCallback(nsTimerCallbackFunc aCallback, void *aClosure, uint32_t aDelay, uint32_t aType) = 0;


  virtual nsresult InitWithCallback(nsITimerCallback *aCallback, uint32_t aDelay, uint32_t aType) = 0;


  virtual nsresult Cancel(void) = 0;


  virtual nsresult InitWithNamedFuncCallback(nsTimerCallbackFunc aCallback, void *aClosure, uint32_t aDelay, uint32_t aType, const char * aName) = 0;


  virtual nsresult InitWithNameableFuncCallback(nsTimerCallbackFunc aCallback, void *aClosure, uint32_t aDelay, uint32_t aType, nsTimerNameCallbackFunc aNameCallback) = 0;


  virtual nsresult GetDelay(uint32_t *aDelay) = 0;
  virtual nsresult SetDelay(uint32_t aDelay) = 0;


  virtual nsresult GetType(uint32_t *aType) = 0;
  virtual nsresult SetType(uint32_t aType) = 0;


  virtual nsresult GetClosure(void **aClosure) = 0;


  virtual nsresult GetCallback(nsITimerCallback * *aCallback) = 0;


  virtual nsresult GetTarget(nsIEventTarget * *aTarget) = 0;
  virtual nsresult SetTarget(nsIEventTarget *aTarget) = 0;

   virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const = 0;
};

  template<typename T> struct nsITimer::COMTypeInfo<nsITimer, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsITimer::COMTypeInfo<nsITimer, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x3de4b105, 0x363c, 0x482c, { 0xa4, 0x09, 0xba, 0xac, 0x83, 0xa0, 0x1b, 0xfc }};









extern "C" {






extern __attribute__((visibility("default"))) PRUint32
PL_strlen(const char *str);
extern __attribute__((visibility("default"))) PRUint32
PL_strnlen(const char *str, PRUint32 max);
extern __attribute__((visibility("default"))) char *
PL_strcpy(char *dest, const char *src);
extern __attribute__((visibility("default"))) char *
PL_strncpy(char *dest, const char *src, PRUint32 max);
extern __attribute__((visibility("default"))) char *
PL_strncpyz(char *dest, const char *src, PRUint32 max);
extern __attribute__((visibility("default"))) char *
PL_strdup(const char *s);







extern __attribute__((visibility("default"))) void
PL_strfree(char *s);
extern __attribute__((visibility("default"))) char *
PL_strndup(const char *s, PRUint32 max);
extern __attribute__((visibility("default"))) char *
PL_strcat(char *dst, const char *src);
extern __attribute__((visibility("default"))) char *
PL_strncat(char *dst, const char *src, PRUint32 max);
extern __attribute__((visibility("default"))) char *
PL_strcatn(char *dst, PRUint32 max, const char *src);
extern __attribute__((visibility("default"))) PRIntn
PL_strcmp(const char *a, const char *b);
extern __attribute__((visibility("default"))) PRIntn
PL_strncmp(const char *a, const char *b, PRUint32 max);
extern __attribute__((visibility("default"))) PRIntn
PL_strcasecmp(const char *a, const char *b);
extern __attribute__((visibility("default"))) PRIntn
PL_strncasecmp(const char *a, const char *b, PRUint32 max);
extern __attribute__((visibility("default"))) char *
PL_strchr(const char *s, char c);
extern __attribute__((visibility("default"))) char *
PL_strrchr(const char *s, char c);
extern __attribute__((visibility("default"))) char *
PL_strnchr(const char *s, char c, PRUint32 n);
extern __attribute__((visibility("default"))) char *
PL_strnrchr(const char *s, char c, PRUint32 n);
extern __attribute__((visibility("default"))) char *
PL_strpbrk(const char *s, const char *list);
extern __attribute__((visibility("default"))) char *
PL_strprbrk(const char *s, const char *list);
extern __attribute__((visibility("default"))) char *
PL_strnpbrk(const char *s, const char *list, PRUint32 n);
extern __attribute__((visibility("default"))) char *
PL_strnprbrk(const char *s, const char *list, PRUint32 n);
extern __attribute__((visibility("default"))) char *
PL_strstr(const char *big, const char *little);
extern __attribute__((visibility("default"))) char *
PL_strrstr(const char *big, const char *little);
extern __attribute__((visibility("default"))) char *
PL_strnstr(const char *big, const char *little, PRUint32 n);
extern __attribute__((visibility("default"))) char *
PL_strnrstr(const char *big, const char *little, PRUint32 max);
extern __attribute__((visibility("default"))) char *
PL_strcasestr(const char *big, const char *little);
extern __attribute__((visibility("default"))) char *
PL_strcaserstr(const char *big, const char *little);
extern __attribute__((visibility("default"))) char *
PL_strncasestr(const char *big, const char *little, PRUint32 max);
extern __attribute__((visibility("default"))) char *
PL_strncaserstr(const char *big, const char *little, PRUint32 max);
extern __attribute__((visibility("default"))) char *
PL_strtok_r(char *s1, const char *s2, char **lasts);







}
extern const char16_t kIsoLatin1ToUCS2[256];



class nsCRT
{
public:
  enum
  {
    LF = '\n' ,
    VTAB = '\v' ,
    CR = '\r'
  };


  static int32_t strcmp(const char* aStr1, const char* aStr2)
  {
    return int32_t(PL_strcmp(aStr1, aStr2));
  }

  static int32_t strncmp(const char* aStr1, const char* aStr2,
                         uint32_t aMaxLen)
  {
    return int32_t(PL_strncmp(aStr1, aStr2, aMaxLen));
  }


  static int32_t strcasecmp(const char* aStr1, const char* aStr2)
  {
    return int32_t(PL_strcasecmp(aStr1, aStr2));
  }


  static int32_t strncasecmp(const char* aStr1, const char* aStr2,
                             uint32_t aMaxLen)
  {
    int32_t result = int32_t(PL_strncasecmp(aStr1, aStr2, aMaxLen));


    if (result < 0) {
      result = -1;
    }
    return result;
  }

  static int32_t strncmp(const char* aStr1, const char* aStr2, int32_t aMaxLen)
  {

    int32_t diff =
      ((const unsigned char*)aStr1)[0] - ((const unsigned char*)aStr2)[0];
    if (diff != 0) {
      return diff;
    }
    return int32_t(PL_strncmp(aStr1, aStr2, unsigned(aMaxLen)));
  }
  static char* strtok(char* aStr, const char* aDelims, char** aNewStr);


  static int32_t strcmp(const char16_t* aStr1, const char16_t* aStr2);

  static int32_t strncmp(const char16_t* aStr1, const char16_t* aStr2,
                         uint32_t aMaxLen);




  static const char* memmem(const char* aHaystack, uint32_t aHaystackLen,
                            const char* aNeedle, uint32_t aNeedleLen);


  static int64_t atoll(const char* aStr);

  static char ToUpper(char aChar) { return NS_ToUpper(aChar); }
  static char ToLower(char aChar) { return NS_ToLower(aChar); }

  static bool IsUpper(char aChar) { return NS_IsUpper(aChar); }
  static bool IsLower(char aChar) { return NS_IsLower(aChar); }

  static bool IsAscii(char16_t aChar) { return NS_IsAscii(aChar); }
  static bool IsAscii(const char16_t* aString) { return NS_IsAscii(aString); }
  static bool IsAsciiAlpha(char16_t aChar) { return NS_IsAsciiAlpha(aChar); }
  static bool IsAsciiDigit(char16_t aChar) { return NS_IsAsciiDigit(aChar); }
  static bool IsAsciiSpace(char16_t aChar) { return NS_IsAsciiWhitespace(aChar); }
  static bool IsAscii(const char* aString) { return NS_IsAscii(aString); }
  static bool IsAscii(const char* aString, uint32_t aLength)
  {
    return NS_IsAscii(aString, aLength);
  }
};


inline bool
NS_IS_SPACE(char16_t aChar)
{
  return ((int(aChar) & 0x7f) == int(aChar)) && isspace(int(aChar));
}
class nsView;
class nsIPresShell;
class nsIWidget;
class nsIXULWindow;




enum nsSizeMode
{
  nsSizeMode_Normal = 0,
  nsSizeMode_Minimized,
  nsSizeMode_Maximized,
  nsSizeMode_Fullscreen,
  nsSizeMode_Invalid
};




enum nsWindowZ
{
  nsWindowZTop = 0,
  nsWindowZBottom,
  nsWindowZRelative
};

class nsIWidgetListener
{
public:






  virtual nsIXULWindow* GetXULWindow();




  virtual nsView* GetView();




  virtual nsIPresShell* GetPresShell();





  virtual bool WindowMoved(nsIWidget* aWidget, int32_t aX, int32_t aY);





  virtual bool WindowResized(nsIWidget* aWidget,
                             int32_t aWidth, int32_t aHeight);




  virtual void SizeModeChanged(nsSizeMode aSizeMode);





  virtual void UIResolutionChanged();
  virtual bool ZLevelChanged(bool aImmediate, nsWindowZ* aPlacement,
                             nsIWidget* aRequestBelow,
                             nsIWidget** aActualBelow);




  virtual void FullscreenChanged(bool aInFullscreen);




  virtual void WindowActivated();




  virtual void WindowDeactivated();




  virtual void OSToolbarButtonPressed();





  virtual bool RequestWindowClose(nsIWidget* aWidget);






  virtual void WillPaintWindow(nsIWidget* aWidget);







  virtual bool PaintWindow(nsIWidget* aWidget,
                           mozilla::LayoutDeviceIntRegion aRegion);







  virtual void DidPaintWindow();

  virtual void DidCompositeWindow(uint64_t aTransactionId,
                                  const mozilla::TimeStamp& aCompositeStart,
                                  const mozilla::TimeStamp& aCompositeEnd);




  virtual void RequestRepaint();




  virtual nsEventStatus HandleEvent(mozilla::WidgetGUIEvent* aEvent,
                                    bool aUseAttachedEvents);
};
namespace mozilla {





struct unused_t
{
  template<typename T>
  inline void
  operator<<(const T& ) const {}
};

extern __attribute__((weak)) __attribute__((visibility("default"))) const unused_t Unused;

}




class nsIFrame;

namespace mozilla {

struct FramePropertyDescriptorUntyped
{



  typedef void UntypedDestructor(void* aPropertyValue);
  UntypedDestructor* mDestructor;
  typedef void UntypedDestructorWithFrame(const nsIFrame* aFrame,
                                          void* aPropertyValue);
  UntypedDestructorWithFrame* mDestructorWithFrame;





protected:





  constexpr FramePropertyDescriptorUntyped(
    UntypedDestructor* aDtor, UntypedDestructorWithFrame* aDtorWithFrame)
    : mDestructor(aDtor)
    , mDestructorWithFrame(aDtorWithFrame)
  {}
};
template<typename T>
struct FramePropertyDescriptor : public FramePropertyDescriptorUntyped
{
  typedef void Destructor(T* aPropertyValue);
  typedef void DestructorWithFrame(const nsIFrame* aaFrame,
                                   T* aPropertyValue);

  template<Destructor Dtor>
  static constexpr const FramePropertyDescriptor<T> NewWithDestructor()
  {
    return { Destruct<Dtor>, nullptr };
  }

  template<DestructorWithFrame Dtor>
  static constexpr
  const FramePropertyDescriptor<T> NewWithDestructorWithFrame()
  {
    return { nullptr, DestructWithFrame<Dtor> };
  }

  static constexpr const FramePropertyDescriptor<T> NewWithoutDestructor()
  {
    return { nullptr, nullptr };
  }

private:
  constexpr FramePropertyDescriptor(
    UntypedDestructor* aDtor, UntypedDestructorWithFrame* aDtorWithFrame)
    : FramePropertyDescriptorUntyped(aDtor, aDtorWithFrame)
  {}

  template<Destructor Dtor>
  static void Destruct(void* aPropertyValue)
  {
    Dtor(static_cast<T*>(aPropertyValue));
  }

  template<DestructorWithFrame Dtor>
  static void DestructWithFrame(const nsIFrame* aFrame, void* aPropertyValue)
  {
    Dtor(aFrame, static_cast<T*>(aPropertyValue));
  }
};





template<typename T>
class SmallValueHolder;

namespace detail {

template<typename T>
struct FramePropertyTypeHelper
{
  typedef T* Type;
};
template<typename T>
struct FramePropertyTypeHelper<SmallValueHolder<T>>
{
  typedef T Type;
};

}
class FramePropertyTable {
public:
  template<typename T>
  using Descriptor = const FramePropertyDescriptor<T>*;
  using UntypedDescriptor = const FramePropertyDescriptorUntyped*;

  template<typename T>
  using PropertyType = typename detail::FramePropertyTypeHelper<T>::Type;

  FramePropertyTable() : mLastFrame(nullptr), mLastEntry(nullptr)
  {
  }
  ~FramePropertyTable()
  {
    DeleteAll();
  }







  template<typename T>
  void Set(nsIFrame* aFrame, Descriptor<T> aProperty,
           PropertyType<T> aValue)
  {
    void* ptr = ReinterpretHelper<T>::ToPointer(aValue);
    SetInternal(aFrame, aProperty, ptr);
  }
  template<typename T>
  bool Has(const nsIFrame* aFrame, Descriptor<T> aProperty)
  {
    bool foundResult = false;
    mozilla::Unused << GetInternal(aFrame, aProperty, false, &foundResult);
    return foundResult;
  }

  template<typename T>
  bool HasSkippingBitCheck(const nsIFrame* aFrame, Descriptor<T> aProperty)
  {
    bool foundResult = false;
    mozilla::Unused << GetInternal(aFrame, aProperty, true, &foundResult);
    return foundResult;
  }
  template<typename T>
  PropertyType<T> Get(const nsIFrame* aFrame, Descriptor<T> aProperty,
                      bool* aFoundResult = nullptr)
  {
    void* ptr = GetInternal(aFrame, aProperty, false, aFoundResult);
    return ReinterpretHelper<T>::FromPointer(ptr);
  }
  template<typename T>
  PropertyType<T> Remove(nsIFrame* aFrame, Descriptor<T> aProperty,
                         bool* aFoundResult = nullptr)
  {
    void* ptr = RemoveInternal(aFrame, aProperty, false, aFoundResult);
    return ReinterpretHelper<T>::FromPointer(ptr);
  }
  template<typename T>
  void Delete(nsIFrame* aFrame, Descriptor<T> aProperty)
  {
    DeleteInternal(aFrame, aProperty, false);
  }

  template<typename T>
  void DeleteSkippingBitCheck(nsIFrame* aFrame, Descriptor<T> aProperty)
  {
    DeleteInternal(aFrame, aProperty, true);
  }




  void DeleteAllFor(nsIFrame* aFrame);



  void DeleteAll();

  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

protected:
  void SetInternal(nsIFrame* aFrame, UntypedDescriptor aProperty,
                   void* aValue);

  void* GetInternal(const nsIFrame* aFrame, UntypedDescriptor aProperty,
                    bool aSkipBitCheck, bool* aFoundResult);

  void* RemoveInternal(nsIFrame* aFrame, UntypedDescriptor aProperty,
                       bool aSkipBitCheck, bool* aFoundResult);

  void DeleteInternal(nsIFrame* aFrame, UntypedDescriptor aProperty,
                      bool aSkipBitCheck);

  template<typename T>
  struct ReinterpretHelper
  {
    static_assert(sizeof(PropertyType<T>) <= sizeof(void*),
                  "size of the value must never be larger than a pointer");

    static void* ToPointer(PropertyType<T> aValue)
    {
      void* ptr = nullptr;
      memcpy(&ptr, &aValue, sizeof(aValue));
      return ptr;
    }

    static PropertyType<T> FromPointer(void* aPtr)
    {
      PropertyType<T> value;
      memcpy(&value, &aPtr, sizeof(value));
      return value;
    }
  };

  template<typename T>
  struct ReinterpretHelper<T*>
  {
    static void* ToPointer(T* aValue)
    {
      return static_cast<void*>(aValue);
    }

    static T* FromPointer(void* aPtr)
    {
      return static_cast<T*>(aPtr);
    }
  };





  struct PropertyValue {
    PropertyValue() : mProperty(nullptr), mValue(nullptr) {}
    PropertyValue(UntypedDescriptor aProperty, void* aValue)
      : mProperty(aProperty), mValue(aValue) {}

    bool IsArray() { return !mProperty && mValue; }
    nsTArray<PropertyValue>* ToArray()
    {
      do { } while(0);
      return reinterpret_cast<nsTArray<PropertyValue>*>(&mValue);
    }

    void DestroyValueFor(const nsIFrame* aFrame) {
      if (mProperty->mDestructor) {
        mProperty->mDestructor(mValue);
      } else if (mProperty->mDestructorWithFrame) {
        mProperty->mDestructorWithFrame(aFrame, mValue);
      }
    }

    size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) {
      size_t n = 0;





      if (IsArray()) {
        nsTArray<PropertyValue>* array = ToArray();
        n += array->ShallowSizeOfExcludingThis(aMallocSizeOf);
      }
      return n;
    }

    UntypedDescriptor mProperty;
    void* mValue;
  };





  class PropertyComparator {
  public:
    bool Equals(const PropertyValue& a, const PropertyValue& b) const {
      return a.mProperty == b.mProperty;
    }
    bool Equals(UntypedDescriptor a, const PropertyValue& b) const {
      return a == b.mProperty;
    }
    bool Equals(const PropertyValue& a, UntypedDescriptor b) const {
      return a.mProperty == b;
    }
  };





  class Entry : public nsPtrHashKey<const nsIFrame>
  {
  public:
    explicit Entry(KeyTypePointer aKey) : nsPtrHashKey<const nsIFrame>(aKey) {}
    Entry(const Entry &toCopy) :
      nsPtrHashKey<const nsIFrame>(toCopy), mProp(toCopy.mProp) {}

    size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) {
      return mProp.SizeOfExcludingThis(aMallocSizeOf);
    }

    PropertyValue mProp;
  };

  static void DeleteAllForEntry(Entry* aEntry);




  nsTHashtable<Entry> mEntries;
  const nsIFrame* mLastFrame;
  Entry* mLastEntry;
};
template<class CVnsIFrame>
class FramePropertiesBase {
public:
  template<typename T> using Descriptor = FramePropertyTable::Descriptor<T>;
  template<typename T> using PropertyType = FramePropertyTable::PropertyType<T>;

  template<typename T>
  bool Has(Descriptor<T> aProperty) const
  {
    return mTable->Has(mFrame, aProperty);
  }

  template<typename T>
  PropertyType<T> Get(Descriptor<T> aProperty,
                      bool* aFoundResult = nullptr) const
  {
    return mTable->Get(mFrame, aProperty, aFoundResult);
  }

protected:
  FramePropertiesBase(FramePropertyTable* aTable, CVnsIFrame* aFrame)
    : mTable(aTable), mFrame(aFrame) {}

  FramePropertyTable* const mTable;
  CVnsIFrame* const mFrame;
};

class ConstFrameProperties : public FramePropertiesBase<const nsIFrame> {
public:
  ConstFrameProperties(FramePropertyTable* aTable, const nsIFrame* aFrame)
    : FramePropertiesBase(aTable, aFrame)
  {
  }
};

class FrameProperties : public FramePropertiesBase<nsIFrame> {
public:
  FrameProperties(FramePropertyTable* aTable, nsIFrame* aFrame)
    : FramePropertiesBase(aTable, aFrame)
  {
  }

  template<typename T>
  void Set(Descriptor<T> aProperty, PropertyType<T> aValue) const
  {
    mTable->Set(mFrame, aProperty, aValue);
  }

  template<typename T>
  PropertyType<T> Remove(Descriptor<T> aProperty,
                         bool* aFoundResult = nullptr) const
  {
    return mTable->Remove(mFrame, aProperty, aFoundResult);
  }

  template<typename T>
  void Delete(Descriptor<T> aProperty) const
  {
    mTable->Delete(mFrame, aProperty);
  }

};

}





struct gfxQuad;

struct gfxMargin : public mozilla::gfx::BaseMargin<gfxFloat, gfxMargin> {
  typedef mozilla::gfx::BaseMargin<gfxFloat, gfxMargin> Super;


  gfxMargin() : Super() {}
  gfxMargin(const gfxMargin& aMargin) : Super(aMargin) {}
  gfxMargin(gfxFloat aTop, gfxFloat aRight, gfxFloat aBottom, gfxFloat aLeft)
    : Super(aTop, aRight, aBottom, aLeft) {}
};

struct gfxRect :
    public mozilla::gfx::BaseRect<gfxFloat, gfxRect, gfxPoint, gfxSize, gfxMargin> {
    typedef mozilla::gfx::BaseRect<gfxFloat, gfxRect, gfxPoint, gfxSize, gfxMargin> Super;

    gfxRect() : Super() {}
    gfxRect(const gfxPoint& aPos, const gfxSize& aSize) :
        Super(aPos, aSize) {}
    gfxRect(gfxFloat aX, gfxFloat aY, gfxFloat aWidth, gfxFloat aHeight) :
        Super(aX, aY, aWidth, aHeight) {}







    bool WithinEpsilonOfIntegerPixels(gfxFloat aEpsilon) const;

    gfxPoint AtCorner(mozilla::Corner corner) const {
        switch (corner) {
            case mozilla::eCornerTopLeft: return TopLeft();
            case mozilla::eCornerTopRight: return TopRight();
            case mozilla::eCornerBottomRight: return BottomRight();
            case mozilla::eCornerBottomLeft: return BottomLeft();
        }
        return gfxPoint(0.0, 0.0);
    }

    gfxPoint CCWCorner(mozilla::Side side) const {
        switch (side) {
            case mozilla::eSideTop: return TopLeft();
            case mozilla::eSideRight: return TopRight();
            case mozilla::eSideBottom: return BottomRight();
            case mozilla::eSideLeft: return BottomLeft();
        }
        do { AnnotateMozCrashReason("MOZ_CRASH(" "Incomplete switch" ")"); do { *((volatile int*) __null) = 65; ::abort(); } while (0); } while (0);
    }

    gfxPoint CWCorner(mozilla::Side side) const {
        switch (side) {
            case mozilla::eSideTop: return TopRight();
            case mozilla::eSideRight: return BottomRight();
            case mozilla::eSideBottom: return BottomLeft();
            case mozilla::eSideLeft: return TopLeft();
        }
        do { AnnotateMozCrashReason("MOZ_CRASH(" "Incomplete switch" ")"); do { *((volatile int*) __null) = 75; ::abort(); } while (0); } while (0);
    }





    void Condition();

    void Scale(gfxFloat k) {
        do { } while(0);
        x *= k;
        y *= k;
        width *= k;
        height *= k;
    }

    void Scale(gfxFloat sx, gfxFloat sy) {
        do { } while(0);
        do { } while(0);
        x *= sx;
        y *= sy;
        width *= sx;
        height *= sy;
    }

    void ScaleInverse(gfxFloat k) {
        do { } while(0);
        x /= k;
        y /= k;
        width /= k;
        height /= k;
    }




    gfxQuad TransformToQuad(const mozilla::gfx::Matrix4x4 &aMatrix) const;
};





typedef struct PRCListStr PRCList;




struct PRCListStr {
    PRCList *next;
    PRCList *prev;
};
class nsIThread;







extern nsresult NS_GetMainThread(nsIThread** aResult);






extern nsIThread* NS_GetCurrentThread();



bool NS_IsMainThread();
class nsICancelableRunnable : public nsISupports
{
public:
  template<typename T, typename U> struct COMTypeInfo;
  virtual nsresult Cancel() = 0;

protected:
  nsICancelableRunnable() { }
  virtual ~nsICancelableRunnable() {}
};

template<typename T> struct nsICancelableRunnable::COMTypeInfo<nsICancelableRunnable, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsICancelableRunnable::COMTypeInfo<nsICancelableRunnable, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0xde93dc4c, 0x5eea, 0x4eb7, { 0xb6, 0xd1, 0xdb, 0xf1, 0xe0, 0xce, 0xf6, 0x5c } };
namespace mozilla {
class TimeStamp;
}
class nsIIdlePeriod : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetIdlePeriodHint(mozilla::TimeStamp *_retval) = 0;

};

  template<typename T> struct nsIIdlePeriod::COMTypeInfo<nsIIdlePeriod, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIIdlePeriod::COMTypeInfo<nsIIdlePeriod, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x21dd35a2, 0xeae9, 0x4bd8, { 0xb4, 0x70, 0x0d, 0xfa, 0x35, 0xa0, 0xe3, 0xb9 }};
class nsIIncrementalRunnable : public nsISupports
{
public:
  template<typename T, typename U> struct COMTypeInfo;





  virtual void SetDeadline(mozilla::TimeStamp aDeadline) = 0;

protected:
  nsIIncrementalRunnable() { }
  virtual ~nsIIncrementalRunnable() {}
};

template<typename T> struct nsIIncrementalRunnable::COMTypeInfo<nsIIncrementalRunnable, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIIncrementalRunnable::COMTypeInfo<nsIIncrementalRunnable, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x688be92e, 0x7ade, 0x4fdc, { 0x9d, 0x83, 0x74, 0xcb, 0xef, 0xf4, 0xa5, 0x2c } };
class nsINamed : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetName(nsACString & aName) = 0;


  virtual nsresult SetName(const char * aName) = 0;

};

  template<typename T> struct nsINamed::COMTypeInfo<nsINamed, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsINamed::COMTypeInfo<nsINamed, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x0c5fe7de, 0x7e83, 0x4d0d, { 0xa8, 0xa6, 0x4a, 0x65, 0x18, 0xb9, 0xa7, 0xb3 }};
class nsIRunnable : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult Run(void) = 0;

};

  template<typename T> struct nsIRunnable::COMTypeInfo<nsIRunnable, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIRunnable::COMTypeInfo<nsIRunnable, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x4a2abaf0, 0x6886, 0x11d3, { 0x93, 0x82, 0x00, 0x10, 0x4b, 0xa0, 0xfd, 0x40 }};
class nsIRunnablePriority : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    PRIORITY_NORMAL = 0U,
    PRIORITY_HIGH = 1U
  };


  virtual nsresult GetPriority(uint32_t *aPriority) = 0;

};

  template<typename T> struct nsIRunnablePriority::COMTypeInfo<nsIRunnablePriority, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIRunnablePriority::COMTypeInfo<nsIRunnablePriority, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xe75aa42a, 0x80a9, 0x11e6, { 0xaf, 0xb5, 0xe8, 0x9d, 0x87, 0x34, 0x8e, 0x2c }};
class nsIThread;
class nsIThreadManager : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    DEFAULT_STACK_SIZE = 0U
  };


  virtual nsresult NewThread(uint32_t creationFlags, uint32_t stackSize, nsIThread * *_retval) = 0;


  virtual nsresult NewNamedThread(const nsACString & name, uint32_t stackSize, nsIThread * *_retval) = 0;


  virtual nsresult GetThreadFromPRThread(PRThread *prthread, nsIThread * *_retval) = 0;


  virtual nsresult GetMainThread(nsIThread * *aMainThread) = 0;


  virtual nsresult GetCurrentThread(nsIThread * *aCurrentThread) = 0;


  virtual nsresult GetIsMainThread(bool *aIsMainThread) = 0;

};

  template<typename T> struct nsIThreadManager::COMTypeInfo<nsIThreadManager, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIThreadManager::COMTypeInfo<nsIThreadManager, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x1be89eca, 0xe2f7, 0x453b, { 0x8d, 0x38, 0xc1, 0x1b, 0xa2, 0x47, 0xf6, 0xf3 }};
class nsIEventTarget : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

     nsresult Dispatch(nsIRunnable* aEvent, uint32_t aFlags) {
      return Dispatch(nsCOMPtr<nsIRunnable>(aEvent).forget(), aFlags);
    }
  enum {
    DISPATCH_NORMAL = 0U,
    DISPATCH_SYNC = 1U,
    DISPATCH_AT_END = 2U
  };


  virtual nsresult IsOnCurrentThread(bool *_retval) = 0;


  virtual nsresult Dispatch(already_AddRefed<nsIRunnable> event, uint32_t flags) = 0;


  virtual nsresult DispatchFromScript(nsIRunnable *event, uint32_t flags) = 0;


  virtual nsresult DelayedDispatch(already_AddRefed<nsIRunnable> event, uint32_t delay) = 0;

};

  template<typename T> struct nsIEventTarget::COMTypeInfo<nsIEventTarget, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIEventTarget::COMTypeInfo<nsIEventTarget, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x88145945, 0x3278, 0x424e, { 0x9f, 0x37, 0xd8, 0x74, 0xcb, 0xdd, 0x9f, 0x6f }};
class nsIThread : public nsIEventTarget {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetPRThread(PRThread **aPRThread) = 0;


  virtual nsresult GetCanInvokeJS(bool *aCanInvokeJS) = 0;
  virtual nsresult SetCanInvokeJS(bool aCanInvokeJS) = 0;


  virtual nsresult Shutdown(void) = 0;


  virtual nsresult HasPendingEvents(bool *_retval) = 0;


  virtual nsresult ProcessNextEvent(bool mayWait, bool *_retval) = 0;


  virtual nsresult AsyncShutdown(void) = 0;


  virtual nsresult RegisterIdlePeriod(already_AddRefed<nsIIdlePeriod> aIdlePeriod) = 0;


  virtual nsresult IdleDispatch(already_AddRefed<nsIRunnable> event) = 0;

};

  template<typename T> struct nsIThread::COMTypeInfo<nsIThread, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIThread::COMTypeInfo<nsIThread, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x5801d193, 0x29d1, 0x4964, { 0xa6, 0xb7, 0x70, 0xeb, 0x69, 0x7d, 0xdf, 0x2b }};





namespace mozilla {




template<size_t... Indices>
struct IndexSequence
{
  static constexpr size_t Size() { return sizeof...(Indices); }
};

namespace detail {



template<size_t... Indices>
struct IndexTuple
{
  typedef IndexTuple<Indices..., sizeof...(Indices)> Next;
};


template<size_t N>
struct BuildIndexTuple
{
  typedef typename BuildIndexTuple<N - 1>::Type::Next Type;
};

template<>
struct BuildIndexTuple<0>
{
  typedef IndexTuple<> Type;
};

template<size_t N, typename IndexTuple>
struct MakeIndexSequenceImpl;

template<size_t N, size_t... Indices>
struct MakeIndexSequenceImpl<N, IndexTuple<Indices...>>
{
  typedef IndexSequence<Indices...> Type;
};

}







template<size_t N>
struct MakeIndexSequence
{
  typedef typename detail::MakeIndexSequenceImpl<N,
    typename detail::BuildIndexTuple<N>::Type>::Type Type;
};
template<typename... Types>
struct IndexSequenceFor
{
  typedef typename MakeIndexSequence<sizeof...(Types)>::Type Type;
};

}





namespace mozilla {

namespace detail {





template<typename... Ts>
struct Group;
template<typename Source, typename Target, bool SameSize>
struct CheckConvertibilityImpl;

template<typename Source, typename Target>
struct CheckConvertibilityImpl<Source, Target, false>
  : FalseType {};

template<typename... SourceTypes, typename... TargetTypes>
struct CheckConvertibilityImpl<Group<SourceTypes...>, Group<TargetTypes...>, true>
  : IntegralConstant<bool, tl::And<IsConvertible<SourceTypes, TargetTypes>::value...>::value> { };

template<typename Source, typename Target>
struct CheckConvertibility;

template<typename... SourceTypes, typename... TargetTypes>
struct CheckConvertibility<Group<SourceTypes...>, Group<TargetTypes...>>
  : CheckConvertibilityImpl<Group<SourceTypes...>, Group<TargetTypes...>,
        sizeof...(SourceTypes) == sizeof...(TargetTypes)> { };
template<std::size_t Index, typename... Elements>
struct TupleImpl;





template<std::size_t Index>
struct TupleImpl<Index> {
  bool operator==(const TupleImpl<Index>& aOther) const
  {
    return true;
  }
};






template<std::size_t Index, typename HeadT, typename... TailT>
struct TupleImpl<Index, HeadT, TailT...>
  : public TupleImpl<Index + 1, TailT...>
{
  typedef TupleImpl<Index + 1, TailT...> Base;






  static HeadT& Head(TupleImpl& aTuple) { return aTuple.mHead; }
  static const HeadT& Head(const TupleImpl& aTuple) { return aTuple.mHead; }
  static Base& Tail(TupleImpl& aTuple) { return aTuple; }
  static const Base& Tail(const TupleImpl& aTuple) { return aTuple; }

  TupleImpl() : Base(), mHead() { }


  explicit TupleImpl(const HeadT& aHead, const TailT&... aTail)
    : Base(aTail...), mHead(aHead) { }





  template <typename OtherHeadT, typename... OtherTailT,
            typename = typename EnableIf<
                CheckConvertibility<
                    Group<OtherHeadT, OtherTailT...>,
                    Group<HeadT, TailT...>>::value>::Type>
  explicit TupleImpl(OtherHeadT&& aHead, OtherTailT&&... aTail)
    : Base(Forward<OtherTailT>(aTail)...), mHead(Forward<OtherHeadT>(aHead)) { }




  TupleImpl(const TupleImpl& aOther)
    : Base(Tail(aOther))
    , mHead(Head(aOther)) {}
  TupleImpl(TupleImpl&& aOther)
    : Base(Move(Tail(aOther)))
    , mHead(Forward<HeadT>(Head(aOther))) {}



  template <typename... OtherElements,
            typename = typename EnableIf<
                sizeof...(OtherElements) == sizeof...(TailT) + 1>::Type>
  TupleImpl& operator=(const TupleImpl<Index, OtherElements...>& aOther)
  {
    typedef TupleImpl<Index, OtherElements...> OtherT;
    Head(*this) = OtherT::Head(aOther);
    Tail(*this) = OtherT::Tail(aOther);
    return *this;
  }
  template <typename... OtherElements,
            typename = typename EnableIf<
                sizeof...(OtherElements) == sizeof...(TailT) + 1>::Type>
  TupleImpl& operator=(TupleImpl<Index, OtherElements...>&& aOther)
  {
    typedef TupleImpl<Index, OtherElements...> OtherT;
    Head(*this) = Move(OtherT::Head(aOther));
    Tail(*this) = Move(OtherT::Tail(aOther));
    return *this;
  }


  TupleImpl& operator=(const TupleImpl& aOther)
  {
    Head(*this) = Head(aOther);
    Tail(*this) = Tail(aOther);
    return *this;
  }
  TupleImpl& operator=(TupleImpl&& aOther)
  {
    Head(*this) = Move(Head(aOther));
    Tail(*this) = Move(Tail(aOther));
    return *this;
  }
  bool operator==(const TupleImpl& aOther) const
  {
    return Head(*this) == Head(aOther) && Tail(*this) == Tail(aOther);
  }
private:
  HeadT mHead;
};

}
template<typename... Elements>
class Tuple : public detail::TupleImpl<0, Elements...>
{
  typedef detail::TupleImpl<0, Elements...> Impl;
public:



  Tuple() : Impl() { }
  explicit Tuple(const Elements&... aElements) : Impl(aElements...) { }




  template <typename OtherHead, typename... OtherTail,
            typename = typename EnableIf<
                detail::CheckConvertibility<
                    detail::Group<OtherHead, OtherTail...>,
                    detail::Group<Elements...>>::value>::Type>
  explicit Tuple(OtherHead&& aHead, OtherTail&&... aTail)
    : Impl(Forward<OtherHead>(aHead), Forward<OtherTail>(aTail)...) { }
  Tuple(const Tuple& aOther) : Impl(aOther) { }
  Tuple(Tuple&& aOther) : Impl(Move(aOther)) { }

  template <typename... OtherElements,
            typename = typename EnableIf<
                sizeof...(OtherElements) == sizeof...(Elements)>::Type>
  Tuple& operator=(const Tuple<OtherElements...>& aOther)
  {
    static_cast<Impl&>(*this) = aOther;
    return *this;
  }
  template <typename... OtherElements,
            typename = typename EnableIf<
                sizeof...(OtherElements) == sizeof...(Elements)>::Type>
  Tuple& operator=(Tuple<OtherElements...>&& aOther)
  {
    static_cast<Impl&>(*this) = Move(aOther);
    return *this;
  }
  Tuple& operator=(const Tuple& aOther)
  {
    static_cast<Impl&>(*this) = aOther;
    return *this;
  }
  Tuple& operator=(Tuple&& aOther)
  {
    static_cast<Impl&>(*this) = Move(aOther);
    return *this;
  }
  bool operator==(const Tuple& aOther) const
  {
    return static_cast<const Impl&>(*this) == static_cast<const Impl&>(aOther);
  }
};





template <typename A, typename B>
class Tuple<A, B> : public detail::TupleImpl<0, A, B>
{
  typedef detail::TupleImpl<0, A, B> Impl;

public:



  Tuple() : Impl() { }
  explicit Tuple(const A& aA, const B& aB) : Impl(aA, aB) { }
  template <typename AArg, typename BArg,
            typename = typename EnableIf<
                detail::CheckConvertibility<
                    detail::Group<AArg, BArg>,
                    detail::Group<A, B>>::value>::Type>
  explicit Tuple(AArg&& aA, BArg&& aB)
    : Impl(Forward<AArg>(aA), Forward<BArg>(aB)) { }
  Tuple(const Tuple& aOther) : Impl(aOther) { }
  Tuple(Tuple&& aOther) : Impl(Move(aOther)) { }
  explicit Tuple(const Pair<A, B>& aOther)
    : Impl(aOther.first(), aOther.second()) { }
  explicit Tuple(Pair<A, B>&& aOther) : Impl(Forward<A>(aOther.first()),
                                    Forward<B>(aOther.second())) { }
  explicit Tuple(const std::pair<A, B>& aOther)
    : Impl(aOther.first, aOther.second) { }
  explicit Tuple(std::pair<A, B>&& aOther) : Impl(Forward<A>(aOther.first),
                                    Forward<B>(aOther.second)) { }

  template <typename AArg, typename BArg>
  Tuple& operator=(const Tuple<AArg, BArg>& aOther)
  {
    static_cast<Impl&>(*this) = aOther;
    return *this;
  }
  template <typename AArg, typename BArg>
  Tuple& operator=(Tuple<AArg, BArg>&& aOther)
  {
    static_cast<Impl&>(*this) = Move(aOther);
    return *this;
  }
  Tuple& operator=(const Tuple& aOther)
  {
    static_cast<Impl&>(*this) = aOther;
    return *this;
  }
  Tuple& operator=(Tuple&& aOther)
  {
    static_cast<Impl&>(*this) = Move(aOther);
    return *this;
  }
  template <typename AArg, typename BArg>
  Tuple& operator=(const Pair<AArg, BArg>& aOther)
  {
    Impl::Head(*this) = aOther.first();
    Impl::Tail(*this).Head(*this) = aOther.second();
    return *this;
  }
  template <typename AArg, typename BArg>
  Tuple& operator=(Pair<AArg, BArg>&& aOther)
  {
    Impl::Head(*this) = Forward<AArg>(aOther.first());
    Impl::Tail(*this).Head(*this) = Forward<BArg>(aOther.second());
    return *this;
  }
  template <typename AArg, typename BArg>
  Tuple& operator=(const std::pair<AArg, BArg>& aOther)
  {
    Impl::Head(*this) = aOther.first;
    Impl::Tail(*this).Head(*this) = aOther.second;
    return *this;
  }
  template <typename AArg, typename BArg>
  Tuple& operator=(std::pair<AArg, BArg>&& aOther)
  {
    Impl::Head(*this) = Forward<AArg>(aOther.first);
    Impl::Tail(*this).Head(*this) = Forward<BArg>(aOther.second);
    return *this;
  }
};







template <>
class Tuple<> {};

namespace detail {
template<std::size_t Index, typename... Elements>
auto TupleGetHelper(TupleImpl<Index, Elements...>& aTuple)
    -> decltype(TupleImpl<Index, Elements...>::Head(aTuple))
{
  return TupleImpl<Index, Elements...>::Head(aTuple);
}


template<std::size_t Index, typename... Elements>
auto TupleGetHelper(const TupleImpl<Index, Elements...>& aTuple)
    -> decltype(TupleImpl<Index, Elements...>::Head(aTuple))
{
  return TupleImpl<Index, Elements...>::Head(aTuple);
}

}
template<std::size_t Index, typename... Elements>
auto Get(Tuple<Elements...>& aTuple)
    -> decltype(detail::TupleGetHelper<Index>(aTuple))
{
  return detail::TupleGetHelper<Index>(aTuple);
}


template<std::size_t Index, typename... Elements>
auto Get(const Tuple<Elements...>& aTuple)
    -> decltype(detail::TupleGetHelper<Index>(aTuple))
{
  return detail::TupleGetHelper<Index>(aTuple);
}


template<std::size_t Index, typename... Elements>
auto Get(Tuple<Elements...>&& aTuple)
    -> decltype(Move(mozilla::Get<Index>(aTuple)))
{


  return Move(mozilla::Get<Index>(aTuple));
}
template<typename... Elements>
inline Tuple<typename Decay<Elements>::Type...>
MakeTuple(Elements&&... aElements)
{
  return Tuple<typename Decay<Elements>::Type...>(Forward<Elements>(aElements)...);
}
template<typename... Elements>
inline Tuple<Elements&...>
Tie(Elements&... aVariables)
{
  return Tuple<Elements&...>(aVariables...);
}

}
extern nsresult
NS_NewThread(nsIThread** aResult,
             nsIRunnable* aInitialEvent = nullptr,
             uint32_t aStackSize = nsIThreadManager::DEFAULT_STACK_SIZE);




extern nsresult
NS_NewNamedThread(const nsACString& aName,
                  nsIThread** aResult,
                  nsIRunnable* aInitialEvent = nullptr,
                  uint32_t aStackSize = nsIThreadManager::DEFAULT_STACK_SIZE);

template<size_t LEN>
inline nsresult
NS_NewNamedThread(const char (&aName)[LEN],
                  nsIThread** aResult,
                  nsIRunnable* aInitialEvent = nullptr,
                  uint32_t aStackSize = nsIThreadManager::DEFAULT_STACK_SIZE)
{
  static_assert(LEN <= 16,
                "Thread name must be no more than 16 characters");
  return NS_NewNamedThread(nsDependentCString(aName, LEN - 1),
                           aResult, aInitialEvent, aStackSize);
}







extern nsresult NS_GetCurrentThread(nsIThread** aResult);
extern nsresult NS_DispatchToCurrentThread(nsIRunnable* aEvent);
extern nsresult
NS_DispatchToCurrentThread(already_AddRefed<nsIRunnable>&& aEvent);
extern nsresult
NS_DispatchToMainThread(nsIRunnable* aEvent,
                        uint32_t aDispatchFlags = nsIEventTarget::DISPATCH_NORMAL);
extern nsresult
NS_DispatchToMainThread(already_AddRefed<nsIRunnable>&& aEvent,
                        uint32_t aDispatchFlags = nsIEventTarget::DISPATCH_NORMAL);

extern nsresult
NS_DelayedDispatchToCurrentThread(
  already_AddRefed<nsIRunnable>&& aEvent, uint32_t aDelayMs);

extern nsresult
NS_IdleDispatchToCurrentThread(already_AddRefed<nsIRunnable>&& aEvent);
extern nsresult
NS_ProcessPendingEvents(nsIThread* aThread,
                        PRIntervalTime aTimeout = 0xffffffffUL);
extern bool NS_HasPendingEvents(nsIThread* aThread = nullptr);
extern bool NS_ProcessNextEvent(nsIThread* aThread = nullptr,
                                bool aMayWait = true);
extern bool NS_IsInCompositorThread();




inline already_AddRefed<nsIThread>
do_GetCurrentThread()
{
  nsIThread* thread = nullptr;
  NS_GetCurrentThread(&thread);
  return already_AddRefed<nsIThread>(thread);
}

inline already_AddRefed<nsIThread>
do_GetMainThread()
{
  nsIThread* thread = nullptr;
  NS_GetMainThread(&thread);
  return already_AddRefed<nsIThread>(thread);
}
extern nsIThread* NS_GetCurrentThread();






namespace mozilla {


class IdlePeriod : public nsIIdlePeriod
{
public:
  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:
  virtual nsresult GetIdlePeriodHint(mozilla::TimeStamp *_retval) override;

  IdlePeriod() {}

protected:
  virtual ~IdlePeriod() {}
private:
  IdlePeriod(const IdlePeriod&) = delete;
  IdlePeriod& operator=(const IdlePeriod&) = delete;
  IdlePeriod& operator=(const IdlePeriod&&) = delete;
};


class Runnable : public nsIRunnable, public nsINamed
{
public:
  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:
  virtual nsresult Run(void) override;
  virtual nsresult GetName(nsACString & aName) override; virtual nsresult SetName(const char * aName) override;

  Runnable() {}




  explicit Runnable(const char* aName) : mName(aName) {}


protected:
  virtual ~Runnable() {}
private:
  Runnable(const Runnable&) = delete;
  Runnable& operator=(const Runnable&) = delete;
  Runnable& operator=(const Runnable&&) = delete;


  const char* mName = nullptr;

};


class CancelableRunnable : public Runnable,
                           public nsICancelableRunnable
{
public:
  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override;

  virtual nsresult Cancel() override;

  CancelableRunnable() {}
  explicit CancelableRunnable(const char* aName) : Runnable(aName) {}

protected:
  virtual ~CancelableRunnable() {}
private:
  CancelableRunnable(const CancelableRunnable&) = delete;
  CancelableRunnable& operator=(const CancelableRunnable&) = delete;
  CancelableRunnable& operator=(const CancelableRunnable&&) = delete;
};


class IncrementalRunnable : public CancelableRunnable,
                            public nsIIncrementalRunnable
{
public:
  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override;

  virtual void SetDeadline(TimeStamp aDeadline) override;

  IncrementalRunnable() {}

protected:
  virtual ~IncrementalRunnable() {}
private:
  IncrementalRunnable(const IncrementalRunnable&) = delete;
  IncrementalRunnable& operator=(const IncrementalRunnable&) = delete;
  IncrementalRunnable& operator=(const IncrementalRunnable&&) = delete;
};

namespace detail {




template<typename StoredFunction>
class RunnableFunction : public Runnable
{
public:
  template <typename F>
  explicit RunnableFunction(F&& aFunction)
    : mFunction(Forward<F>(aFunction))
  { }

  virtual nsresult Run() override {
    static_assert(IsVoid<decltype(mFunction())>::value,
                  "The lambda must return void!");
    mFunction();
    return NS_OK;
  }
private:
  StoredFunction mFunction;
};


template<typename Function>
using RunnableFunctionImpl =

  typename detail::RunnableFunction<typename RemoveReference<Function>::Type>;

template <typename T>
inline already_AddRefed<T>
SetRunnableName(already_AddRefed<T>&& aObj, const char* aName)
{
  do { static_assert(mozilla::detail::AssertionConditionType<decltype(aName)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(aName))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "aName" ")"); do { *((volatile int*) __null) = 340; ::abort(); } while (0); } } while (0);
  RefPtr<T> ref(aObj);
  ref->SetName(aName);
  return ref.forget();
}

}

namespace detail {

template<typename CVRemoved>
struct IsRefcountedSmartPointerHelper : FalseType {};

template<typename Pointee>
struct IsRefcountedSmartPointerHelper<RefPtr<Pointee>> : TrueType {};

template<typename Pointee>
struct IsRefcountedSmartPointerHelper<nsCOMPtr<Pointee>> : TrueType {};

}

template<typename T>
struct IsRefcountedSmartPointer
  : detail::IsRefcountedSmartPointerHelper<typename RemoveCV<T>::Type>
{};

namespace detail {

template<typename T, typename CVRemoved>
struct RemoveSmartPointerHelper
{
  typedef T Type;
};

template<typename T, typename Pointee>
struct RemoveSmartPointerHelper<T, RefPtr<Pointee>>
{
  typedef Pointee Type;
};

template<typename T, typename Pointee>
struct RemoveSmartPointerHelper<T, nsCOMPtr<Pointee>>
{
  typedef Pointee Type;
};

}

template<typename T>
struct RemoveSmartPointer
  : detail::RemoveSmartPointerHelper<T, typename RemoveCV<T>::Type>
{};

namespace detail {

template<typename T, typename CVRemoved>
struct RemoveRawOrSmartPointerHelper
{
  typedef T Type;
};

template<typename T, typename Pointee>
struct RemoveRawOrSmartPointerHelper<T, Pointee*>
{
  typedef Pointee Type;
};

template<typename T, typename Pointee>
struct RemoveRawOrSmartPointerHelper<T, RefPtr<Pointee>>
{
  typedef Pointee Type;
};

template<typename T, typename Pointee>
struct RemoveRawOrSmartPointerHelper<T, nsCOMPtr<Pointee>>
{
  typedef Pointee Type;
};

}

template<typename T>
struct RemoveRawOrSmartPointer
  : detail::RemoveRawOrSmartPointerHelper<T, typename RemoveCV<T>::Type>
{};

}

inline nsISupports*
ToSupports(mozilla::Runnable *p)
{
  return static_cast<nsIRunnable*>(p);
}

template<typename Function>
already_AddRefed<mozilla::Runnable>
NS_NewRunnableFunction(Function&& aFunction)
{


  return do_AddRef(new mozilla::detail::RunnableFunctionImpl<Function>
    (mozilla::Forward<Function>(aFunction)));
}

template<typename Function>
already_AddRefed<mozilla::Runnable>
NS_NewRunnableFunction(const char* aName, Function&& aFunction)
{
  return mozilla::detail::SetRunnableName(
    NS_NewRunnableFunction(mozilla::Forward<Function>(aFunction)), aName);
}




template<class ClassType,
         typename ReturnType = void,
         bool Owning = true,
         bool Cancelable = false>
class nsRunnableMethod : public mozilla::Conditional<!Cancelable,
                                                     mozilla::Runnable,
                                                     mozilla::CancelableRunnable>::Type
{
public:
  virtual void Revoke() = 0;




  template<typename OtherReturnType>
  class ReturnTypeEnforcer
  {
  public:
    typedef int ReturnTypeIsSafe;
  };

  template<class T>
  class ReturnTypeEnforcer<already_AddRefed<T>>
  {

  };


  typedef typename ReturnTypeEnforcer<ReturnType>::ReturnTypeIsSafe check;
};

template<class ClassType, bool Owning>
struct nsRunnableMethodReceiver
{
  RefPtr<ClassType> mObj;
  explicit nsRunnableMethodReceiver(ClassType* aObj) : mObj(aObj) {}
  ~nsRunnableMethodReceiver() { Revoke(); }
  ClassType* Get() const { return mObj.get(); }
  void Revoke() { mObj = nullptr; }
};

template<class ClassType>
struct nsRunnableMethodReceiver<ClassType, false>
{
  ClassType* mObj;
  explicit nsRunnableMethodReceiver(ClassType* aObj) : mObj(aObj) {}
  ClassType* Get() const { return mObj; }
  void Revoke() { mObj = nullptr; }
};

template<typename PtrType, typename Method, bool Owning, bool Cancelable>
struct nsRunnableMethodTraits;

template<typename PtrType, class C, typename R, bool Owning, bool Cancelable, typename... As>
struct nsRunnableMethodTraits<PtrType, R(C::*)(As...), Owning, Cancelable>
{
  typedef typename mozilla::RemoveRawOrSmartPointer<PtrType>::Type class_type;
  static_assert(mozilla::IsBaseOf<C, class_type>::value,
                "Stored class must inherit from method's class");
  typedef R return_type;
  typedef nsRunnableMethod<C, R, Owning, Cancelable> base_type;
  static const bool can_cancel = Cancelable;
};

template<typename PtrType, class C, typename R, bool Owning, bool Cancelable, typename... As>
struct nsRunnableMethodTraits<PtrType, R(C::*)(As...) const, Owning, Cancelable>
{
  typedef const typename mozilla::RemoveRawOrSmartPointer<PtrType>::Type class_type;
  static_assert(mozilla::IsBaseOf<C, class_type>::value,
                "Stored class must inherit from method's class");
  typedef R return_type;
  typedef nsRunnableMethod<C, R, Owning, Cancelable> base_type;
  static const bool can_cancel = Cancelable;
};
template<typename T>
struct IsParameterStorageClass : public mozilla::FalseType {};




template<typename T>
struct StoreCopyPassByValue
{
  typedef T stored_type;
  typedef T passed_type;
  stored_type m;
  template <typename A>
               StoreCopyPassByValue(A&& a) : m(mozilla::Forward<A>(a)) {}
  passed_type PassAsParameter() { return m; }
};
template<typename S>
struct IsParameterStorageClass<StoreCopyPassByValue<S>>
  : public mozilla::TrueType {};

template<typename T>
struct StoreCopyPassByConstLRef
{
  typedef T stored_type;
  typedef const T& passed_type;
  stored_type m;
  template <typename A>
               StoreCopyPassByConstLRef(A&& a) : m(mozilla::Forward<A>(a)) {}
  passed_type PassAsParameter() { return m; }
};
template<typename S>
struct IsParameterStorageClass<StoreCopyPassByConstLRef<S>>
  : public mozilla::TrueType {};

template<typename T>
struct StoreCopyPassByLRef
{
  typedef T stored_type;
  typedef T& passed_type;
  stored_type m;
  template <typename A>
               StoreCopyPassByLRef(A&& a) : m(mozilla::Forward<A>(a)) {}
  passed_type PassAsParameter() { return m; }
};
template<typename S>
struct IsParameterStorageClass<StoreCopyPassByLRef<S>>
  : public mozilla::TrueType {};

template<typename T>
struct StoreCopyPassByRRef
{
  typedef T stored_type;
  typedef T&& passed_type;
  stored_type m;
  template <typename A>
               StoreCopyPassByRRef(A&& a) : m(mozilla::Forward<A>(a)) {}
  passed_type PassAsParameter() { return mozilla::Move(m); }
};
template<typename S>
struct IsParameterStorageClass<StoreCopyPassByRRef<S>>
  : public mozilla::TrueType {};

template<typename T>
struct StoreRefPassByLRef
{
  typedef T& stored_type;
  typedef T& passed_type;
  stored_type m;
  template <typename A>
               StoreRefPassByLRef(A& a) : m(a) {}
  passed_type PassAsParameter() { return m; }
};
template<typename S>
struct IsParameterStorageClass<StoreRefPassByLRef<S>>
  : public mozilla::TrueType {};

template<typename T>
struct StoreConstRefPassByConstLRef
{
  typedef const T& stored_type;
  typedef const T& passed_type;
  stored_type m;
  template <typename A>
               StoreConstRefPassByConstLRef(const A& a) : m(a) {}
  passed_type PassAsParameter() { return m; }
};
template<typename S>
struct IsParameterStorageClass<StoreConstRefPassByConstLRef<S>>
  : public mozilla::TrueType {};

template<typename T>
struct StoreRefPtrPassByPtr
{
  typedef RefPtr<T> stored_type;
  typedef T* passed_type;
  stored_type m;
  template <typename A>
               StoreRefPtrPassByPtr(A&& a) : m(mozilla::Forward<A>(a)) {}
  passed_type PassAsParameter() { return m.get(); }
};
template<typename S>
struct IsParameterStorageClass<StoreRefPtrPassByPtr<S>>
  : public mozilla::TrueType {};

template<typename T>
struct StorePtrPassByPtr
{
  typedef T* stored_type;
  typedef T* passed_type;
  stored_type m;
  template <typename A>
               StorePtrPassByPtr(A a) : m(a) {}
  passed_type PassAsParameter() { return m; }
};
template<typename S>
struct IsParameterStorageClass<StorePtrPassByPtr<S>>
  : public mozilla::TrueType {};

template<typename T>
struct StoreConstPtrPassByConstPtr
{
  typedef const T* stored_type;
  typedef const T* passed_type;
  stored_type m;
  template <typename A>
               StoreConstPtrPassByConstPtr(A a) : m(a) {}
  passed_type PassAsParameter() { return m; }
};
template<typename S>
struct IsParameterStorageClass<StoreConstPtrPassByConstPtr<S>>
  : public mozilla::TrueType {};

template<typename T>
struct StoreCopyPassByConstPtr
{
  typedef T stored_type;
  typedef const T* passed_type;
  stored_type m;
  template <typename A>
               StoreCopyPassByConstPtr(A&& a) : m(mozilla::Forward<A>(a)) {}
  passed_type PassAsParameter() { return &m; }
};
template<typename S>
struct IsParameterStorageClass<StoreCopyPassByConstPtr<S>>
  : public mozilla::TrueType {};

template<typename T>
struct StoreCopyPassByPtr
{
  typedef T stored_type;
  typedef T* passed_type;
  stored_type m;
  template <typename A>
               StoreCopyPassByPtr(A&& a) : m(mozilla::Forward<A>(a)) {}
  passed_type PassAsParameter() { return &m; }
};
template<typename S>
struct IsParameterStorageClass<StoreCopyPassByPtr<S>>
  : public mozilla::TrueType {};

namespace detail {

template<typename>
struct SFINAE1True : mozilla::TrueType
{};

template<class T>
static auto HasRefCountMethodsTest(int)
    -> SFINAE1True<decltype(mozilla::DeclVal<T>().AddRef(),
                            mozilla::DeclVal<T>().Release())>;
template<class>
static auto HasRefCountMethodsTest(long) -> mozilla::FalseType;

template<class T>
struct HasRefCountMethods : decltype(HasRefCountMethodsTest<T>(0))
{};

template<typename TWithoutPointer>
struct NonnsISupportsPointerStorageClass
  : mozilla::Conditional<mozilla::IsConst<TWithoutPointer>::value,
                         StoreConstPtrPassByConstPtr<
                           typename mozilla::RemoveConst<TWithoutPointer>::Type>,
                         StorePtrPassByPtr<TWithoutPointer>>
{};

template<typename TWithoutPointer>
struct PointerStorageClass
  : mozilla::Conditional<HasRefCountMethods<TWithoutPointer>::value,
                         StoreRefPtrPassByPtr<TWithoutPointer>,
                         typename NonnsISupportsPointerStorageClass<
                           TWithoutPointer
                         >::Type>
{};

template<typename TWithoutRef>
struct LValueReferenceStorageClass
  : mozilla::Conditional<mozilla::IsConst<TWithoutRef>::value,
                         StoreConstRefPassByConstLRef<
                           typename mozilla::RemoveConst<TWithoutRef>::Type>,
                         StoreRefPassByLRef<TWithoutRef>>
{};

template<typename T>
struct SmartPointerStorageClass
  : mozilla::Conditional<mozilla::IsRefcountedSmartPointer<T>::value,
                         StoreRefPtrPassByPtr<
                           typename mozilla::RemoveSmartPointer<T>::Type>,
                         StoreCopyPassByConstLRef<T>>
{};

template<typename T>
struct NonLValueReferenceStorageClass
  : mozilla::Conditional<mozilla::IsRvalueReference<T>::value,
                         StoreCopyPassByRRef<
                           typename mozilla::RemoveReference<T>::Type>,
                         typename SmartPointerStorageClass<T>::Type>
{};

template<typename T>
struct NonPointerStorageClass
  : mozilla::Conditional<mozilla::IsLvalueReference<T>::value,
                         typename LValueReferenceStorageClass<
                           typename mozilla::RemoveReference<T>::Type
                         >::Type,
                         typename NonLValueReferenceStorageClass<T>::Type>
{};

template<typename T>
struct NonParameterStorageClass
  : mozilla::Conditional<mozilla::IsPointer<T>::value,
                         typename PointerStorageClass<
                           typename mozilla::RemovePointer<T>::Type
                         >::Type,
                         typename NonPointerStorageClass<T>::Type>
{};
template<typename T>
struct ParameterStorage
  : mozilla::Conditional<IsParameterStorageClass<T>::value,
                         T,
                         typename NonParameterStorageClass<T>::Type>
{};

}

namespace mozilla {

namespace detail {


template <typename... Ts>
struct RunnableMethodArguments final
{
  Tuple<typename ::detail::ParameterStorage<Ts>::Type...> mArguments;
  template <typename... As>
  explicit RunnableMethodArguments(As&&... aArguments)
    : mArguments(Forward<As>(aArguments)...)
  {}
  template<typename C, typename M, typename... Args, size_t... Indices>
  static auto
  applyImpl(C* o, M m, Tuple<Args...>& args, IndexSequence<Indices...>)
      -> decltype(((*o).*m)(Get<Indices>(args).PassAsParameter()...))
  {
    return ((*o).*m)(Get<Indices>(args).PassAsParameter()...);
  }
  template<class C, typename M> auto apply(C* o, M m)
      -> decltype(applyImpl(o, m, mArguments,
                  typename IndexSequenceFor<Ts...>::Type()))
  {
    return applyImpl(o, m, mArguments,
        typename IndexSequenceFor<Ts...>::Type());
  }
};

template<typename PtrType, typename Method, bool Owning, bool Cancelable, typename... Storages>
class RunnableMethodImpl final
  : public ::nsRunnableMethodTraits<PtrType, Method, Owning, Cancelable>::base_type
{
  typedef typename ::nsRunnableMethodTraits<PtrType, Method, Owning, Cancelable>::class_type
      ClassType;
  ::nsRunnableMethodReceiver<ClassType, Owning> mReceiver;
  Method mMethod;
  RunnableMethodArguments<Storages...> mArgs;
private:
  virtual ~RunnableMethodImpl() { Revoke(); };
public:
  template<typename ForwardedPtrType, typename... Args>
  explicit RunnableMethodImpl(ForwardedPtrType&& aObj, Method aMethod,
                              Args&&... aArgs)
    : mReceiver(Forward<ForwardedPtrType>(aObj))
    , mMethod(aMethod)
    , mArgs(Forward<Args>(aArgs)...)
  {
    static_assert(sizeof...(Storages) == sizeof...(Args), "Storages and Args should have equal sizes");
  }
  virtual nsresult Run()
  {
    if ((__builtin_expect(!!(mReceiver.Get()), 1))) {
      mArgs.apply(mReceiver.Get(), mMethod);
    }
    return NS_OK;
  }
  nsresult Cancel() {
    static_assert(Cancelable, "Don't use me!");
    Revoke();
    return NS_OK;
  }
  void Revoke() { mReceiver.Revoke(); }
};


template<typename PtrType, typename Method>
using OwningRunnableMethod = typename ::nsRunnableMethodTraits<
  typename RemoveReference<PtrType>::Type, Method, true, false>::base_type;
template<typename PtrType, typename Method, typename... Storages>
using OwningRunnableMethodImpl = RunnableMethodImpl<
  typename RemoveReference<PtrType>::Type, Method, true, false, Storages...>;


template<typename PtrType, typename Method>
using CancelableRunnableMethod = typename ::nsRunnableMethodTraits<
  typename RemoveReference<PtrType>::Type, Method, true, true>::base_type;
template<typename PtrType, typename Method, typename... Storages>
using CancelableRunnableMethodImpl = RunnableMethodImpl<
  typename RemoveReference<PtrType>::Type, Method, true, true, Storages...>;


template<typename PtrType, typename Method>
using NonOwningRunnableMethod = typename ::nsRunnableMethodTraits<
  typename RemoveReference<PtrType>::Type, Method, false, false>::base_type;
template<typename PtrType, typename Method, typename... Storages>
using NonOwningRunnableMethodImpl = RunnableMethodImpl<
  typename RemoveReference<PtrType>::Type, Method, false, false, Storages...>;


template<typename PtrType, typename Method>
using NonOwningCancelableRunnableMethod = typename ::nsRunnableMethodTraits<
  typename RemoveReference<PtrType>::Type, Method, false, true>::base_type;
template<typename PtrType, typename Method, typename... Storages>
using NonOwningCancelableRunnableMethodImpl = RunnableMethodImpl<
  typename RemoveReference<PtrType>::Type, Method, false, true, Storages...>;

}
template<typename PtrType, typename Method>
already_AddRefed<detail::OwningRunnableMethod<PtrType, Method>>
NewRunnableMethod(PtrType&& aPtr, Method aMethod)
{
  return do_AddRef(
    new detail::OwningRunnableMethodImpl<PtrType, Method>
      (Forward<PtrType>(aPtr), aMethod));
}

template<typename PtrType, typename Method>
already_AddRefed<detail::OwningRunnableMethod<PtrType, Method>>
NewRunnableMethod(const char* aName, PtrType&& aPtr, Method aMethod)
{
  return detail::SetRunnableName(
    NewRunnableMethod(Forward<PtrType>(aPtr), aMethod), aName);
}

template<typename PtrType, typename Method>
already_AddRefed<detail::CancelableRunnableMethod<PtrType, Method>>
NewCancelableRunnableMethod(PtrType&& aPtr, Method aMethod)
{
  return do_AddRef(
    new detail::CancelableRunnableMethodImpl<PtrType, Method>
      (Forward<PtrType>(aPtr), aMethod));
}

template<typename PtrType, typename Method>
already_AddRefed<detail::CancelableRunnableMethod<PtrType, Method>>
NewCancelableRunnableMethod(const char* aName, PtrType&& aPtr, Method aMethod)
{
  return detail::SetRunnableName(
    NewCancelableRunnableMethod(Forward<PtrType>(aPtr), aMethod), aName);
}

template<typename PtrType, typename Method>
already_AddRefed<detail::NonOwningRunnableMethod<PtrType, Method>>
NewNonOwningRunnableMethod(PtrType&& aPtr, Method aMethod)
{
  return do_AddRef(
    new detail::NonOwningRunnableMethodImpl<PtrType, Method>
      (Forward<PtrType>(aPtr), aMethod));
}

template<typename PtrType, typename Method>
already_AddRefed<detail::NonOwningRunnableMethod<PtrType, Method>>
NewNonOwningRunnableMethod(const char* aName, PtrType&& aPtr, Method aMethod)
{
  return detail::SetRunnableName(
    NewNonOwningRunnableMethod(Forward<PtrType>(aPtr), aMethod), aName);
}

template<typename PtrType, typename Method>
already_AddRefed<detail::NonOwningCancelableRunnableMethod<PtrType, Method>>
NewNonOwningCancelableRunnableMethod(PtrType&& aPtr, Method aMethod)
{
  return do_AddRef(
    new detail::NonOwningCancelableRunnableMethodImpl<PtrType, Method>
      (Forward<PtrType>(aPtr), aMethod));
}

template<typename PtrType, typename Method>
already_AddRefed<detail::NonOwningCancelableRunnableMethod<PtrType, Method>>
NewNonOwningCancelableRunnableMethod(const char* aName, PtrType&& aPtr,
                                     Method aMethod)
{
  return detail::SetRunnableName(
    NewNonOwningCancelableRunnableMethod(Forward<PtrType>(aPtr), aMethod), aName);
}





template<typename... Storages, typename PtrType, typename Method, typename... Args>
already_AddRefed<detail::OwningRunnableMethod<PtrType, Method>>
NewRunnableMethod(PtrType&& aPtr, Method aMethod, Args&&... aArgs)
{
  static_assert(sizeof...(Storages) == sizeof...(Args),
                "<Storages...> size should be equal to number of arguments");
  return do_AddRef(
    new detail::OwningRunnableMethodImpl<PtrType, Method, Storages...>
      (Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
}

template<typename... Storages, typename PtrType, typename Method, typename... Args>
already_AddRefed<detail::OwningRunnableMethod<PtrType, Method>>
NewRunnableMethod(const char* aName, PtrType&& aPtr, Method aMethod, Args&&... aArgs)
{
  static_assert(sizeof...(Storages) == sizeof...(Args),
                "<Storages...> size should be equal to number of arguments");
  return detail::SetRunnableName(
    NewRunnableMethod<Storages...>
      (Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...), aName);
}

template<typename... Storages, typename PtrType, typename Method, typename... Args>
already_AddRefed<detail::NonOwningRunnableMethod<PtrType, Method>>
NewNonOwningRunnableMethod(PtrType&& aPtr, Method aMethod, Args&&... aArgs)
{
  static_assert(sizeof...(Storages) == sizeof...(Args),
                "<Storages...> size should be equal to number of arguments");
  return do_AddRef(
      new detail::NonOwningRunnableMethodImpl<PtrType, Method, Storages...>
      (Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
}

template<typename... Storages, typename PtrType, typename Method, typename... Args>
already_AddRefed<detail::NonOwningRunnableMethod<PtrType, Method>>
NewNonOwningRunnableMethod(const char* aName, PtrType&& aPtr, Method aMethod,
                           Args&&... aArgs)
{
  static_assert(sizeof...(Storages) == sizeof...(Args),
                "<Storages...> size should be equal to number of arguments");
  return detail::SetRunnableName(
    NewNonOwningRunnableMethod<Storages...>
      (Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...), aName);
}

template<typename... Storages, typename PtrType, typename Method, typename... Args>
already_AddRefed<detail::CancelableRunnableMethod<PtrType, Method>>
NewCancelableRunnableMethod(PtrType&& aPtr, Method aMethod, Args&&... aArgs)
{
  static_assert(sizeof...(Storages) == sizeof...(Args),
                "<Storages...> size should be equal to number of arguments");
  return do_AddRef(
    new detail::CancelableRunnableMethodImpl<PtrType, Method, Storages...>
      (Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
}

template<typename... Storages, typename PtrType, typename Method, typename... Args>
already_AddRefed<detail::CancelableRunnableMethod<PtrType, Method>>
NewCancelableRunnableMethod(const char* aName, PtrType&& aPtr, Method aMethod,
                            Args&&... aArgs)
{
  static_assert(sizeof...(Storages) == sizeof...(Args),
                "<Storages...> size should be equal to number of arguments");
  return detail::SetRunnableName(
    NewCancelableRunnableMethod<Storages...>
      (Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...), aName);
}

template<typename... Storages, typename PtrType, typename Method, typename... Args>
already_AddRefed<detail::NonOwningCancelableRunnableMethod<PtrType, Method>>
NewNonOwningCancelableRunnableMethod(PtrType&& aPtr, Method aMethod,
                                     Args&&... aArgs)
{
  static_assert(sizeof...(Storages) == sizeof...(Args),
                "<Storages...> size should be equal to number of arguments");
  return do_AddRef(
    new detail::NonOwningCancelableRunnableMethodImpl<PtrType, Method, Storages...>
      (Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
}

template<typename... Storages, typename PtrType, typename Method, typename... Args>
already_AddRefed<detail::NonOwningCancelableRunnableMethod<PtrType, Method>>
NewNonOwningCancelableRunnableMethod(const char* aName, PtrType&& aPtr,
                                     Method aMethod, Args&&... aArgs)
{
  static_assert(sizeof...(Storages) == sizeof...(Args),
                "<Storages...> size should be equal to number of arguments");
  return detail::SetRunnableName(
    NewNonOwningCancelableRunnableMethod<Storages...>
      (Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...), aName);
}

}
template<class T>
class nsRevocableEventPtr
{
public:
  nsRevocableEventPtr() : mEvent(nullptr) {}
  ~nsRevocableEventPtr() { Revoke(); }

  const nsRevocableEventPtr& operator=(T* aEvent)
  {
    if (mEvent != aEvent) {
      Revoke();
      mEvent = aEvent;
    }
    return *this;
  }

  const nsRevocableEventPtr& operator=(already_AddRefed<T> aEvent)
  {
    RefPtr<T> event = aEvent;
    if (mEvent != event) {
      Revoke();
      mEvent = event.forget();
    }
    return *this;
  }

  void Revoke()
  {
    if (mEvent) {
      mEvent->Revoke();
      mEvent = nullptr;
    }
  }

  void Forget() { mEvent = nullptr; }
  bool IsPending() { return mEvent != nullptr; }
  T* get() { return mEvent; }

private:

  nsRevocableEventPtr(const nsRevocableEventPtr&);
  nsRevocableEventPtr& operator=(const nsRevocableEventPtr&);

  RefPtr<T> mEvent;
};





class nsThreadPoolNaming
{
public:
  nsThreadPoolNaming() : mCounter(0) {}




  nsCString GetNextThreadName(const nsACString& aPoolName);

  template<size_t LEN>
  nsCString GetNextThreadName(const char (&aPoolName)[LEN])
  {
    return GetNextThreadName(nsDependentCString(aPoolName, LEN - 1));
  }

private:
  mozilla::Atomic<uint32_t> mCounter;

  nsThreadPoolNaming(const nsThreadPoolNaming&) = delete;
  void operator=(const nsThreadPoolNaming&) = delete;
};







class nsAutoLowPriorityIO
{
public:
  nsAutoLowPriorityIO();
  ~nsAutoLowPriorityIO();

private:
  bool lowIOPrioritySet;



};

void
NS_SetMainThread();



namespace mozilla {


enum class StyleBasicShapeType : uint8_t {
  Polygon,
  Circle,
  Ellipse,
  Inset,
};


enum class StyleBoxAlign : uint8_t {
  Stretch,
  Start,
  Center,
  Baseline,
  End,
};


enum class StyleBoxDecorationBreak : uint8_t {
  Slice,
  Clone,
};


enum class StyleBoxDirection : uint8_t {
  Normal,
  Reverse,
};


enum class StyleBoxOrient : uint8_t {
  Horizontal,
  Vertical,
};


enum class StyleBoxPack : uint8_t {
  Start,
  Center,
  End,
  Justify,
};


enum class StyleBoxSizing : uint8_t {
  Content,
  Border
};


enum class StyleBoxShadowType : uint8_t {
  Inset,
};


enum class StyleClear : uint8_t {
  None = 0,
  Left,
  Right,
  InlineStart,
  InlineEnd,
  Both,


  Line = 8,
  Max = 13
};



enum class StyleGeometryBox : uint8_t {
  ContentBox,
  PaddingBox,
  BorderBox,
  MarginBox,



  FillBox,
  StrokeBox,
  ViewBox,
  NoClip,
  Text,
  NoBox,






  MozAlmostPadding = 127






};


enum class StyleFillRule : uint8_t {
  Nonzero,
  Evenodd,
};



enum class StyleFloat : uint8_t {
  None,
  Left,
  Right,
  InlineStart,
  InlineEnd
};


enum class StyleFloatEdge : uint8_t {
  ContentBox,
  MarginBox,
};


enum class StyleHyphens : uint8_t {
  None,
  Manual,
  Auto,
};


enum class StyleShapeRadius : uint8_t {
  ClosestSide,
  FarthestSide,
};


enum class StyleShapeSourceType : uint8_t {
  None,
  URL,
  Shape,
  Box,
};


enum class StyleTextJustify : uint8_t {
  None,
  Auto,
  InterWord,
  InterCharacter,
};


enum class StyleUserFocus : uint8_t {
  None,
  Ignore,
  Normal,
  SelectAll,
  SelectBefore,
  SelectAfter,
  SelectSame,
  SelectMenu,
};


enum class StyleUserSelect : uint8_t {
  None,
  Text,
  Element,
  Elements,
  All,
  Toggle,
  TriState,
  Auto,
  MozAll,
  MozText,
};


enum class StyleUserInput : uint8_t {
  None,
  Enabled,
  Disabled,
  Auto,
};


enum class StyleUserModify : uint8_t {
  ReadOnly,
  ReadWrite,
  WriteOnly,
};


enum class StyleWindowDragging : uint8_t {
  Default,
  Drag,
  NoDrag,
};


enum class StyleOrient : uint8_t {
  Inline,
  Block,
  Horizontal,
  Vertical,
};
namespace dom {
enum class PlaybackDirection : uint8_t;
enum class FillMode : uint8_t;
}
enum class StyleDisplay : uint8_t {
  None = 0,
  Block,
  FlowRoot,
  Inline,
  InlineBlock,
  ListItem,
  Table,
  InlineTable,
  TableRowGroup,
  TableColumn,
  TableColumnGroup,
  TableHeaderGroup,
  TableFooterGroup,
  TableRow,
  TableCell,
  TableCaption,
  Flex,
  InlineFlex,
  Grid,
  InlineGrid,
  Ruby,
  RubyBase,
  RubyBaseContainer,
  RubyText,
  RubyTextContainer,
  Contents,
  WebkitBox,
  WebkitInlineBox,
  MozBox,
  MozInlineBox,

  MozGrid,
  MozInlineGrid,
  MozGridGroup,
  MozGridLine,
  MozStack,
  MozInlineStack,
  MozDeck,
  MozGroupbox,
  MozPopup,

};
enum class StyleGridTrackBreadth : uint8_t {
  MaxContent = 1,
  MinContent = 2,
};
}
namespace mozilla {

class WritingMode;


enum LogicalAxis {
  eLogicalAxisBlock = 0x0,
  eLogicalAxisInline = 0x1
};
enum LogicalEdge {
  eLogicalEdgeStart = 0x0,
  eLogicalEdgeEnd = 0x1
};
enum LogicalSide {
  eLogicalSideBStart = (eLogicalAxisBlock << 1) | eLogicalEdgeStart,
  eLogicalSideBEnd = (eLogicalAxisBlock << 1) | eLogicalEdgeEnd,
  eLogicalSideIStart = (eLogicalAxisInline << 1) | eLogicalEdgeStart,
  eLogicalSideIEnd = (eLogicalAxisInline << 1) | eLogicalEdgeEnd
};

enum LogicalCorner
{
  eLogicalCornerBStartIStart = 0,
  eLogicalCornerBStartIEnd = 1,
  eLogicalCornerBEndIEnd = 2,
  eLogicalCornerBEndIStart = 3
};

}

enum nsStyleUnit : uint8_t {
  eStyleUnit_Null = 0,
  eStyleUnit_Normal = 1,
  eStyleUnit_Auto = 2,
  eStyleUnit_None = 3,
  eStyleUnit_Percent = 10,
  eStyleUnit_Factor = 11,
  eStyleUnit_Degree = 12,
  eStyleUnit_Grad = 13,
  eStyleUnit_Radian = 14,
  eStyleUnit_Turn = 15,
  eStyleUnit_FlexFraction = 16,
  eStyleUnit_Coord = 20,
  eStyleUnit_Integer = 30,
  eStyleUnit_Enumerated = 32,


  eStyleUnit_Calc = 40,


  eStyleUnit_MAX = 40
};

typedef union {
  int32_t mInt;
  float mFloat;


  void* mPointer;
} nsStyleUnion;
class nsStyleCoord {
public:


  struct CalcValue {

    nscoord mLength;
    float mPercent;
    bool mHasPercent;

    bool operator==(const CalcValue& aOther) const {
      return mLength == aOther.mLength &&
             mPercent == aOther.mPercent &&
             mHasPercent == aOther.mHasPercent;
    }
    bool operator!=(const CalcValue& aOther) const {
      return !(*this == aOther);
    }

    nscoord ToLength() const {
      do { } while (0);
      return mLength;
    }



    bool IsDefinitelyZero() const { return mLength == 0 && mPercent == 0; }
  };



  struct Calc final : public CalcValue {
    public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<Calc>::value, "Reference-counted class " "Calc" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); nsrefcnt count = ++mRefCnt; ; return (nsrefcnt) count; } MozExternalRefCountType Release(void) { do { } while (0); nsrefcnt count = --mRefCnt; ; if (count == 0) { delete (this); return 0; } return count; } typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:
    Calc() {}

  private:
    Calc(const Calc&) = delete;
    ~Calc() {}
    Calc& operator=(const Calc&) = delete;
  };

  explicit nsStyleCoord(nsStyleUnit aUnit = eStyleUnit_Null);
  enum CoordConstructorType { CoordConstructor };
  inline nsStyleCoord(nscoord aValue, CoordConstructorType);
  nsStyleCoord(int32_t aValue, nsStyleUnit aUnit);
  nsStyleCoord(float aValue, nsStyleUnit aUnit);
  inline nsStyleCoord(const nsStyleCoord& aCopy);
  inline nsStyleCoord(const nsStyleUnion& aValue, nsStyleUnit aUnit);
  ~nsStyleCoord() { Reset(); }

  nsStyleCoord& operator=(const nsStyleCoord& aOther)
  {
    if (this != &aOther) {
      SetValue(mUnit, mValue, aOther);
    }
    return *this;
  }
  bool operator==(const nsStyleCoord& aOther) const;
  bool operator!=(const nsStyleCoord& aOther) const;

  nsStyleUnit GetUnit() const {
    do { } while(0);
    return mUnit;
  }

  bool IsAngleValue() const {
    return eStyleUnit_Degree <= mUnit && mUnit <= eStyleUnit_Turn;
  }

  static bool IsCalcUnit(nsStyleUnit aUnit) {
    return aUnit == eStyleUnit_Calc;
  }

  static bool IsPointerUnit(nsStyleUnit aUnit) {
    return IsCalcUnit(aUnit);
  }

  bool IsCalcUnit() const {
    return IsCalcUnit(mUnit);
  }

  bool IsPointerValue() const {
    return IsPointerUnit(mUnit);
  }

  bool IsCoordPercentCalcUnit() const {
    return mUnit == eStyleUnit_Coord ||
           mUnit == eStyleUnit_Percent ||
           IsCalcUnit();
  }



  bool CalcHasPercent() const {
    return GetCalcValue()->mHasPercent;
  }

  bool HasPercent() const {
    return mUnit == eStyleUnit_Percent ||
           (IsCalcUnit() && CalcHasPercent());
  }

  static bool ConvertsToLength(const nsStyleUnit aUnit,
                               const nsStyleUnion aValue) {
    return aUnit == eStyleUnit_Coord ||
           (IsCalcUnit(aUnit) && !AsCalcValue(aValue)->mHasPercent);
  }

  bool ConvertsToLength() const {
    return ConvertsToLength(mUnit, mValue);
  }

  static nscoord ToLength(nsStyleUnit aUnit, nsStyleUnion aValue) {
    do { } while (0);
    if (IsCalcUnit(aUnit)) {
      return AsCalcValue(aValue)->ToLength();
    }
    do { } while (0);
    return aValue.mInt;
  }

  nscoord ToLength() const {
    return ToLength(GetUnit(), mValue);
  }


  static Calc* AsCalcValue(nsStyleUnion aValue) {
    return static_cast<Calc*>(aValue.mPointer);
  }

  nscoord GetCoordValue() const;
  int32_t GetIntValue() const;
  float GetPercentValue() const;
  float GetFactorValue() const;
  float GetFactorOrPercentValue() const;
  float GetAngleValue() const;
  double GetAngleValueInDegrees() const;
  double GetAngleValueInRadians() const;
  float GetFlexFractionValue() const;
  Calc* GetCalcValue() const;
  uint32_t HashValue(uint32_t aHash) const;
  template<typename T,
           typename = typename std::enable_if<std::is_enum<T>::value>::type>
  T GetEnumValue() const
  {
    do { } while (0);

    return static_cast<T>(GetIntValue());
  }



  void Reset();

  void SetCoordValue(nscoord aValue);
  void SetIntValue(int32_t aValue, nsStyleUnit aUnit);
  void SetPercentValue(float aValue);
  void SetFactorValue(float aValue);
  void SetAngleValue(float aValue, nsStyleUnit aUnit);
  void SetFlexFractionValue(float aValue);
  void SetNormalValue();
  void SetAutoValue();
  void SetNoneValue();
  void SetCalcValue(Calc* aValue);
  template<typename T,
           typename = typename std::enable_if<std::is_enum<T>::value>::type>
  void SetEnumValue(T aValue)
  {
    static_assert(mozilla::EnumTypeFitsWithin<T, int32_t>::value,
                  "aValue must be an enum that fits within mValue.mInt!");
    SetIntValue(static_cast<int32_t>(aValue), eStyleUnit_Enumerated);
  }


  static inline void Reset(nsStyleUnit& aUnit, nsStyleUnion& aValue);



  static inline void SetValue(nsStyleUnit& aUnit,
                              nsStyleUnion& aValue,
                              nsStyleUnit aOtherUnit,
                              const nsStyleUnion& aOtherValue);


  static inline void SetValue(nsStyleUnit& aUnit, nsStyleUnion& aValue,
                              const nsStyleCoord& aOther);


  static inline void InitWithValue(nsStyleUnit& aUnit,
                                   nsStyleUnion& aValue,
                                   nsStyleUnit aOtherUnit,
                                   const nsStyleUnion& aOtherValue);

  static inline void InitWithValue(nsStyleUnit& aUnit, nsStyleUnion& aValue,
                                   const nsStyleCoord& aOther);

private:
  nsStyleUnit mUnit;
  nsStyleUnion mValue;
};







class nsStyleSides {
public:
  nsStyleSides();
  nsStyleSides(const nsStyleSides&);
  ~nsStyleSides();

  nsStyleSides& operator=(const nsStyleSides& aCopy);
  bool operator==(const nsStyleSides& aOther) const;
  bool operator!=(const nsStyleSides& aOther) const;

  inline nsStyleUnit GetUnit(mozilla::Side aSide) const;
  inline nsStyleUnit GetLeftUnit() const;
  inline nsStyleUnit GetTopUnit() const;
  inline nsStyleUnit GetRightUnit() const;
  inline nsStyleUnit GetBottomUnit() const;

  inline nsStyleCoord Get(mozilla::Side aSide) const;
  inline nsStyleCoord GetLeft() const;
  inline nsStyleCoord GetTop() const;
  inline nsStyleCoord GetRight() const;
  inline nsStyleCoord GetBottom() const;





  inline nsStyleUnit GetUnit(mozilla::WritingMode aWritingMode,
                             mozilla::LogicalSide aSide) const;
  inline nsStyleUnit GetIStartUnit(mozilla::WritingMode aWritingMode) const;
  inline nsStyleUnit GetBStartUnit(mozilla::WritingMode aWritingMode) const;
  inline nsStyleUnit GetIEndUnit(mozilla::WritingMode aWritingMode) const;
  inline nsStyleUnit GetBEndUnit(mozilla::WritingMode aWritingMode) const;


  inline bool HasBlockAxisAuto(mozilla::WritingMode aWritingMode) const;
  inline bool HasInlineAxisAuto(mozilla::WritingMode aWritingMode) const;

  inline nsStyleCoord Get(mozilla::WritingMode aWritingMode,
                          mozilla::LogicalSide aSide) const;
  inline nsStyleCoord GetIStart(mozilla::WritingMode aWritingMode) const;
  inline nsStyleCoord GetBStart(mozilla::WritingMode aWritingMode) const;
  inline nsStyleCoord GetIEnd(mozilla::WritingMode aWritingMode) const;
  inline nsStyleCoord GetBEnd(mozilla::WritingMode aWritingMode) const;




  void Reset();

  inline void Set(mozilla::Side aSide, const nsStyleCoord& aCoord);
  inline void SetLeft(const nsStyleCoord& aCoord);
  inline void SetTop(const nsStyleCoord& aCoord);
  inline void SetRight(const nsStyleCoord& aCoord);
  inline void SetBottom(const nsStyleCoord& aCoord);

  nscoord ToLength(mozilla::Side aSide) const {
    return nsStyleCoord::ToLength(mUnits[aSide], mValues[aSide]);
  }

  bool ConvertsToLength() const {
    int32_t side354 = mozilla::eSideTop; for (mozilla::Side side; side354 <= mozilla::eSideLeft && ((side = mozilla::Side(side354)), true); ++side354) {
      if (!nsStyleCoord::ConvertsToLength(mUnits[side], mValues[side])) {
        return false;
      }
    }
    return true;
  }

protected:
  nsStyleUnit mUnits[4];
  nsStyleUnion mValues[4];
};







class nsStyleCorners {
public:
  nsStyleCorners();
  nsStyleCorners(const nsStyleCorners&);
  ~nsStyleCorners();


  nsStyleCorners& operator=(const nsStyleCorners& aCopy);
  bool operator==(const nsStyleCorners& aOther) const;
  bool operator!=(const nsStyleCorners& aOther) const;


  inline nsStyleUnit GetUnit(uint8_t aHalfCorner) const;

  inline nsStyleCoord Get(uint8_t aHalfCorner) const;




  void Reset();

  inline void Set(uint8_t aHalfCorner, const nsStyleCoord& aCoord);

protected:





  nsStyleUnit mUnits[8];
  nsStyleUnion mValues[8];
};





inline nsStyleCoord::nsStyleCoord(nscoord aValue, CoordConstructorType)
  : mUnit(eStyleUnit_Coord)
{
  mValue.mInt = aValue;
}

inline nsStyleCoord::nsStyleCoord(const nsStyleCoord& aCopy)
  : mUnit(eStyleUnit_Null)
{
  InitWithValue(mUnit, mValue, aCopy);
}

inline nsStyleCoord::nsStyleCoord(const nsStyleUnion& aValue, nsStyleUnit aUnit)
  : mUnit(eStyleUnit_Null)
{
  InitWithValue(mUnit, mValue, aUnit, aValue);
}

inline bool nsStyleCoord::operator!=(const nsStyleCoord& aOther) const
{
  return !((*this) == aOther);
}

inline nscoord nsStyleCoord::GetCoordValue() const
{
  do { } while(0);
  if (mUnit == eStyleUnit_Coord) {
    return mValue.mInt;
  }
  return 0;
}

inline int32_t nsStyleCoord::GetIntValue() const
{
  do { } while(0);

  if ((mUnit == eStyleUnit_Enumerated) ||
      (mUnit == eStyleUnit_Integer)) {
    return mValue.mInt;
  }
  return 0;
}

inline float nsStyleCoord::GetPercentValue() const
{
  do { } while(0);
  if (mUnit == eStyleUnit_Percent) {
    return mValue.mFloat;
  }
  return 0.0f;
}

inline float nsStyleCoord::GetFactorValue() const
{
  do { } while(0);
  if (mUnit == eStyleUnit_Factor) {
    return mValue.mFloat;
  }
  return 0.0f;
}

inline float nsStyleCoord::GetFactorOrPercentValue() const
{
  do { } while(0);

  if (mUnit == eStyleUnit_Factor || mUnit == eStyleUnit_Percent) {
    return mValue.mFloat;
  }
  return 0.0f;
}

inline float nsStyleCoord::GetAngleValue() const
{
  do { } while(0);

  if (mUnit >= eStyleUnit_Degree && mUnit <= eStyleUnit_Turn) {
    return mValue.mFloat;
  }
  return 0.0f;
}

inline float nsStyleCoord::GetFlexFractionValue() const
{
  do { } while(0);
  if (mUnit == eStyleUnit_FlexFraction) {
    return mValue.mFloat;
  }
  return 0.0f;
}

inline nsStyleCoord::Calc* nsStyleCoord::GetCalcValue() const
{
  do { } while(0);
  if (IsCalcUnit()) {
    return AsCalcValue(mValue);
  }
  return nullptr;
}

             inline void
nsStyleCoord::Reset(nsStyleUnit& aUnit, nsStyleUnion& aValue)
{
  do { } while (0);


  switch (aUnit) {
    case eStyleUnit_Calc:
      static_cast<Calc*>(aValue.mPointer)->Release();
      break;
    default:
      do { } while (0);
  }

  aUnit = eStyleUnit_Null;
  aValue.mInt = 0;
}

             inline void
nsStyleCoord::SetValue(nsStyleUnit& aUnit,
                       nsStyleUnion& aValue,
                       nsStyleUnit aOtherUnit,
                       const nsStyleUnion& aOtherValue)
{
  Reset(aUnit, aValue);
  InitWithValue(aUnit, aValue, aOtherUnit, aOtherValue);
}

             inline void
nsStyleCoord::InitWithValue(nsStyleUnit& aUnit,
                            nsStyleUnion& aValue,
                            nsStyleUnit aOtherUnit,
                            const nsStyleUnion& aOtherValue)
{
  aUnit = aOtherUnit;
  aValue = aOtherValue;

  switch (aUnit) {
    case eStyleUnit_Calc:
      static_cast<Calc*>(aValue.mPointer)->AddRef();
      break;
    default:
      do { } while (0);
  }
}

             inline void
nsStyleCoord::SetValue(nsStyleUnit& aUnit, nsStyleUnion& aValue,
                       const nsStyleCoord& aOther)
{
  SetValue(aUnit, aValue, aOther.mUnit, aOther.mValue);
}

             inline void
nsStyleCoord::InitWithValue(nsStyleUnit& aUnit, nsStyleUnion& aValue,
                            const nsStyleCoord& aOther)
{
  InitWithValue(aUnit, aValue, aOther.mUnit, aOther.mValue);
}





inline bool nsStyleSides::operator!=(const nsStyleSides& aOther) const
{
  return !((*this) == aOther);
}

inline nsStyleUnit nsStyleSides::GetUnit(mozilla::Side aSide) const
{
  return (nsStyleUnit)mUnits[aSide];
}

inline nsStyleUnit nsStyleSides::GetLeftUnit() const
{
  return GetUnit(mozilla::eSideLeft);
}

inline nsStyleUnit nsStyleSides::GetTopUnit() const
{
  return GetUnit(mozilla::eSideTop);
}

inline nsStyleUnit nsStyleSides::GetRightUnit() const
{
  return GetUnit(mozilla::eSideRight);
}

inline nsStyleUnit nsStyleSides::GetBottomUnit() const
{
  return GetUnit(mozilla::eSideBottom);
}

inline nsStyleCoord nsStyleSides::Get(mozilla::Side aSide) const
{
  return nsStyleCoord(mValues[aSide], nsStyleUnit(mUnits[aSide]));
}

inline nsStyleCoord nsStyleSides::GetLeft() const
{
  return Get(mozilla::eSideLeft);
}

inline nsStyleCoord nsStyleSides::GetTop() const
{
  return Get(mozilla::eSideTop);
}

inline nsStyleCoord nsStyleSides::GetRight() const
{
  return Get(mozilla::eSideRight);
}

inline nsStyleCoord nsStyleSides::GetBottom() const
{
  return Get(mozilla::eSideBottom);
}

inline void nsStyleSides::Set(mozilla::Side aSide, const nsStyleCoord& aCoord)
{
  nsStyleCoord::SetValue(mUnits[aSide], mValues[aSide], aCoord);
}

inline void nsStyleSides::SetLeft(const nsStyleCoord& aCoord)
{
  Set(mozilla::eSideLeft, aCoord);
}

inline void nsStyleSides::SetTop(const nsStyleCoord& aCoord)
{
  Set(mozilla::eSideTop, aCoord);
}

inline void nsStyleSides::SetRight(const nsStyleCoord& aCoord)
{
  Set(mozilla::eSideRight, aCoord);
}

inline void nsStyleSides::SetBottom(const nsStyleCoord& aCoord)
{
  Set(mozilla::eSideBottom, aCoord);
}




inline bool nsStyleCorners::operator!=(const nsStyleCorners& aOther) const
{
  return !((*this) == aOther);
}

inline nsStyleUnit nsStyleCorners::GetUnit(uint8_t aCorner) const
{
  return (nsStyleUnit)mUnits[aCorner];
}

inline nsStyleCoord nsStyleCorners::Get(uint8_t aCorner) const
{
  return nsStyleCoord(mValues[aCorner], nsStyleUnit(mUnits[aCorner]));
}

inline void nsStyleCorners::Set(uint8_t aCorner, const nsStyleCoord& aCoord)
{
  nsStyleCoord::SetValue(mUnits[aCorner], mValues[aCorner], aCoord);
}











typedef uint8_t jsbytecode;



namespace JS {


typedef bool (*IsAcceptableThis)(HandleValue v);



typedef bool (*NativeImpl)(JSContext* cx, const CallArgs& args);

namespace detail {


extern bool
CallMethodIfWrapped(JSContext* cx, IsAcceptableThis test, NativeImpl impl, const CallArgs& args);

}
template<IsAcceptableThis Test, NativeImpl Impl>
__attribute__((always_inline)) inline bool
CallNonGenericMethod(JSContext* cx, const CallArgs& args)
{
    HandleValue thisv = args.thisv();
    if (Test(thisv))
        return Impl(cx, args);

    return detail::CallMethodIfWrapped(cx, Test, Impl, args);
}

__attribute__((always_inline)) inline bool
CallNonGenericMethod(JSContext* cx, IsAcceptableThis Test, NativeImpl Impl, const CallArgs& args)
{
    HandleValue thisv = args.thisv();
    if (Test(thisv))
        return Impl(cx, args);

    return detail::CallMethodIfWrapped(cx, Test, Impl, args);
}

}
class JSAtom;
struct JSErrorFormatString;
class JSLinearString;
struct JSJitInfo;
class JSErrorReport;

namespace JS {
template <class T>
class Heap;
}

namespace js {
class BaseProxyHandler;
class InterpreterFrame;
}

extern void
JS_SetGrayGCRootsTracer(JSContext* cx, JSTraceDataOp traceOp, void* data);

extern JSObject*
JS_FindCompilationScope(JSContext* cx, JS::HandleObject obj);

extern JSFunction*
JS_GetObjectFunction(JSObject* obj);

extern bool
JS_SplicePrototype(JSContext* cx, JS::HandleObject obj, JS::HandleObject proto);

extern JSObject*
JS_NewObjectWithUniqueType(JSContext* cx, const JSClass* clasp, JS::HandleObject proto);







extern JSObject*
JS_NewObjectWithoutMetadata(JSContext* cx, const JSClass* clasp, JS::Handle<JSObject*> proto);

extern uint32_t
JS_ObjectCountDynamicSlots(JS::HandleObject obj);

extern size_t
JS_SetProtoCalled(JSContext* cx);

extern size_t
JS_GetCustomIteratorCount(JSContext* cx);

extern bool
JS_NondeterministicGetWeakMapKeys(JSContext* cx, JS::HandleObject obj, JS::MutableHandleObject ret);

extern bool
JS_NondeterministicGetWeakSetKeys(JSContext* cx, JS::HandleObject obj, JS::MutableHandleObject ret);


extern unsigned
JS_PCToLineNumber(JSScript* script, jsbytecode* pc, unsigned* columnp = nullptr);







extern bool
JS_IsDeadWrapper(JSObject* obj);





extern void
JS_TraceShapeCycleCollectorChildren(JS::CallbackTracer* trc, JS::GCCellPtr shape);
extern void
JS_TraceObjectGroupCycleCollectorChildren(JS::CallbackTracer* trc, JS::GCCellPtr group);

enum {
    JS_TELEMETRY_GC_REASON,
    JS_TELEMETRY_GC_IS_ZONE_GC,
    JS_TELEMETRY_GC_MS,
    JS_TELEMETRY_GC_BUDGET_MS,
    JS_TELEMETRY_GC_ANIMATION_MS,
    JS_TELEMETRY_GC_MAX_PAUSE_MS,
    JS_TELEMETRY_GC_MARK_MS,
    JS_TELEMETRY_GC_SWEEP_MS,
    JS_TELEMETRY_GC_COMPACT_MS,
    JS_TELEMETRY_GC_MARK_ROOTS_MS,
    JS_TELEMETRY_GC_MARK_GRAY_MS,
    JS_TELEMETRY_GC_SLICE_MS,
    JS_TELEMETRY_GC_SLOW_PHASE,
    JS_TELEMETRY_GC_MMU_50,
    JS_TELEMETRY_GC_RESET,
    JS_TELEMETRY_GC_RESET_REASON,
    JS_TELEMETRY_GC_INCREMENTAL_DISABLED,
    JS_TELEMETRY_GC_NON_INCREMENTAL,
    JS_TELEMETRY_GC_NON_INCREMENTAL_REASON,
    JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS,
    JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS,
    JS_TELEMETRY_GC_MINOR_REASON,
    JS_TELEMETRY_GC_MINOR_REASON_LONG,
    JS_TELEMETRY_GC_MINOR_US,
    JS_TELEMETRY_GC_NURSERY_BYTES,
    JS_TELEMETRY_GC_PRETENURE_COUNT,
    JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_CONTENT,
    JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_ADDONS,
    JS_TELEMETRY_ADDON_EXCEPTIONS,
    JS_TELEMETRY_AOT_USAGE,
    JS_TELEMETRY_PRIVILEGED_PARSER_COMPILE_LAZY_AFTER_MS,
    JS_TELEMETRY_WEB_PARSER_COMPILE_LAZY_AFTER_MS,
    JS_TELEMETRY_END
};

typedef void
(*JSAccumulateTelemetryDataCallback)(int id, uint32_t sample, const char* key);

extern void
JS_SetAccumulateTelemetryCallback(JSContext* cx, JSAccumulateTelemetryDataCallback callback);

extern bool
JS_GetIsSecureContext(JSCompartment* compartment);

extern JSPrincipals*
JS_GetCompartmentPrincipals(JSCompartment* compartment);

extern void
JS_SetCompartmentPrincipals(JSCompartment* compartment, JSPrincipals* principals);

extern JSPrincipals*
JS_GetScriptPrincipals(JSScript* script);

extern bool
JS_ScriptHasMutedErrors(JSScript* script);

extern JSObject*
JS_CloneObject(JSContext* cx, JS::HandleObject obj, JS::HandleObject proto);
extern bool
JS_InitializePropertiesFromCompatibleNativeObject(JSContext* cx,
                                                  JS::HandleObject dst,
                                                  JS::HandleObject src);

extern JSString*
JS_BasicObjectToString(JSContext* cx, JS::HandleObject obj);

namespace js {

bool
GetBuiltinClass(JSContext* cx, JS::HandleObject obj, ESClass* cls);

const char*
ObjectClassName(JSContext* cx, JS::HandleObject obj);

void
ReportOverRecursed(JSContext* maybecx);

bool
AddRawValueRoot(JSContext* cx, JS::Value* vp, const char* name);

void
RemoveRawValueRoot(JSContext* cx, JS::Value* vp);

JSAtom*
GetPropertyNameFromPC(JSScript* script, jsbytecode* pc);
extern void
DumpString(JSString* str, FILE* fp);

extern void
DumpAtom(JSAtom* atom, FILE* fp);

extern void
DumpObject(JSObject* obj, FILE* fp);

extern void
DumpChars(const char16_t* s, size_t n, FILE* fp);

extern void
DumpValue(const JS::Value& val, FILE* fp);

extern void
DumpId(jsid id, FILE* fp);

extern void
DumpInterpreterFrame(JSContext* cx, FILE* fp, InterpreterFrame* start = nullptr);

extern bool
DumpPC(JSContext* cx, FILE* fp);

extern bool
DumpScript(JSContext* cx, JSScript* scriptArg, FILE* fp);



extern void DumpString(JSString* str);
extern void DumpAtom(JSAtom* atom);
extern void DumpObject(JSObject* obj);
extern void DumpChars(const char16_t* s, size_t n);
extern void DumpValue(const JS::Value& val);
extern void DumpId(jsid id);
extern void DumpInterpreterFrame(JSContext* cx, InterpreterFrame* start = nullptr);
extern bool DumpPC(JSContext* cx);
extern bool DumpScript(JSContext* cx, JSScript* scriptArg);



extern void
DumpBacktrace(JSContext* cx, FILE* fp);

extern void
DumpBacktrace(JSContext* cx);

}

namespace JS {


extern char*
FormatStackDump(JSContext* cx, char* buf, bool showArgs, bool showLocals, bool showThisProps);





extern bool
ForceLexicalInitialization(JSContext *cx, HandleObject obj);






extern int
IsGCPoisoning();

}
extern bool
JS_CopyPropertiesFrom(JSContext* cx, JS::HandleObject target, JS::HandleObject obj);
typedef enum {
    MakeNonConfigurableIntoConfigurable,
    CopyNonConfigurableAsIs
} PropertyCopyBehavior;

extern bool
JS_CopyPropertyFrom(JSContext* cx, JS::HandleId id, JS::HandleObject target,
                    JS::HandleObject obj,
                    PropertyCopyBehavior copyBehavior = CopyNonConfigurableAsIs);

extern bool
JS_WrapPropertyDescriptor(JSContext* cx, JS::MutableHandle<JS::PropertyDescriptor> desc);

struct JSFunctionSpecWithHelp {
    const char* name;
    JSNative call;
    uint16_t nargs;
    uint16_t flags;
    const JSJitInfo* jitInfo;
    const char* usage;
    const char* help;
};
extern bool
JS_DefineFunctionsWithHelp(JSContext* cx, JS::HandleObject obj, const JSFunctionSpecWithHelp* fs);

namespace js {

extern const js::ClassOps ProxyClassOps;
extern const js::ClassExtension ProxyClassExtension;
extern const js::ObjectOps ProxyObjectOps;
extern JSObject*
proxy_WeakmapKeyDelegate(JSObject* obj);
class SourceHook {
  public:
    virtual ~SourceHook() { }






    virtual bool load(JSContext* cx, const char* filename, char16_t** src, size_t* length) = 0;
};







extern void
SetSourceHook(JSContext* cx, mozilla::UniquePtr<SourceHook> hook);


extern mozilla::UniquePtr<SourceHook>
ForgetSourceHook(JSContext* cx);

extern JS::Zone*
GetCompartmentZone(JSCompartment* comp);

typedef bool
(* PreserveWrapperCallback)(JSContext* cx, JSObject* obj);

typedef enum {
    CollectNurseryBeforeDump,
    IgnoreNurseryObjects
} DumpHeapNurseryBehaviour;





extern void
DumpHeap(JSContext* cx, FILE* fp, DumpHeapNurseryBehaviour nurseryBehaviour);


bool obj_defineGetter(JSContext* cx, unsigned argc, JS::Value* vp);
bool obj_defineSetter(JSContext* cx, unsigned argc, JS::Value* vp);


extern bool
IsSystemCompartment(JSCompartment* comp);

extern bool
IsSystemZone(JS::Zone* zone);

extern bool
IsAtomsCompartment(JSCompartment* comp);

extern bool
IsAtomsZone(JS::Zone* zone);

struct WeakMapTracer
{
    JSContext* context;

    explicit WeakMapTracer(JSContext* cx) : context(cx) {}







    virtual void trace(JSObject* m, JS::GCCellPtr key, JS::GCCellPtr value) = 0;
};

extern void
TraceWeakMaps(WeakMapTracer* trc);

extern bool
AreGCGrayBitsValid(JSContext* cx);

extern bool
ZoneGlobalsAreAllGray(JS::Zone* zone);

typedef void
(*GCThingCallback)(void* closure, JS::GCCellPtr thing);

extern void
VisitGrayWrapperTargets(JS::Zone* zone, GCThingCallback callback, void* closure);

extern JSObject*
GetWeakmapKeyDelegate(JSObject* key);




extern void
IterateGrayObjects(JS::Zone* zone, GCThingCallback cellCallback, void* data);





extern void
IterateGrayObjectsUnderCC(JS::Zone* zone, GCThingCallback cellCallback, void* data);
extern size_t
SizeOfDataIfCDataObject(mozilla::MallocSizeOf mallocSizeOf, JSObject* obj);


extern JSCompartment*
GetAnyCompartmentInZone(JS::Zone* zone);







namespace shadow {

struct ObjectGroup {
    const Class* clasp;
    JSObject* proto;
    JSCompartment* compartment;
};

struct BaseShape {
    const js::Class* clasp_;
    JSObject* parent;
};

class Shape {
public:
    shadow::BaseShape* base;
    jsid _1;
    uint32_t slotInfo;

    static const uint32_t FIXED_SLOTS_SHIFT = 27;
};






struct Object {
    shadow::ObjectGroup* group;
    shadow::Shape* shape;
    JS::Value* slots;
    void* _1;

    size_t numFixedSlots() const { return shape->slotInfo >> Shape::FIXED_SLOTS_SHIFT; }
    JS::Value* fixedSlots() const {
        return (JS::Value*)(uintptr_t(this) + sizeof(shadow::Object));
    }

    JS::Value& slotRef(size_t slot) const {
        size_t nfixed = numFixedSlots();
        if (slot < nfixed)
            return fixedSlots()[slot];
        return slots[slot - nfixed];
    }
};

struct Function {
    Object base;
    uint16_t nargs;
    uint16_t flags;

    JSNative native;
    const JSJitInfo* jitinfo;
    void* _1;
};

struct String
{
    static const uint32_t INLINE_CHARS_BIT = ((uint32_t)1 << (2));
    static const uint32_t LATIN1_CHARS_BIT = ((uint32_t)1 << (6));
    static const uint32_t ROPE_FLAGS = 0;
    static const uint32_t EXTERNAL_FLAGS = ((uint32_t)1 << (5));
    static const uint32_t TYPE_FLAGS_MASK = ((uint32_t)1 << (6)) - 1;
    uint32_t flags;
    uint32_t length;
    union {
        const JS::Latin1Char* nonInlineCharsLatin1;
        const char16_t* nonInlineCharsTwoByte;
        JS::Latin1Char inlineStorageLatin1[1];
        char16_t inlineStorageTwoByte[1];
    };
    const JSStringFinalizer* externalFinalizer;
};

}



extern const js::Class* const ObjectClassPtr;

inline const js::Class*
GetObjectClass(const JSObject* obj)
{
    return reinterpret_cast<const shadow::Object*>(obj)->group->clasp;
}

inline const JSClass*
GetObjectJSClass(JSObject* obj)
{
    return js::Jsvalify(GetObjectClass(obj));
}

const Class*
ProtoKeyToClass(JSProtoKey key);
inline JSProtoKey
InheritanceProtoKeyForStandardClass(JSProtoKey key)
{

    if (key == JSProto_Object)
        return JSProto_Null;


    if (ProtoKeyToClass(key)->specDefined())
        return ProtoKeyToClass(key)->specInheritanceProtoKey();


    return JSProto_Object;
}

bool
IsFunctionObject(JSObject* obj);

static __attribute__((always_inline)) inline JSCompartment*
GetObjectCompartment(JSObject* obj)
{
    return reinterpret_cast<shadow::Object*>(obj)->group->compartment;
}

JSObject*
GetGlobalForObjectCrossCompartment(JSObject* obj);

JSObject*
GetPrototypeNoProxy(JSObject* obj);

void
AssertSameCompartment(JSContext* cx, JSObject* obj);

void
AssertSameCompartment(JSContext* cx, JS::HandleValue v);


void
AssertSameCompartment(JSObject* objA, JSObject* objB);




void
NotifyAnimationActivity(JSObject* obj);
JSFunction*
GetOutermostEnclosingFunctionOfScriptedCaller(JSContext* cx);

JSFunction*
DefineFunctionWithReserved(JSContext* cx, JSObject* obj, const char* name, JSNative call,
                           unsigned nargs, unsigned attrs);

JSFunction*
NewFunctionWithReserved(JSContext* cx, JSNative call, unsigned nargs, unsigned flags,
                        const char* name);

JSFunction*
NewFunctionByIdWithReserved(JSContext* cx, JSNative native, unsigned nargs, unsigned flags,
                            jsid id);

const JS::Value&
GetFunctionNativeReserved(JSObject* fun, size_t which);

void
SetFunctionNativeReserved(JSObject* fun, size_t which, const JS::Value& val);

bool
FunctionHasNativeReserved(JSObject* fun);

bool
GetObjectProto(JSContext* cx, JS::HandleObject obj, JS::MutableHandleObject proto);

extern JSObject*
GetStaticPrototype(JSObject* obj);

bool
GetOriginalEval(JSContext* cx, JS::HandleObject scope,
                JS::MutableHandleObject eval);

inline void*
GetObjectPrivate(JSObject* obj)
{
    do { } while (0);
    const shadow::Object* nobj = reinterpret_cast<const shadow::Object*>(obj);
    void** addr = reinterpret_cast<void**>(&nobj->fixedSlots()[nobj->numFixedSlots()]);
    return *addr;
}

inline const JS::Value&
GetReservedSlot(JSObject* obj, size_t slot)
{
    do { } while (0);
    return reinterpret_cast<const shadow::Object*>(obj)->slotRef(slot);
}

void
SetReservedOrProxyPrivateSlotWithBarrier(JSObject* obj, size_t slot, const JS::Value& value);

inline void
SetReservedSlot(JSObject* obj, size_t slot, const JS::Value& value)
{
    do { } while (0);
    shadow::Object* sobj = reinterpret_cast<shadow::Object*>(obj);
    if (sobj->slotRef(slot).isGCThing() || value.isGCThing())
        SetReservedOrProxyPrivateSlotWithBarrier(obj, slot, value);
    else
        sobj->slotRef(slot) = value;
}

uint32_t
GetObjectSlotSpan(JSObject* obj);

inline const JS::Value&
GetObjectSlot(JSObject* obj, size_t slot)
{
    do { } while (0);
    return reinterpret_cast<const shadow::Object*>(obj)->slotRef(slot);
}

__attribute__((always_inline)) inline size_t
GetAtomLength(JSAtom* atom)
{
    return reinterpret_cast<shadow::String*>(atom)->length;
}

static const uint32_t MaxStringLength = (1 << 28) - 1;

__attribute__((always_inline)) inline size_t
GetStringLength(JSString* s)
{
    return reinterpret_cast<shadow::String*>(s)->length;
}

__attribute__((always_inline)) inline size_t
GetFlatStringLength(JSFlatString* s)
{
    return reinterpret_cast<shadow::String*>(s)->length;
}

__attribute__((always_inline)) inline size_t
GetLinearStringLength(JSLinearString* s)
{
    return reinterpret_cast<shadow::String*>(s)->length;
}

__attribute__((always_inline)) inline bool
LinearStringHasLatin1Chars(JSLinearString* s)
{
    return reinterpret_cast<shadow::String*>(s)->flags & shadow::String::LATIN1_CHARS_BIT;
}

__attribute__((always_inline)) inline bool
AtomHasLatin1Chars(JSAtom* atom)
{
    return reinterpret_cast<shadow::String*>(atom)->flags & shadow::String::LATIN1_CHARS_BIT;
}

__attribute__((always_inline)) inline bool
StringHasLatin1Chars(JSString* s)
{
    return reinterpret_cast<shadow::String*>(s)->flags & shadow::String::LATIN1_CHARS_BIT;
}

__attribute__((always_inline)) inline const JS::Latin1Char*
GetLatin1LinearStringChars(const JS::AutoCheckCannotGC& nogc, JSLinearString* linear)
{
    do { } while (0);

    using shadow::String;
    String* s = reinterpret_cast<String*>(linear);
    if (s->flags & String::INLINE_CHARS_BIT)
        return s->inlineStorageLatin1;
    return s->nonInlineCharsLatin1;
}

__attribute__((always_inline)) inline const char16_t*
GetTwoByteLinearStringChars(const JS::AutoCheckCannotGC& nogc, JSLinearString* linear)
{
    do { } while (0);

    using shadow::String;
    String* s = reinterpret_cast<String*>(linear);
    if (s->flags & String::INLINE_CHARS_BIT)
        return s->inlineStorageTwoByte;
    return s->nonInlineCharsTwoByte;
}

__attribute__((always_inline)) inline JSLinearString*
AtomToLinearString(JSAtom* atom)
{
    return reinterpret_cast<JSLinearString*>(atom);
}

__attribute__((always_inline)) inline JSFlatString*
AtomToFlatString(JSAtom* atom)
{
    return reinterpret_cast<JSFlatString*>(atom);
}

__attribute__((always_inline)) inline JSLinearString*
FlatStringToLinearString(JSFlatString* s)
{
    return reinterpret_cast<JSLinearString*>(s);
}

__attribute__((always_inline)) inline const JS::Latin1Char*
GetLatin1AtomChars(const JS::AutoCheckCannotGC& nogc, JSAtom* atom)
{
    return GetLatin1LinearStringChars(nogc, AtomToLinearString(atom));
}

__attribute__((always_inline)) inline const char16_t*
GetTwoByteAtomChars(const JS::AutoCheckCannotGC& nogc, JSAtom* atom)
{
    return GetTwoByteLinearStringChars(nogc, AtomToLinearString(atom));
}

__attribute__((always_inline)) inline bool
IsExternalString(JSString* str, const JSStringFinalizer** fin, const char16_t** chars)
{
    using shadow::String;
    String* s = reinterpret_cast<String*>(str);

    if ((s->flags & String::TYPE_FLAGS_MASK) != String::EXTERNAL_FLAGS)
        return false;

    do { } while (0);
    *fin = s->externalFinalizer;
    *chars = s->nonInlineCharsTwoByte;
    return true;
}

JSLinearString*
StringToLinearStringSlow(JSContext* cx, JSString* str);

__attribute__((always_inline)) inline JSLinearString*
StringToLinearString(JSContext* cx, JSString* str)
{
    using shadow::String;
    String* s = reinterpret_cast<String*>(str);
    if ((__builtin_expect(!!((s->flags & String::TYPE_FLAGS_MASK) == String::ROPE_FLAGS), 0)))
        return StringToLinearStringSlow(cx, str);
    return reinterpret_cast<JSLinearString*>(str);
}

template<typename CharType>
__attribute__((always_inline)) inline void
CopyLinearStringChars(CharType* dest, JSLinearString* s, size_t len, size_t start = 0);

__attribute__((always_inline)) inline void
CopyLinearStringChars(char16_t* dest, JSLinearString* s, size_t len, size_t start = 0)
{
    do { } while (0);
    JS::AutoCheckCannotGC nogc;
    if (LinearStringHasLatin1Chars(s)) {
        const JS::Latin1Char* src = GetLatin1LinearStringChars(nogc, s);
        for (size_t i = 0; i < len; i++)
            dest[i] = src[start + i];
    } else {
        const char16_t* src = GetTwoByteLinearStringChars(nogc, s);
        mozilla::PodCopy(dest, src + start, len);
    }
}

__attribute__((always_inline)) inline void
CopyLinearStringChars(char* dest, JSLinearString* s, size_t len, size_t start = 0)
{
    do { } while (0);
    JS::AutoCheckCannotGC nogc;
    if (LinearStringHasLatin1Chars(s)) {
        const JS::Latin1Char* src = GetLatin1LinearStringChars(nogc, s);
        for (size_t i = 0; i < len; i++)
           dest[i] = char(src[start + i]);
    } else {
      const char16_t* src = GetTwoByteLinearStringChars(nogc, s);
      for (size_t i = 0; i < len; i++)
          dest[i] = char(src[start + i]);
    }
}

template<typename CharType>
inline bool
CopyStringChars(JSContext* cx, CharType* dest, JSString* s, size_t len, size_t start = 0)
{
    JSLinearString* linear = StringToLinearString(cx, s);
    if (!linear)
        return false;

    CopyLinearStringChars(dest, linear, len, start);
    return true;
}

inline void
CopyFlatStringChars(char16_t* dest, JSFlatString* s, size_t len)
{
    CopyLinearStringChars(dest, FlatStringToLinearString(s), len);
}
bool
GetPropertyKeys(JSContext* cx, JS::HandleObject obj, unsigned flags, JS::AutoIdVector* props);

bool
AppendUnique(JSContext* cx, JS::AutoIdVector& base, JS::AutoIdVector& others);

bool
StringIsArrayIndex(JSLinearString* str, uint32_t* indexp);

void
SetPreserveWrapperCallback(JSContext* cx, PreserveWrapperCallback callback);

bool
IsObjectInContextCompartment(JSObject* obj, const JSContext* cx);
bool
RunningWithTrustedPrincipals(JSContext* cx);

__attribute__((always_inline)) inline uintptr_t
GetNativeStackLimit(JSContext* cx, JS::StackKind kind, int extraAllowance = 0)
{
    uintptr_t limit = JS::RootingContext::get(cx)->nativeStackLimit[kind];



    limit -= extraAllowance;

    return limit;
}

__attribute__((always_inline)) inline uintptr_t
GetNativeStackLimit(JSContext* cx, int extraAllowance = 0)
{
    JS::StackKind kind = RunningWithTrustedPrincipals(cx) ? JS::StackForTrustedScript
                                                          : JS::StackForUntrustedScript;
    return GetNativeStackLimit(cx, kind, extraAllowance);
}
__attribute__((always_inline)) inline bool
CheckRecursionLimit(JSContext* cx, uintptr_t limit)
{
    int stackDummy;
    if (!((__builtin_expect(!!((uintptr_t)(&stackDummy) > (limit)), 1)))) {
        ReportOverRecursed(cx);
        return false;
    }
    return true;
}

__attribute__((always_inline)) inline bool
CheckRecursionLimitDontReport(JSContext* cx, uintptr_t limit)
{
    int stackDummy;
    return ((__builtin_expect(!!((uintptr_t)(&stackDummy) > (limit)), 1)));
}

__attribute__((always_inline)) inline bool
CheckRecursionLimit(JSContext* cx)
{




    uintptr_t untrustedLimit = GetNativeStackLimit(cx, JS::StackForUntrustedScript);
    if ((__builtin_expect(!!(CheckRecursionLimitDontReport(cx, untrustedLimit)), 1)))
        return true;
    return CheckRecursionLimit(cx, GetNativeStackLimit(cx));
}

__attribute__((always_inline)) inline bool
CheckRecursionLimitDontReport(JSContext* cx)
{
    return CheckRecursionLimitDontReport(cx, GetNativeStackLimit(cx));
}

__attribute__((always_inline)) inline bool
CheckRecursionLimitWithStackPointerDontReport(JSContext* cx, void* sp)
{
    return ((__builtin_expect(!!((uintptr_t)(sp) > (GetNativeStackLimit(cx))), 1)));
}

__attribute__((always_inline)) inline bool
CheckRecursionLimitWithStackPointer(JSContext* cx, void* sp)
{
    if (!((__builtin_expect(!!((uintptr_t)(sp) > (GetNativeStackLimit(cx))), 1)))) {
        ReportOverRecursed(cx);
        return false;
    }
    return true;
}

__attribute__((always_inline)) inline bool
CheckSystemRecursionLimit(JSContext* cx)
{
    return CheckRecursionLimit(cx, GetNativeStackLimit(cx, JS::StackForSystemCode));
}

__attribute__((always_inline)) inline bool
CheckRecursionLimitConservative(JSContext* cx)
{
    return CheckRecursionLimit(cx, GetNativeStackLimit(cx, JS::StackForUntrustedScript,
                                                       -1024 * int(sizeof(size_t))));
}

__attribute__((always_inline)) inline bool
CheckRecursionLimitConservativeDontReport(JSContext* cx)
{
    return CheckRecursionLimitDontReport(cx, GetNativeStackLimit(cx, JS::StackForUntrustedScript,
                                                                 -1024 * int(sizeof(size_t))));
}

void
StartPCCountProfiling(JSContext* cx);

void
StopPCCountProfiling(JSContext* cx);

void
PurgePCCounts(JSContext* cx);

size_t
GetPCCountScriptCount(JSContext* cx);

JSString*
GetPCCountScriptSummary(JSContext* cx, size_t script);

JSString*
GetPCCountScriptContents(JSContext* cx, size_t script);
char*
GetCodeCoverageSummary(JSContext* cx, size_t* length);

typedef void
(* ActivityCallback)(void* arg, bool active);






void
SetActivityCallback(JSContext* cx, ActivityCallback cb, void* arg);

typedef bool
(* DOMInstanceClassHasProtoAtDepth)(const Class* instanceClass,
                                    uint32_t protoID, uint32_t depth);
struct JSDOMCallbacks {
    DOMInstanceClassHasProtoAtDepth instanceClassMatchesProto;
};
typedef struct JSDOMCallbacks DOMCallbacks;

extern void
SetDOMCallbacks(JSContext* cx, const DOMCallbacks* callbacks);

extern const DOMCallbacks*
GetDOMCallbacks(JSContext* cx);

extern JSObject*
GetTestingFunctions(JSContext* cx);






inline JSFreeOp*
CastToJSFreeOp(FreeOp* fop)
{
    return reinterpret_cast<JSFreeOp*>(fop);
}







extern JSFlatString*
GetErrorTypeName(JSContext* cx, int16_t exnType);


extern unsigned
GetEnterCompartmentDepth(JSContext* cx);


extern bool
RegExpToSharedNonInline(JSContext* cx, JS::HandleObject regexp,
                        JS::MutableHandle<RegExpShared*> shared);


typedef enum NukeReferencesToWindow {
    NukeWindowReferences,
    DontNukeWindowReferences
} NukeReferencesToWindow;

typedef enum NukeReferencesFromTarget {
    NukeAllReferences,
    NukeIncomingReferences,
} NukeReferencesFromTarget;





struct CompartmentFilter {
    virtual bool match(JSCompartment* c) const = 0;
};

struct AllCompartments : public CompartmentFilter {
    virtual bool match(JSCompartment* c) const override { return true; }
};

struct ContentCompartmentsOnly : public CompartmentFilter {
    virtual bool match(JSCompartment* c) const override {
        return !IsSystemCompartment(c);
    }
};

struct ChromeCompartmentsOnly : public CompartmentFilter {
    virtual bool match(JSCompartment* c) const override {
        return IsSystemCompartment(c);
    }
};

struct SingleCompartment : public CompartmentFilter {
    JSCompartment* ours;
    explicit SingleCompartment(JSCompartment* c) : ours(c) {}
    virtual bool match(JSCompartment* c) const override { return c == ours; }
};

struct CompartmentsWithPrincipals : public CompartmentFilter {
    JSPrincipals* principals;
    explicit CompartmentsWithPrincipals(JSPrincipals* p) : principals(p) {}
    virtual bool match(JSCompartment* c) const override {
        return JS_GetCompartmentPrincipals(c) == principals;
    }
};

extern bool
NukeCrossCompartmentWrappers(JSContext* cx,
                             const CompartmentFilter& sourceFilter,
                             const CompartmentFilter& targetFilter,
                             NukeReferencesToWindow nukeReferencesToWindow,
                             NukeReferencesFromTarget nukeReferencesFromTarget);
struct ExpandoAndGeneration {
  ExpandoAndGeneration()
    : expando(JS::UndefinedValue()),
      generation(0)
  {}

  void OwnerUnlinked()
  {
      ++generation;
  }

  static size_t offsetOfExpando()
  {
      return __builtin_offsetof(ExpandoAndGeneration, expando);
  }

  static size_t offsetOfGeneration()
  {
      return __builtin_offsetof(ExpandoAndGeneration, generation);
  }

  JS::Heap<JS::Value> expando;
  uint64_t generation;
};

typedef enum DOMProxyShadowsResult {
  ShadowCheckFailed,
  Shadows,
  DoesntShadow,
  DoesntShadowUnique,
  ShadowsViaDirectExpando,
  ShadowsViaIndirectExpando
} DOMProxyShadowsResult;
typedef DOMProxyShadowsResult
(* DOMProxyShadowsCheck)(JSContext* cx, JS::HandleObject object, JS::HandleId id);
void
SetDOMProxyInformation(const void* domProxyHandlerFamily, uint32_t domProxyExpandoSlot,
                       DOMProxyShadowsCheck domProxyShadowsCheck);

const void* GetDOMProxyHandlerFamily();
uint32_t GetDOMProxyExpandoSlot();
DOMProxyShadowsCheck GetDOMProxyShadowsCheck();
inline bool DOMProxyIsShadowing(DOMProxyShadowsResult result) {
    return result == Shadows ||
           result == ShadowsViaDirectExpando ||
           result == ShadowsViaIndirectExpando;
}




extern bool
DateIsValid(JSContext* cx, JS::HandleObject obj, bool* isValid);

extern bool
DateGetMsecSinceEpoch(JSContext* cx, JS::HandleObject obj, double* msecSinceEpoch);

}







typedef enum JSErrNum {



JSMSG_NOT_AN_ERROR,
JSMSG_NOT_DEFINED,
JSMSG_MORE_ARGS_NEEDED,
JSMSG_INCOMPATIBLE_PROTO,
JSMSG_NO_CONSTRUCTOR,
JSMSG_BAD_SORT_ARG,
JSMSG_CANT_WATCH,
JSMSG_READ_ONLY,
JSMSG_CANT_DELETE,
JSMSG_CANT_TRUNCATE_ARRAY,
JSMSG_NOT_FUNCTION,
JSMSG_NOT_CONSTRUCTOR,
JSMSG_CANT_CONVERT_TO,
JSMSG_TOPRIMITIVE_NOT_CALLABLE,
JSMSG_TOPRIMITIVE_RETURNED_OBJECT,
JSMSG_NO_PROPERTIES,
JSMSG_BAD_REGEXP_FLAG,
JSMSG_ARG_INDEX_OUT_OF_RANGE,
JSMSG_SPREAD_TOO_LARGE,
JSMSG_BAD_WEAKMAP_KEY,
JSMSG_BAD_GETTER_OR_SETTER,
JSMSG_BAD_ARRAY_LENGTH,
JSMSG_REDECLARED_PREV,
JSMSG_REDECLARED_VAR,
JSMSG_UNDECLARED_VAR,
JSMSG_GETTER_ONLY,
JSMSG_OVERWRITING_ACCESSOR,
JSMSG_UNDEFINED_PROP,
JSMSG_INVALID_MAP_ITERABLE,
JSMSG_NESTING_GENERATOR,
JSMSG_INCOMPATIBLE_METHOD,
JSMSG_OBJECT_WATCH_DEPRECATED,
JSMSG_BAD_SURROGATE_CHAR,
JSMSG_UTF8_CHAR_TOO_LARGE,
JSMSG_MALFORMED_UTF8_CHAR,
JSMSG_BUILTIN_CTOR_NO_NEW,
JSMSG_BAD_GENERATOR_YIELD,
JSMSG_EMPTY_ARRAY_REDUCE,
JSMSG_UNEXPECTED_TYPE,
JSMSG_MISSING_FUN_ARG,
JSMSG_NOT_NONNULL_OBJECT,
JSMSG_NOT_NONNULL_OBJECT_NAME,
JSMSG_NOT_NONNULL_OBJECT_ARG,
JSMSG_SET_NON_OBJECT_RECEIVER,
JSMSG_INVALID_DESCRIPTOR,
JSMSG_OBJECT_NOT_EXTENSIBLE,
JSMSG_CANT_DEFINE_PROP_OBJECT_NOT_EXTENSIBLE,
JSMSG_CANT_REDEFINE_PROP,
JSMSG_CANT_REDEFINE_ARRAY_LENGTH,
JSMSG_CANT_DEFINE_PAST_ARRAY_LENGTH,
JSMSG_BAD_GET_SET_FIELD,
JSMSG_THROW_TYPE_ERROR,
JSMSG_NOT_EXPECTED_TYPE,
JSMSG_NOT_ITERABLE,
JSMSG_NOT_ITERATOR,
JSMSG_ALREADY_HAS_PRAGMA,
JSMSG_GET_ITER_RETURNED_PRIMITIVE,
JSMSG_ITER_METHOD_RETURNED_PRIMITIVE,
JSMSG_CANT_SET_PROTO,
JSMSG_CANT_SET_PROTO_OF,
JSMSG_CANT_SET_PROTO_CYCLE,
JSMSG_INVALID_ARG_TYPE,
JSMSG_TERMINATED,
JSMSG_PROTO_NOT_OBJORNULL,
JSMSG_CANT_CALL_CLASS_CONSTRUCTOR,
JSMSG_UNINITIALIZED_THIS,
JSMSG_UNINITIALIZED_THIS_ARROW,
JSMSG_BAD_DERIVED_RETURN,


JSMSG_JSON_BAD_PARSE,
JSMSG_JSON_CYCLIC_VALUE,


JSMSG_BAD_INSTANCEOF_RHS,
JSMSG_BAD_LEFTSIDE_OF_ASS,
JSMSG_BAD_PROTOTYPE,
JSMSG_IN_NOT_OBJECT,
JSMSG_TOO_MANY_CON_SPREADARGS,
JSMSG_TOO_MANY_FUN_SPREADARGS,
JSMSG_UNINITIALIZED_LEXICAL,
JSMSG_BAD_CONST_ASSIGN,
JSMSG_CANT_DECLARE_GLOBAL_BINDING,


JSMSG_INVALID_DATE,
JSMSG_BAD_TOISOSTRING_PROP,
JSMSG_DEPRECATED_TOLOCALEFORMAT,


JSMSG_BAD_URI,
JSMSG_INVALID_NORMALIZE_FORM,
JSMSG_NEGATIVE_REPETITION_COUNT,
JSMSG_NOT_A_CODEPOINT,
JSMSG_RESULTING_STRING_TOO_LARGE,
JSMSG_DEPRECATED_STRING_METHOD,


JSMSG_BAD_RADIX,
JSMSG_PRECISION_RANGE,


JSMSG_BAD_APPLY_ARGS,
JSMSG_BAD_FORMAL,
JSMSG_CALLER_IS_STRICT,
JSMSG_DEPRECATED_USAGE,
JSMSG_NOT_SCRIPTED_FUNCTION,
JSMSG_NO_REST_NAME,
JSMSG_PARAMETER_AFTER_REST,
JSMSG_TOO_MANY_ARGUMENTS,


JSMSG_CSP_BLOCKED_EVAL,
JSMSG_CSP_BLOCKED_FUNCTION,


JSMSG_ACCESSOR_DEF_DENIED,
JSMSG_DEAD_OBJECT,
JSMSG_OBJECT_ACCESS_DENIED,
JSMSG_PROPERTY_ACCESS_DENIED,


JSMSG_BAD_CLONE_FUNOBJ_SCOPE,
JSMSG_CANT_CLONE_OBJECT,
JSMSG_CANT_OPEN,
JSMSG_USER_DEFINED_ERROR,


JSMSG_ALLOC_OVERFLOW,
JSMSG_BAD_BYTECODE,
JSMSG_BUFFER_TOO_SMALL,
JSMSG_BUILD_ID_NOT_AVAILABLE,
JSMSG_BYTECODE_TOO_BIG,
JSMSG_ERR_DURING_THROW,
JSMSG_NEED_DIET,
JSMSG_OUT_OF_MEMORY,
JSMSG_OVER_RECURSED,
JSMSG_TOO_BIG_TO_ENCODE,
JSMSG_TOO_DEEP,
JSMSG_UNCAUGHT_EXCEPTION,
JSMSG_UNKNOWN_FORMAT,


JSMSG_ACCESSOR_WRONG_ARGS,
JSMSG_ARRAY_COMP_LEFTSIDE,
JSMSG_ARRAY_INIT_TOO_BIG,
JSMSG_AS_AFTER_IMPORT_STAR,
JSMSG_AS_AFTER_RESERVED_WORD,
JSMSG_ASYNC_GENERATOR,
JSMSG_AWAIT_IN_DEFAULT,
JSMSG_AWAIT_OUTSIDE_ASYNC,
JSMSG_BAD_ARROW_ARGS,
JSMSG_BAD_BINDING,
JSMSG_BAD_CONST_DECL,
JSMSG_BAD_CONTINUE,
JSMSG_BAD_DESTRUCT_ASS,
JSMSG_BAD_DESTRUCT_TARGET,
JSMSG_BAD_DESTRUCT_PARENS,
JSMSG_BAD_DESTRUCT_DECL,
JSMSG_BAD_DUP_ARGS,
JSMSG_BAD_FOR_EACH_LOOP,
JSMSG_BAD_FOR_LEFTSIDE,
JSMSG_LEXICAL_DECL_DEFINES_LET,
JSMSG_LET_STARTING_FOROF_LHS,
JSMSG_BAD_FUNCTION_YIELD,
JSMSG_BAD_GENERATOR_RETURN,
JSMSG_BAD_GENEXP_BODY,
JSMSG_BAD_INCOP_OPERAND,
JSMSG_BAD_METHOD_DEF,
JSMSG_BAD_OCTAL,
JSMSG_BAD_POW_LEFTSIDE,
JSMSG_BAD_PROP_ID,
JSMSG_BAD_RETURN_OR_YIELD,
JSMSG_BAD_STRICT_ASSIGN,
JSMSG_BAD_SWITCH,
JSMSG_BAD_SUPER,
JSMSG_BAD_SUPERPROP,
JSMSG_BAD_SUPERCALL,
JSMSG_BRACKET_AFTER_ARRAY_COMPREHENSION,
JSMSG_BRACKET_AFTER_LIST,
JSMSG_BRACKET_IN_INDEX,
JSMSG_BRACKET_OPENED,
JSMSG_CATCH_AFTER_GENERAL,
JSMSG_CATCH_IDENTIFIER,
JSMSG_CATCH_OR_FINALLY,
JSMSG_CATCH_WITHOUT_TRY,
JSMSG_COLON_AFTER_CASE,
JSMSG_COLON_AFTER_ID,
JSMSG_COLON_IN_COND,
JSMSG_COMP_PROP_UNTERM_EXPR,
JSMSG_CONTRARY_NONDIRECTIVE,
JSMSG_CURLY_AFTER_BODY,
JSMSG_CURLY_OPENED,
JSMSG_CURLY_AFTER_CATCH,
JSMSG_CURLY_AFTER_FINALLY,
JSMSG_CURLY_AFTER_LIST,
JSMSG_CURLY_AFTER_TRY,
JSMSG_CURLY_BEFORE_BODY,
JSMSG_CURLY_BEFORE_CATCH,
JSMSG_CURLY_BEFORE_CLASS,
JSMSG_CURLY_BEFORE_FINALLY,
JSMSG_CURLY_BEFORE_SWITCH,
JSMSG_CURLY_BEFORE_TRY,
JSMSG_CURLY_IN_COMPOUND,
JSMSG_DECLARATION_AFTER_EXPORT,
JSMSG_DECLARATION_AFTER_IMPORT,
JSMSG_DEPRECATED_DELETE_OPERAND,
JSMSG_DEPRECATED_EXPR_CLOSURE,
JSMSG_DEPRECATED_FOR_EACH,
JSMSG_DEPRECATED_OCTAL,
JSMSG_DEPRECATED_PRAGMA,
JSMSG_DEPRECATED_BLOCK_SCOPE_FUN_REDECL,
JSMSG_DUPLICATE_EXPORT_NAME,
JSMSG_DUPLICATE_FORMAL,
JSMSG_DUPLICATE_LABEL,
JSMSG_DUPLICATE_PROPERTY,
JSMSG_DUPLICATE_PROTO_PROPERTY,
JSMSG_EMPTY_CONSEQUENT,
JSMSG_EQUAL_AS_ASSIGN,
JSMSG_EXPORT_DECL_AT_TOP_LEVEL,
JSMSG_FINALLY_WITHOUT_TRY,
JSMSG_FORBIDDEN_AS_STATEMENT,
JSMSG_FROM_AFTER_IMPORT_CLAUSE,
JSMSG_FROM_AFTER_EXPORT_STAR,
JSMSG_GARBAGE_AFTER_INPUT,
JSMSG_IDSTART_AFTER_NUMBER,
JSMSG_ILLEGAL_CHARACTER,
JSMSG_IMPORT_DECL_AT_TOP_LEVEL,
JSMSG_OF_AFTER_FOR_LOOP_DECL,
JSMSG_IN_AFTER_LEXICAL_FOR_DECL,
JSMSG_INVALID_FOR_IN_DECL_WITH_INIT,
JSMSG_INVALID_ID,
JSMSG_LABEL_NOT_FOUND,
JSMSG_LET_COMP_BINDING,
JSMSG_LEXICAL_DECL_NOT_IN_BLOCK,
JSMSG_LEXICAL_DECL_LABEL,
JSMSG_GENERATOR_LABEL,
JSMSG_FUNCTION_LABEL,
JSMSG_SLOPPY_FUNCTION_LABEL,
JSMSG_LINE_BREAK_AFTER_THROW,
JSMSG_LINE_BREAK_BEFORE_ARROW,
JSMSG_MALFORMED_ESCAPE,
JSMSG_MISSING_BINARY_DIGITS,
JSMSG_MISSING_EXPONENT,
JSMSG_MISSING_EXPR_AFTER_THROW,
JSMSG_MISSING_FORMAL,
JSMSG_MISSING_HEXDIGITS,
JSMSG_MISSING_OCTAL_DIGITS,
JSMSG_MODULE_SPEC_AFTER_FROM,
JSMSG_NAME_AFTER_DOT,
JSMSG_NAMED_IMPORTS_OR_NAMESPACE_IMPORT,
JSMSG_NO_BINDING_NAME,
JSMSG_NO_EXPORT_NAME,
JSMSG_NO_IMPORT_NAME,
JSMSG_NO_VARIABLE_NAME,
JSMSG_OF_AFTER_FOR_NAME,
JSMSG_PAREN_AFTER_ARGS,
JSMSG_PAREN_AFTER_CATCH,
JSMSG_PAREN_AFTER_COND,
JSMSG_PAREN_AFTER_FOR,
JSMSG_PAREN_AFTER_FORMAL,
JSMSG_PAREN_AFTER_FOR_CTRL,
JSMSG_PAREN_AFTER_FOR_OF_ITERABLE,
JSMSG_PAREN_AFTER_SWITCH,
JSMSG_PAREN_AFTER_WITH,
JSMSG_PAREN_BEFORE_CATCH,
JSMSG_PAREN_BEFORE_COND,
JSMSG_PAREN_BEFORE_FORMAL,
JSMSG_PAREN_BEFORE_SWITCH,
JSMSG_PAREN_BEFORE_WITH,
JSMSG_PAREN_IN_PAREN,
JSMSG_RC_AFTER_EXPORT_SPEC_LIST,
JSMSG_RC_AFTER_IMPORT_SPEC_LIST,
JSMSG_REDECLARED_CATCH_IDENTIFIER,
JSMSG_RESERVED_ID,
JSMSG_REST_WITH_COMMA,
JSMSG_REST_WITH_DEFAULT,
JSMSG_SELFHOSTED_TOP_LEVEL_LEXICAL,
JSMSG_SELFHOSTED_METHOD_CALL,
JSMSG_SELFHOSTED_UNBOUND_NAME,
JSMSG_SEMI_AFTER_FOR_COND,
JSMSG_SEMI_AFTER_FOR_INIT,
JSMSG_SEMI_BEFORE_STMNT,
JSMSG_SOURCE_TOO_LONG,
JSMSG_STMT_AFTER_RETURN,
JSMSG_STRICT_CODE_WITH,
JSMSG_STRICT_NON_SIMPLE_PARAMS,
JSMSG_TEMPLSTR_UNTERM_EXPR,
JSMSG_SIMD_NOT_A_VECTOR,
JSMSG_TOO_MANY_CASES,
JSMSG_TOO_MANY_CATCH_VARS,
JSMSG_TOO_MANY_CON_ARGS,
JSMSG_TOO_MANY_DEFAULTS,
JSMSG_TOO_MANY_FUN_ARGS,
JSMSG_TOO_MANY_LOCALS,
JSMSG_TOO_MANY_YIELDS,
JSMSG_TOUGH_BREAK,
JSMSG_UNEXPECTED_TOKEN,
JSMSG_UNEXPECTED_PARAMLIST_END,
JSMSG_UNNAMED_CLASS_STMT,
JSMSG_UNNAMED_FUNCTION_STMT,
JSMSG_UNTERMINATED_COMMENT,
JSMSG_UNTERMINATED_REGEXP,
JSMSG_UNTERMINATED_STRING,
JSMSG_USELESS_EXPR,
JSMSG_USE_ASM_DIRECTIVE_FAIL,
JSMSG_VAR_HIDES_ARG,
JSMSG_WHILE_AFTER_DO,
JSMSG_YIELD_IN_ARROW,
JSMSG_YIELD_IN_DEFAULT,
JSMSG_YIELD_IN_METHOD,
JSMSG_BAD_COLUMN_NUMBER,
JSMSG_COMPUTED_NAME_IN_PATTERN,
JSMSG_DEFAULT_IN_PATTERN,
JSMSG_BAD_NEWTARGET,
JSMSG_ESCAPED_KEYWORD,


JSMSG_USE_ASM_TYPE_FAIL,
JSMSG_USE_ASM_LINK_FAIL,
JSMSG_USE_ASM_TYPE_OK,


JSMSG_WASM_COMPILE_ERROR,
JSMSG_WASM_BAD_IMPORT_TYPE,
JSMSG_WASM_BAD_IMPORT_SIG,
JSMSG_WASM_BAD_IMP_SIZE,
JSMSG_WASM_BAD_IMP_MAX,
JSMSG_WASM_BAD_FIT,
JSMSG_WASM_IND_CALL_TO_NULL,
JSMSG_WASM_IND_CALL_BAD_SIG,
JSMSG_WASM_UNREACHABLE,
JSMSG_WASM_INTEGER_OVERFLOW,
JSMSG_WASM_INVALID_CONVERSION,
JSMSG_WASM_INT_DIVIDE_BY_ZERO,
JSMSG_WASM_OUT_OF_BOUNDS,
JSMSG_WASM_UNALIGNED_ACCESS,
JSMSG_WASM_BAD_UINT32,
JSMSG_WASM_BAD_GROW,
JSMSG_WASM_BAD_BUF_ARG,
JSMSG_WASM_BAD_MOD_ARG,
JSMSG_WASM_BAD_BUF_MOD_ARG,
JSMSG_WASM_BAD_DESC_ARG,
JSMSG_WASM_BAD_ELEMENT,
JSMSG_WASM_BAD_IMPORT_ARG,
JSMSG_WASM_BAD_IMPORT_FIELD,
JSMSG_WASM_BAD_TABLE_VALUE,
JSMSG_WASM_BAD_I64,
JSMSG_WASM_NO_TRANSFER,
JSMSG_WASM_TEXT_FAIL,


JSMSG_BAD_TRAP_RETURN_VALUE,
JSMSG_BAD_GETPROTOTYPEOF_TRAP_RETURN,
JSMSG_INCONSISTENT_GETPROTOTYPEOF_TRAP,
JSMSG_PROXY_SETPROTOTYPEOF_RETURNED_FALSE,
JSMSG_PROXY_ISEXTENSIBLE_RETURNED_FALSE,
JSMSG_INCONSISTENT_SETPROTOTYPEOF_TRAP,
JSMSG_CANT_CHANGE_EXTENSIBILITY,
JSMSG_CANT_DEFINE_INVALID,
JSMSG_CANT_DEFINE_NEW,
JSMSG_CANT_DEFINE_NE_AS_NC,
JSMSG_PROXY_DEFINE_RETURNED_FALSE,
JSMSG_PROXY_DELETE_RETURNED_FALSE,
JSMSG_PROXY_PREVENTEXTENSIONS_RETURNED_FALSE,
JSMSG_PROXY_SET_RETURNED_FALSE,
JSMSG_CANT_REPORT_AS_NON_EXTENSIBLE,
JSMSG_CANT_REPORT_C_AS_NC,
JSMSG_CANT_REPORT_E_AS_NE,
JSMSG_CANT_REPORT_INVALID,
JSMSG_CANT_REPORT_NC_AS_NE,
JSMSG_CANT_REPORT_NEW,
JSMSG_CANT_REPORT_NE_AS_NC,
JSMSG_CANT_SET_NW_NC,
JSMSG_CANT_SET_WO_SETTER,
JSMSG_CANT_SKIP_NC,
JSMSG_ONWKEYS_STR_SYM,
JSMSG_MUST_REPORT_SAME_VALUE,
JSMSG_MUST_REPORT_UNDEFINED,
JSMSG_PROXY_CONSTRUCT_OBJECT,
JSMSG_PROXY_EXTENSIBILITY,
JSMSG_PROXY_GETOWN_OBJORUNDEF,
JSMSG_PROXY_REVOKED,
JSMSG_PROXY_ARG_REVOKED,
JSMSG_BAD_TRAP,


JSMSG_SC_BAD_CLONE_VERSION,
JSMSG_SC_BAD_SERIALIZED_DATA,
JSMSG_SC_DUP_TRANSFERABLE,
JSMSG_SC_NOT_TRANSFERABLE,
JSMSG_SC_UNSUPPORTED_TYPE,
JSMSG_SC_NOT_CLONABLE,
JSMSG_SC_SAB_TRANSFERABLE,
JSMSG_SC_SAB_DISABLED,


JSMSG_ASSIGN_FUNCTION_OR_NULL,
JSMSG_DEBUG_BAD_LINE,
JSMSG_DEBUG_BAD_OFFSET,
JSMSG_DEBUG_BAD_REFERENT,
JSMSG_DEBUG_BAD_RESUMPTION,
JSMSG_DEBUG_BAD_YIELD,
JSMSG_DEBUG_CANT_DEBUG_GLOBAL,
JSMSG_DEBUG_CCW_REQUIRED,
JSMSG_DEBUG_COMPARTMENT_MISMATCH,
JSMSG_DEBUG_LOOP,
JSMSG_DEBUG_NOT_DEBUGGEE,
JSMSG_DEBUG_NOT_DEBUGGING,
JSMSG_DEBUG_NOT_IDLE,
JSMSG_DEBUG_NOT_LIVE,
JSMSG_DEBUG_NO_ENV_OBJECT,
JSMSG_DEBUG_PROTO,
JSMSG_DEBUG_WRONG_OWNER,
JSMSG_DEBUG_OPTIMIZED_OUT,
JSMSG_DEBUG_RESUMPTION_VALUE_DISALLOWED,
JSMSG_DEBUG_VARIABLE_NOT_FOUND,
JSMSG_DEBUG_WRAPPER_IN_WAY,
JSMSG_DEBUGGEE_WOULD_RUN,
JSMSG_NOT_CALLABLE_OR_UNDEFINED,
JSMSG_NOT_TRACKING_ALLOCATIONS,
JSMSG_OBJECT_METADATA_CALLBACK_ALREADY_SET,
JSMSG_QUERY_INNERMOST_WITHOUT_LINE_URL,
JSMSG_QUERY_LINE_WITHOUT_URL,
JSMSG_DEBUG_CANT_SET_OPT_ENV,
JSMSG_DEBUG_INVISIBLE_COMPARTMENT,
JSMSG_DEBUG_CENSUS_BREAKDOWN,
JSMSG_DEBUG_PROMISE_NOT_RESOLVED,
JSMSG_DEBUG_PROMISE_NOT_FULFILLED,
JSMSG_DEBUG_PROMISE_NOT_REJECTED,


JSMSG_TRACELOGGER_ENABLE_FAIL,


JSMSG_DATE_NOT_FINITE,
JSMSG_INTERNAL_INTL_ERROR,
JSMSG_INTL_OBJECT_NOT_INITED,
JSMSG_INVALID_CURRENCY_CODE,
JSMSG_INVALID_DIGITS_VALUE,
JSMSG_INVALID_KEYS_TYPE,
JSMSG_INVALID_KEY,
JSMSG_INVALID_LANGUAGE_TAG,
JSMSG_INVALID_LOCALES_ELEMENT,
JSMSG_INVALID_LOCALE_MATCHER,
JSMSG_INVALID_OPTION_VALUE,
JSMSG_INVALID_TIME_ZONE,
JSMSG_UNDEFINED_CURRENCY,


JSMSG_BACK_REF_OUT_OF_RANGE,
JSMSG_BAD_CLASS_RANGE,
JSMSG_ESCAPE_AT_END_OF_REGEXP,
JSMSG_EXEC_NOT_OBJORNULL,
JSMSG_INVALID_DECIMAL_ESCAPE,
JSMSG_INVALID_GROUP,
JSMSG_INVALID_IDENTITY_ESCAPE,
JSMSG_INVALID_UNICODE_ESCAPE,
JSMSG_MISSING_PAREN,
JSMSG_NEWREGEXP_FLAGGED,
JSMSG_NOTHING_TO_REPEAT,
JSMSG_NUMBERS_OUT_OF_ORDER,
JSMSG_RANGE_WITH_CLASS_ESCAPE,
JSMSG_RAW_BRACE_IN_REGEP,
JSMSG_RAW_BRACKET_IN_REGEP,
JSMSG_TOO_MANY_PARENS,
JSMSG_UNICODE_OVERFLOW,
JSMSG_UNMATCHED_RIGHT_PAREN,
JSMSG_UNTERM_CLASS,


JSMSG_DEFAULT_LOCALE_ERROR,
JSMSG_NO_SUCH_SELF_HOSTED_PROP,


JSMSG_INVALID_PROTOTYPE,
JSMSG_TYPEDOBJECT_BAD_ARGS,
JSMSG_TYPEDOBJECT_BINARYARRAY_BAD_INDEX,
JSMSG_TYPEDOBJECT_HANDLE_UNATTACHED,
JSMSG_TYPEDOBJECT_STRUCTTYPE_BAD_ARGS,
JSMSG_TYPEDOBJECT_TOO_BIG,
JSMSG_SIMD_FAILED_CONVERSION,
JSMSG_SIMD_TO_NUMBER,


JSMSG_TOO_LONG_ARRAY,


JSMSG_BAD_INDEX,
JSMSG_NON_ARRAY_BUFFER_RETURNED,
JSMSG_SAME_ARRAY_BUFFER_RETURNED,
JSMSG_SHORT_ARRAY_BUFFER_RETURNED,
JSMSG_TYPED_ARRAY_BAD_ARGS,
JSMSG_TYPED_ARRAY_NEGATIVE_ARG,
JSMSG_TYPED_ARRAY_DETACHED,
JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS,
JSMSG_TYPED_ARRAY_CALL_OR_CONSTRUCT,
JSMSG_NON_TYPED_ARRAY_RETURNED,
JSMSG_SHORT_TYPED_ARRAY_RETURNED,


JSMSG_SHARED_ARRAY_BAD_LENGTH,
JSMSG_NON_SHARED_ARRAY_BUFFER_RETURNED,
JSMSG_SAME_SHARED_ARRAY_BUFFER_RETURNED,
JSMSG_SHORT_SHARED_ARRAY_BUFFER_RETURNED,


JSMSG_BAD_PARSE_NODE,


JSMSG_SYMBOL_TO_STRING,
JSMSG_SYMBOL_TO_NUMBER,


JSMSG_ATOMICS_BAD_ARRAY,
JSMSG_ATOMICS_TOO_LONG,
JSMSG_ATOMICS_WAIT_NOT_ALLOWED,


JSMSG_CANT_SET_INTERPOSED,
JSMSG_CANT_DEFINE_WINDOW_ELEMENT,
JSMSG_CANT_DELETE_WINDOW_ELEMENT,
JSMSG_CANT_DELETE_WINDOW_NAMED_PROPERTY,
JSMSG_CANT_PREVENT_EXTENSIONS,
JSMSG_NO_NAMED_SETTER,
JSMSG_NO_INDEXED_SETTER,


JSMSG_CANT_DELETE_SUPER,
JSMSG_REINIT_THIS,


JSMSG_BAD_DEFAULT_EXPORT,
JSMSG_MISSING_INDIRECT_EXPORT,
JSMSG_AMBIGUOUS_INDIRECT_EXPORT,
JSMSG_MISSING_IMPORT,
JSMSG_AMBIGUOUS_IMPORT,
JSMSG_MISSING_NAMESPACE_EXPORT,
JSMSG_MISSING_EXPORT,
JSMSG_MODULE_INSTANTIATE_FAILED,
JSMSG_BAD_MODULE_STATE,


JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF,
JSMSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY,
JSMSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE,
JSMSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE,
JSMSG_PROMISE_ERROR_IN_WRAPPED_REJECTION_REASON,


JSMSG_RETURN_NOT_CALLABLE,
JSMSG_ITERATOR_NO_THROW,


JSMSG_FOR_AWAIT_NOT_OF,
JSMSG_NOT_AN_ASYNC_GENERATOR,
JSMSG_NOT_AN_ASYNC_ITERATOR,
JSMSG_GET_ASYNC_ITER_RETURNED_PRIMITIVE,

    JSErr_Limit
} JSErrNum;

namespace js {

extern const JSErrorFormatString*
GetErrorMessage(void* userRef, const unsigned errorNumber);
class AutoStableStringChars
{





    static const size_t InlineCapacity = 24;


    JS::RootedString s_;
    union {
        const char16_t* twoByteChars_;
        const JS::Latin1Char* latin1Chars_;
    };
    mozilla::Maybe<Vector<uint8_t, InlineCapacity>> ownChars_;
    enum State { Uninitialized, Latin1, TwoByte };
    State state_;

  public:
    explicit AutoStableStringChars(JSContext* cx)
      : s_(cx), state_(Uninitialized)
    {}

    __attribute__ ((warn_unused_result))
    bool init(JSContext* cx, JSString* s);


    __attribute__ ((warn_unused_result))
    bool initTwoByte(JSContext* cx, JSString* s);

    bool isLatin1() const { return state_ == Latin1; }
    bool isTwoByte() const { return state_ == TwoByte; }

    const char16_t* twoByteChars() const {
        do { } while (0);
        return twoByteChars_;
    }

    mozilla::Range<const JS::Latin1Char> latin1Range() const {
        do { } while (0);
        return mozilla::Range<const JS::Latin1Char>(latin1Chars_,
                                                    GetStringLength(s_));
    }

    mozilla::Range<const char16_t> twoByteRange() const {
        do { } while (0);
        return mozilla::Range<const char16_t>(twoByteChars_,
                                              GetStringLength(s_));
    }


    bool maybeGiveOwnershipToCaller() {
        do { } while (0);
        if (!ownChars_.isSome() || !ownChars_->extractRawBuffer())
            return false;
        state_ = Uninitialized;
        ownChars_.reset();
        return true;
    }

  private:
    AutoStableStringChars(const AutoStableStringChars& other) = delete;
    void operator=(const AutoStableStringChars& other) = delete;

    bool baseIsInline(JS::Handle<JSLinearString*> linearString);
    template <typename T> T* allocOwnChars(JSContext* cx, size_t count);
    bool copyLatin1Chars(JSContext* cx, JS::Handle<JSLinearString*> linearString);
    bool copyTwoByteChars(JSContext* cx, JS::Handle<JSLinearString*> linearString);
    bool copyAndInflateLatin1Chars(JSContext*, JS::Handle<JSLinearString*> linearString);
};

struct ErrorReport
{
    explicit ErrorReport(JSContext* cx);
    ~ErrorReport();

    enum SniffingBehavior {
        WithSideEffects,
        NoSideEffects
    };
    bool init(JSContext* cx, JS::HandleValue exn,
              SniffingBehavior sniffingBehavior);

    JSErrorReport* report()
    {
        return reportp;
    }

    const JS::ConstUTF8CharsZ toStringResult()
    {
        return toStringResult_;
    }

  private:






    bool populateUncaughtExceptionReportUTF8(JSContext* cx, ...);
    bool populateUncaughtExceptionReportUTF8VA(JSContext* cx, va_list ap);


    void ReportAddonExceptionToTelementry(JSContext* cx);


    JSErrorReport* reportp;


    JSErrorReport ownedReport;



    JS::RootedString str;


    AutoStableStringChars strChars;


    JS::RootedObject exnObject;


    JSAutoByteString filename;




    JS::ConstUTF8CharsZ toStringResult_;
    JSAutoByteString toStringResultBytesStorage;
};


extern uint64_t
GetSCOffset(JSStructuredCloneWriter* writer);

namespace Scalar {







enum Type {
    Int8 = 0,
    Uint8,
    Int16,
    Uint16,
    Int32,
    Uint32,
    Float32,
    Float64,





    Uint8Clamped,




    MaxTypedArrayViewType,

    Int64,
    Float32x4,
    Int8x16,
    Int16x8,
    Int32x4
};

static inline size_t
byteSize(Type atype)
{
    switch (atype) {
      case Int8:
      case Uint8:
      case Uint8Clamped:
        return 1;
      case Int16:
      case Uint16:
        return 2;
      case Int32:
      case Uint32:
      case Float32:
        return 4;
      case Int64:
      case Float64:
        return 8;
      case Int8x16:
      case Int16x8:
      case Int32x4:
      case Float32x4:
        return 16;
      default:
        do { AnnotateMozCrashReason("MOZ_CRASH(" "invalid scalar type" ")"); do { *((volatile int*) __null) = 1568; ::abort(); } while (0); } while (0);
    }
}

static inline bool
isSignedIntType(Type atype) {
    switch (atype) {
      case Int8:
      case Int16:
      case Int32:
      case Int64:
      case Int8x16:
      case Int16x8:
      case Int32x4:
        return true;
      case Uint8:
      case Uint8Clamped:
      case Uint16:
      case Uint32:
      case Float32:
      case Float64:
      case Float32x4:
        return false;
      default:
        do { AnnotateMozCrashReason("MOZ_CRASH(" "invalid scalar type" ")"); do { *((volatile int*) __null) = 1592; ::abort(); } while (0); } while (0);
    }
}

static inline bool
isSimdType(Type atype) {
    switch (atype) {
      case Int8:
      case Uint8:
      case Uint8Clamped:
      case Int16:
      case Uint16:
      case Int32:
      case Uint32:
      case Int64:
      case Float32:
      case Float64:
        return false;
      case Int8x16:
      case Int16x8:
      case Int32x4:
      case Float32x4:
        return true;
      case MaxTypedArrayViewType:
        break;
    }
    do { AnnotateMozCrashReason("MOZ_CRASH(" "invalid scalar type" ")"); do { *((volatile int*) __null) = 1618; ::abort(); } while (0); } while (0);
}

static inline size_t
scalarByteSize(Type atype) {
    switch (atype) {
      case Int8x16:
        return 1;
      case Int16x8:
        return 2;
      case Int32x4:
      case Float32x4:
        return 4;
      case Int8:
      case Uint8:
      case Uint8Clamped:
      case Int16:
      case Uint16:
      case Int32:
      case Uint32:
      case Int64:
      case Float32:
      case Float64:
      case MaxTypedArrayViewType:
        break;
    }
    do { AnnotateMozCrashReason("MOZ_CRASH(" "invalid simd type" ")"); do { *((volatile int*) __null) = 1644; ::abort(); } while (0); } while (0);
}

}
}







extern JSObject*
JS_NewInt8Array(JSContext* cx, uint32_t nelements);
extern JSObject*
JS_NewUint8Array(JSContext* cx, uint32_t nelements);
extern JSObject*
JS_NewUint8ClampedArray(JSContext* cx, uint32_t nelements);
extern JSObject*
JS_NewInt16Array(JSContext* cx, uint32_t nelements);
extern JSObject*
JS_NewUint16Array(JSContext* cx, uint32_t nelements);
extern JSObject*
JS_NewInt32Array(JSContext* cx, uint32_t nelements);
extern JSObject*
JS_NewUint32Array(JSContext* cx, uint32_t nelements);
extern JSObject*
JS_NewFloat32Array(JSContext* cx, uint32_t nelements);
extern JSObject*
JS_NewFloat64Array(JSContext* cx, uint32_t nelements);
extern JSObject*
JS_NewInt8ArrayFromArray(JSContext* cx, JS::HandleObject array);
extern JSObject*
JS_NewUint8ArrayFromArray(JSContext* cx, JS::HandleObject array);
extern JSObject*
JS_NewUint8ClampedArrayFromArray(JSContext* cx, JS::HandleObject array);
extern JSObject*
JS_NewInt16ArrayFromArray(JSContext* cx, JS::HandleObject array);
extern JSObject*
JS_NewUint16ArrayFromArray(JSContext* cx, JS::HandleObject array);
extern JSObject*
JS_NewInt32ArrayFromArray(JSContext* cx, JS::HandleObject array);
extern JSObject*
JS_NewUint32ArrayFromArray(JSContext* cx, JS::HandleObject array);
extern JSObject*
JS_NewFloat32ArrayFromArray(JSContext* cx, JS::HandleObject array);
extern JSObject*
JS_NewFloat64ArrayFromArray(JSContext* cx, JS::HandleObject array);
extern JSObject*
JS_NewInt8ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                          uint32_t byteOffset, int32_t length);
extern JSObject*
JS_NewUint8ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                           uint32_t byteOffset, int32_t length);
extern JSObject*
JS_NewUint8ClampedArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                                  uint32_t byteOffset, int32_t length);
extern JSObject*
JS_NewInt16ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                           uint32_t byteOffset, int32_t length);
extern JSObject*
JS_NewUint16ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                            uint32_t byteOffset, int32_t length);
extern JSObject*
JS_NewInt32ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                           uint32_t byteOffset, int32_t length);
extern JSObject*
JS_NewUint32ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                            uint32_t byteOffset, int32_t length);
extern JSObject*
JS_NewFloat32ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                             uint32_t byteOffset, int32_t length);
extern JSObject*
JS_NewFloat64ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                             uint32_t byteOffset, int32_t length);







extern JSObject*
JS_NewSharedArrayBuffer(JSContext* cx, uint32_t nbytes);




extern JSObject*
JS_NewArrayBuffer(JSContext* cx, uint32_t nbytes);







extern bool
JS_IsTypedArrayObject(JSObject* obj);
extern bool
JS_IsArrayBufferViewObject(JSObject* obj);





extern bool
JS_IsInt8Array(JSObject* obj);
extern bool
JS_IsUint8Array(JSObject* obj);
extern bool
JS_IsUint8ClampedArray(JSObject* obj);
extern bool
JS_IsInt16Array(JSObject* obj);
extern bool
JS_IsUint16Array(JSObject* obj);
extern bool
JS_IsInt32Array(JSObject* obj);
extern bool
JS_IsUint32Array(JSObject* obj);
extern bool
JS_IsFloat32Array(JSObject* obj);
extern bool
JS_IsFloat64Array(JSObject* obj);
extern bool
JS_GetTypedArraySharedness(JSObject* obj);






namespace js {

extern JSObject*
UnwrapInt8Array(JSObject* obj);
extern JSObject*
UnwrapUint8Array(JSObject* obj);
extern JSObject*
UnwrapUint8ClampedArray(JSObject* obj);
extern JSObject*
UnwrapInt16Array(JSObject* obj);
extern JSObject*
UnwrapUint16Array(JSObject* obj);
extern JSObject*
UnwrapInt32Array(JSObject* obj);
extern JSObject*
UnwrapUint32Array(JSObject* obj);
extern JSObject*
UnwrapFloat32Array(JSObject* obj);
extern JSObject*
UnwrapFloat64Array(JSObject* obj);

extern JSObject*
UnwrapArrayBuffer(JSObject* obj);

extern JSObject*
UnwrapArrayBufferView(JSObject* obj);

extern JSObject*
UnwrapSharedArrayBuffer(JSObject* obj);


namespace detail {

extern const Class* const Int8ArrayClassPtr;
extern const Class* const Uint8ArrayClassPtr;
extern const Class* const Uint8ClampedArrayClassPtr;
extern const Class* const Int16ArrayClassPtr;
extern const Class* const Uint16ArrayClassPtr;
extern const Class* const Int32ArrayClassPtr;
extern const Class* const Uint32ArrayClassPtr;
extern const Class* const Float32ArrayClassPtr;
extern const Class* const Float64ArrayClassPtr;

const size_t TypedArrayLengthSlot = 1;

}
inline void GetInt8ArrayLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, int8_t** data) { do { } while (0); const JS::Value& lenSlot = GetReservedSlot(obj, detail::TypedArrayLengthSlot); *length = mozilla::AssertedCast<uint32_t>(lenSlot.toInt32()); *isSharedMemory = JS_GetTypedArraySharedness(obj); *data = static_cast<int8_t*>(GetObjectPrivate(obj)); }
inline void GetUint8ArrayLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data) { do { } while (0); const JS::Value& lenSlot = GetReservedSlot(obj, detail::TypedArrayLengthSlot); *length = mozilla::AssertedCast<uint32_t>(lenSlot.toInt32()); *isSharedMemory = JS_GetTypedArraySharedness(obj); *data = static_cast<uint8_t*>(GetObjectPrivate(obj)); }
inline void GetUint8ClampedArrayLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data) { do { } while (0); const JS::Value& lenSlot = GetReservedSlot(obj, detail::TypedArrayLengthSlot); *length = mozilla::AssertedCast<uint32_t>(lenSlot.toInt32()); *isSharedMemory = JS_GetTypedArraySharedness(obj); *data = static_cast<uint8_t*>(GetObjectPrivate(obj)); }
inline void GetInt16ArrayLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, int16_t** data) { do { } while (0); const JS::Value& lenSlot = GetReservedSlot(obj, detail::TypedArrayLengthSlot); *length = mozilla::AssertedCast<uint32_t>(lenSlot.toInt32()); *isSharedMemory = JS_GetTypedArraySharedness(obj); *data = static_cast<int16_t*>(GetObjectPrivate(obj)); }
inline void GetUint16ArrayLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint16_t** data) { do { } while (0); const JS::Value& lenSlot = GetReservedSlot(obj, detail::TypedArrayLengthSlot); *length = mozilla::AssertedCast<uint32_t>(lenSlot.toInt32()); *isSharedMemory = JS_GetTypedArraySharedness(obj); *data = static_cast<uint16_t*>(GetObjectPrivate(obj)); }
inline void GetInt32ArrayLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, int32_t** data) { do { } while (0); const JS::Value& lenSlot = GetReservedSlot(obj, detail::TypedArrayLengthSlot); *length = mozilla::AssertedCast<uint32_t>(lenSlot.toInt32()); *isSharedMemory = JS_GetTypedArraySharedness(obj); *data = static_cast<int32_t*>(GetObjectPrivate(obj)); }
inline void GetUint32ArrayLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint32_t** data) { do { } while (0); const JS::Value& lenSlot = GetReservedSlot(obj, detail::TypedArrayLengthSlot); *length = mozilla::AssertedCast<uint32_t>(lenSlot.toInt32()); *isSharedMemory = JS_GetTypedArraySharedness(obj); *data = static_cast<uint32_t*>(GetObjectPrivate(obj)); }
inline void GetFloat32ArrayLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, float** data) { do { } while (0); const JS::Value& lenSlot = GetReservedSlot(obj, detail::TypedArrayLengthSlot); *length = mozilla::AssertedCast<uint32_t>(lenSlot.toInt32()); *isSharedMemory = JS_GetTypedArraySharedness(obj); *data = static_cast<float*>(GetObjectPrivate(obj)); }
inline void GetFloat64ArrayLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, double** data) { do { } while (0); const JS::Value& lenSlot = GetReservedSlot(obj, detail::TypedArrayLengthSlot); *length = mozilla::AssertedCast<uint32_t>(lenSlot.toInt32()); *isSharedMemory = JS_GetTypedArraySharedness(obj); *data = static_cast<double*>(GetObjectPrivate(obj)); }





extern void
GetArrayBufferViewLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);






extern void
GetArrayBufferLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);





extern void
GetSharedArrayBufferLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);

}

uint8_t*
JS_GetSharedArrayBufferData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);






extern JSObject*
JS_GetObjectAsInt8Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, int8_t** data);
extern JSObject*
JS_GetObjectAsUint8Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);
extern JSObject*
JS_GetObjectAsUint8ClampedArray(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);
extern JSObject*
JS_GetObjectAsInt16Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, int16_t** data);
extern JSObject*
JS_GetObjectAsUint16Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint16_t** data);
extern JSObject*
JS_GetObjectAsInt32Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, int32_t** data);
extern JSObject*
JS_GetObjectAsUint32Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint32_t** data);
extern JSObject*
JS_GetObjectAsFloat32Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, float** data);
extern JSObject*
JS_GetObjectAsFloat64Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, double** data);
extern JSObject*
JS_GetObjectAsArrayBufferView(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);




extern JSObject*
JS_GetObjectAsArrayBuffer(JSObject* obj, uint32_t* length, uint8_t** data);
extern js::Scalar::Type
JS_GetArrayBufferViewType(JSObject* obj);

extern js::Scalar::Type
JS_GetSharedArrayBufferViewType(JSObject* obj);







extern bool
JS_IsArrayBufferObject(JSObject* obj);

extern bool
JS_IsSharedArrayBufferObject(JSObject* obj);
extern uint32_t
JS_GetArrayBufferByteLength(JSObject* obj);

extern uint32_t
JS_GetSharedArrayBufferByteLength(JSObject* obj);
extern bool
JS_ArrayBufferHasData(JSObject* obj);
extern uint8_t*
JS_GetArrayBufferData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);






extern bool
JS_IsMappedArrayBufferObject(JSObject* obj);
extern uint32_t
JS_GetTypedArrayLength(JSObject* obj);
extern uint32_t
JS_GetTypedArrayByteOffset(JSObject* obj);
extern uint32_t
JS_GetTypedArrayByteLength(JSObject* obj);






extern bool
JS_IsArrayBufferViewObject(JSObject* obj);




extern uint32_t
JS_GetArrayBufferViewByteLength(JSObject* obj);
extern int8_t*
JS_GetInt8ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
extern uint8_t*
JS_GetUint8ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
extern uint8_t*
JS_GetUint8ClampedArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
extern int16_t*
JS_GetInt16ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
extern uint16_t*
JS_GetUint16ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
extern int32_t*
JS_GetInt32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
extern uint32_t*
JS_GetUint32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
extern float*
JS_GetFloat32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
extern double*
JS_GetFloat64ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);





extern void*
JS_GetArrayBufferViewData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);






extern JSObject*
JS_GetArrayBufferViewBuffer(JSContext* cx, JS::HandleObject obj, bool* isSharedMemory);







extern bool
JS_DetachArrayBuffer(JSContext* cx, JS::HandleObject obj);






extern bool
JS_IsDetachedArrayBufferObject(JSObject* obj);




bool
JS_IsDataViewObject(JSObject* obj);
JSObject*
JS_NewDataView(JSContext* cx, JS::HandleObject buffer, uint32_t byteOffset, int32_t byteLength);
uint32_t
JS_GetDataViewByteOffset(JSObject* obj);
uint32_t
JS_GetDataViewByteLength(JSObject* obj);
void*
JS_GetDataViewData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);

namespace js {
extern bool
WatchGuts(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleObject callable);
extern bool
UnwatchGuts(JSContext* cx, JS::HandleObject obj, JS::HandleId id);

namespace jit {

enum class InlinableNative : uint16_t;

}

}





class JSJitGetterCallArgs : protected JS::MutableHandleValue
{
  public:
    explicit JSJitGetterCallArgs(const JS::CallArgs& args)
      : JS::MutableHandleValue(args.rval())
    {}

    explicit JSJitGetterCallArgs(JS::RootedValue* rooted)
      : JS::MutableHandleValue(rooted)
    {}

    JS::MutableHandleValue rval() {
        return *this;
    }
};





class JSJitSetterCallArgs : protected JS::MutableHandleValue
{
  public:
    explicit JSJitSetterCallArgs(const JS::CallArgs& args)
      : JS::MutableHandleValue(args[0])
    {}

    JS::MutableHandleValue operator[](unsigned i) {
        do { } while (0);
        return *this;
    }

    unsigned length() const { return 1; }


};

struct JSJitMethodCallArgsTraits;





class JSJitMethodCallArgs : protected JS::detail::CallArgsBase<JS::detail::NoUsedRval>
{
  private:
    typedef JS::detail::CallArgsBase<JS::detail::NoUsedRval> Base;
    friend struct JSJitMethodCallArgsTraits;

  public:
    explicit JSJitMethodCallArgs(const JS::CallArgs& args) {
        argv_ = args.array();
        argc_ = args.length();
    }

    JS::MutableHandleValue rval() const {
        return Base::rval();
    }

    unsigned length() const { return Base::length(); }

    JS::MutableHandleValue operator[](unsigned i) const {
        return Base::operator[](i);
    }

    bool hasDefined(unsigned i) const {
        return Base::hasDefined(i);
    }

    JSObject& callee() const {


        return argv_[-2].toObject();
    }

    JS::HandleValue get(unsigned i) const {
        return Base::get(i);
    }
};

struct JSJitMethodCallArgsTraits
{
    static const size_t offsetOfArgv = __builtin_offsetof(JSJitMethodCallArgs, argv_);
    static const size_t offsetOfArgc = __builtin_offsetof(JSJitMethodCallArgs, argc_);
};

typedef bool
(* JSJitGetterOp)(JSContext* cx, JS::HandleObject thisObj,
                  void* specializedThis, JSJitGetterCallArgs args);
typedef bool
(* JSJitSetterOp)(JSContext* cx, JS::HandleObject thisObj,
                  void* specializedThis, JSJitSetterCallArgs args);
typedef bool
(* JSJitMethodOp)(JSContext* cx, JS::HandleObject thisObj,
                  void* specializedThis, const JSJitMethodCallArgs& args);






struct JSJitInfo {
    enum OpType {
        Getter,
        Setter,
        Method,
        StaticMethod,
        InlinableNative,
        IgnoresReturnValueNative,

        OpTypeCount
    };

    enum ArgType {

        String = (1 << 0),
        Integer = (1 << 1),
        Double = (1 << 2),
        Boolean = (1 << 3),
        Object = (1 << 4),
        Null = (1 << 5),


        Numeric = Integer | Double,


        Primitive = Numeric | Boolean | Null | String,
        ObjectOrNull = Object | Null,
        Any = ObjectOrNull | Primitive,


        ArgTypeListEnd = (1 << 31)
    };

    static_assert(Any & String, "Any must include String.");
    static_assert(Any & Integer, "Any must include Integer.");
    static_assert(Any & Double, "Any must include Double.");
    static_assert(Any & Boolean, "Any must include Boolean.");
    static_assert(Any & Object, "Any must include Object.");
    static_assert(Any & Null, "Any must include Null.");






    enum AliasSet {




        AliasNone,





        AliasDOMSets,





        AliasEverything,


        AliasSetCount
    };

    bool needsOuterizedThisObject() const
    {
        return type() != Getter && type() != Setter;
    }

    bool isTypedMethodJitInfo() const
    {
        return isTypedMethod;
    }

    OpType type() const
    {
        return OpType(type_);
    }

    AliasSet aliasSet() const
    {
        return AliasSet(aliasSet_);
    }

    JSValueType returnType() const
    {
        return JSValueType(returnType_);
    }

    union {
        JSJitGetterOp getter;
        JSJitSetterOp setter;
        JSJitMethodOp method;

        JSNative staticMethod;
        JSNative ignoresReturnValueMethod;
    };

    static unsigned offsetOfIgnoresReturnValueNative() {
        return __builtin_offsetof(JSJitInfo, ignoresReturnValueMethod);
    }

    union {
        uint16_t protoID;
        js::jit::InlinableNative inlinableNative;
    };

    union {
        uint16_t depth;


        uint16_t nativeOp;
    };
    uint32_t type_ : 4;







    uint32_t aliasSet_ : 4;


    uint32_t returnType_ : 8;

    static_assert(OpTypeCount <= (1 << 4),
                  "Not enough space for OpType");
    static_assert(AliasSetCount <= (1 << 4),
                  "Not enough space for AliasSet");
    static_assert((sizeof(JSValueType) * 8) <= 8,
                  "Not enough space for JSValueType");






    uint32_t isInfallible : 1;







    uint32_t isMovable : 1;






    uint32_t isEliminatable : 1;






    uint32_t isAlwaysInSlot : 1;





    uint32_t isLazilyCachedInSlot : 1;


    uint32_t isTypedMethod : 1;






    uint32_t slotIndex : 10;

    static const size_t maxSlotIndex = (1 << 10) - 1;


};

static_assert(sizeof(JSJitInfo) == (sizeof(void*) + 2 * sizeof(uint32_t)),
              "There are several thousand instances of JSJitInfo stored in "
              "a binary. Please don't increase its space requirements without "
              "verifying that there is no other way forward (better packing, "
              "smaller datatypes for fields, subclassing, etc.).");

struct JSTypedMethodJitInfo
{
    JSJitInfo base;

    const JSJitInfo::ArgType* const argTypes;





};

namespace js {

static __attribute__((always_inline)) inline shadow::Function*
FunctionObjectToShadowFunction(JSObject* fun)
{
    do { } while (0);
    return reinterpret_cast<shadow::Function*>(fun);
}


static const unsigned JS_FUNCTION_INTERPRETED_BITS = 0x0201;


static __attribute__((always_inline)) inline bool
FunctionObjectIsNative(JSObject* fun)
{
    return !(FunctionObjectToShadowFunction(fun)->flags & JS_FUNCTION_INTERPRETED_BITS);
}

static __attribute__((always_inline)) inline JSNative
GetFunctionObjectNative(JSObject* fun)
{
    do { } while (0);
    return FunctionObjectToShadowFunction(fun)->native;
}

}

static __attribute__((always_inline)) inline const JSJitInfo*
FUNCTION_VALUE_TO_JITINFO(const JS::Value& v)
{
    do { } while (0);
    return js::FunctionObjectToShadowFunction(&v.toObject())->jitinfo;
}

static __attribute__((always_inline)) inline void
SET_JITINFO(JSFunction * func, const JSJitInfo* info)
{
    js::shadow::Function* fun = reinterpret_cast<js::shadow::Function*>(func);
    do { } while (0);
    fun->jitinfo = info;
}






static __attribute__((always_inline)) inline jsid
JSID_FROM_BITS(size_t bits)
{
    jsid id;
    (id.asBits) = bits;
    return id;
}

namespace js {
namespace detail {
bool IdMatchesAtom(jsid id, JSAtom* atom);
}
}
static __attribute__((always_inline)) inline jsid
NON_INTEGER_ATOM_TO_JSID(JSAtom* atom)
{
    do { } while (0);
    jsid id = JSID_FROM_BITS((size_t)atom);
    do { } while (0);
    return id;
}


static __attribute__((always_inline)) inline bool
JSID_IS_ATOM(jsid id)
{
    return JSID_IS_STRING(id);
}

static __attribute__((always_inline)) inline bool
JSID_IS_ATOM(jsid id, JSAtom* atom)
{
    return id == JSID_FROM_BITS((size_t)atom);
}

static __attribute__((always_inline)) inline JSAtom*
JSID_TO_ATOM(jsid id)
{
    return (JSAtom*)JSID_TO_STRING(id);
}

static_assert(sizeof(jsid) == sizeof(void*), "JS_STATIC_ASSERT");

namespace js {

static __attribute__((always_inline)) inline JS::Value
IdToValue(jsid id)
{
    if (JSID_IS_STRING(id))
        return JS::StringValue(JSID_TO_STRING(id));
    if (JSID_IS_INT(id))
        return JS::Int32Value(JSID_TO_INT(id));
    if (JSID_IS_SYMBOL(id))
        return JS::SymbolValue(JSID_TO_SYMBOL(id));
    do { } while (0);
    return JS::UndefinedValue();
}
struct ScriptEnvironmentPreparer {
    struct Closure {
        virtual bool operator()(JSContext* cx) = 0;
    };

    virtual void invoke(JS::HandleObject scope, Closure& closure) = 0;
};

extern void
PrepareScriptEnvironmentAndInvoke(JSContext* cx, JS::HandleObject scope,
                                  ScriptEnvironmentPreparer::Closure& closure);

void
SetScriptEnvironmentPreparer(JSContext* cx, ScriptEnvironmentPreparer* preparer);

enum CTypesActivityType {
    CTYPES_CALL_BEGIN,
    CTYPES_CALL_END,
    CTYPES_CALLBACK_BEGIN,
    CTYPES_CALLBACK_END
};

typedef void
(* CTypesActivityCallback)(JSContext* cx, CTypesActivityType type);





void
SetCTypesActivityCallback(JSContext* cx, CTypesActivityCallback cb);

class AutoCTypesActivityCallback {
  private:
    JSContext* cx;
    CTypesActivityCallback callback;
    CTypesActivityType endType;


  public:
    AutoCTypesActivityCallback(JSContext* cx, CTypesActivityType beginType,
                               CTypesActivityType endType
                                                              );
    ~AutoCTypesActivityCallback() {
        DoEndCallback();
    }
    void DoEndCallback() {
        if (callback) {
            callback(cx, endType);
            callback = nullptr;
        }
    }
};



struct AllocationMetadataBuilder {
    AllocationMetadataBuilder() { }







    virtual JSObject* build(JSContext* cx, JS::HandleObject obj,
                            AutoEnterOOMUnsafeRegion& oomUnsafe) const
    {
        return nullptr;
    }
};






void
SetAllocationMetadataBuilder(JSContext* cx, const AllocationMetadataBuilder *callback);


JSObject*
GetAllocationMetadata(JSObject* obj);

bool
GetElementsWithAdder(JSContext* cx, JS::HandleObject obj, JS::HandleObject receiver,
                     uint32_t begin, uint32_t end, js::ElementAdder* adder);

bool
ForwardToNative(JSContext* cx, JSNative native, const JS::CallArgs& args);
bool
SetPropertyIgnoringNamedGetter(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                               JS::HandleValue v, JS::HandleValue receiver,
                               JS::Handle<JS::PropertyDescriptor> ownDesc,
                               JS::ObjectOpResult& result);


extern bool
ExecuteInGlobalAndReturnScope(JSContext* cx, JS::HandleObject obj, JS::HandleScript script,
                              JS::MutableHandleObject scope);
extern JSObject*
GetNearestEnclosingWithEnvironmentObjectForFunction(JSFunction* fun);
extern JSObject*
GetFirstSubsumedSavedFrame(JSContext* cx, JS::HandleObject savedFrame, JS::SavedFrameSelfHosted selfHosted);

extern bool
ReportIsNotFunction(JSContext* cx, JS::HandleValue v);

extern JSObject*
ConvertArgsToArray(JSContext* cx, const JS::CallArgs& args);
extern void
SetWindowProxyClass(JSContext* cx, const Class* clasp);





extern void
SetWindowProxy(JSContext* cx, JS::HandleObject global, JS::HandleObject windowProxy);

namespace detail {

bool
IsWindowSlow(JSObject* obj);

}





inline bool
IsWindow(JSObject* obj)
{
    if (GetObjectClass(obj)->flags & (1<<((8 + 8)+1)))
        return detail::IsWindowSlow(obj);
    return false;
}




bool
IsWindowProxy(JSObject* obj);






extern JSObject*
ToWindowProxyIfWindow(JSObject* obj);






extern JSObject*
ToWindowIfWindowProxy(JSObject* obj);




extern bool
AddPluralRulesConstructor(JSContext* cx, JS::Handle<JSObject*> intl);
extern bool
AddMozDateTimeFormatConstructor(JSContext* cx, JS::Handle<JSObject*> intl);

class AutoAssertNoContentJS
{
  public:
    explicit AutoAssertNoContentJS(JSContext* cx);
    ~AutoAssertNoContentJS();

  private:
    JSContext* context_;
    bool prevAllowContentJS_;
};





extern void
EnableAccessValidation(JSContext* cx, bool enabled);





extern void
SetCompartmentValidAccessPtr(JSContext* cx, JS::HandleObject global, bool* accessp);

}

class NativeProfiler
{
  public:
    virtual ~NativeProfiler() {};
    virtual void sampleNative(void* addr, uint32_t size) = 0;
    virtual void removeNative(void* addr) = 0;
    virtual void reset() = 0;
};

class GCHeapProfiler
{
  public:
    virtual ~GCHeapProfiler() {};
    virtual void sampleTenured(void* addr, uint32_t size) = 0;
    virtual void sampleNursery(void* addr, uint32_t size) = 0;
    virtual void markTenuredStart() = 0;
    virtual void markTenured(void* addr) = 0;
    virtual void sweepTenured() = 0;
    virtual void sweepNursery() = 0;
    virtual void moveNurseryToTenured(void* addrOld, void* addrNew) = 0;
    virtual void reset() = 0;
};

class MemProfiler
{
    static mozilla::Atomic<uint32_t, mozilla::Relaxed> sActiveProfilerCount;
    static NativeProfiler* sNativeProfiler;

    static GCHeapProfiler* GetGCHeapProfiler(void* addr);
    static GCHeapProfiler* GetGCHeapProfiler(JSRuntime* runtime);

    static NativeProfiler* GetNativeProfiler() {
        return sNativeProfiler;
    }

    GCHeapProfiler* mGCHeapProfiler;
    JSRuntime* mRuntime;

  public:
    explicit MemProfiler(JSRuntime* aRuntime) : mGCHeapProfiler(nullptr), mRuntime(aRuntime) {}

    void start(GCHeapProfiler* aGCHeapProfiler);
    void stop();

    GCHeapProfiler* getGCHeapProfiler() const {
        return mGCHeapProfiler;
    }

    static __attribute__((always_inline)) inline bool enabled() {
        return sActiveProfilerCount > 0;
    }

    static MemProfiler* GetMemProfiler(JSContext* context);

    static void SetNativeProfiler(NativeProfiler* aProfiler) {
        sNativeProfiler = aProfiler;
    }

    static __attribute__((always_inline)) inline void SampleNative(void* addr, uint32_t size) {
        JS::AutoSuppressGCAnalysis nogc;

        if ((__builtin_expect(!!(!enabled()), 1)))
            return;

        NativeProfiler* profiler = GetNativeProfiler();
        if (profiler)
            profiler->sampleNative(addr, size);
    }

    static __attribute__((always_inline)) inline void SampleTenured(void* addr, uint32_t size) {
        JS::AutoSuppressGCAnalysis nogc;

        if ((__builtin_expect(!!(!enabled()), 1)))
            return;

        GCHeapProfiler* profiler = GetGCHeapProfiler(addr);
        if (profiler)
            profiler->sampleTenured(addr, size);
    }

    static __attribute__((always_inline)) inline void SampleNursery(void* addr, uint32_t size) {
        JS::AutoSuppressGCAnalysis nogc;

        if ((__builtin_expect(!!(!enabled()), 1)))
            return;

        GCHeapProfiler* profiler = GetGCHeapProfiler(addr);
        if (profiler)
            profiler->sampleNursery(addr, size);
    }

    static __attribute__((always_inline)) inline void RemoveNative(void* addr) {
        JS::AutoSuppressGCAnalysis nogc;

        if ((__builtin_expect(!!(!enabled()), 1)))
            return;

        NativeProfiler* profiler = GetNativeProfiler();
        if (profiler)
            profiler->removeNative(addr);
    }

    static __attribute__((always_inline)) inline void MarkTenuredStart(JSRuntime* runtime) {
        JS::AutoSuppressGCAnalysis nogc;

        if ((__builtin_expect(!!(!enabled()), 1)))
            return;

        GCHeapProfiler* profiler = GetGCHeapProfiler(runtime);
        if (profiler)
            profiler->markTenuredStart();
    }

    static __attribute__((always_inline)) inline void MarkTenured(void* addr) {
        JS::AutoSuppressGCAnalysis nogc;

        if ((__builtin_expect(!!(!enabled()), 1)))
            return;

        GCHeapProfiler* profiler = GetGCHeapProfiler(addr);
        if (profiler)
            profiler->markTenured(addr);
    }

    static __attribute__((always_inline)) inline void SweepTenured(JSRuntime* runtime) {
        JS::AutoSuppressGCAnalysis nogc;

        if ((__builtin_expect(!!(!enabled()), 1)))
            return;

        GCHeapProfiler* profiler = GetGCHeapProfiler(runtime);
        if (profiler)
            profiler->sweepTenured();
    }

    static __attribute__((always_inline)) inline void SweepNursery(JSRuntime* runtime) {
        JS::AutoSuppressGCAnalysis nogc;

        if ((__builtin_expect(!!(!enabled()), 1)))
            return;

        GCHeapProfiler* profiler = GetGCHeapProfiler(runtime);
        if (profiler)
            profiler->sweepNursery();
    }

    static __attribute__((always_inline)) inline void MoveNurseryToTenured(void* addrOld, void* addrNew) {
        JS::AutoSuppressGCAnalysis nogc;

        if ((__builtin_expect(!!(!enabled()), 1)))
            return;

        GCHeapProfiler* profiler = GetGCHeapProfiler(addrOld);
        if (profiler)
            profiler->moveNurseryToTenured(addrOld, addrNew);
    }
};



namespace mozilla {
namespace dom {
namespace binding_detail {



struct FakeString {
  FakeString() :
    mFlags(nsString::F_TERMINATED)
  {
  }

  ~FakeString() {
    if (mFlags & nsString::F_SHARED) {
      nsStringBuffer::FromData(mData)->Release();
    }
  }

  void Rebind(const nsString::char_type* aData, nsString::size_type aLength) {
    do { } while (0);
    mData = const_cast<nsString::char_type*>(aData);
    mLength = aLength;
  }




  void ShareOrDependUpon(const nsAString& aString) {
    RefPtr<nsStringBuffer> sharedBuffer = nsStringBuffer::FromString(aString);
    if (!sharedBuffer) {
      Rebind(aString.Data(), aString.Length());
    } else {
      AssignFromStringBuffer(sharedBuffer.forget());
      mLength = aString.Length();
    }
  }

  void Truncate() {
    do { } while (0);
    mData = nsString::char_traits::sEmptyBuffer;
    mLength = 0;
  }

  void SetIsVoid(bool aValue) {
    do { } while (0);

    Truncate();
    mFlags |= nsString::F_VOIDED;
  }

  const nsString::char_type* Data() const
  {
    return mData;
  }

  nsString::char_type* BeginWriting()
  {
    return mData;
  }

  nsString::size_type Length() const
  {
    return mLength;
  }


  bool SetLength(nsString::size_type aLength, mozilla::fallible_t const&) {

    if (aLength < sInlineCapacity) {
      SetData(mInlineStorage);
    } else {
      RefPtr<nsStringBuffer> buf = nsStringBuffer::Alloc((aLength + 1) * sizeof(nsString::char_type));
      if ((__builtin_expect(!!(!buf), 0))) {
        return false;
      }

      AssignFromStringBuffer(buf.forget());
    }
    mLength = aLength;
    mData[mLength] = char16_t(0);
    return true;
  }



  const nsAString* ToAStringPtr() const {
    return reinterpret_cast<const nsString*>(this);
  }

operator const nsAString& () const {
    return *reinterpret_cast<const nsString*>(this);
  }

private:
  nsAString* ToAStringPtr() {
    return reinterpret_cast<nsString*>(this);
  }

  nsString::char_type* mData;
  nsString::size_type mLength;
  uint32_t mFlags;

  static const size_t sInlineCapacity = 64;
  nsString::char_type mInlineStorage[sInlineCapacity];

  FakeString(const FakeString& other) = delete;
  void operator=(const FakeString& other) = delete;

  void SetData(nsString::char_type* aData) {
    do { } while (0);
    mData = const_cast<nsString::char_type*>(aData);
  }
  void AssignFromStringBuffer(already_AddRefed<nsStringBuffer> aBuffer) {
    SetData(static_cast<nsString::char_type*>(aBuffer.take()->Data()));
    mFlags = nsString::F_SHARED | nsString::F_TERMINATED;
  }

  friend class NonNull<nsAString>;



  class StringAsserter;
  friend class StringAsserter;

  class StringAsserter : public nsString {
  public:
    static void StaticAsserts() {
      static_assert(__builtin_offsetof(FakeString, mInlineStorage) ==
                      sizeof(nsString),
                    "FakeString should include all nsString members");
      static_assert(__builtin_offsetof(FakeString, mData) ==
                      __builtin_offsetof(StringAsserter, mData),
                    "Offset of mData should match");
      static_assert(__builtin_offsetof(FakeString, mLength) ==
                      __builtin_offsetof(StringAsserter, mLength),
                    "Offset of mLength should match");
      static_assert(__builtin_offsetof(FakeString, mFlags) ==
                      __builtin_offsetof(StringAsserter, mFlags),
                    "Offset of mFlags should match");
    }
  };
};
}
}
}

namespace mozilla {
namespace dom {




struct TypedArrayObjectStorage : AllTypedArraysBase {
protected:
  JSObject* mTypedObj;
  JSObject* mWrappedObj;

  TypedArrayObjectStorage()
    : mTypedObj(nullptr),
      mWrappedObj(nullptr)
  {
  }

  TypedArrayObjectStorage(TypedArrayObjectStorage&& aOther)
    : mTypedObj(aOther.mTypedObj),
      mWrappedObj(aOther.mWrappedObj)
  {
    aOther.mTypedObj = nullptr;
    aOther.mWrappedObj = nullptr;
  }

public:
  inline void TraceSelf(JSTracer* trc)
  {
    JS::UnsafeTraceRoot(trc, &mTypedObj, "TypedArray.mTypedObj");
    JS::UnsafeTraceRoot(trc, &mTypedObj, "TypedArray.mWrappedObj");
  }

private:
  TypedArrayObjectStorage(const TypedArrayObjectStorage&) = delete;
};







template<typename T,
         JSObject* UnwrapArray(JSObject*),
         void GetLengthAndDataAndSharedness(JSObject*, uint32_t*, bool*, T**)>
struct TypedArray_base : public TypedArrayObjectStorage {
  typedef T element_type;

  TypedArray_base()
    : mData(nullptr),
      mLength(0),
      mShared(false),
      mComputed(false)
  {
  }

  TypedArray_base(TypedArray_base&& aOther)
    : TypedArrayObjectStorage(Move(aOther)),
      mData(aOther.mData),
      mLength(aOther.mLength),
      mShared(aOther.mShared),
      mComputed(aOther.mComputed)
  {
    aOther.mData = nullptr;
    aOther.mLength = 0;
    aOther.mShared = false;
    aOther.mComputed = false;
  }

private:
  mutable T* mData;
  mutable uint32_t mLength;
  mutable bool mShared;
  mutable bool mComputed;

public:
  inline bool Init(JSObject* obj)
  {
    do { } while (0);
    mTypedObj = mWrappedObj = UnwrapArray(obj);
    return inited();
  }

  inline bool inited() const {
    return !!mTypedObj;
  }
  inline bool IsShared() const {
    do { } while (0);
    return mShared;
  }

  inline T *Data() const {
    do { } while (0);
    if (mShared)
      return nullptr;
    return mData;
  }

  inline T *DataAllowShared() const {
    do { } while (0);
    return mData;
  }

  inline uint32_t Length() const {
    do { } while (0);
    if (mShared)
      return 0;
    return mLength;
  }

  inline uint32_t LengthAllowShared() const {
    do { } while (0);
    return mLength;
  }

  inline JSObject *Obj() const {
    do { } while (0);
    return mWrappedObj;
  }

  inline bool WrapIntoNewCompartment(JSContext* cx)
  {
    return JS_WrapObject(cx,
      JS::MutableHandle<JSObject*>::fromMarkedLocation(&mWrappedObj));
  }

  inline void ComputeLengthAndData() const
  {
    do { } while (0);
    do { } while (0);
    GetLengthAndDataAndSharedness(mTypedObj, &mLength, &mShared, &mData);
    mComputed = true;
  }

private:
  TypedArray_base(const TypedArray_base&) = delete;
};

template<typename T,
         JSObject* UnwrapArray(JSObject*),
         T* GetData(JSObject*, bool* isShared, const JS::AutoCheckCannotGC&),
         void GetLengthAndDataAndSharedness(JSObject*, uint32_t*, bool*, T**),
         JSObject* CreateNew(JSContext*, uint32_t)>
struct TypedArray
  : public TypedArray_base<T, UnwrapArray, GetLengthAndDataAndSharedness>
{
private:
  typedef TypedArray_base<T, UnwrapArray, GetLengthAndDataAndSharedness> Base;

public:
  TypedArray()
    : Base()
  {}

  TypedArray(TypedArray&& aOther)
    : Base(Move(aOther))
  {
  }

  static inline JSObject*
  Create(JSContext* cx, nsWrapperCache* creator, uint32_t length,
         const T* data = nullptr) {
    JS::Rooted<JSObject*> creatorWrapper(cx);
    Maybe<JSAutoCompartment> ac;
    if (creator && (creatorWrapper = creator->GetWrapperPreserveColor())) {
      ac.emplace(cx, creatorWrapper);
    }

    return CreateCommon(cx, length, data);
  }

  static inline JSObject*
  Create(JSContext* cx, uint32_t length, const T* data = nullptr) {
    return CreateCommon(cx, length, data);
  }

private:
  static inline JSObject*
  CreateCommon(JSContext* cx, uint32_t length, const T* data) {
    JSObject* obj = CreateNew(cx, length);
    if (!obj) {
      return nullptr;
    }
    if (data) {
      JS::AutoCheckCannotGC nogc;
      bool isShared;
      T* buf = static_cast<T*>(GetData(obj, &isShared, nogc));


      do { } while (0);
      memcpy(buf, data, length*sizeof(T));
    }
    return obj;
  }

  TypedArray(const TypedArray&) = delete;
};

template<JSObject* UnwrapArray(JSObject*),
         void GetLengthAndDataAndSharedness(JSObject*, uint32_t*, bool*,
                                            uint8_t**),
         js::Scalar::Type GetViewType(JSObject*)>
struct ArrayBufferView_base
  : public TypedArray_base<uint8_t, UnwrapArray, GetLengthAndDataAndSharedness>
{
private:
  typedef TypedArray_base<uint8_t, UnwrapArray, GetLengthAndDataAndSharedness>
          Base;

public:
  ArrayBufferView_base()
    : Base()
  {
  }

  ArrayBufferView_base(ArrayBufferView_base&& aOther)
    : Base(Move(aOther)),
      mType(aOther.mType)
  {
    aOther.mType = js::Scalar::MaxTypedArrayViewType;
  }

private:
  js::Scalar::Type mType;

public:
  inline bool Init(JSObject* obj)
  {
    if (!Base::Init(obj)) {
      return false;
    }

    mType = GetViewType(this->Obj());
    return true;
  }

  inline js::Scalar::Type Type() const
  {
    do { } while (0);
    return mType;
  }
};

typedef TypedArray<int8_t, js::UnwrapInt8Array, JS_GetInt8ArrayData,
                   js::GetInt8ArrayLengthAndData, JS_NewInt8Array>
        Int8Array;
typedef TypedArray<uint8_t, js::UnwrapUint8Array, JS_GetUint8ArrayData,
                   js::GetUint8ArrayLengthAndData, JS_NewUint8Array>
        Uint8Array;
typedef TypedArray<uint8_t, js::UnwrapUint8ClampedArray, JS_GetUint8ClampedArrayData,
                   js::GetUint8ClampedArrayLengthAndData, JS_NewUint8ClampedArray>
        Uint8ClampedArray;
typedef TypedArray<int16_t, js::UnwrapInt16Array, JS_GetInt16ArrayData,
                   js::GetInt16ArrayLengthAndData, JS_NewInt16Array>
        Int16Array;
typedef TypedArray<uint16_t, js::UnwrapUint16Array, JS_GetUint16ArrayData,
                   js::GetUint16ArrayLengthAndData, JS_NewUint16Array>
        Uint16Array;
typedef TypedArray<int32_t, js::UnwrapInt32Array, JS_GetInt32ArrayData,
                   js::GetInt32ArrayLengthAndData, JS_NewInt32Array>
        Int32Array;
typedef TypedArray<uint32_t, js::UnwrapUint32Array, JS_GetUint32ArrayData,
                   js::GetUint32ArrayLengthAndData, JS_NewUint32Array>
        Uint32Array;
typedef TypedArray<float, js::UnwrapFloat32Array, JS_GetFloat32ArrayData,
                   js::GetFloat32ArrayLengthAndData, JS_NewFloat32Array>
        Float32Array;
typedef TypedArray<double, js::UnwrapFloat64Array, JS_GetFloat64ArrayData,
                   js::GetFloat64ArrayLengthAndData, JS_NewFloat64Array>
        Float64Array;
typedef ArrayBufferView_base<js::UnwrapArrayBufferView,
                             js::GetArrayBufferViewLengthAndData,
                             JS_GetArrayBufferViewType>
        ArrayBufferView;
typedef TypedArray<uint8_t, js::UnwrapArrayBuffer, JS_GetArrayBufferData,
                   js::GetArrayBufferLengthAndData, JS_NewArrayBuffer>
        ArrayBuffer;

typedef TypedArray<uint8_t, js::UnwrapSharedArrayBuffer, JS_GetSharedArrayBufferData,
                   js::GetSharedArrayBufferLengthAndData, JS_NewSharedArrayBuffer>
        SharedArrayBuffer;





template<typename TypedArrayType>
class TypedArrayCreator
{
  typedef nsTArray<typename TypedArrayType::element_type> ArrayType;

  public:
    explicit TypedArrayCreator(const ArrayType& aArray)
      : mArray(aArray)
    {}

    JSObject* Create(JSContext* aCx) const
    {
      return TypedArrayType::Create(aCx, mArray.Length(), mArray.Elements());
    }

  private:
    const ArrayType& mArray;
};


template<typename ArrayType>
class TypedArrayRooter : private JS::CustomAutoRooter
{
public:
  template <typename CX>
  TypedArrayRooter(const CX& cx,
                   ArrayType* aArray ) :
    JS::CustomAutoRooter(cx ),
    mArray(aArray)
  {
  }

  virtual void trace(JSTracer* trc) override
  {
    mArray->TraceSelf(trc);
  }

private:
  TypedArrayObjectStorage* const mArray;
};


template<typename Inner> struct Nullable;
template<typename ArrayType>
class TypedArrayRooter<Nullable<ArrayType> > :
    private JS::CustomAutoRooter
{
public:
  template <typename CX>
  TypedArrayRooter(const CX& cx,
                   Nullable<ArrayType>* aArray ) :
    JS::CustomAutoRooter(cx ),
    mArray(aArray)
  {
  }

  virtual void trace(JSTracer* trc) override
  {
    if (!mArray->IsNull()) {
      mArray->Value().TraceSelf(trc);
    }
  }

private:
  Nullable<ArrayType>* const mArray;
};


template<typename ArrayType>
class RootedTypedArray final : public ArrayType,
                                        private TypedArrayRooter<ArrayType>
{
public:
  template <typename CX>
  explicit RootedTypedArray(const CX& cx ) :
    ArrayType(),
    TypedArrayRooter<ArrayType>(cx, this
                                                                         )
  {
  }

  template <typename CX>
  RootedTypedArray(const CX& cx, JSObject* obj ) :
    ArrayType(obj),
    TypedArrayRooter<ArrayType>(cx, this
                                                                         )
  {
  }
};

}
}
namespace mozilla {
namespace dom {



template<class T>
class UnionMember
{
  AlignedStorage2<T> mStorage;



  UnionMember(const UnionMember&) = delete;

public:
  UnionMember() = default;
  ~UnionMember() = default;

  T& SetValue()
  {
    new (mStorage.addr()) T();
    return *mStorage.addr();
  }
  template <typename T1>
  T& SetValue(const T1& aValue)
  {
    new (mStorage.addr()) T(aValue);
    return *mStorage.addr();
  }
  template<typename T1, typename T2>
  T& SetValue(const T1& aValue1, const T2& aValue2)
  {
    new (mStorage.addr()) T(aValue1, aValue2);
    return *mStorage.addr();
  }
  T& Value()
  {
    return *mStorage.addr();
  }
  const T& Value() const
  {
    return *mStorage.addr();
  }
  void Destroy()
  {
    mStorage.addr()->~T();
  }
};

}
}

namespace mozilla {
namespace dom {

class Blob;
class CanvasRenderingContext2D;
struct ChannelPixelLayoutAtoms;
class HTMLCanvasElement;
class HTMLImageElement;
class HTMLVideoElement;
class ImageBitmap;
struct ImageBitmapAtoms;
class ImageData;
struct NativePropertyHooks;
class OwningHTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer;
class ProtoAndIfaceCache;

}
}

namespace mozilla {
namespace dom {

enum class ImageBitmapFormat : uint8_t {
  RGBA32,
  BGRA32,
  RGB24,
  BGR24,
  GRAY8,
  YUV444P,
  YUV422P,
  YUV420P,
  YUV420SP_NV12,
  YUV420SP_NV21,
  HSV,
  Lab,
  DEPTH,
  EndGuard_
};

namespace ImageBitmapFormatValues {
extern const EnumEntry strings[14];
}

bool
ToJSValue(JSContext* aCx, ImageBitmapFormat aArgument, JS::MutableHandle<JS::Value> aValue);


enum class ChannelPixelLayoutDataType : uint8_t {
  Uint8,
  Int8,
  Uint16,
  Int16,
  Uint32,
  Int32,
  Float32,
  Float64,
  EndGuard_
};

namespace ChannelPixelLayoutDataTypeValues {
extern const EnumEntry strings[9];
}

bool
ToJSValue(JSContext* aCx, ChannelPixelLayoutDataType aArgument, JS::MutableHandle<JS::Value> aValue);


void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback, OwningHTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer& aUnion, const char* aName, uint32_t aFlags = 0);


void
ImplCycleCollectionUnlink(OwningHTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer& aUnion);


struct ChannelPixelLayout : public DictionaryBase
{
                        ChannelPixelLayoutDataType mDataType;
                        uint32_t mHeight;
                        uint32_t mOffset;
                        uint32_t mSkip;
                        uint32_t mStride;
                        uint32_t mWidth;

  ChannelPixelLayout();

  explicit inline ChannelPixelLayout(const FastDictionaryInitializer& )
  {

  }

  explicit inline ChannelPixelLayout(const ChannelPixelLayout& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  ChannelPixelLayout&
  operator=(const ChannelPixelLayout& aOther);

private:
  static bool
  InitIds(JSContext* cx, ChannelPixelLayoutAtoms* atomsCache);
};

namespace binding_detail {
struct FastChannelPixelLayout : public ChannelPixelLayout
{
  inline FastChannelPixelLayout()
    : ChannelPixelLayout(FastDictionaryInitializer())
  {

  }
};
}


class HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer
{
  friend class HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBufferArgument;
  enum Type
  {
    eUninitialized,
    eHTMLImageElement,
    eHTMLVideoElement,
    eHTMLCanvasElement,
    eBlob,
    eImageData,
    eCanvasRenderingContext2D,
    eImageBitmap,
    eArrayBufferView,
    eArrayBuffer
  };

  union Value
  {
    UnionMember<NonNull<mozilla::dom::HTMLImageElement> > mHTMLImageElement;
    UnionMember<NonNull<mozilla::dom::HTMLVideoElement> > mHTMLVideoElement;
    UnionMember<NonNull<mozilla::dom::HTMLCanvasElement> > mHTMLCanvasElement;
    UnionMember<NonNull<mozilla::dom::Blob> > mBlob;
    UnionMember<NonNull<mozilla::dom::ImageData> > mImageData;
    UnionMember<NonNull<mozilla::dom::CanvasRenderingContext2D> > mCanvasRenderingContext2D;
    UnionMember<NonNull<mozilla::dom::ImageBitmap> > mImageBitmap;
    UnionMember<RootedTypedArray<ArrayBufferView> > mArrayBufferView;
    UnionMember<RootedTypedArray<ArrayBuffer> > mArrayBuffer;

  };

  Type mType;
  Value mValue;

  HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer(const HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer&) = delete;
  HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer& operator=(const HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer&) = delete;
public:
  explicit inline HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer()
    : mType(eUninitialized)
  {
  }

  inline ~HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer()
  {
    Uninit();
  }

  inline NonNull<mozilla::dom::HTMLImageElement>&
  RawSetAsHTMLImageElement()
  {
    if (mType == eHTMLImageElement) {
      return mValue.mHTMLImageElement.Value();
    }
    do { } while (0);
    mType = eHTMLImageElement;
    return mValue.mHTMLImageElement.SetValue();
  }

  inline NonNull<mozilla::dom::HTMLImageElement>&
  SetAsHTMLImageElement()
  {
    if (mType == eHTMLImageElement) {
      return mValue.mHTMLImageElement.Value();
    }
    Uninit();
    mType = eHTMLImageElement;
    return mValue.mHTMLImageElement.SetValue();
  }

  inline bool
  IsHTMLImageElement() const
  {
    return mType == eHTMLImageElement;
  }

  inline NonNull<mozilla::dom::HTMLImageElement>&
  GetAsHTMLImageElement()
  {
    do { } while (0);
    return mValue.mHTMLImageElement.Value();
  }

  inline mozilla::dom::HTMLImageElement&
  GetAsHTMLImageElement() const
  {
    do { } while (0);
    return mValue.mHTMLImageElement.Value();
  }

  inline NonNull<mozilla::dom::HTMLVideoElement>&
  RawSetAsHTMLVideoElement()
  {
    if (mType == eHTMLVideoElement) {
      return mValue.mHTMLVideoElement.Value();
    }
    do { } while (0);
    mType = eHTMLVideoElement;
    return mValue.mHTMLVideoElement.SetValue();
  }

  inline NonNull<mozilla::dom::HTMLVideoElement>&
  SetAsHTMLVideoElement()
  {
    if (mType == eHTMLVideoElement) {
      return mValue.mHTMLVideoElement.Value();
    }
    Uninit();
    mType = eHTMLVideoElement;
    return mValue.mHTMLVideoElement.SetValue();
  }

  inline bool
  IsHTMLVideoElement() const
  {
    return mType == eHTMLVideoElement;
  }

  inline NonNull<mozilla::dom::HTMLVideoElement>&
  GetAsHTMLVideoElement()
  {
    do { } while (0);
    return mValue.mHTMLVideoElement.Value();
  }

  inline mozilla::dom::HTMLVideoElement&
  GetAsHTMLVideoElement() const
  {
    do { } while (0);
    return mValue.mHTMLVideoElement.Value();
  }

  inline NonNull<mozilla::dom::HTMLCanvasElement>&
  RawSetAsHTMLCanvasElement()
  {
    if (mType == eHTMLCanvasElement) {
      return mValue.mHTMLCanvasElement.Value();
    }
    do { } while (0);
    mType = eHTMLCanvasElement;
    return mValue.mHTMLCanvasElement.SetValue();
  }

  inline NonNull<mozilla::dom::HTMLCanvasElement>&
  SetAsHTMLCanvasElement()
  {
    if (mType == eHTMLCanvasElement) {
      return mValue.mHTMLCanvasElement.Value();
    }
    Uninit();
    mType = eHTMLCanvasElement;
    return mValue.mHTMLCanvasElement.SetValue();
  }

  inline bool
  IsHTMLCanvasElement() const
  {
    return mType == eHTMLCanvasElement;
  }

  inline NonNull<mozilla::dom::HTMLCanvasElement>&
  GetAsHTMLCanvasElement()
  {
    do { } while (0);
    return mValue.mHTMLCanvasElement.Value();
  }

  inline mozilla::dom::HTMLCanvasElement&
  GetAsHTMLCanvasElement() const
  {
    do { } while (0);
    return mValue.mHTMLCanvasElement.Value();
  }

  inline NonNull<mozilla::dom::Blob>&
  RawSetAsBlob()
  {
    if (mType == eBlob) {
      return mValue.mBlob.Value();
    }
    do { } while (0);
    mType = eBlob;
    return mValue.mBlob.SetValue();
  }

  inline NonNull<mozilla::dom::Blob>&
  SetAsBlob()
  {
    if (mType == eBlob) {
      return mValue.mBlob.Value();
    }
    Uninit();
    mType = eBlob;
    return mValue.mBlob.SetValue();
  }

  inline bool
  IsBlob() const
  {
    return mType == eBlob;
  }

  inline NonNull<mozilla::dom::Blob>&
  GetAsBlob()
  {
    do { } while (0);
    return mValue.mBlob.Value();
  }

  inline mozilla::dom::Blob&
  GetAsBlob() const
  {
    do { } while (0);
    return mValue.mBlob.Value();
  }

  inline NonNull<mozilla::dom::ImageData>&
  RawSetAsImageData()
  {
    if (mType == eImageData) {
      return mValue.mImageData.Value();
    }
    do { } while (0);
    mType = eImageData;
    return mValue.mImageData.SetValue();
  }

  inline NonNull<mozilla::dom::ImageData>&
  SetAsImageData()
  {
    if (mType == eImageData) {
      return mValue.mImageData.Value();
    }
    Uninit();
    mType = eImageData;
    return mValue.mImageData.SetValue();
  }

  inline bool
  IsImageData() const
  {
    return mType == eImageData;
  }

  inline NonNull<mozilla::dom::ImageData>&
  GetAsImageData()
  {
    do { } while (0);
    return mValue.mImageData.Value();
  }

  inline mozilla::dom::ImageData&
  GetAsImageData() const
  {
    do { } while (0);
    return mValue.mImageData.Value();
  }

  inline NonNull<mozilla::dom::CanvasRenderingContext2D>&
  RawSetAsCanvasRenderingContext2D()
  {
    if (mType == eCanvasRenderingContext2D) {
      return mValue.mCanvasRenderingContext2D.Value();
    }
    do { } while (0);
    mType = eCanvasRenderingContext2D;
    return mValue.mCanvasRenderingContext2D.SetValue();
  }

  inline NonNull<mozilla::dom::CanvasRenderingContext2D>&
  SetAsCanvasRenderingContext2D()
  {
    if (mType == eCanvasRenderingContext2D) {
      return mValue.mCanvasRenderingContext2D.Value();
    }
    Uninit();
    mType = eCanvasRenderingContext2D;
    return mValue.mCanvasRenderingContext2D.SetValue();
  }

  inline bool
  IsCanvasRenderingContext2D() const
  {
    return mType == eCanvasRenderingContext2D;
  }

  inline NonNull<mozilla::dom::CanvasRenderingContext2D>&
  GetAsCanvasRenderingContext2D()
  {
    do { } while (0);
    return mValue.mCanvasRenderingContext2D.Value();
  }

  inline mozilla::dom::CanvasRenderingContext2D&
  GetAsCanvasRenderingContext2D() const
  {
    do { } while (0);
    return mValue.mCanvasRenderingContext2D.Value();
  }

  inline NonNull<mozilla::dom::ImageBitmap>&
  RawSetAsImageBitmap()
  {
    if (mType == eImageBitmap) {
      return mValue.mImageBitmap.Value();
    }
    do { } while (0);
    mType = eImageBitmap;
    return mValue.mImageBitmap.SetValue();
  }

  inline NonNull<mozilla::dom::ImageBitmap>&
  SetAsImageBitmap()
  {
    if (mType == eImageBitmap) {
      return mValue.mImageBitmap.Value();
    }
    Uninit();
    mType = eImageBitmap;
    return mValue.mImageBitmap.SetValue();
  }

  inline bool
  IsImageBitmap() const
  {
    return mType == eImageBitmap;
  }

  inline NonNull<mozilla::dom::ImageBitmap>&
  GetAsImageBitmap()
  {
    do { } while (0);
    return mValue.mImageBitmap.Value();
  }

  inline mozilla::dom::ImageBitmap&
  GetAsImageBitmap() const
  {
    do { } while (0);
    return mValue.mImageBitmap.Value();
  }

  inline RootedTypedArray<ArrayBufferView>&
  RawSetAsArrayBufferView(JSContext* cx)
  {
    if (mType == eArrayBufferView) {
      return mValue.mArrayBufferView.Value();
    }
    do { } while (0);
    mType = eArrayBufferView;
    return mValue.mArrayBufferView.SetValue(cx);
  }

  inline RootedTypedArray<ArrayBufferView>&
  SetAsArrayBufferView(JSContext* cx)
  {
    if (mType == eArrayBufferView) {
      return mValue.mArrayBufferView.Value();
    }
    Uninit();
    mType = eArrayBufferView;
    return mValue.mArrayBufferView.SetValue(cx);
  }

  inline bool
  IsArrayBufferView() const
  {
    return mType == eArrayBufferView;
  }

  inline RootedTypedArray<ArrayBufferView>&
  GetAsArrayBufferView()
  {
    do { } while (0);
    return mValue.mArrayBufferView.Value();
  }

  inline ArrayBufferView const &
  GetAsArrayBufferView() const
  {
    do { } while (0);
    return mValue.mArrayBufferView.Value();
  }

  inline RootedTypedArray<ArrayBuffer>&
  RawSetAsArrayBuffer(JSContext* cx)
  {
    if (mType == eArrayBuffer) {
      return mValue.mArrayBuffer.Value();
    }
    do { } while (0);
    mType = eArrayBuffer;
    return mValue.mArrayBuffer.SetValue(cx);
  }

  inline RootedTypedArray<ArrayBuffer>&
  SetAsArrayBuffer(JSContext* cx)
  {
    if (mType == eArrayBuffer) {
      return mValue.mArrayBuffer.Value();
    }
    Uninit();
    mType = eArrayBuffer;
    return mValue.mArrayBuffer.SetValue(cx);
  }

  inline bool
  IsArrayBuffer() const
  {
    return mType == eArrayBuffer;
  }

  inline RootedTypedArray<ArrayBuffer>&
  GetAsArrayBuffer()
  {
    do { } while (0);
    return mValue.mArrayBuffer.Value();
  }

  inline ArrayBuffer const &
  GetAsArrayBuffer() const
  {
    do { } while (0);
    return mValue.mArrayBuffer.Value();
  }

  inline void
  Uninit()
  {
    switch (mType) {
      case eUninitialized: {
        break;
      }
      case eHTMLImageElement: {
        DestroyHTMLImageElement();
        break;
      }
      case eHTMLVideoElement: {
        DestroyHTMLVideoElement();
        break;
      }
      case eHTMLCanvasElement: {
        DestroyHTMLCanvasElement();
        break;
      }
      case eBlob: {
        DestroyBlob();
        break;
      }
      case eImageData: {
        DestroyImageData();
        break;
      }
      case eCanvasRenderingContext2D: {
        DestroyCanvasRenderingContext2D();
        break;
      }
      case eImageBitmap: {
        DestroyImageBitmap();
        break;
      }
      case eArrayBufferView: {
        DestroyArrayBufferView();
        break;
      }
      case eArrayBuffer: {
        DestroyArrayBuffer();
        break;
      }
    }
  }

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

private:
  inline void
  DestroyHTMLImageElement()
  {
    do { } while (0);
    mValue.mHTMLImageElement.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyHTMLVideoElement()
  {
    do { } while (0);
    mValue.mHTMLVideoElement.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyHTMLCanvasElement()
  {
    do { } while (0);
    mValue.mHTMLCanvasElement.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyBlob()
  {
    do { } while (0);
    mValue.mBlob.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyImageData()
  {
    do { } while (0);
    mValue.mImageData.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyCanvasRenderingContext2D()
  {
    do { } while (0);
    mValue.mCanvasRenderingContext2D.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyImageBitmap()
  {
    do { } while (0);
    mValue.mImageBitmap.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyArrayBufferView()
  {
    do { } while (0);
    mValue.mArrayBufferView.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyArrayBuffer()
  {
    do { } while (0);
    mValue.mArrayBuffer.Destroy();
    mType = eUninitialized;
  }
};


class OwningHTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer : public AllOwningUnionBase
{
  friend void ImplCycleCollectionUnlink(OwningHTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer& aUnion);
  enum Type
  {
    eUninitialized,
    eHTMLImageElement,
    eHTMLVideoElement,
    eHTMLCanvasElement,
    eBlob,
    eImageData,
    eCanvasRenderingContext2D,
    eImageBitmap,
    eArrayBufferView,
    eArrayBuffer
  };

  union Value
  {
    UnionMember<OwningNonNull<mozilla::dom::HTMLImageElement> > mHTMLImageElement;
    UnionMember<OwningNonNull<mozilla::dom::HTMLVideoElement> > mHTMLVideoElement;
    UnionMember<OwningNonNull<mozilla::dom::HTMLCanvasElement> > mHTMLCanvasElement;
    UnionMember<OwningNonNull<mozilla::dom::Blob> > mBlob;
    UnionMember<OwningNonNull<mozilla::dom::ImageData> > mImageData;
    UnionMember<OwningNonNull<mozilla::dom::CanvasRenderingContext2D> > mCanvasRenderingContext2D;
    UnionMember<OwningNonNull<mozilla::dom::ImageBitmap> > mImageBitmap;
    UnionMember<ArrayBufferView > mArrayBufferView;
    UnionMember<ArrayBuffer > mArrayBuffer;

  };

  Type mType;
  Value mValue;

  OwningHTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer(const OwningHTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer&) = delete;
  OwningHTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer& operator=(const OwningHTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer&) = delete;
public:
  explicit inline OwningHTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer()
    : mType(eUninitialized)
  {
  }

  inline ~OwningHTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer()
  {
    Uninit();
  }

  OwningNonNull<mozilla::dom::HTMLImageElement>&
  RawSetAsHTMLImageElement();

  OwningNonNull<mozilla::dom::HTMLImageElement>&
  SetAsHTMLImageElement();

  bool
  TrySetToHTMLImageElement(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsHTMLImageElement() const
  {
    return mType == eHTMLImageElement;
  }

  inline OwningNonNull<mozilla::dom::HTMLImageElement>&
  GetAsHTMLImageElement()
  {
    do { } while (0);
    return mValue.mHTMLImageElement.Value();
  }

  inline OwningNonNull<mozilla::dom::HTMLImageElement> const &
  GetAsHTMLImageElement() const
  {
    do { } while (0);
    return mValue.mHTMLImageElement.Value();
  }

  OwningNonNull<mozilla::dom::HTMLVideoElement>&
  RawSetAsHTMLVideoElement();

  OwningNonNull<mozilla::dom::HTMLVideoElement>&
  SetAsHTMLVideoElement();

  bool
  TrySetToHTMLVideoElement(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsHTMLVideoElement() const
  {
    return mType == eHTMLVideoElement;
  }

  inline OwningNonNull<mozilla::dom::HTMLVideoElement>&
  GetAsHTMLVideoElement()
  {
    do { } while (0);
    return mValue.mHTMLVideoElement.Value();
  }

  inline OwningNonNull<mozilla::dom::HTMLVideoElement> const &
  GetAsHTMLVideoElement() const
  {
    do { } while (0);
    return mValue.mHTMLVideoElement.Value();
  }

  OwningNonNull<mozilla::dom::HTMLCanvasElement>&
  RawSetAsHTMLCanvasElement();

  OwningNonNull<mozilla::dom::HTMLCanvasElement>&
  SetAsHTMLCanvasElement();

  bool
  TrySetToHTMLCanvasElement(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsHTMLCanvasElement() const
  {
    return mType == eHTMLCanvasElement;
  }

  inline OwningNonNull<mozilla::dom::HTMLCanvasElement>&
  GetAsHTMLCanvasElement()
  {
    do { } while (0);
    return mValue.mHTMLCanvasElement.Value();
  }

  inline OwningNonNull<mozilla::dom::HTMLCanvasElement> const &
  GetAsHTMLCanvasElement() const
  {
    do { } while (0);
    return mValue.mHTMLCanvasElement.Value();
  }

  OwningNonNull<mozilla::dom::Blob>&
  RawSetAsBlob();

  OwningNonNull<mozilla::dom::Blob>&
  SetAsBlob();

  bool
  TrySetToBlob(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsBlob() const
  {
    return mType == eBlob;
  }

  inline OwningNonNull<mozilla::dom::Blob>&
  GetAsBlob()
  {
    do { } while (0);
    return mValue.mBlob.Value();
  }

  inline OwningNonNull<mozilla::dom::Blob> const &
  GetAsBlob() const
  {
    do { } while (0);
    return mValue.mBlob.Value();
  }

  OwningNonNull<mozilla::dom::ImageData>&
  RawSetAsImageData();

  OwningNonNull<mozilla::dom::ImageData>&
  SetAsImageData();

  bool
  TrySetToImageData(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsImageData() const
  {
    return mType == eImageData;
  }

  inline OwningNonNull<mozilla::dom::ImageData>&
  GetAsImageData()
  {
    do { } while (0);
    return mValue.mImageData.Value();
  }

  inline OwningNonNull<mozilla::dom::ImageData> const &
  GetAsImageData() const
  {
    do { } while (0);
    return mValue.mImageData.Value();
  }

  OwningNonNull<mozilla::dom::CanvasRenderingContext2D>&
  RawSetAsCanvasRenderingContext2D();

  OwningNonNull<mozilla::dom::CanvasRenderingContext2D>&
  SetAsCanvasRenderingContext2D();

  bool
  TrySetToCanvasRenderingContext2D(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsCanvasRenderingContext2D() const
  {
    return mType == eCanvasRenderingContext2D;
  }

  inline OwningNonNull<mozilla::dom::CanvasRenderingContext2D>&
  GetAsCanvasRenderingContext2D()
  {
    do { } while (0);
    return mValue.mCanvasRenderingContext2D.Value();
  }

  inline OwningNonNull<mozilla::dom::CanvasRenderingContext2D> const &
  GetAsCanvasRenderingContext2D() const
  {
    do { } while (0);
    return mValue.mCanvasRenderingContext2D.Value();
  }

  OwningNonNull<mozilla::dom::ImageBitmap>&
  RawSetAsImageBitmap();

  OwningNonNull<mozilla::dom::ImageBitmap>&
  SetAsImageBitmap();

  bool
  TrySetToImageBitmap(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsImageBitmap() const
  {
    return mType == eImageBitmap;
  }

  inline OwningNonNull<mozilla::dom::ImageBitmap>&
  GetAsImageBitmap()
  {
    do { } while (0);
    return mValue.mImageBitmap.Value();
  }

  inline OwningNonNull<mozilla::dom::ImageBitmap> const &
  GetAsImageBitmap() const
  {
    do { } while (0);
    return mValue.mImageBitmap.Value();
  }

  ArrayBufferView&
  RawSetAsArrayBufferView();

  ArrayBufferView&
  SetAsArrayBufferView();

  bool
  TrySetToArrayBufferView(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsArrayBufferView() const
  {
    return mType == eArrayBufferView;
  }

  inline ArrayBufferView&
  GetAsArrayBufferView()
  {
    do { } while (0);
    return mValue.mArrayBufferView.Value();
  }

  inline ArrayBufferView const &
  GetAsArrayBufferView() const
  {
    do { } while (0);
    return mValue.mArrayBufferView.Value();
  }

  ArrayBuffer&
  RawSetAsArrayBuffer();

  ArrayBuffer&
  SetAsArrayBuffer();

  bool
  TrySetToArrayBuffer(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsArrayBuffer() const
  {
    return mType == eArrayBuffer;
  }

  inline ArrayBuffer&
  GetAsArrayBuffer()
  {
    do { } while (0);
    return mValue.mArrayBuffer.Value();
  }

  inline ArrayBuffer const &
  GetAsArrayBuffer() const
  {
    do { } while (0);
    return mValue.mArrayBuffer.Value();
  }

  void
  Uninit();

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceUnion(JSTracer* trc);

private:
  void
  DestroyHTMLImageElement();

  void
  DestroyHTMLVideoElement();

  void
  DestroyHTMLCanvasElement();

  void
  DestroyBlob();

  void
  DestroyImageData();

  void
  DestroyCanvasRenderingContext2D();

  void
  DestroyImageBitmap();

  void
  DestroyArrayBufferView();

  void
  DestroyArrayBuffer();
};


namespace ImageBitmapBinding {

  typedef mozilla::dom::ImageBitmap NativeType;

  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::ImageBitmap* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetProtoObjectHandle(JSContext* aCx);

  JS::Handle<JSObject*>
  GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true);

  JSObject*
  GetConstructorObject(JSContext* aCx);

}



}
}



namespace js {

using JS::AutoIdVector;
using JS::CallArgs;
using JS::Handle;
using JS::HandleId;
using JS::HandleObject;
using JS::HandleValue;
using JS::IsAcceptableThis;
using JS::MutableHandle;
using JS::MutableHandleObject;
using JS::MutableHandleValue;
using JS::NativeImpl;
using JS::ObjectOpResult;
using JS::PrivateValue;
using JS::PropertyDescriptor;
using JS::Value;

class RegExpShared;

class Wrapper;
class BaseProxyHandler
{
    const void* mFamily;
    bool mHasPrototype;







    bool mHasSecurityPolicy;

  public:
    explicit constexpr BaseProxyHandler(const void* aFamily, bool aHasPrototype = false,
                                            bool aHasSecurityPolicy = false)
      : mFamily(aFamily),
        mHasPrototype(aHasPrototype),
        mHasSecurityPolicy(aHasSecurityPolicy)
    { }

    bool hasPrototype() const {
        return mHasPrototype;
    }

    bool hasSecurityPolicy() const {
        return mHasSecurityPolicy;
    }

    inline const void* family() const {
        return mFamily;
    }
    static size_t offsetOfFamily() {
        return __builtin_offsetof(BaseProxyHandler, mFamily);
    }

    virtual bool finalizeInBackground(const Value& priv) const {




        return true;
    }

    virtual bool canNurseryAllocate() const {




        return false;
    }
    typedef uint32_t Action;
    enum {
        NONE = 0x00,
        GET = 0x01,
        SET = 0x02,
        CALL = 0x04,
        ENUMERATE = 0x08,
        GET_PROPERTY_DESCRIPTOR = 0x10
    };

    virtual bool enter(JSContext* cx, HandleObject wrapper, HandleId id, Action act, bool mayThrow,
                       bool* bp) const;


    virtual bool getOwnPropertyDescriptor(JSContext* cx, HandleObject proxy, HandleId id,
                                          MutableHandle<PropertyDescriptor> desc) const = 0;
    virtual bool defineProperty(JSContext* cx, HandleObject proxy, HandleId id,
                                Handle<PropertyDescriptor> desc,
                                ObjectOpResult& result) const = 0;
    virtual bool ownPropertyKeys(JSContext* cx, HandleObject proxy,
                                 AutoIdVector& props) const = 0;
    virtual bool delete_(JSContext* cx, HandleObject proxy, HandleId id,
                         ObjectOpResult& result) const = 0;







    virtual bool getPrototype(JSContext* cx, HandleObject proxy, MutableHandleObject protop) const;
    virtual bool setPrototype(JSContext* cx, HandleObject proxy, HandleObject proto,
                              ObjectOpResult& result) const;


    virtual bool getPrototypeIfOrdinary(JSContext* cx, HandleObject proxy, bool* isOrdinary,
                                        MutableHandleObject protop) const = 0;
    virtual bool setImmutablePrototype(JSContext* cx, HandleObject proxy, bool* succeeded) const;

    virtual bool preventExtensions(JSContext* cx, HandleObject proxy,
                                   ObjectOpResult& result) const = 0;
    virtual bool isExtensible(JSContext* cx, HandleObject proxy, bool* extensible) const = 0;
    virtual bool has(JSContext* cx, HandleObject proxy, HandleId id, bool* bp) const;
    virtual bool get(JSContext* cx, HandleObject proxy, HandleValue receiver,
                     HandleId id, MutableHandleValue vp) const;
    virtual bool set(JSContext* cx, HandleObject proxy, HandleId id, HandleValue v,
                     HandleValue receiver, ObjectOpResult& result) const;
    virtual bool call(JSContext* cx, HandleObject proxy, const CallArgs& args) const;
    virtual bool construct(JSContext* cx, HandleObject proxy, const CallArgs& args) const;


    virtual bool enumerate(JSContext* cx, HandleObject proxy, MutableHandleObject objp) const;
    virtual bool getPropertyDescriptor(JSContext* cx, HandleObject proxy, HandleId id,
                                       MutableHandle<PropertyDescriptor> desc) const;
    virtual bool hasOwn(JSContext* cx, HandleObject proxy, HandleId id, bool* bp) const;
    virtual bool getOwnEnumerablePropertyKeys(JSContext* cx, HandleObject proxy,
                                              AutoIdVector& props) const;
    virtual bool nativeCall(JSContext* cx, IsAcceptableThis test, NativeImpl impl,
                            const CallArgs& args) const;
    virtual bool hasInstance(JSContext* cx, HandleObject proxy, MutableHandleValue v, bool* bp) const;
    virtual bool getBuiltinClass(JSContext* cx, HandleObject proxy,
                                 ESClass* cls) const;
    virtual bool isArray(JSContext* cx, HandleObject proxy, JS::IsArrayAnswer* answer) const;
    virtual const char* className(JSContext* cx, HandleObject proxy) const;
    virtual JSString* fun_toString(JSContext* cx, HandleObject proxy, unsigned indent) const;
    virtual bool regexp_toShared(JSContext* cx, HandleObject proxy,
                                 MutableHandle<js::RegExpShared*> shared) const;
    virtual bool boxedValue_unbox(JSContext* cx, HandleObject proxy, MutableHandleValue vp) const;
    virtual void trace(JSTracer* trc, JSObject* proxy) const;
    virtual void finalize(JSFreeOp* fop, JSObject* proxy) const;
    virtual void objectMoved(JSObject* proxy, const JSObject* old) const;





    virtual bool isCallable(JSObject* obj) const;
    virtual bool isConstructor(JSObject* obj) const;



    virtual bool watch(JSContext* cx, JS::HandleObject proxy, JS::HandleId id,
                       JS::HandleObject callable) const;
    virtual bool unwatch(JSContext* cx, JS::HandleObject proxy, JS::HandleId id) const;

    virtual bool getElements(JSContext* cx, HandleObject proxy, uint32_t begin, uint32_t end,
                             ElementAdder* adder) const;


    virtual JSObject* weakmapKeyDelegate(JSObject* proxy) const;
    virtual bool isScripted() const { return false; }
};

extern const js::Class* const ProxyClassPtr;

inline bool IsProxy(const JSObject* obj)
{
    return GetObjectClass(obj)->isProxy();
}

namespace detail {
const uint32_t PROXY_EXTRA_SLOTS = 2;






struct ProxyValueArray
{
    Value privateSlot;
    Value extraSlots[PROXY_EXTRA_SLOTS];

    ProxyValueArray()
      : privateSlot(JS::UndefinedValue())
    {
        for (size_t i = 0; i < PROXY_EXTRA_SLOTS; i++)
            extraSlots[i] = JS::UndefinedValue();
    }

    static size_t offsetOfPrivateSlot() {
        return __builtin_offsetof(ProxyValueArray, privateSlot);
    }
};
struct ProxyDataLayout
{
    ProxyValueArray* values;
    const BaseProxyHandler* handler;
};

const uint32_t ProxyDataOffset = 2 * sizeof(void*);

inline ProxyDataLayout*
GetProxyDataLayout(JSObject* obj)
{
    do { } while (0);
    return reinterpret_cast<ProxyDataLayout*>(reinterpret_cast<uint8_t*>(obj) + ProxyDataOffset);
}

inline const ProxyDataLayout*
GetProxyDataLayout(const JSObject* obj)
{
    do { } while (0);
    return reinterpret_cast<const ProxyDataLayout*>(reinterpret_cast<const uint8_t*>(obj) +
                                                    ProxyDataOffset);
}
}

inline const BaseProxyHandler*
GetProxyHandler(const JSObject* obj)
{
    return detail::GetProxyDataLayout(obj)->handler;
}

inline const Value&
GetProxyPrivate(const JSObject* obj)
{
    return detail::GetProxyDataLayout(obj)->values->privateSlot;
}

inline JSObject*
GetProxyTargetObject(JSObject* obj)
{
    return GetProxyPrivate(obj).toObjectOrNull();
}

inline const Value&
GetProxyExtra(const JSObject* obj, size_t n)
{
    do { } while (0);
    return detail::GetProxyDataLayout(obj)->values->extraSlots[n];
}

inline void
SetProxyHandler(JSObject* obj, const BaseProxyHandler* handler)
{
    detail::GetProxyDataLayout(obj)->handler = handler;
}

void
SetValueInProxy(Value* slot, const Value& value);

inline void
SetProxyExtra(JSObject* obj, size_t n, const Value& extra)
{
    do { } while (0);
    Value* vp = &detail::GetProxyDataLayout(obj)->values->extraSlots[n];


    if (vp->isGCThing() || extra.isGCThing())
        SetValueInProxy(vp, extra);
    else
        *vp = extra;
}

inline bool
IsScriptedProxy(const JSObject* obj)
{
    return IsProxy(obj) && GetProxyHandler(obj)->isScripted();
}

inline const Value&
GetReservedOrProxyPrivateSlot(const JSObject* obj, size_t slot)
{
    do { } while (0);
    do { } while (0);
    return reinterpret_cast<const shadow::Object*>(obj)->slotRef(slot);
}

inline void
SetReservedOrProxyPrivateSlot(JSObject* obj, size_t slot, const Value& value)
{
    do { } while (0);
    do { } while (0);
    shadow::Object* sobj = reinterpret_cast<shadow::Object*>(obj);
    if (sobj->slotRef(slot).isGCThing() || value.isGCThing())
        SetReservedOrProxyPrivateSlotWithBarrier(obj, slot, value);
    else
        sobj->slotRef(slot) = value;
}

class ProxyOptions {
  protected:

    explicit ProxyOptions(bool singletonArg, bool lazyProtoArg = false)
      : singleton_(singletonArg),
        lazyProto_(lazyProtoArg),
        clasp_(ProxyClassPtr)
    {}

  public:
    ProxyOptions() : singleton_(false),
                     lazyProto_(false),
                     clasp_(ProxyClassPtr)
    {}

    bool singleton() const { return singleton_; }
    ProxyOptions& setSingleton(bool flag) {
        singleton_ = flag;
        return *this;
    }

    bool lazyProto() const { return lazyProto_; }
    ProxyOptions& setLazyProto(bool flag) {
        lazyProto_ = flag;
        return *this;
    }

    const Class* clasp() const {
        return clasp_;
    }
    ProxyOptions& setClass(const Class* claspArg) {
        clasp_ = claspArg;
        return *this;
    }

  private:
    bool singleton_;
    bool lazyProto_;
    const Class* clasp_;
};

JSObject*
NewProxyObject(JSContext* cx, const BaseProxyHandler* handler, HandleValue priv,
               JSObject* proto, const ProxyOptions& options = ProxyOptions());

JSObject*
RenewProxyObject(JSContext* cx, JSObject* obj, BaseProxyHandler* handler, const Value& priv);

class AutoEnterPolicy
{
  public:
    typedef BaseProxyHandler::Action Action;
    AutoEnterPolicy(JSContext* cx, const BaseProxyHandler* handler,
                    HandleObject wrapper, HandleId id, Action act, bool mayThrow)

        : context(nullptr)

    {
        allow = handler->hasSecurityPolicy() ? handler->enter(cx, wrapper, id, act, mayThrow, &rv)
                                             : true;
        recordEnter(cx, wrapper, id, act);





        if (!allow && !rv && mayThrow)
            reportErrorIfExceptionIsNotPending(cx, id);
    }

    virtual ~AutoEnterPolicy() { recordLeave(); }
    inline bool allowed() { return allow; }
    inline bool returnValue() { do { } while (0); return rv; }

  protected:

    AutoEnterPolicy()

        : context(nullptr)
        , enteredAction(BaseProxyHandler::NONE)

        {}
    void reportErrorIfExceptionIsNotPending(JSContext* cx, jsid id);
    bool allow;
    bool rv;


    JSContext* context;
    mozilla::Maybe<HandleObject> enteredProxy;
    mozilla::Maybe<HandleId> enteredId;
    Action enteredAction;




    AutoEnterPolicy* prev;
    void recordEnter(JSContext* cx, HandleObject proxy, HandleId id, Action act);
    void recordLeave();

    friend void assertEnteredPolicy(JSContext* cx, JSObject* proxy, jsid id, Action act);





  private:






    AutoEnterPolicy(const AutoEnterPolicy&) = delete;
    AutoEnterPolicy& operator=(const AutoEnterPolicy&) = delete;
};


class AutoWaivePolicy : public AutoEnterPolicy {
public:
    AutoWaivePolicy(JSContext* cx, HandleObject proxy, HandleId id,
                    BaseProxyHandler::Action act)
    {
        allow = true;
        recordEnter(cx, proxy, id, act);
    }
};
extern void
assertEnteredPolicy(JSContext* cx, JSObject* obj, jsid id,
                    BaseProxyHandler::Action act);






extern JSObject*
InitProxyClass(JSContext* cx, JS::HandleObject obj);

}

namespace js {







class WrapperOptions : public ProxyOptions {
  public:
    WrapperOptions() : ProxyOptions(false),
                       proto_()
    {}

    explicit WrapperOptions(JSContext* cx) : ProxyOptions(false),
                                             proto_()
    {
        proto_.emplace(cx);
    }

    inline JSObject* proto() const;
    WrapperOptions& setProto(JSObject* protoArg) {
        do { } while (0);
        *proto_ = protoArg;
        return *this;
    }

  private:
    mozilla::Maybe<JS::RootedObject> proto_;
};
class Wrapper : public BaseProxyHandler
{
    unsigned mFlags;

  public:
    explicit constexpr Wrapper(unsigned aFlags, bool aHasPrototype = false,
                                   bool aHasSecurityPolicy = false)
      : BaseProxyHandler(&family, aHasPrototype, aHasSecurityPolicy),
        mFlags(aFlags)
    { }

    virtual bool finalizeInBackground(const Value& priv) const override;


    virtual bool getOwnPropertyDescriptor(JSContext* cx, HandleObject proxy, HandleId id,
                                          MutableHandle<PropertyDescriptor> desc) const override;
    virtual bool defineProperty(JSContext* cx, HandleObject proxy, HandleId id,
                                Handle<PropertyDescriptor> desc,
                                ObjectOpResult& result) const override;
    virtual bool ownPropertyKeys(JSContext* cx, HandleObject proxy,
                                 AutoIdVector& props) const override;
    virtual bool delete_(JSContext* cx, HandleObject proxy, HandleId id,
                         ObjectOpResult& result) const override;
    virtual bool enumerate(JSContext* cx, HandleObject proxy,
                           MutableHandleObject objp) const override;
    virtual bool getPrototype(JSContext* cx, HandleObject proxy,
                              MutableHandleObject protop) const override;
    virtual bool setPrototype(JSContext* cx, HandleObject proxy, HandleObject proto,
                              ObjectOpResult& result) const override;
    virtual bool getPrototypeIfOrdinary(JSContext* cx, HandleObject proxy, bool* isOrdinary,
                                        MutableHandleObject protop) const override;
    virtual bool setImmutablePrototype(JSContext* cx, HandleObject proxy,
                                       bool* succeeded) const override;
    virtual bool preventExtensions(JSContext* cx, HandleObject proxy,
                                   ObjectOpResult& result) const override;
    virtual bool isExtensible(JSContext* cx, HandleObject proxy, bool* extensible) const override;
    virtual bool has(JSContext* cx, HandleObject proxy, HandleId id,
                     bool* bp) const override;
    virtual bool get(JSContext* cx, HandleObject proxy, HandleValue receiver,
                     HandleId id, MutableHandleValue vp) const override;
    virtual bool set(JSContext* cx, HandleObject proxy, HandleId id, HandleValue v,
                     HandleValue receiver, ObjectOpResult& result) const override;
    virtual bool call(JSContext* cx, HandleObject proxy, const CallArgs& args) const override;
    virtual bool construct(JSContext* cx, HandleObject proxy, const CallArgs& args) const override;


    virtual bool getPropertyDescriptor(JSContext* cx, HandleObject proxy, HandleId id,
                                       MutableHandle<PropertyDescriptor> desc) const override;
    virtual bool hasOwn(JSContext* cx, HandleObject proxy, HandleId id,
                        bool* bp) const override;
    virtual bool getOwnEnumerablePropertyKeys(JSContext* cx, HandleObject proxy,
                                              AutoIdVector& props) const override;
    virtual bool nativeCall(JSContext* cx, IsAcceptableThis test, NativeImpl impl,
                            const CallArgs& args) const override;
    virtual bool hasInstance(JSContext* cx, HandleObject proxy, MutableHandleValue v,
                             bool* bp) const override;
    virtual bool getBuiltinClass(JSContext* cx, HandleObject proxy, ESClass* cls) const override;
    virtual bool isArray(JSContext* cx, HandleObject proxy,
                         JS::IsArrayAnswer* answer) const override;
    virtual const char* className(JSContext* cx, HandleObject proxy) const override;
    virtual JSString* fun_toString(JSContext* cx, HandleObject proxy,
                                   unsigned indent) const override;
    virtual bool regexp_toShared(JSContext* cx, HandleObject proxy,
                                 MutableHandle<RegExpShared*> shared) const override;
    virtual bool boxedValue_unbox(JSContext* cx, HandleObject proxy,
                                  MutableHandleValue vp) const override;
    virtual bool isCallable(JSObject* obj) const override;
    virtual bool isConstructor(JSObject* obj) const override;
    virtual JSObject* weakmapKeyDelegate(JSObject* proxy) const override;

  public:
    using BaseProxyHandler::Action;

    enum Flags {
        CROSS_COMPARTMENT = 1 << 0,
        LAST_USED_FLAG = CROSS_COMPARTMENT
    };

    static JSObject* New(JSContext* cx, JSObject* obj, const Wrapper* handler,
                         const WrapperOptions& options = WrapperOptions());

    static JSObject* Renew(JSObject* existing, JSObject* obj, const Wrapper* handler);

    static const Wrapper* wrapperHandler(JSObject* wrapper);

    static JSObject* wrappedObject(JSObject* wrapper);

    unsigned flags() const {
        return mFlags;
    }

    static const char family;
    static const Wrapper singleton;
    static const Wrapper singletonWithPrototype;

    static JSObject* defaultProto;
};

inline JSObject*
WrapperOptions::proto() const
{
    return proto_ ? *proto_ : Wrapper::defaultProto;
}


class CrossCompartmentWrapper : public Wrapper
{
  public:
    explicit constexpr CrossCompartmentWrapper(unsigned aFlags, bool aHasPrototype = false,
                                                   bool aHasSecurityPolicy = false)
      : Wrapper(CROSS_COMPARTMENT | aFlags, aHasPrototype, aHasSecurityPolicy)
    { }


    virtual bool getOwnPropertyDescriptor(JSContext* cx, HandleObject wrapper, HandleId id,
                                          MutableHandle<PropertyDescriptor> desc) const override;
    virtual bool defineProperty(JSContext* cx, HandleObject wrapper, HandleId id,
                                Handle<PropertyDescriptor> desc,
                                ObjectOpResult& result) const override;
    virtual bool ownPropertyKeys(JSContext* cx, HandleObject wrapper,
                                 AutoIdVector& props) const override;
    virtual bool delete_(JSContext* cx, HandleObject wrapper, HandleId id,
                         ObjectOpResult& result) const override;
    virtual bool enumerate(JSContext* cx, HandleObject wrapper, MutableHandleObject objp) const override;
    virtual bool getPrototype(JSContext* cx, HandleObject proxy,
                              MutableHandleObject protop) const override;
    virtual bool setPrototype(JSContext* cx, HandleObject proxy, HandleObject proto,
                              ObjectOpResult& result) const override;

    virtual bool getPrototypeIfOrdinary(JSContext* cx, HandleObject proxy, bool* isOrdinary,
                                        MutableHandleObject protop) const override;
    virtual bool setImmutablePrototype(JSContext* cx, HandleObject proxy,
                                       bool* succeeded) const override;
    virtual bool preventExtensions(JSContext* cx, HandleObject wrapper,
                                   ObjectOpResult& result) const override;
    virtual bool isExtensible(JSContext* cx, HandleObject wrapper, bool* extensible) const override;
    virtual bool has(JSContext* cx, HandleObject wrapper, HandleId id, bool* bp) const override;
    virtual bool get(JSContext* cx, HandleObject wrapper, HandleValue receiver,
                     HandleId id, MutableHandleValue vp) const override;
    virtual bool set(JSContext* cx, HandleObject wrapper, HandleId id, HandleValue v,
                     HandleValue receiver, ObjectOpResult& result) const override;
    virtual bool call(JSContext* cx, HandleObject wrapper, const CallArgs& args) const override;
    virtual bool construct(JSContext* cx, HandleObject wrapper, const CallArgs& args) const override;


    virtual bool getPropertyDescriptor(JSContext* cx, HandleObject wrapper, HandleId id,
                                       MutableHandle<PropertyDescriptor> desc) const override;
    virtual bool hasOwn(JSContext* cx, HandleObject wrapper, HandleId id, bool* bp) const override;
    virtual bool getOwnEnumerablePropertyKeys(JSContext* cx, HandleObject wrapper,
                                              AutoIdVector& props) const override;
    virtual bool nativeCall(JSContext* cx, IsAcceptableThis test, NativeImpl impl,
                            const CallArgs& args) const override;
    virtual bool hasInstance(JSContext* cx, HandleObject wrapper, MutableHandleValue v,
                             bool* bp) const override;
    virtual const char* className(JSContext* cx, HandleObject proxy) const override;
    virtual JSString* fun_toString(JSContext* cx, HandleObject wrapper,
                                   unsigned indent) const override;
    virtual bool regexp_toShared(JSContext* cx, HandleObject proxy,
                                 MutableHandle<RegExpShared*> shared) const override;
    virtual bool boxedValue_unbox(JSContext* cx, HandleObject proxy, MutableHandleValue vp) const override;


    virtual bool canNurseryAllocate() const override { return true; }

    static const CrossCompartmentWrapper singleton;
    static const CrossCompartmentWrapper singletonWithPrototype;
};

class OpaqueCrossCompartmentWrapper : public CrossCompartmentWrapper
{
  public:
    explicit constexpr OpaqueCrossCompartmentWrapper() : CrossCompartmentWrapper(0)
    { }


    virtual bool getOwnPropertyDescriptor(JSContext* cx, HandleObject wrapper, HandleId id,
                                          MutableHandle<PropertyDescriptor> desc) const override;
    virtual bool defineProperty(JSContext* cx, HandleObject wrapper, HandleId id,
                                Handle<PropertyDescriptor> desc,
                                ObjectOpResult& result) const override;
    virtual bool ownPropertyKeys(JSContext* cx, HandleObject wrapper,
                                 AutoIdVector& props) const override;
    virtual bool delete_(JSContext* cx, HandleObject wrapper, HandleId id,
                         ObjectOpResult& result) const override;
    virtual bool enumerate(JSContext* cx, HandleObject wrapper,
                           MutableHandleObject objp) const override;
    virtual bool getPrototype(JSContext* cx, HandleObject wrapper,
                              MutableHandleObject protop) const override;
    virtual bool setPrototype(JSContext* cx, HandleObject wrapper, HandleObject proto,
                              ObjectOpResult& result) const override;
    virtual bool getPrototypeIfOrdinary(JSContext* cx, HandleObject wrapper, bool* isOrdinary,
                                        MutableHandleObject protop) const override;
    virtual bool setImmutablePrototype(JSContext* cx, HandleObject wrapper,
                                       bool* succeeded) const override;
    virtual bool preventExtensions(JSContext* cx, HandleObject wrapper,
                                   ObjectOpResult& result) const override;
    virtual bool isExtensible(JSContext* cx, HandleObject wrapper, bool* extensible) const override;
    virtual bool has(JSContext* cx, HandleObject wrapper, HandleId id,
                     bool* bp) const override;
    virtual bool get(JSContext* cx, HandleObject wrapper, HandleValue receiver,
                     HandleId id, MutableHandleValue vp) const override;
    virtual bool set(JSContext* cx, HandleObject wrapper, HandleId id, HandleValue v,
                     HandleValue receiver, ObjectOpResult& result) const override;
    virtual bool call(JSContext* cx, HandleObject wrapper, const CallArgs& args) const override;
    virtual bool construct(JSContext* cx, HandleObject wrapper, const CallArgs& args) const override;


    virtual bool getPropertyDescriptor(JSContext* cx, HandleObject wrapper, HandleId id,
                                       MutableHandle<PropertyDescriptor> desc) const override;
    virtual bool hasOwn(JSContext* cx, HandleObject wrapper, HandleId id,
                        bool* bp) const override;
    virtual bool getOwnEnumerablePropertyKeys(JSContext* cx, HandleObject wrapper,
                                              AutoIdVector& props) const override;
    virtual bool getBuiltinClass(JSContext* cx, HandleObject wrapper, ESClass* cls) const override;
    virtual bool isArray(JSContext* cx, HandleObject obj,
                         JS::IsArrayAnswer* answer) const override;
    virtual const char* className(JSContext* cx, HandleObject wrapper) const override;
    virtual JSString* fun_toString(JSContext* cx, HandleObject proxy, unsigned indent) const override;

    static const OpaqueCrossCompartmentWrapper singleton;
};
template <class Base>
class SecurityWrapper : public Base
{
  public:
    explicit constexpr SecurityWrapper(unsigned flags, bool hasPrototype = false)
      : Base(flags, hasPrototype, true)
    { }

    virtual bool enter(JSContext* cx, HandleObject wrapper, HandleId id, Wrapper::Action act,
                       bool mayThrow, bool* bp) const override;

    virtual bool defineProperty(JSContext* cx, HandleObject wrapper, HandleId id,
                                Handle<PropertyDescriptor> desc,
                                ObjectOpResult& result) const override;
    virtual bool isExtensible(JSContext* cx, HandleObject wrapper, bool* extensible) const override;
    virtual bool preventExtensions(JSContext* cx, HandleObject wrapper,
                                   ObjectOpResult& result) const override;
    virtual bool setPrototype(JSContext* cx, HandleObject proxy, HandleObject proto,
                              ObjectOpResult& result) const override;
    virtual bool setImmutablePrototype(JSContext* cx, HandleObject proxy, bool* succeeded) const override;

    virtual bool nativeCall(JSContext* cx, IsAcceptableThis test, NativeImpl impl,
                            const CallArgs& args) const override;
    virtual bool getBuiltinClass(JSContext* cx, HandleObject wrapper, ESClass* cls) const override;
    virtual bool isArray(JSContext* cx, HandleObject wrapper, JS::IsArrayAnswer* answer) const override;
    virtual bool regexp_toShared(JSContext* cx, HandleObject proxy,
                                 MutableHandle<RegExpShared*> shared) const override;
    virtual bool boxedValue_unbox(JSContext* cx, HandleObject proxy, MutableHandleValue vp) const override;




    virtual bool watch(JSContext* cx, JS::HandleObject proxy, JS::HandleId id,
                       JS::HandleObject callable) const override;
    virtual bool unwatch(JSContext* cx, JS::HandleObject proxy, JS::HandleId id) const override;





    typedef Base Permissive;
    typedef SecurityWrapper<Base> Restrictive;
};

typedef SecurityWrapper<CrossCompartmentWrapper> CrossCompartmentSecurityWrapper;

extern JSObject*
TransparentObjectWrapper(JSContext* cx, HandleObject existing, HandleObject obj);

inline bool
IsWrapper(JSObject* obj)
{
    return IsProxy(obj) && GetProxyHandler(obj)->family() == &Wrapper::family;
}





JSObject*
UncheckedUnwrap(JSObject* obj, bool stopAtWindowProxy = true, unsigned* flagsp = nullptr);





JSObject*
CheckedUnwrap(JSObject* obj, bool stopAtWindowProxy = true);



JSObject*
UnwrapOneChecked(JSObject* obj, bool stopAtWindowProxy = true);

void
ReportAccessDenied(JSContext* cx);

bool
IsCrossCompartmentWrapper(JSObject* obj);

void
NukeCrossCompartmentWrapper(JSContext* cx, JSObject* wrapper);

void
RemapWrapper(JSContext* cx, JSObject* wobj, JSObject* newTarget);

bool
RemapAllWrappersForObject(JSContext* cx, JSObject* oldTarget,
                          JSObject* newTarget);



bool
RecomputeWrappers(JSContext* cx, const CompartmentFilter& sourceFilter,
                  const CompartmentFilter& targetFilter);

}


class nsISupports;
class nsScriptObjectTracer;



namespace mozilla {
namespace cyclecollector {

void HoldJSObjectsImpl(void* aHolder, nsScriptObjectTracer* aTracer);
void HoldJSObjectsImpl(nsISupports* aHolder);
void DropJSObjectsImpl(void* aHolder);
void DropJSObjectsImpl(nsISupports* aHolder);

}


template<class T, bool isISupports = IsBaseOf<nsISupports, T>::value>
struct HoldDropJSObjectsHelper
{
  static void Hold(T* aHolder)
  {
    cyclecollector::HoldJSObjectsImpl(aHolder,
                                      T::cycleCollection::GetParticipant());
  }
  static void Drop(T* aHolder)
  {
    cyclecollector::DropJSObjectsImpl(aHolder);
  }
};

template<class T>
struct HoldDropJSObjectsHelper<T, true>
{
  static void Hold(T* aHolder)
  {
    cyclecollector::HoldJSObjectsImpl(ToSupports(aHolder));
  }
  static void Drop(T* aHolder)
  {
    cyclecollector::DropJSObjectsImpl(ToSupports(aHolder));
  }
};


template<class T>
void
HoldJSObjects(T* aHolder)
{
  HoldDropJSObjectsHelper<T>::Hold(aHolder);
}

template<class T>
void
DropJSObjects(T* aHolder)
{
  HoldDropJSObjectsHelper<T>::Drop(aHolder);
}





}


namespace mozilla {



enum class TaskCategory {

  UI,


  Network,


  Timer,


  Worker,


  IdleCallback,


  RefreshDriver,


  GarbageCollection,


  Other,

  Count
};

}

class nsIEventTarget;
class nsIRunnable;

namespace mozilla {
class AbstractThread;
namespace dom {
class TabGroup;





class DispatcherTrait {
public:


  virtual nsresult Dispatch(const char* aName,
                            TaskCategory aCategory,
                            already_AddRefed<nsIRunnable>&& aRunnable);




  virtual nsIEventTarget* EventTargetFor(TaskCategory aCategory) const;



  virtual AbstractThread* AbstractMainThreadFor(TaskCategory aCategory);
};

}
}








class nsACString;
class nsCString;
class nsCycleCollectionTraversalCallback;
class nsIPrincipal;

class nsIGlobalObject : public nsISupports,
                        public mozilla::dom::DispatcherTrait
{
  nsTArray<nsCString> mHostObjectURIs;
  bool mIsDying;

protected:
  nsIGlobalObject()
   : mIsDying(false)
  {}

public:
  template<typename T, typename U> struct COMTypeInfo;
  bool
  IsDying() const
  {
    return mIsDying;
  }







  virtual JSObject* GetGlobalJSObject() = 0;


  nsIPrincipal* PrincipalOrNull();

  void RegisterHostObjectURI(const nsACString& aURI);

  void UnregisterHostObjectURI(const nsACString& aURI);



  void UnlinkHostObjectURIs();
  void TraverseHostObjectURIs(nsCycleCollectionTraversalCallback &aCb);

protected:
  virtual ~nsIGlobalObject();

  void
  StartDying()
  {
    mIsDying = true;
  }
};

template<typename T> struct nsIGlobalObject::COMTypeInfo<nsIGlobalObject, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIGlobalObject::COMTypeInfo<nsIGlobalObject, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x11afa8be, 0xd997, 0x4e07, { 0xa6, 0xa3, 0x6f, 0x87, 0x2e, 0xc3, 0xee, 0x7f } };





namespace js {
class Debugger;
}

namespace JS {
namespace dbg {
class BuilderOrigin;

class Builder {


    PersistentRootedObject debuggerObject;


    js::Debugger* debugger;







    void assertBuilt(JSObject* obj) { }


  protected:


    template<typename T>
    class BuiltThing {
        friend class BuilderOrigin;

      protected:

        Builder& owner;


        PersistentRooted<T> value;

        BuiltThing(JSContext* cx, Builder& owner_, T value_ = GCPolicy<T>::initial())
          : owner(owner_), value(cx, value_)
        {
            owner.assertBuilt(value_);
        }


        js::Debugger* debugger() const { return owner.debugger; }
        JSObject* debuggerObject() const { return owner.debuggerObject; }

      public:
        BuiltThing(const BuiltThing& rhs) : owner(rhs.owner), value(rhs.value) { }
        BuiltThing& operator=(const BuiltThing& rhs) {
            do { } while (0);
            owner.assertBuilt(rhs.value);
            value = rhs.value;
            return *this;
        }

        explicit operator bool() const {

            return value;
        }

      private:
        BuiltThing() = delete;
    };

  public:



    class Object: private BuiltThing<JSObject*> {
        friend class Builder;
        friend class BuilderOrigin;

        typedef BuiltThing<JSObject*> Base;



        Object(JSContext* cx, Builder& owner_, HandleObject obj) : Base(cx, owner_, obj.get()) { }

        bool definePropertyToTrusted(JSContext* cx, const char* name,
                                     JS::MutableHandleValue value);

      public:
        Object(JSContext* cx, Builder& owner_) : Base(cx, owner_, nullptr) { }
        Object(const Object& rhs) : Base(rhs) { }
        bool defineProperty(JSContext* cx, const char* name, JS::HandleValue value);
        bool defineProperty(JSContext* cx, const char* name, JS::HandleObject value);
        bool defineProperty(JSContext* cx, const char* name, Object& value);

        using Base::operator bool;
    };



    Object newObject(JSContext* cx);

  protected:
    Builder(JSContext* cx, js::Debugger* debugger);
};



class BuilderOrigin : public Builder {
    template<typename T>
    T unwrapAny(const BuiltThing<T>& thing) {
        do { } while (0);
        return thing.value.get();
    }

  public:
    BuilderOrigin(JSContext* cx, js::Debugger* debugger_)
      : Builder(cx, debugger_)
    { }

    JSObject* unwrap(Object& object) { return unwrapAny(object); }
};
void
SetDebuggerMallocSizeOf(JSContext* cx, mozilla::MallocSizeOf mallocSizeOf);



mozilla::MallocSizeOf
GetDebuggerMallocSizeOf(JSContext* cx);
bool
FireOnGarbageCollectionHook(JSContext* cx, GarbageCollectionEvent::Ptr&& data);
void
onNewPromise(JSContext* cx, HandleObject promise);
void
onPromiseSettled(JSContext* cx, HandleObject promise);




bool
IsDebugger(JSObject& obj);



bool
GetDebuggeeGlobals(JSContext* cx, JSObject& dbgObj, AutoObjectVector& vector);
class AutoEntryMonitor {
    JSContext* cx_;
    AutoEntryMonitor* savedMonitor_;

  public:
    explicit AutoEntryMonitor(JSContext* cx);
    ~AutoEntryMonitor();
    virtual void Entry(JSContext* cx, JSFunction* function,
                       HandleValue asyncStack,
                       const char* asyncCause) = 0;




    virtual void Entry(JSContext* cx, JSScript* script,
                       HandleValue asyncStack,
                       const char* asyncCause) = 0;


    virtual void Exit(JSContext* cx) { }
};



}
}

class nsPIDOMWindowInner;
class nsGlobalWindow;
class nsIScriptContext;
class nsIDocument;
class nsIDocShell;

namespace mozilla {
namespace dom {





void InitScriptSettings();
void DestroyScriptSettings();
bool ScriptSettingsInitialized();
void UseEntryScriptProfiling();
void UnuseEntryScriptProfiling();
nsIGlobalObject* GetEntryGlobal();



nsIDocument* GetEntryDocument();



nsIGlobalObject* GetIncumbentGlobal();


nsIGlobalObject* GetCurrentGlobal();
nsIPrincipal* GetWebIDLCallerPrincipal();




inline JSObject& IncumbentJSGlobal()
{
  return *GetIncumbentGlobal()->GetGlobalJSObject();
}




bool IsJSAPIActive();

namespace danger {




JSContext* GetJSContext();

}

JS::RootingContext* RootingCx();

class ScriptSettingsStack;
class ScriptSettingsStackEntry {
  friend class ScriptSettingsStack;

public:
  ~ScriptSettingsStackEntry();

  bool NoJSAPI() const { return mType == eNoJSAPI; }
  bool IsEntryCandidate() const {
    return mType == eEntryScript || mType == eNoJSAPI;
  }
  bool IsIncumbentCandidate() { return mType != eJSAPI; }
  bool IsIncumbentScript() { return mType == eIncumbentScript; }

protected:
  enum Type {
    eEntryScript,
    eIncumbentScript,
    eJSAPI,
    eNoJSAPI
  };

  ScriptSettingsStackEntry(nsIGlobalObject *aGlobal,
                           Type aEntryType);

  nsCOMPtr<nsIGlobalObject> mGlobalObject;
  Type mType;

private:
  ScriptSettingsStackEntry *mOlder;
};
class AutoJSAPI : protected ScriptSettingsStackEntry {
public:


  AutoJSAPI();

  ~AutoJSAPI();
  void Init();
  __attribute__ ((warn_unused_result)) bool Init(nsIGlobalObject* aGlobalObject);



  __attribute__ ((warn_unused_result)) bool Init(JSObject* aObject);
  __attribute__ ((warn_unused_result)) bool Init(nsIGlobalObject* aGlobalObject, JSContext* aCx);



  __attribute__ ((warn_unused_result)) bool Init(nsPIDOMWindowInner* aWindow);
  __attribute__ ((warn_unused_result)) bool Init(nsPIDOMWindowInner* aWindow, JSContext* aCx);

  __attribute__ ((warn_unused_result)) bool Init(nsGlobalWindow* aWindow);
  __attribute__ ((warn_unused_result)) bool Init(nsGlobalWindow* aWindow, JSContext* aCx);

  JSContext* cx() const {
    do { } while (0);
    do { } while (0);
    return mCx;
  }






  void ReportException();

  bool HasException() const {
    do { } while (0);
    return JS_IsExceptionPending(cx());
  };







  __attribute__ ((warn_unused_result)) bool StealException(JS::MutableHandle<JS::Value> aVal);







  __attribute__ ((warn_unused_result)) bool PeekException(JS::MutableHandle<JS::Value> aVal);

  void ClearException() {
    do { } while (0);
    JS_ClearPendingException(cx());
  }

protected:


  AutoJSAPI(nsIGlobalObject* aGlobalObject, bool aIsMainThread, Type aType);

private:
  mozilla::Maybe<JSAutoRequest> mAutoRequest;
  mozilla::Maybe<JSAutoNullableCompartment> mAutoNullableCompartment;
  JSContext *mCx;


  bool mIsMainThread;
  Maybe<JS::WarningReporter> mOldWarningReporter;

  void InitInternal(nsIGlobalObject* aGlobalObject, JSObject* aGlobal,
                    JSContext* aCx, bool aIsMainThread);

  AutoJSAPI(const AutoJSAPI&) = delete;
  AutoJSAPI& operator= (const AutoJSAPI&) = delete;
};
class AutoEntryScript : public AutoJSAPI {
public:
  AutoEntryScript(nsIGlobalObject* aGlobalObject,
                  const char *aReason,
                  bool aIsMainThread = NS_IsMainThread());

  AutoEntryScript(JSObject* aObject,
                  const char *aReason,
                  bool aIsMainThread = NS_IsMainThread());

  ~AutoEntryScript();

  void SetWebIDLCallerPrincipal(nsIPrincipal *aPrincipal) {
    mWebIDLCallerPrincipal = aPrincipal;
  }

private:

  class DocshellEntryMonitor final : public JS::dbg::AutoEntryMonitor
  {
  public:
    DocshellEntryMonitor(JSContext* aCx, const char* aReason);






    void Entry(JSContext* aCx, JSFunction* aFunction,
               JS::Handle<JS::Value> aAsyncStack,
               const char* aAsyncCause) override
    {
      Entry(aCx, aFunction, nullptr, aAsyncStack, aAsyncCause);
    }

    void Entry(JSContext* aCx, JSScript* aScript,
               JS::Handle<JS::Value> aAsyncStack,
               const char* aAsyncCause) override
    {
      Entry(aCx, nullptr, aScript, aAsyncStack, aAsyncCause);
    }

    void Exit(JSContext* aCx) override;

  private:
    void Entry(JSContext* aCx, JSFunction* aFunction, JSScript* aScript,
               JS::Handle<JS::Value> aAsyncStack,
               const char* aAsyncCause);

    const char* mReason;
  };
  nsIPrincipal* mWebIDLCallerPrincipal;
  friend nsIPrincipal* GetWebIDLCallerPrincipal();

  Maybe<DocshellEntryMonitor> mDocShellEntryMonitor;
  JS::AutoHideScriptedCaller mCallerOverride;
};




class AutoIncumbentScript : protected ScriptSettingsStackEntry {
public:
  explicit AutoIncumbentScript(nsIGlobalObject* aGlobalObject);
  ~AutoIncumbentScript();

private:
  JS::AutoHideScriptedCaller mCallerOverride;
};
class AutoNoJSAPI : protected ScriptSettingsStackEntry {
public:
  explicit AutoNoJSAPI();
  ~AutoNoJSAPI();
};

}






class AutoJSContext {
public:
  explicit AutoJSContext();
  operator JSContext*() const;

protected:
  JSContext* mCx;
  dom::AutoJSAPI mJSAPI;

};







class AutoSafeJSContext : public dom::AutoJSAPI {
public:
  explicit AutoSafeJSContext();
  operator JSContext*() const
  {
    return cx();
  }

private:

};
class AutoSlowOperation : public dom::AutoJSAPI
{
public:
  explicit AutoSlowOperation();
  void CheckForInterrupt();
private:

};

}









class nsIScriptGlobalObject;





class nsIOffThreadScriptReceiver;





class nsIScriptContext : public nsISupports
{
public:
  template<typename T, typename U> struct COMTypeInfo;





  virtual nsIScriptGlobalObject *GetGlobalObject() = 0;




  virtual nsresult InitContext() = 0;
  virtual bool IsContextInitialized() = 0;



  virtual nsresult SetProperty(JS::Handle<JSObject*> aTarget,
                               const char* aPropName, nsISupports* aVal) = 0;




  virtual bool GetProcessingScriptTag() = 0;
  virtual void SetProcessingScriptTag(bool aResult) = 0;







  virtual nsresult InitClasses(JS::Handle<JSObject*> aGlobalObj) = 0;




  virtual void WillInitializeContext() = 0;




  virtual void DidInitializeContext() = 0;




  virtual void SetWindowProxy(JS::Handle<JSObject*> aWindowProxy) = 0;
  virtual JSObject* GetWindowProxy() = 0;
};

template<typename T> struct nsIScriptContext::COMTypeInfo<nsIScriptContext, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIScriptContext::COMTypeInfo<nsIScriptContext, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x54cbe9cf, 0x7282, 0x421a, { 0x91, 0x6f, 0xd0, 0x70, 0x73, 0xde, 0xb8, 0xc0 } };





class nsIOffThreadScriptReceiver : public nsISupports
{
public:
  template<typename T, typename U> struct COMTypeInfo;






  virtual nsresult OnScriptCompileComplete(JSScript* aScript, nsresult aStatus) = 0;
};

template<typename T> struct nsIOffThreadScriptReceiver::COMTypeInfo<nsIOffThreadScriptReceiver, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIOffThreadScriptReceiver::COMTypeInfo<nsIOffThreadScriptReceiver, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x3a980010, 0x878d, 0x46a9, {0x93, 0xad, 0xbc, 0xfd, 0xd3, 0x8e, 0xa0, 0xc2}};
class nsIScriptContext;
class nsIScriptGlobalObject;

namespace mozilla {
namespace dom {
struct ErrorEventInit;
}
}






bool
NS_HandleScriptError(nsIScriptGlobalObject *aScriptGlobal,
                     const mozilla::dom::ErrorEventInit &aErrorEvent,
                     nsEventStatus *aStatus);
class nsIScriptGlobalObject : public nsIGlobalObject
{
public:
  template<typename T, typename U> struct COMTypeInfo;
  virtual nsresult EnsureScriptEnvironment() = 0;



  virtual nsIScriptContext *GetScriptContext() = 0;

  nsIScriptContext* GetContext() {
    return GetScriptContext();
  }




  virtual nsresult HandleScriptError(
                     const mozilla::dom::ErrorEventInit &aErrorEventInit,
                     nsEventStatus *aEventStatus) {
    do { if ((__builtin_expect(!!(!(NS_HandleScriptError(this, aErrorEventInit, aEventStatus))), 0))) { do { } while(0); return NS_ERROR_UNEXPECTED; } } while(0);
    return NS_OK;
  }

  virtual bool IsBlackForCC(bool aTracingNeeded = true) { return false; }

protected:
  virtual ~nsIScriptGlobalObject() {}
};

template<typename T> struct nsIScriptGlobalObject::COMTypeInfo<nsIScriptGlobalObject, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIScriptGlobalObject::COMTypeInfo<nsIScriptGlobalObject, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x876f83bd, 0x6314, 0x460a, { 0xa0, 0x45, 0x1c, 0x8f, 0x46, 0x2f, 0xb8, 0xe1 } };


extern "C" {
extern __attribute__((visibility("default"))) PRInt64 LL_MaxInt(void);
extern __attribute__((visibility("default"))) PRInt64 LL_MinInt(void);
extern __attribute__((visibility("default"))) PRInt64 LL_Zero(void);
extern __attribute__((visibility("default"))) PRUint64 LL_MaxUint(void);
}

extern "C" {
typedef PRInt64 PRTime;






typedef struct PRTimeParameters {
    PRInt32 tp_gmt_offset;
    PRInt32 tp_dst_offset;
} PRTimeParameters;
typedef struct PRExplodedTime {
    PRInt32 tm_usec;
    PRInt32 tm_sec;

    PRInt32 tm_min;
    PRInt32 tm_hour;
    PRInt32 tm_mday;

    PRInt32 tm_month;
    PRInt16 tm_year;


    PRInt8 tm_wday;

    PRInt16 tm_yday;


    PRTimeParameters tm_params;
} PRExplodedTime;
typedef PRTimeParameters ( *PRTimeParamFn)(const PRExplodedTime *gmt);
extern __attribute__((visibility("default"))) PRTime
PR_Now(void);
extern __attribute__((visibility("default"))) void PR_ExplodeTime(
    PRTime usecs, PRTimeParamFn params, PRExplodedTime *exploded);


extern __attribute__((visibility("default"))) PRTime
PR_ImplodeTime(const PRExplodedTime *exploded);
extern __attribute__((visibility("default"))) void PR_NormalizeTime(
    PRExplodedTime *exploded, PRTimeParamFn params);






extern __attribute__((visibility("default"))) PRTimeParameters PR_LocalTimeParameters(const PRExplodedTime *gmt);


extern __attribute__((visibility("default"))) PRTimeParameters PR_GMTParameters(const PRExplodedTime *gmt);





extern __attribute__((visibility("default"))) PRTimeParameters PR_USPacificTimeParameters(const PRExplodedTime *gmt);
extern __attribute__((visibility("default"))) PRStatus PR_ParseTimeStringToExplodedTime (
        const char *string,
        PRBool default_to_gmt,
        PRExplodedTime *result);
extern __attribute__((visibility("default"))) PRStatus PR_ParseTimeString (
 const char *string,
 PRBool default_to_gmt,
 PRTime *result);


extern __attribute__((visibility("default"))) PRUint32 PR_FormatTime(char *buf, int buflen, const char *fmt,
                                 const PRExplodedTime *time);




extern __attribute__((visibility("default"))) PRUint32
PR_FormatTimeUSEnglish(char *buf, PRUint32 bufSize,
                       const char *format, const PRExplodedTime *time);

}

struct JSFreeOp;
class nsWrapperCache;
class nsAXPCNativeCallContext;
class nsIXPCScriptable;

class nsIXPConnect;

class nsIXPConnectWrappedNative;

class nsIInterfaceInfo;

class nsIXPCSecurityManager;

class nsIPrincipal;

class nsIClassInfo;

class nsIVariant;

class nsIStackFrame;

class nsIObjectInputStream;

class nsIObjectOutputStream;
class nsIXPConnectJSObjectHolder : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual JSObject * GetJSObject(void) = 0;

};

  template<typename T> struct nsIXPConnectJSObjectHolder::COMTypeInfo<nsIXPConnectJSObjectHolder, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIXPConnectJSObjectHolder::COMTypeInfo<nsIXPConnectJSObjectHolder, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x73e6ff4a, 0xab99, 0x4d99, { 0xac, 0x00, 0xba, 0x39, 0xcc, 0xb8, 0xe4, 0xd7 }};
class nsIXPConnectWrappedNative : public nsIXPConnectJSObjectHolder {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetNative(nsISupports * *aNative) = 0;


  virtual nsresult GetJSObjectPrototype(JSObject **aJSObjectPrototype) = 0;


  virtual nsresult FindInterfaceWithMember(JS::Handle<jsid> nameID, nsIInterfaceInfo * *_retval) = 0;


  virtual nsresult FindInterfaceWithName(JS::Handle<jsid> nameID, nsIInterfaceInfo * *_retval) = 0;


  virtual bool HasNativeMember(JS::Handle<jsid> name) = 0;


  virtual nsresult DebugDump(int16_t depth) = 0;




    nsISupports* Native() const { return mIdentity; }
protected:
    nsCOMPtr<nsISupports> mIdentity;
public:
};

  template<typename T> struct nsIXPConnectWrappedNative::COMTypeInfo<nsIXPConnectWrappedNative, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIXPConnectWrappedNative::COMTypeInfo<nsIXPConnectWrappedNative, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xe787be29, 0xdb5d, 0x4a45, { 0xa3, 0xd6, 0x1d, 0xe1, 0xd6, 0xb8, 0x5c, 0x30 }};
inline
const nsQueryInterface
do_QueryWrappedNative(nsIXPConnectWrappedNative *aWrappedNative)
{
    return nsQueryInterface(aWrappedNative->Native());
}
inline
const nsQueryInterfaceWithError
do_QueryWrappedNative(nsIXPConnectWrappedNative *aWrappedNative,
                      nsresult *aError)
{
    return nsQueryInterfaceWithError(aWrappedNative->Native(), aError);
}
class nsIXPConnectWrappedJS : public nsIXPConnectJSObjectHolder {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetInterfaceInfo(nsIInterfaceInfo * *aInterfaceInfo) = 0;


  virtual nsresult GetInterfaceIID(nsIID **aInterfaceIID) = 0;


  virtual nsresult DebugDump(int16_t depth) = 0;


  virtual nsresult AggregatedQueryInterface(const nsIID & uuid, void **result) = 0;

};

  template<typename T> struct nsIXPConnectWrappedJS::COMTypeInfo<nsIXPConnectWrappedJS, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIXPConnectWrappedJS::COMTypeInfo<nsIXPConnectWrappedJS, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x3a01b0d6, 0x074b, 0x49ed, { 0xba, 0xc3, 0x08, 0xc7, 0x63, 0x66, 0xca, 0xe4 }};
class nsIXPConnectWrappedJSUnmarkGray : public nsIXPConnectWrappedJS {
 public:

  template<typename T, typename U> struct COMTypeInfo;

};

  template<typename T> struct nsIXPConnectWrappedJSUnmarkGray::COMTypeInfo<nsIXPConnectWrappedJSUnmarkGray, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIXPConnectWrappedJSUnmarkGray::COMTypeInfo<nsIXPConnectWrappedJSUnmarkGray, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xc02a0ce6, 0x275f, 0x4ea1, { 0x9c, 0x23, 0x08, 0x49, 0x48, 0x98, 0xb0, 0x70 }};
class nsIXPCWrappedJSObjectGetter : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetNeverCalled(nsISupports * *aNeverCalled) = 0;

};

  template<typename T> struct nsIXPCWrappedJSObjectGetter::COMTypeInfo<nsIXPCWrappedJSObjectGetter, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIXPCWrappedJSObjectGetter::COMTypeInfo<nsIXPCWrappedJSObjectGetter, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x254bb2e0, 0x6439, 0x11d4, { 0x8f, 0xe0, 0x00, 0x10, 0xa4, 0xe7, 0x3d, 0x9a }};
class nsIXPCFunctionThisTranslator : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult TranslateThis(nsISupports *aInitialThis, nsISupports * *_retval) = 0;

};

  template<typename T> struct nsIXPCFunctionThisTranslator::COMTypeInfo<nsIXPCFunctionThisTranslator, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIXPCFunctionThisTranslator::COMTypeInfo<nsIXPCFunctionThisTranslator, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xf5f84b70, 0x92eb, 0x41f1, { 0xa1, 0xdd, 0x2e, 0xaa, 0xc0, 0xed, 0x56, 0x4c }};
class nsIXPConnect : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

   static const nsID& GetCID() {static const nsID cid = { 0xcb6593e0, 0xf9b2, 0x11d2, { 0xbd, 0xd6, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74 } }; return cid;}

  virtual nsresult InitClassesWithNewWrappedGlobal(JSContext *aJSContext, nsISupports *aCOMObj, nsIPrincipal *aPrincipal, uint32_t aFlags, JS::CompartmentOptions & aOptions, nsIXPConnectJSObjectHolder * *_retval) = 0;

  enum {
    INIT_JS_STANDARD_CLASSES = 1U,
    DONT_FIRE_ONNEWGLOBALHOOK = 2U,
    OMIT_COMPONENTS_OBJECT = 4U
  };


  virtual nsresult WrapNative(JSContext *aJSContext, JSObject *aScope, nsISupports *aCOMObj, const nsIID & aIID, JSObject **_retval) = 0;


  virtual nsresult WrapNativeHolder(JSContext *aJSContext, JSObject *aScope, nsISupports *aCOMObj, const nsIID & aIID, nsIXPConnectJSObjectHolder * *_retval) = 0;


  virtual nsresult WrapNativeToJSVal(JSContext *aJSContext, JSObject *aScope, nsISupports *aCOMObj, nsWrapperCache *aCache, const nsIID *aIID, bool aAllowWrapper, JS::MutableHandleValue aVal) = 0;


  virtual nsresult WrapJS(JSContext *aJSContext, JSObject *aJSObj, const nsIID & aIID, void **result) = 0;


  virtual nsresult JSValToVariant(JSContext *cx, JS::HandleValue aJSVal, nsIVariant * *_retval) = 0;


  virtual nsresult GetWrappedNativeOfJSObject(JSContext *aJSContext, JSObject *aJSObj, nsIXPConnectWrappedNative * *_retval) = 0;


  virtual nsISupports * GetNativeOfWrapper(JSContext *aJSContext, JSObject *aJSObj) = 0;


  virtual nsresult GetCurrentJSStack(nsIStackFrame * *aCurrentJSStack) = 0;


  virtual nsresult GetCurrentNativeCallContext(nsAXPCNativeCallContext **aCurrentNativeCallContext) = 0;


  virtual nsresult DebugDump(int16_t depth) = 0;


  virtual nsresult DebugDumpObject(nsISupports *aCOMObj, int16_t depth) = 0;


  virtual nsresult DebugDumpJSStack(bool showArgs, bool showLocals, bool showThisProps) = 0;


  virtual nsresult WrapJSAggregatedToNative(nsISupports *aOuter, JSContext *aJSContext, JSObject *aJSObj, const nsIID & aIID, void **result) = 0;


  virtual nsresult GetWrappedNativeOfNativeObject(JSContext *aJSContext, JSObject *aScope, nsISupports *aCOMObj, const nsIID & aIID, nsIXPConnectWrappedNative * *_retval) = 0;


  virtual nsresult SetFunctionThisTranslator(const nsIID & aIID, nsIXPCFunctionThisTranslator *aTranslator) = 0;


  virtual nsresult GetWrappedNativePrototype(JSContext *aJSContext, JSObject *aScope, nsIClassInfo *aClassInfo, JSObject **_retval) = 0;


  virtual nsresult VariantToJS(JSContext *ctx, JSObject *scope, nsIVariant *value, JS::MutableHandleValue _retval) = 0;


  virtual nsresult JSToVariant(JSContext *ctx, JS::HandleValue value, nsIVariant * *_retval) = 0;


  virtual nsresult CreateSandbox(JSContext *cx, nsIPrincipal *principal, JSObject **_retval) = 0;


  virtual nsresult EvalInSandboxObject(const nsAString & source, const char * filename, JSContext *cx, JSObject *sandbox, JS::MutableHandleValue _retval) = 0;


  virtual nsresult GarbageCollect(uint32_t reason) = 0;


  virtual nsresult NotifyDidPaint(void) = 0;







    virtual nsIPrincipal* GetPrincipal(JSObject* obj,
                                       bool allowShortCircuit) const = 0;
    virtual char* DebugPrintJSStack(bool showArgs,
                                    bool showLocals,
                                    bool showThisProps) = 0;

  virtual nsresult WriteScript(nsIObjectOutputStream *aStream, JSContext *aJSContext, JSScript *aJSScript) = 0;


  virtual nsresult ReadScript(nsIObjectInputStream *aStream, JSContext *aJSContext, JSScript **_retval) = 0;


  virtual nsresult WriteFunction(nsIObjectOutputStream *aStream, JSContext *aJSContext, JSObject *aJSObject) = 0;


  virtual nsresult ReadFunction(nsIObjectInputStream *aStream, JSContext *aJSContext, JSObject **_retval) = 0;

};

  template<typename T> struct nsIXPConnect::COMTypeInfo<nsIXPConnect, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIXPConnect::COMTypeInfo<nsIXPConnect, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x768507b5, 0xb981, 0x40c7, { 0x82, 0x76, 0xf6, 0xa1, 0xda, 0x50, 0x2a, 0x24 }};
class nsISimpleEnumerator;
class nsIArray : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetLength(uint32_t *aLength) = 0;


  virtual nsresult QueryElementAt(uint32_t index, const nsIID & uuid, void **result) = 0;


  virtual nsresult IndexOf(uint32_t startIndex, nsISupports *element, uint32_t *_retval) = 0;


  virtual nsresult Enumerate(nsISimpleEnumerator * *_retval) = 0;

};

  template<typename T> struct nsIArray::COMTypeInfo<nsIArray, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIArray::COMTypeInfo<nsIArray, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x114744d9, 0xc369, 0x456e, { 0xb5, 0x5a, 0x52, 0xfe, 0x52, 0x88, 0x0d, 0x2d }};


class nsIURI : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetSpec(nsACString & aSpec) = 0;
  virtual nsresult SetSpec(const nsACString & aSpec) = 0;





    nsCString GetSpecOrDefault()
    {
        nsCString spec;
        nsresult rv = GetSpec(spec);
        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {
            spec.Assign("[nsIURI::GetSpec failed]");
        }
        return spec;
    }

  virtual nsresult GetPrePath(nsACString & aPrePath) = 0;


  virtual nsresult GetScheme(nsACString & aScheme) = 0;
  virtual nsresult SetScheme(const nsACString & aScheme) = 0;


  virtual nsresult GetUserPass(nsACString & aUserPass) = 0;
  virtual nsresult SetUserPass(const nsACString & aUserPass) = 0;


  virtual nsresult GetUsername(nsACString & aUsername) = 0;
  virtual nsresult SetUsername(const nsACString & aUsername) = 0;


  virtual nsresult GetPassword(nsACString & aPassword) = 0;
  virtual nsresult SetPassword(const nsACString & aPassword) = 0;


  virtual nsresult GetHostPort(nsACString & aHostPort) = 0;
  virtual nsresult SetHostPort(const nsACString & aHostPort) = 0;


  virtual nsresult SetHostAndPort(const nsACString & hostport) = 0;


  virtual nsresult GetHost(nsACString & aHost) = 0;
  virtual nsresult SetHost(const nsACString & aHost) = 0;


  virtual nsresult GetPort(int32_t *aPort) = 0;
  virtual nsresult SetPort(int32_t aPort) = 0;


  virtual nsresult GetPath(nsACString & aPath) = 0;
  virtual nsresult SetPath(const nsACString & aPath) = 0;


  virtual nsresult Equals(nsIURI *other, bool *_retval) = 0;


  virtual nsresult SchemeIs(const char * scheme, bool *_retval) = 0;


  virtual nsresult Clone(nsIURI * *_retval) = 0;


  virtual nsresult Resolve(const nsACString & relativePath, nsACString & _retval) = 0;


  virtual nsresult GetAsciiSpec(nsACString & aAsciiSpec) = 0;


  virtual nsresult GetAsciiHostPort(nsACString & aAsciiHostPort) = 0;


  virtual nsresult GetAsciiHost(nsACString & aAsciiHost) = 0;


  virtual nsresult GetOriginCharset(nsACString & aOriginCharset) = 0;


  virtual nsresult GetRef(nsACString & aRef) = 0;
  virtual nsresult SetRef(const nsACString & aRef) = 0;


  virtual nsresult EqualsExceptRef(nsIURI *other, bool *_retval) = 0;


  virtual nsresult CloneIgnoringRef(nsIURI * *_retval) = 0;


  virtual nsresult CloneWithNewRef(const nsACString & newRef, nsIURI * *_retval) = 0;


  virtual nsresult GetSpecIgnoringRef(nsACString & aSpecIgnoringRef) = 0;


  virtual nsresult GetHasRef(bool *aHasRef) = 0;


  virtual nsresult GetFilePath(nsACString & aFilePath) = 0;
  virtual nsresult SetFilePath(const nsACString & aFilePath) = 0;


  virtual nsresult GetQuery(nsACString & aQuery) = 0;
  virtual nsresult SetQuery(const nsACString & aQuery) = 0;

};

  template<typename T> struct nsIURI::COMTypeInfo<nsIURI, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIURI::COMTypeInfo<nsIURI, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x92073a54, 0x6d78, 0x4f30, { 0x91, 0x3a, 0xb8, 0x71, 0x81, 0x32, 0x08, 0xc6 }};


class nsIControllers;

class nsIDOMBlob;

class nsIDOMLocation;

class nsIDOMOfflineResourceList;

class nsIPrompt;

class nsISelection;

class nsIVariant;
class nsIDOMWindow : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

};

  template<typename T> struct nsIDOMWindow::COMTypeInfo<nsIDOMWindow, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMWindow::COMTypeInfo<nsIDOMWindow, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xb8343993, 0x0383, 0x4add, { 0x99, 0x30, 0xad, 0x17, 0x6b, 0x18, 0x92, 0x40 }};
class nsIDOMWindowInternal : public nsIDOMWindow {
 public:

  template<typename T, typename U> struct COMTypeInfo;

};

  template<typename T> struct nsIDOMWindowInternal::COMTypeInfo<nsIDOMWindowInternal, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMWindowInternal::COMTypeInfo<nsIDOMWindowInternal, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x8c589e65, 0x3237, 0x4cd1, { 0x8b, 0xad, 0xc5, 0xc4, 0x71, 0x35, 0xe7, 0x9b }};
class mozIDOMWindow : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

};

  template<typename T> struct mozIDOMWindow::COMTypeInfo<mozIDOMWindow, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID mozIDOMWindow::COMTypeInfo<mozIDOMWindow, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x75fbabd6, 0x7a2e, 0x4787, { 0xaa, 0x33, 0x44, 0x9a, 0x33, 0x51, 0x21, 0x35 }};
class mozIDOMWindowProxy : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

};

  template<typename T> struct mozIDOMWindowProxy::COMTypeInfo<mozIDOMWindowProxy, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID mozIDOMWindowProxy::COMTypeInfo<mozIDOMWindowProxy, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x53ca090c, 0xe739, 0x48b9, { 0x89, 0x11, 0x20, 0x8c, 0x72, 0xf9, 0x19, 0x1e }};
class nsGlobalWindow;
class nsIArray;
class nsIContent;
class nsICSSDeclaration;
class nsIDocShell;
class nsIDocShellLoadInfo;
class nsIDocument;
class nsIEventTarget;
class nsIIdleObserver;
class nsIPrincipal;
class nsIScriptTimeoutHandler;
class nsIURI;
class nsPIDOMWindowInner;
class nsPIDOMWindowOuter;
class nsPIWindowRoot;
class nsXBLPrototypeHandler;

typedef uint32_t SuspendTypes;

namespace mozilla {
class ThrottledEventQueue;
namespace dom {
class AudioContext;
class DocGroup;
class TabGroup;
class Element;
class Performance;
class ServiceWorkerRegistration;
class Timeout;
class TimeoutManager;
class CustomElementRegistry;
enum class CallerType : uint32_t;
}
}






enum PopupControlState {
  openAllowed = 0,
  openControlled,
  openAbused,
  openOverridden
};

enum UIStateChangeType
{
  UIStateChangeType_NoChange,
  UIStateChangeType_Set,
  UIStateChangeType_Clear,
  UIStateChangeType_Invalid
};

enum class FullscreenReason
{

  ForFullscreenMode,

  ForFullscreenAPI,



  ForForceExitFullscreen
};

namespace mozilla {
namespace dom {




enum class LargeAllocStatus : uint8_t
{



  NONE,
  SUCCESS,




  NON_GET,
  NON_E10S,
  NOT_ONLY_TOPLEVEL_IN_TABGROUP,
  NON_WIN32
};
}
}




template<class T>
class nsPIDOMWindow : public T
{
public:
  nsPIDOMWindowInner* AsInner();
  const nsPIDOMWindowInner* AsInner() const;
  nsPIDOMWindowOuter* AsOuter();
  const nsPIDOMWindowOuter* AsOuter() const;

  virtual nsPIDOMWindowOuter* GetPrivateRoot() = 0;
  virtual mozilla::dom::CustomElementRegistry* CustomElements() = 0;

  virtual void ActivateOrDeactivate(bool aActivate) = 0;
  virtual already_AddRefed<nsPIDOMWindowOuter> GetTop() = 0;
  virtual already_AddRefed<nsPIDOMWindowOuter> GetParent() = 0;
  virtual nsPIDOMWindowOuter* GetScriptableTop() = 0;
  virtual nsPIDOMWindowOuter* GetScriptableParent() = 0;
  virtual already_AddRefed<nsPIWindowRoot> GetTopWindowRoot() = 0;

  bool IsRootOuterWindow()
  {
    do { } while (0);
    return mIsRootOuterWindow;
  }





  virtual nsPIDOMWindowOuter* GetScriptableParentOrNull() = 0;


  virtual nsresult RegisterIdleObserver(nsIIdleObserver* aIdleObserver) = 0;
  virtual nsresult UnregisterIdleObserver(nsIIdleObserver* aIdleObserver) = 0;

  virtual bool IsTopLevelWindowActive() = 0;


  virtual void SetActive(bool aActive)
  {
    do { } while (0);
    mIsActive = aActive;
  }

  virtual void SetIsBackground(bool aIsBackground)
  {
    do { } while (0);
    mIsBackground = aIsBackground;
  }

  mozilla::dom::EventTarget* GetChromeEventHandler() const
  {
    return mChromeEventHandler;
  }


  virtual void SetChromeEventHandler(mozilla::dom::EventTarget* aChromeEventHandler) = 0;

  mozilla::dom::EventTarget* GetParentTarget()
  {
    if (!mParentTarget) {
      UpdateParentTarget();
    }
    return mParentTarget;
  }

  virtual void MaybeUpdateTouchState() {}

  nsIDocument* GetExtantDoc() const
  {
    return mDoc;
  }
  nsIURI* GetDocumentURI() const;
  nsIURI* GetDocBaseURI() const;

  nsIDocument* GetDoc()
  {
    if (!mDoc) {
      MaybeCreateDoc();
    }
    return mDoc;
  }

protected:


  void MaybeCreateDoc();

public:

  inline bool IsLoading() const;
  inline bool IsHandlingResizeEvent() const;




  virtual void SetInitialPrincipalToSubject() = 0;

  virtual PopupControlState PushPopupControlState(PopupControlState aState,
                                                  bool aForce) const = 0;
  virtual void PopPopupControlState(PopupControlState state) const = 0;
  virtual PopupControlState GetPopupControlState() const = 0;



  virtual already_AddRefed<nsISupports> SaveWindowState() = 0;


  virtual nsresult RestoreWindowState(nsISupports *aState) = 0;





  virtual bool IsSuspended() const = 0;
  virtual bool IsFrozen() const = 0;



  virtual nsresult FireDelayedDOMEvents() = 0;

  nsPIDOMWindowOuter* GetOuterWindow()
  {
    return mIsInnerWindow ? mOuterWindow.get() : AsOuter();
  }

  bool IsInnerWindow() const
  {
    return mIsInnerWindow;
  }

  bool IsOuterWindow() const
  {
    return !IsInnerWindow();
  }


  virtual bool WouldReuseInnerWindow(nsIDocument* aNewDocument) = 0;




  nsIDocShell *GetDocShell() const;





  virtual void SetDocShell(nsIDocShell *aDocShell) = 0;




  virtual void DetachFromDocShell() = 0;
  virtual nsresult SetNewDocument(nsIDocument *aDocument,
                                  nsISupports *aState,
                                  bool aForceReuseInnerWindow) = 0;
  virtual void SetOpenerWindow(nsPIDOMWindowOuter* aOpener,
                               bool aOriginalOpener) = 0;

  virtual void EnsureSizeUpToDate() = 0;





  virtual void EnterModalState() = 0;
  virtual void LeaveModalState() = 0;


  virtual bool CanClose() = 0;
  virtual void ForceClose() = 0;

  bool IsModalContentWindow() const
  {
    return mIsModalContentWindow;
  }





  void SetHasPaintEventListeners()
  {
    mMayHavePaintEventListener = true;
  }





  bool HasPaintEventListeners()
  {
    return mMayHavePaintEventListener;
  }





  void SetHasTouchEventListeners()
  {
    if (!mMayHaveTouchEventListener) {
      mMayHaveTouchEventListener = true;
      MaybeUpdateTouchState();
    }
  }







  virtual nsresult SetFullscreenInternal(
    FullscreenReason aReason, bool aIsFullscreen) = 0;
  virtual void FinishFullscreenChange(bool aIsFullscreen) = 0;

  virtual JSObject* GetCachedXBLPrototypeHandler(nsXBLPrototypeHandler* aKey) = 0;
  virtual void CacheXBLPrototypeHandler(nsXBLPrototypeHandler* aKey,
                                        JS::Handle<JSObject*> aHandler) = 0;
  nsIContent* GetFocusedNode() const;
  virtual void SetFocusedNode(nsIContent* aNode,
                              uint32_t aFocusMethod = 0,
                              bool aNeedsFocus = false) = 0;




  virtual uint32_t GetFocusMethod() = 0;
  virtual bool TakeFocus(bool aFocus, uint32_t aFocusMethod) = 0;





  virtual void SetReadyForFocus() = 0;




  virtual bool ShouldShowFocusRing() = 0;




  virtual void SetKeyboardIndicators(UIStateChangeType aShowAccelerators,
                                     UIStateChangeType aShowFocusRings) = 0;





  virtual void PageHidden() = 0;





  virtual nsresult DispatchAsyncHashchange(nsIURI *aOldURI,
                                           nsIURI *aNewURI) = 0;




  virtual nsresult DispatchSyncPopState() = 0;







  virtual void EnableDeviceSensor(uint32_t aType) = 0;







  virtual void DisableDeviceSensor(uint32_t aType) = 0;






  virtual void EnableTimeChangeNotifications() = 0;
  virtual void DisableTimeChangeNotifications() = 0;
  virtual void SetHasGamepadEventListener(bool aHasGamepad = true) = 0;
  virtual nsresult SetArguments(nsIArray *aArguments) = 0;






  virtual uint32_t GetSerial() = 0;




  uint64_t WindowID() const { return mWindowID; }







  virtual bool DispatchCustomEvent(const nsAString& aEventName) = 0;






  virtual nsresult
  OpenNoNavigate(const nsAString& aUrl, const nsAString& aName,
                 const nsAString& aOptions, nsPIDOMWindowOuter **_retval) = 0;




  virtual void
  FirePopupBlockedEvent(nsIDocument* aDoc,
                        nsIURI* aPopupURI,
                        const nsAString& aPopupWindowName,
                        const nsAString& aPopupWindowFeatures) = 0;


  void MarkUncollectableForCCGeneration(uint32_t aGeneration)
  {
    mMarkedCCGeneration = aGeneration;
  }

  uint32_t GetMarkedCCGeneration()
  {
    return mMarkedCCGeneration;
  }

  virtual nsIDOMScreen* GetScreen() = 0;
  virtual nsIDOMNavigator* GetNavigator() = 0;
  virtual nsIDOMLocation* GetLocation() = 0;
  virtual nsresult GetPrompter(nsIPrompt** aPrompt) = 0;
  virtual nsresult GetControllers(nsIControllers** aControllers) = 0;
  virtual already_AddRefed<nsISelection> GetSelection() = 0;
  virtual already_AddRefed<nsPIDOMWindowOuter> GetOpener() = 0;
  virtual already_AddRefed<nsIDOMWindowCollection> GetFrames() = 0;



  virtual nsresult Open(const nsAString& aUrl, const nsAString& aName,
                        const nsAString& aOptions,
                        nsIDocShellLoadInfo* aLoadInfo,
                        bool aForceNoOpener,
                        nsPIDOMWindowOuter **_retval) = 0;
  virtual nsresult OpenDialog(const nsAString& aUrl, const nsAString& aName,
                              const nsAString& aOptions,
                              nsISupports* aExtraArgument,
                              nsPIDOMWindowOuter** _retval) = 0;

  virtual nsresult GetInnerWidth(int32_t* aWidth) = 0;
  virtual nsresult GetInnerHeight(int32_t* aHeight) = 0;
  virtual already_AddRefed<nsICSSDeclaration>
    GetComputedStyle(mozilla::dom::Element& aElt, const nsAString& aPseudoElt,
                     mozilla::ErrorResult& aError) = 0;
  virtual already_AddRefed<nsIDOMElement> GetFrameElement() = 0;
  virtual already_AddRefed<nsIDOMOfflineResourceList> GetApplicationCache() = 0;
  virtual bool Closed() = 0;
  virtual bool GetFullScreen() = 0;
  virtual nsresult SetFullScreen(bool aFullScreen) = 0;

  virtual nsresult Focus() = 0;
  virtual nsresult Close() = 0;

  virtual nsresult MoveBy(int32_t aXDif, int32_t aYDif) = 0;
  virtual nsresult UpdateCommands(const nsAString& anAction, nsISelection* aSel, int16_t aReason) = 0;

  mozilla::dom::TabGroup* TabGroup();

  mozilla::dom::DocGroup* GetDocGroup() const;

  virtual nsIEventTarget*
  EventTargetFor(mozilla::TaskCategory aCategory) const = 0;

protected:




  explicit nsPIDOMWindow<T>(nsPIDOMWindowOuter *aOuterWindow);

  ~nsPIDOMWindow<T>();

  void SetChromeEventHandlerInternal(mozilla::dom::EventTarget* aChromeEventHandler) {
    mChromeEventHandler = aChromeEventHandler;

    mParentTarget = nullptr;
  }

  virtual void UpdateParentTarget() = 0;




  nsCOMPtr<mozilla::dom::EventTarget> mChromeEventHandler;
  nsCOMPtr<nsIDocument> mDoc;

  nsCOMPtr<nsIURI> mDocumentURI;
  nsCOMPtr<nsIURI> mDocBaseURI;

  nsCOMPtr<mozilla::dom::EventTarget> mParentTarget;


  nsCOMPtr<mozilla::dom::Element> mFrameElement;



  nsIDocShell* mDocShell;


  RefPtr<mozilla::dom::Performance> mPerformance;

  mozilla::UniquePtr<mozilla::dom::TimeoutManager> mTimeoutManager;

  typedef nsRefPtrHashtable<nsStringHashKey,
                            mozilla::dom::ServiceWorkerRegistration>
          ServiceWorkerRegistrationTable;
  ServiceWorkerRegistrationTable mServiceWorkerRegistrationTable;

  uint32_t mModalStateDepth;


  uint32_t mMutationBits;

  bool mIsDocumentLoaded;
  bool mIsHandlingResizeEvent;
  bool mIsInnerWindow;
  bool mMayHavePaintEventListener;
  bool mMayHaveTouchEventListener;
  bool mMayHaveMouseEnterLeaveEventListener;
  bool mMayHavePointerEnterLeaveEventListener;




  bool mInnerObjectsFreed;




  bool mIsModalContentWindow;



  bool mIsActive;




  bool mIsBackground;
  SuspendTypes mMediaSuspend;

  bool mAudioMuted;
  float mAudioVolume;

  bool mAudioCaptured;


  bool mDesktopModeViewport;

  bool mIsRootOuterWindow;


  nsPIDOMWindowInner* mInnerWindow;
  nsCOMPtr<nsPIDOMWindowOuter> mOuterWindow;



  nsCOMPtr<nsIContent> mFocusedNode;


  nsTArray<mozilla::dom::AudioContext*> mAudioContexts;


  RefPtr<mozilla::dom::TabGroup> mTabGroup;



  uint64_t mWindowID;



  bool mHasNotifiedGlobalCreated;

  uint32_t mMarkedCCGeneration;



  bool mServiceWorkersTestingEnabled;

  mozilla::dom::LargeAllocStatus mLargeAllocStatus;



  bool mShouldResumeOnFirstActiveMediaComponent;
};
class nsPIDOMWindowInner : public nsPIDOMWindow<mozIDOMWindow>
{
  friend nsGlobalWindow;

public:
  template<typename T, typename U> struct COMTypeInfo;

  static nsPIDOMWindowInner* From(mozIDOMWindow* aFrom) {
    return static_cast<nsPIDOMWindowInner*>(aFrom);
  }



  inline bool IsCurrentInnerWindow() const;




  inline bool HasActiveDocument();

  bool AddAudioContext(mozilla::dom::AudioContext* aAudioContext);
  void RemoveAudioContext(mozilla::dom::AudioContext* aAudioContext);
  void MuteAudioContexts();
  void UnmuteAudioContexts();

  bool GetAudioCaptured() const;
  nsresult SetAudioCapture(bool aCapture);

  already_AddRefed<mozilla::dom::ServiceWorkerRegistration>
    GetServiceWorkerRegistration(const nsAString& aScope);
  void InvalidateServiceWorkerRegistration(const nsAString& aScope);

  mozilla::dom::Performance* GetPerformance();

  bool HasMutationListeners(uint32_t aMutationEventType) const
  {
    if (!mOuterWindow) {
      do { } while(0);

      return false;
    }

    return (mMutationBits & aMutationEventType) != 0;
  }

  void SetMutationListeners(uint32_t aType)
  {
    if (!mOuterWindow) {
      do { } while(0);

      return;
    }

    mMutationBits |= aType;
  }





  bool HasMouseEnterLeaveEventListeners()
  {
    return mMayHaveMouseEnterLeaveEventListener;
  }





  void SetHasMouseEnterLeaveEventListeners()
  {
    mMayHaveMouseEnterLeaveEventListener = true;
  }





  bool HasPointerEnterLeaveEventListeners()
  {
    return mMayHavePointerEnterLeaveEventListener;
  }





  void SetHasPointerEnterLeaveEventListeners()
  {
    mMayHavePointerEnterLeaveEventListener = true;
  }




  bool InnerObjectsFreed() const
  {
    return mInnerObjectsFreed;
  }




  bool IsSecureContext() const;
  bool IsSecureContextIfOpenerIgnored() const;
  void Suspend();
  void Resume();
  void Freeze();
  void Thaw();



  void SyncStateFromParentWindow();

  bool IsPlayingAudio();

  mozilla::dom::TimeoutManager& TimeoutManager();

  bool IsRunningTimeout();

protected:
  void CreatePerformanceObjectIfNeeded();
};

template<typename T> struct nsPIDOMWindowInner::COMTypeInfo<nsPIDOMWindowInner, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsPIDOMWindowInner::COMTypeInfo<nsPIDOMWindowInner, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x775dabc9, 0x8f43, 0x4277, { 0x9a, 0xdb, 0xf1, 0x99, 0x0d, 0x77, 0xcf, 0xfb } };



class nsPIDOMWindowOuter : public nsPIDOMWindow<mozIDOMWindowProxy>
{
protected:
  void RefreshMediaElementsVolume();
  void RefreshMediaElementsSuspend(SuspendTypes aSuspend);
  bool IsDisposableSuspend(SuspendTypes aSuspend) const;
  void MaybeNotifyMediaResumedFromBlock(SuspendTypes aSuspend);

public:
  template<typename T, typename U> struct COMTypeInfo;

  static nsPIDOMWindowOuter* From(mozIDOMWindowProxy* aFrom) {
    return static_cast<nsPIDOMWindowOuter*>(aFrom);
  }



  static nsPIDOMWindowOuter* GetFromCurrentInner(nsPIDOMWindowInner* aInner);

  nsPIDOMWindowInner* GetCurrentInnerWindow() const
  {
    return mInnerWindow;
  }

  nsPIDOMWindowInner* EnsureInnerWindow()
  {
    do { } while (0);

    GetDoc();
    return GetCurrentInnerWindow();
  }




  void SetInitialKeyboardIndicators(UIStateChangeType aShowAccelerators,
                                    UIStateChangeType aShowFocusRings);




  mozilla::dom::Element* GetFrameElementInternal() const;
  void SetFrameElementInternal(mozilla::dom::Element* aFrameElement);

  bool IsActive()
  {
    return mIsActive;
  }

  void SetDesktopModeViewport(bool aDesktopModeViewport)
  {
    mDesktopModeViewport = aDesktopModeViewport;
  }
  bool IsDesktopModeViewport() const
  {
    return mDesktopModeViewport;
  }
  bool IsBackground()
  {
    return mIsBackground;
  }


  SuspendTypes GetMediaSuspend() const;
  void SetMediaSuspend(SuspendTypes aSuspend);

  bool GetAudioMuted() const;
  void SetAudioMuted(bool aMuted);

  float GetAudioVolume() const;
  nsresult SetAudioVolume(float aVolume);

  void NotifyCreatedNewMediaComponent();
  void MaybeActiveMediaComponents();

  void SetServiceWorkersTestingEnabled(bool aEnabled);
  bool GetServiceWorkersTestingEnabled();

  float GetDevicePixelRatio(mozilla::dom::CallerType aCallerType);

  void SetLargeAllocStatus(mozilla::dom::LargeAllocStatus aStatus);

  bool IsTopLevelWindow();
  bool HadOriginalOpener() const;
};

template<typename T> struct nsPIDOMWindowOuter::COMTypeInfo<nsPIDOMWindowOuter, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsPIDOMWindowOuter::COMTypeInfo<nsPIDOMWindowOuter, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x769693d4, 0xb009, 0x4fe2, { 0xaf, 0x18, 0x7d, 0xc8, 0xdf, 0x74, 0x96, 0xdf } };






template<class T>
nsPIDOMWindowInner*
nsPIDOMWindow<T>::AsInner()
{
  do { } while (0);
  return reinterpret_cast<nsPIDOMWindowInner*>(this);
}

template<class T>
const nsPIDOMWindowInner*
nsPIDOMWindow<T>::AsInner() const
{
  do { } while (0);
  return reinterpret_cast<const nsPIDOMWindowInner*>(this);
}

template<class T>
nsPIDOMWindowOuter*
nsPIDOMWindow<T>::AsOuter()
{
  do { } while (0);
  return reinterpret_cast<nsPIDOMWindowOuter*>(this);
}

template<class T>
const nsPIDOMWindowOuter*
nsPIDOMWindow<T>::AsOuter() const
{
  do { } while (0);
  return reinterpret_cast<const nsPIDOMWindowOuter*>(this);
}

template <class T>
bool
nsPIDOMWindow<T>::IsLoading() const
{
  if (IsOuterWindow()) {
    auto* win = AsOuter()->GetCurrentInnerWindow();

    if (!win) {
      do { } while(0);

      return false;
    }

    return win->IsLoading();
  }

  if (!mOuterWindow) {
    do { } while(0);

    return false;
  }

  return !mIsDocumentLoaded;
}

template <class T>
bool
nsPIDOMWindow<T>::IsHandlingResizeEvent() const
{
  if (IsOuterWindow()) {
    auto* win = AsOuter()->GetCurrentInnerWindow();

    if (!win) {
      do { } while(0);

      return false;
    }

    return win->IsHandlingResizeEvent();
  }

  if (!mOuterWindow) {
    do { } while(0);

    return false;
  }

  return mIsHandlingResizeEvent;
}

bool
nsPIDOMWindowInner::IsCurrentInnerWindow() const
{
  return mOuterWindow && mOuterWindow->GetCurrentInnerWindow() == AsInner();
}

bool
nsPIDOMWindowInner::HasActiveDocument()
{
  return IsCurrentInnerWindow() ||
    (mOuterWindow &&
     mOuterWindow->GetCurrentInnerWindow() &&
     mOuterWindow->GetCurrentInnerWindow()->GetDoc() == mDoc);
}

template <class T>
nsIDocShell*
nsPIDOMWindow<T>::GetDocShell() const
{
  if (mOuterWindow) {
    return mOuterWindow->GetDocShell();
  }

  return mDocShell;
}

template <class T>
nsIContent*
nsPIDOMWindow<T>::GetFocusedNode() const
{
  if (IsOuterWindow()) {
    return mInnerWindow ? mInnerWindow->GetFocusedNode() : nullptr;
  }

  return mFocusedNode;
}


PopupControlState
PushPopupControlState(PopupControlState aState, bool aForce);

void
PopPopupControlState(PopupControlState aState);
class nsAutoPopupStatePusherInternal
{
public:

  explicit nsAutoPopupStatePusherInternal(PopupControlState aState, bool aForce = false)
    : mOldState(::PushPopupControlState(aState, aForce))
  {
  }

  ~nsAutoPopupStatePusherInternal()
  {
    PopPopupControlState(mOldState);
  }
protected:



  PopupControlState mOldState;

private:

  static void* operator new(size_t ) throw() { return nullptr; }
  static void operator delete(void* ) {}
};







class nsIObserver;
class nsIPrefBranch : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    PREF_INVALID = 0,
    PREF_STRING = 32,
    PREF_INT = 64,
    PREF_BOOL = 128
  };


  virtual nsresult GetRoot(char * *aRoot) = 0;


  virtual nsresult GetPrefType(const char * aPrefName, int32_t *_retval) = 0;


  virtual nsresult GetBoolPrefWithDefault(const char * aPrefName, bool aDefaultValue, uint8_t _argc, bool *_retval) = 0;


  virtual nsresult GetBoolPref(const char * aPrefName, bool *_retval) = 0;


  virtual nsresult SetBoolPref(const char * aPrefName, bool aValue) = 0;


  virtual nsresult GetFloatPrefWithDefault(const char * aPrefName, float aDefaultValue, uint8_t _argc, float *_retval) = 0;


  virtual nsresult GetFloatPref(const char * aPrefName, float *_retval) = 0;


  virtual nsresult GetCharPrefWithDefault(const char * aPrefName, const char * aDefaultValue, uint8_t _argc, char * *_retval) = 0;


  virtual nsresult GetCharPref(const char * aPrefName, char * *_retval) = 0;


  virtual nsresult SetCharPref(const char * aPrefName, const char * aValue) = 0;


  virtual nsresult GetStringPref(const char * aPrefName, const nsACString & aDefaultValue, uint8_t _argc, nsACString & _retval) = 0;


  virtual nsresult SetStringPref(const char * aPrefName, const nsACString & aValue) = 0;


  virtual nsresult GetIntPrefWithDefault(const char * aPrefName, int32_t aDefaultValue, uint8_t _argc, int32_t *_retval) = 0;


  virtual nsresult GetIntPref(const char * aPrefName, int32_t *_retval) = 0;


  virtual nsresult SetIntPref(const char * aPrefName, int32_t aValue) = 0;


  virtual nsresult GetComplexValue(const char * aPrefName, const nsIID & aType, void **aValue) = 0;


  virtual nsresult SetComplexValue(const char * aPrefName, const nsIID & aType, nsISupports *aValue) = 0;


  virtual nsresult ClearUserPref(const char * aPrefName) = 0;


  virtual nsresult LockPref(const char * aPrefName) = 0;


  virtual nsresult PrefHasUserValue(const char * aPrefName, bool *_retval) = 0;


  virtual nsresult PrefIsLocked(const char * aPrefName, bool *_retval) = 0;


  virtual nsresult UnlockPref(const char * aPrefName) = 0;


  virtual nsresult DeleteBranch(const char * aStartingAt) = 0;


  virtual nsresult GetChildList(const char * aStartingAt, uint32_t *aCount, char * **aChildArray) = 0;


  virtual nsresult ResetBranch(const char * aStartingAt) = 0;


  virtual nsresult AddObserver(const char * aDomain, nsIObserver *aObserver, bool aHoldWeak) = 0;


  virtual nsresult RemoveObserver(const char * aDomain, nsIObserver *aObserver) = 0;

};

  template<typename T> struct nsIPrefBranch::COMTypeInfo<nsIPrefBranch, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIPrefBranch::COMTypeInfo<nsIPrefBranch, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x55d25e49, 0x793f, 0x4727, { 0xa6, 0x9f, 0xde, 0x8b, 0x15, 0xf4, 0xb9, 0x85 }};






struct PrefTuple;

class nsIFile;
class nsIPrefService : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult ReadUserPrefs(nsIFile *aFile) = 0;


  virtual nsresult ResetPrefs(void) = 0;


  virtual nsresult ResetUserPrefs(void) = 0;


  virtual nsresult SavePrefFile(nsIFile *aFile) = 0;


  virtual nsresult GetBranch(const char * aPrefRoot, nsIPrefBranch * *_retval) = 0;


  virtual nsresult GetDefaultBranch(const char * aPrefRoot, nsIPrefBranch * *_retval) = 0;


  virtual nsresult GetDirty(bool *aDirty) = 0;

};

  template<typename T> struct nsIPrefService::COMTypeInfo<nsIPrefService, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIPrefService::COMTypeInfo<nsIPrefService, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x1f84fd56, 0x3956, 0x40df, { 0xb8, 0x6a, 0x1e, 0xa0, 0x14, 0x02, 0xee, 0x96 }};

class nsIPrefBranch2 : public nsIPrefBranch {
 public:

  template<typename T, typename U> struct COMTypeInfo;

};

  template<typename T> struct nsIPrefBranch2::COMTypeInfo<nsIPrefBranch2, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIPrefBranch2::COMTypeInfo<nsIPrefBranch2, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x8892016d, 0x07f7, 0x4530, { 0xb5, 0xc1, 0xd7, 0x3d, 0xfc, 0xde, 0x4a, 0x1c }};
class nsIPrefBranchInternal : public nsIPrefBranch2 {
 public:

  template<typename T, typename U> struct COMTypeInfo;

};

  template<typename T> struct nsIPrefBranchInternal::COMTypeInfo<nsIPrefBranchInternal, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIPrefBranchInternal::COMTypeInfo<nsIPrefBranchInternal, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x355bd1e9, 0x248a, 0x438b, { 0x80, 0x9d, 0xe0, 0xdb, 0x1b, 0x28, 0x78, 0x82 }};







class nsIFile;
class nsAdoptingString;
class nsAdoptingCString;


typedef void (*PrefChangedFunc)(const char *, void *);
namespace mozilla {

namespace dom {
class PrefSetting;
}

class Preferences final : public nsIPrefService,
                          public nsIObserver,
                          public nsIPrefBranchInternal,
                          public nsSupportsWeakReference
{
public:
  typedef mozilla::dom::PrefSetting PrefSetting;

  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:
  virtual nsresult ReadUserPrefs(nsIFile *aFile) override; virtual nsresult ResetPrefs(void) override; virtual nsresult ResetUserPrefs(void) override; virtual nsresult SavePrefFile(nsIFile *aFile) override; virtual nsresult GetBranch(const char * aPrefRoot, nsIPrefBranch * *_retval) override; virtual nsresult GetDefaultBranch(const char * aPrefRoot, nsIPrefBranch * *_retval) override; virtual nsresult GetDirty(bool *aDirty) override;
  virtual nsresult GetRoot(char * *aRoot) override { return sRootBranch-> GetRoot(aRoot); } virtual nsresult GetPrefType(const char * aPrefName, int32_t *_retval) override { return sRootBranch-> GetPrefType(aPrefName, _retval); } virtual nsresult GetBoolPrefWithDefault(const char * aPrefName, bool aDefaultValue, uint8_t _argc, bool *_retval) override { return sRootBranch-> GetBoolPrefWithDefault(aPrefName, aDefaultValue, _argc, _retval); } virtual nsresult GetBoolPref(const char * aPrefName, bool *_retval) override { return sRootBranch-> GetBoolPref(aPrefName, _retval); } virtual nsresult SetBoolPref(const char * aPrefName, bool aValue) override { return sRootBranch-> SetBoolPref(aPrefName, aValue); } virtual nsresult GetFloatPrefWithDefault(const char * aPrefName, float aDefaultValue, uint8_t _argc, float *_retval) override { return sRootBranch-> GetFloatPrefWithDefault(aPrefName, aDefaultValue, _argc, _retval); } virtual nsresult GetFloatPref(const char * aPrefName, float *_retval) override { return sRootBranch-> GetFloatPref(aPrefName, _retval); } virtual nsresult GetCharPrefWithDefault(const char * aPrefName, const char * aDefaultValue, uint8_t _argc, char * *_retval) override { return sRootBranch-> GetCharPrefWithDefault(aPrefName, aDefaultValue, _argc, _retval); } virtual nsresult GetCharPref(const char * aPrefName, char * *_retval) override { return sRootBranch-> GetCharPref(aPrefName, _retval); } virtual nsresult SetCharPref(const char * aPrefName, const char * aValue) override { return sRootBranch-> SetCharPref(aPrefName, aValue); } virtual nsresult GetStringPref(const char * aPrefName, const nsACString & aDefaultValue, uint8_t _argc, nsACString & _retval) override { return sRootBranch-> GetStringPref(aPrefName, aDefaultValue, _argc, _retval); } virtual nsresult SetStringPref(const char * aPrefName, const nsACString & aValue) override { return sRootBranch-> SetStringPref(aPrefName, aValue); } virtual nsresult GetIntPrefWithDefault(const char * aPrefName, int32_t aDefaultValue, uint8_t _argc, int32_t *_retval) override { return sRootBranch-> GetIntPrefWithDefault(aPrefName, aDefaultValue, _argc, _retval); } virtual nsresult GetIntPref(const char * aPrefName, int32_t *_retval) override { return sRootBranch-> GetIntPref(aPrefName, _retval); } virtual nsresult SetIntPref(const char * aPrefName, int32_t aValue) override { return sRootBranch-> SetIntPref(aPrefName, aValue); } virtual nsresult GetComplexValue(const char * aPrefName, const nsIID & aType, void **aValue) override { return sRootBranch-> GetComplexValue(aPrefName, aType, aValue); } virtual nsresult SetComplexValue(const char * aPrefName, const nsIID & aType, nsISupports *aValue) override { return sRootBranch-> SetComplexValue(aPrefName, aType, aValue); } virtual nsresult ClearUserPref(const char * aPrefName) override { return sRootBranch-> ClearUserPref(aPrefName); } virtual nsresult LockPref(const char * aPrefName) override { return sRootBranch-> LockPref(aPrefName); } virtual nsresult PrefHasUserValue(const char * aPrefName, bool *_retval) override { return sRootBranch-> PrefHasUserValue(aPrefName, _retval); } virtual nsresult PrefIsLocked(const char * aPrefName, bool *_retval) override { return sRootBranch-> PrefIsLocked(aPrefName, _retval); } virtual nsresult UnlockPref(const char * aPrefName) override { return sRootBranch-> UnlockPref(aPrefName); } virtual nsresult DeleteBranch(const char * aStartingAt) override { return sRootBranch-> DeleteBranch(aStartingAt); } virtual nsresult GetChildList(const char * aStartingAt, uint32_t *aCount, char * **aChildArray) override { return sRootBranch-> GetChildList(aStartingAt, aCount, aChildArray); } virtual nsresult ResetBranch(const char * aStartingAt) override { return sRootBranch-> ResetBranch(aStartingAt); } virtual nsresult AddObserver(const char * aDomain, nsIObserver *aObserver, bool aHoldWeak) override { return sRootBranch-> AddObserver(aDomain, aObserver, aHoldWeak); } virtual nsresult RemoveObserver(const char * aDomain, nsIObserver *aObserver) override { return sRootBranch-> RemoveObserver(aDomain, aObserver); }
  virtual nsresult Observe(nsISupports *aSubject, const char * aTopic, const char16_t * aData) override;

  Preferences();

  nsresult Init();




  static bool IsServiceAvailable();




  static nsresult ResetAndReadUserPrefs();




  static Preferences* GetInstanceForService();




  static void Shutdown();





  static nsIPrefService* GetService()
  {
    do { if ((__builtin_expect(!!(!(InitStaticMembers())), 0))) { do { } while(0); return nullptr; } } while(0);
    return sPreferences;
  }





  static nsIPrefBranch* GetRootBranch()
  {
    do { if ((__builtin_expect(!!(!(InitStaticMembers())), 0))) { do { } while(0); return nullptr; } } while(0);
    return sRootBranch;
  }





  static nsIPrefBranch* GetDefaultRootBranch()
  {
    do { if ((__builtin_expect(!!(!(InitStaticMembers())), 0))) { do { } while(0); return nullptr; } } while(0);
    return sDefaultRootBranch;
  }





  static bool GetBool(const char* aPref, bool aDefault = false)
  {
    bool result = aDefault;
    GetBool(aPref, &result);
    return result;
  }

  static int32_t GetInt(const char* aPref, int32_t aDefault = 0)
  {
    int32_t result = aDefault;
    GetInt(aPref, &result);
    return result;
  }

  static uint32_t GetUint(const char* aPref, uint32_t aDefault = 0)
  {
    uint32_t result = aDefault;
    GetUint(aPref, &result);
    return result;
  }

  static float GetFloat(const char* aPref, float aDefault = 0)
  {
    float result = aDefault;
    GetFloat(aPref, &result);
    return result;
  }
  static nsAdoptingCString GetCString(const char* aPref);
  static nsAdoptingString GetString(const char* aPref);
  static nsAdoptingCString GetLocalizedCString(const char* aPref);
  static nsAdoptingString GetLocalizedString(const char* aPref);
  static nsresult GetBool(const char* aPref, bool* aResult);
  static nsresult GetInt(const char* aPref, int32_t* aResult);
  static nsresult GetFloat(const char* aPref, float* aResult);
  static nsresult GetUint(const char* aPref, uint32_t* aResult)
  {
    int32_t result;
    nsresult rv = GetInt(aPref, &result);
    if (((bool)(__builtin_expect(!!(!NS_FAILED_impl(rv)), 1)))) {
      *aResult = static_cast<uint32_t>(result);
    }
    return rv;
  }
  static nsresult GetCString(const char* aPref, nsACString* aResult);
  static nsresult GetString(const char* aPref, nsAString* aResult);
  static nsresult GetLocalizedCString(const char* aPref, nsACString* aResult);
  static nsresult GetLocalizedString(const char* aPref, nsAString* aResult);

  static nsresult GetComplex(const char* aPref, const nsIID &aType,
                             void** aResult);




  static nsresult SetBool(const char* aPref, bool aValue);
  static nsresult SetInt(const char* aPref, int32_t aValue);
  static nsresult SetUint(const char* aPref, uint32_t aValue)
  {
    return SetInt(aPref, static_cast<int32_t>(aValue));
  }
  static nsresult SetFloat(const char* aPref, float aValue);
  static nsresult SetCString(const char* aPref, const char* aValue);
  static nsresult SetCString(const char* aPref, const nsACString &aValue);
  static nsresult SetString(const char* aPref, const char16ptr_t aValue);
  static nsresult SetString(const char* aPref, const nsAString &aValue);

  static nsresult SetComplex(const char* aPref, const nsIID &aType,
                             nsISupports* aValue);




  static nsresult ClearUser(const char* aPref);




  static bool HasUserValue(const char* aPref);




  static int32_t GetType(const char* aPref);







  static nsresult AddStrongObserver(nsIObserver* aObserver, const char* aPref);
  static nsresult AddWeakObserver(nsIObserver* aObserver, const char* aPref);
  static nsresult RemoveObserver(nsIObserver* aObserver, const char* aPref);





  static nsresult AddStrongObservers(nsIObserver* aObserver,
                                     const char** aPrefs);
  static nsresult AddWeakObservers(nsIObserver* aObserver,
                                   const char** aPrefs);
  static nsresult RemoveObservers(nsIObserver* aObserver,
                                  const char** aPrefs);




  static nsresult RegisterCallback(PrefChangedFunc aCallback,
                                   const char* aPref,
                                   void* aClosure = nullptr)
  {
    return RegisterCallback(aCallback, aPref, aClosure, ExactMatch);
  }
  static nsresult UnregisterCallback(PrefChangedFunc aCallback,
                                     const char* aPref,
                                     void* aClosure = nullptr)
  {
    return UnregisterCallback(aCallback, aPref, aClosure, ExactMatch);
  }


  static nsresult RegisterCallbackAndCall(PrefChangedFunc aCallback,
                                          const char* aPref,
                                          void* aClosure = nullptr)
  {
    return RegisterCallbackAndCall(aCallback, aPref, aClosure, ExactMatch);
  }





  static nsresult RegisterPrefixCallback(PrefChangedFunc aCallback,
                                         const char* aPref,
                                         void* aClosure = nullptr)
  {
    return RegisterCallback(aCallback, aPref, aClosure, PrefixMatch);
  }





  static nsresult RegisterPrefixCallbackAndCall(PrefChangedFunc aCallback,
                                                const char* aPref,
                                                void* aClosure = nullptr)
  {
    return RegisterCallbackAndCall(aCallback, aPref, aClosure, PrefixMatch);
  }





  static nsresult UnregisterPrefixCallback(PrefChangedFunc aCallback,
                                           const char* aPref,
                                           void* aClosure = nullptr)
  {
    return UnregisterCallback(aCallback, aPref, aClosure, PrefixMatch);
  }







  static nsresult AddBoolVarCache(bool* aVariable,
                                  const char* aPref,
                                  bool aDefault = false);
  static nsresult AddIntVarCache(int32_t* aVariable,
                                 const char* aPref,
                                 int32_t aDefault = 0);
  static nsresult AddUintVarCache(uint32_t* aVariable,
                                  const char* aPref,
                                  uint32_t aDefault = 0);
  template <MemoryOrdering Order>
  static nsresult AddAtomicUintVarCache(Atomic<uint32_t, Order>* aVariable,
                                        const char* aPref,
                                        uint32_t aDefault = 0);
  static nsresult AddFloatVarCache(float* aVariable,
                                   const char* aPref,
                                   float aDefault = 0.0f);







  static nsresult GetDefaultBool(const char* aPref, bool* aResult);
  static nsresult GetDefaultInt(const char* aPref, int32_t* aResult);
  static nsresult GetDefaultUint(const char* aPref, uint32_t* aResult)
  {
    return GetDefaultInt(aPref, reinterpret_cast<int32_t*>(aResult));
  }







  static bool GetDefaultBool(const char* aPref, bool aFailedResult)
  {
    bool result;
    return ((bool)(__builtin_expect(!!(!NS_FAILED_impl(GetDefaultBool(aPref, &result))), 1))) ? result :
                                                          aFailedResult;
  }
  static int32_t GetDefaultInt(const char* aPref, int32_t aFailedResult)
  {
    int32_t result;
    return ((bool)(__builtin_expect(!!(!NS_FAILED_impl(GetDefaultInt(aPref, &result))), 1))) ? result : aFailedResult;
  }
  static uint32_t GetDefaultUint(const char* aPref, uint32_t aFailedResult)
  {
   return static_cast<uint32_t>(
     GetDefaultInt(aPref, static_cast<int32_t>(aFailedResult)));
  }
  static nsAdoptingString GetDefaultString(const char* aPref);
  static nsAdoptingCString GetDefaultCString(const char* aPref);
  static nsAdoptingString GetDefaultLocalizedString(const char* aPref);
  static nsAdoptingCString GetDefaultLocalizedCString(const char* aPref);

  static nsresult GetDefaultCString(const char* aPref, nsACString* aResult);
  static nsresult GetDefaultString(const char* aPref, nsAString* aResult);
  static nsresult GetDefaultLocalizedCString(const char* aPref,
                                             nsACString* aResult);
  static nsresult GetDefaultLocalizedString(const char* aPref,
                                            nsAString* aResult);

  static nsresult GetDefaultComplex(const char* aPref, const nsIID &aType,
                                    void** aResult);




  static int32_t GetDefaultType(const char* aPref);


  static void GetPreferences(InfallibleTArray<PrefSetting>* aPrefs);
  static void GetPreference(PrefSetting* aPref);
  static void SetPreference(const PrefSetting& aPref);

  static void SetInitPreferences(nsTArray<PrefSetting>* aPrefs);






  static int64_t SizeOfIncludingThisAndOtherStuff(mozilla::MallocSizeOf aMallocSizeOf);

  static void DirtyCallback();

protected:
  virtual ~Preferences();

  nsresult NotifyServiceObservers(const char *aSubject);






  nsresult UseDefaultPrefFile();
  nsresult UseUserPrefFile();
  nsresult ReadAndOwnUserPrefFile(nsIFile *aFile);
  nsresult ReadAndOwnSharedUserPrefFile(nsIFile *aFile);
  nsresult SavePrefFileInternal(nsIFile* aFile);
  nsresult WritePrefFile(nsIFile* aFile);
  nsresult MakeBackupPrefFile(nsIFile *aFile);





public:

  enum MatchKind {
    PrefixMatch,
    ExactMatch,
  };

protected:
  static nsresult RegisterCallback(PrefChangedFunc aCallback,
                                   const char* aPref,
                                   void* aClosure,
                                   MatchKind aMatchKind);
  static nsresult UnregisterCallback(PrefChangedFunc aCallback,
                                     const char* aPref,
                                     void* aClosure,
                                     MatchKind aMatchKind);
  static nsresult RegisterCallbackAndCall(PrefChangedFunc aCallback,
                                          const char* aPref,
                                          void* aClosure,
                                          MatchKind aMatchKind);

private:
  nsCOMPtr<nsIFile> mCurrentFile;
  bool mDirty;

  static Preferences* sPreferences;
  static nsIPrefBranch* sRootBranch;
  static nsIPrefBranch* sDefaultRootBranch;
  static bool sShutdown;




  static bool InitStaticMembers();
};

}

class nsGlobalWindow;
class nsIPrincipal;
class nsScriptNameSpaceManager;
class nsIMemoryReporterCallback;

namespace mozilla {
namespace dom {
class Exception;
}
}

typedef void (* xpcGCCallback)(JSGCStatus status);

namespace xpc {

class Scriptability {
public:
    explicit Scriptability(JSCompartment* c);
    bool Allowed();
    bool IsImmuneToScriptPolicy();

    void Block();
    void Unblock();
    void SetDocShellAllowsScript(bool aAllowed);

    static Scriptability& Get(JSObject* aScope);

private:




    uint32_t mScriptBlocks;



    bool mDocShellAllowsScript;



    bool mImmuneToScriptPolicy;



    bool mScriptBlockedByPolicy;
};

JSObject*
TransplantObject(JSContext* cx, JS::HandleObject origobj, JS::HandleObject target);

bool IsContentXBLScope(JSCompartment* compartment);
bool IsInContentXBLScope(JSObject* obj);
JSObject*
GetXBLScope(JSContext* cx, JSObject* contentScope);

inline JSObject*
GetXBLScopeOrGlobal(JSContext* cx, JSObject* obj)
{
    if (IsInContentXBLScope(obj))
        return js::GetGlobalForObjectCrossCompartment(obj);
    return GetXBLScope(cx, obj);
}





JSObject*
GetScopeForXBLExecution(JSContext* cx, JS::HandleObject obj, JSAddonId* addonId);



bool
AllowContentXBLScope(JSCompartment* c);





bool
UseContentXBLScope(JSCompartment* c);



void
ClearContentXBLScope(JSObject* global);

bool
IsInAddonScope(JSObject* obj);

JSObject*
GetAddonScope(JSContext* cx, JS::HandleObject contentScope, JSAddonId* addonId);

bool
IsSandboxPrototypeProxy(JSObject* obj);

bool
IsReflector(JSObject* obj);

bool
IsXrayWrapper(JSObject* obj);






JSObject*
XrayAwareCalleeGlobal(JSObject* fun);
bool
XrayAwareCalleeGlobalForSpecializedGetters(JSContext* cx,
                                           JS::Handle<JSObject*> thisObj,
                                           JS::MutableHandle<JSObject*> global);


void
TraceXPCGlobal(JSTracer* trc, JSObject* obj);

}

namespace JS {

struct RuntimeStats;

}
inline JSObject*
xpc_FastGetCachedWrapper(JSContext* cx, nsWrapperCache* cache, JS::MutableHandleValue vp)
{
    if (cache) {
        JSObject* wrapper = cache->GetWrapper();
        if (wrapper &&
            js::GetObjectCompartment(wrapper) == js::GetContextCompartment(cx))
        {
            vp.setObject(*wrapper);
            return wrapper;
        }
    }

    return nullptr;
}



extern void
xpc_MarkInCCGeneration(nsISupports* aVariant, uint32_t aGeneration);


extern void
xpc_TryUnmarkWrappedGrayObject(nsISupports* aWrappedJS);

extern void
xpc_UnmarkSkippableJSHolders();


class XPCStringConvert
{





    struct ZoneStringCache
    {
        void* mBuffer = nullptr;
        uint32_t mLength = 0;
        JSString* mString = nullptr;
    };

public:




    static bool ReadableToJSVal(JSContext* cx, const nsAString& readable,
                                nsStringBuffer** sharedBuffer,
                                JS::MutableHandleValue vp);


    static __attribute__((always_inline)) inline bool
    StringBufferToJSVal(JSContext* cx, nsStringBuffer* buf, uint32_t length,
                        JS::MutableHandleValue rval, bool* sharedBuffer)
    {
        JS::Zone* zone = js::GetContextZone(cx);
        ZoneStringCache* cache = static_cast<ZoneStringCache*>(JS_GetZoneUserData(zone));
        if (cache && buf == cache->mBuffer && length == cache->mLength) {
            do { } while (0);
            JS::StringReadBarrier(cache->mString);
            rval.setString(cache->mString);
            *sharedBuffer = false;
            return true;
        }

        bool isExternal;
        JSString* str = JS_NewMaybeExternalString(cx,
                                                  static_cast<char16_t*>(buf->Data()),
                                                  length, &sDOMStringFinalizer, &isExternal);
        if (!str) {
            return false;
        }
        rval.setString(str);



        if (!isExternal) {
            *sharedBuffer = false;
            return true;
        }

        if (!cache) {
            cache = new ZoneStringCache();
            JS_SetZoneUserData(zone, cache);
        }
        cache->mBuffer = buf;
        cache->mLength = length;
        cache->mString = str;
        *sharedBuffer = true;
        return true;
    }

    static void FreeZoneCache(JS::Zone* zone);
    static void ClearZoneCache(JS::Zone* zone);

    static __attribute__((always_inline)) inline bool IsLiteral(JSString* str)
    {
        return JS_IsExternalString(str) &&
               JS_GetExternalStringFinalizer(str) == &sLiteralFinalizer;
    }

    static __attribute__((always_inline)) inline bool IsDOMString(JSString* str)
    {
        return JS_IsExternalString(str) &&
               JS_GetExternalStringFinalizer(str) == &sDOMStringFinalizer;
    }

private:
    static const JSStringFinalizer sLiteralFinalizer, sDOMStringFinalizer;

    static void FinalizeLiteral(JS::Zone* zone, const JSStringFinalizer* fin, char16_t* chars);

    static void FinalizeDOMString(JS::Zone* zone, const JSStringFinalizer* fin, char16_t* chars);

    XPCStringConvert() = delete;
};

class nsIAddonInterposition;

namespace xpc {


bool Base64Encode(JSContext* cx, JS::HandleValue val, JS::MutableHandleValue out);
bool Base64Decode(JSContext* cx, JS::HandleValue val, JS::MutableHandleValue out);






bool NonVoidStringToJsval(JSContext* cx, nsAString& str, JS::MutableHandleValue rval);
inline bool StringToJsval(JSContext* cx, nsAString& str, JS::MutableHandleValue rval)
{

    if (str.IsVoid()) {
        rval.setNull();
        return true;
    }
    return NonVoidStringToJsval(cx, str, rval);
}

inline bool
NonVoidStringToJsval(JSContext* cx, const nsAString& str, JS::MutableHandleValue rval)
{
    nsString mutableCopy;
    if (!mutableCopy.Assign(str, mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
    }
    return NonVoidStringToJsval(cx, mutableCopy, rval);
}

inline bool
StringToJsval(JSContext* cx, const nsAString& str, JS::MutableHandleValue rval)
{
    nsString mutableCopy;
    if (!mutableCopy.Assign(str, mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
    }
    return StringToJsval(cx, mutableCopy, rval);
}




inline
bool NonVoidStringToJsval(JSContext* cx, mozilla::dom::DOMString& str,
                          JS::MutableHandleValue rval)
{
    if (!str.HasStringBuffer()) {

        return NonVoidStringToJsval(cx, str.AsAString(), rval);
    }

    uint32_t length = str.StringBufferLength();
    if (length == 0) {
        rval.set(JS_GetEmptyStringValue(cx));
        return true;
    }

    nsStringBuffer* buf = str.StringBuffer();
    bool shared;
    if (!XPCStringConvert::StringBufferToJSVal(cx, buf, length, rval,
                                               &shared)) {
        return false;
    }
    if (shared) {

        str.RelinquishBufferOwnership();
    }
    return true;
}

__attribute__((always_inline)) inline
bool StringToJsval(JSContext* cx, mozilla::dom::DOMString& str,
                   JS::MutableHandleValue rval)
{
    if (str.IsNull()) {
        rval.setNull();
        return true;
    }
    return NonVoidStringToJsval(cx, str, rval);
}

nsIPrincipal* GetCompartmentPrincipal(JSCompartment* compartment);

void NukeAllWrappersForCompartment(JSContext* cx, JSCompartment* compartment,
                                   js::NukeReferencesToWindow nukeReferencesToWindow = js::NukeWindowReferences);

void SetLocationForGlobal(JSObject* global, const nsACString& location);
void SetLocationForGlobal(JSObject* global, nsIURI* locationURI);

void SetDocGroupValidation(JSObject* global);



class ZoneStatsExtras {
public:
    ZoneStatsExtras() {}

    nsCString pathPrefix;

private:
    ZoneStatsExtras(const ZoneStatsExtras& other) = delete;
    ZoneStatsExtras& operator=(const ZoneStatsExtras& other) = delete;
};



class CompartmentStatsExtras {
public:
    CompartmentStatsExtras() {}

    nsCString jsPathPrefix;
    nsCString domPathPrefix;
    nsCOMPtr<nsIURI> location;

private:
    CompartmentStatsExtras(const CompartmentStatsExtras& other) = delete;
    CompartmentStatsExtras& operator=(const CompartmentStatsExtras& other) = delete;
};





void
ReportJSRuntimeExplicitTreeStats(const JS::RuntimeStats& rtStats,
                                 const nsACString& rtPath,
                                 nsIMemoryReporterCallback* handleReport,
                                 nsISupports* data,
                                 bool anonymize,
                                 size_t* rtTotal = nullptr);




bool
Throw(JSContext* cx, nsresult rv);





nsISupports*
UnwrapReflectorToISupports(JSObject* reflector);
JSObject*
UnprivilegedJunkScope();

JSObject*
PrivilegedJunkScope();






JSObject*
CompilationScope();




nsIGlobalObject*
NativeGlobal(JSObject* aObj);





nsGlobalWindow*
WindowOrNull(JSObject* aObj);





nsGlobalWindow*
WindowGlobalOrNull(JSObject* aObj);






nsGlobalWindow*
AddonWindowOrNull(JSObject* aObj);





nsGlobalWindow*
CurrentWindowOrNull(JSContext* cx);

void
SimulateActivityCallback(bool aActive);



bool
ShouldDiscardSystemSource();

bool
SharedMemoryEnabled();

bool
SetAddonInterposition(const nsACString& addonId, nsIAddonInterposition* interposition);

bool
AllowCPOWsInAddon(const nsACString& addonId, bool allow);

bool
ExtraWarningsForSystemJS();

class ErrorBase {
  public:
    nsString mErrorMsg;
    nsString mFileName;
    uint32_t mLineNumber;
    uint32_t mColumn;

    ErrorBase() : mLineNumber(0)
                , mColumn(0)
    {}

    void Init(JSErrorBase* aReport);

    void AppendErrorDetailsTo(nsCString& error);
};

class ErrorNote : public ErrorBase {
  public:
    void Init(JSErrorNotes::Note* aNote);




    static void ErrorNoteToMessageString(JSErrorNotes::Note* aNote,
                                         nsAString& aString);


    void LogToStderr();
};

class ErrorReport : public ErrorBase {
  public:
    public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<ErrorReport>::value, "Reference-counted class " "ErrorReport" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); nsrefcnt count = ++mRefCnt; ; return (nsrefcnt) count; } MozExternalRefCountType Release(void) { do { } while (0); nsrefcnt count = --mRefCnt; ; if (count == 0) { delete (this); return 0; } return count; } typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:;

    nsTArray<ErrorNote> mNotes;

    nsCString mCategory;
    nsString mSourceLine;
    nsString mErrorMsgName;
    uint64_t mWindowID;
    uint32_t mFlags;
    bool mIsMuted;

    ErrorReport() : mWindowID(0)
                  , mFlags(0)
                  , mIsMuted(false)
    {}

    void Init(JSErrorReport* aReport, const char* aToStringResult,
              bool aIsChrome, uint64_t aWindowID);
    void Init(JSContext* aCx, mozilla::dom::Exception* aException,
              bool aIsChrome, uint64_t aWindowID);



    void LogToConsole();



    void LogToConsoleWithStack(JS::HandleObject aStack);




    static void ErrorReportToMessageString(JSErrorReport* aReport,
                                           nsAString& aString);


    void LogToStderr();

  private:
    ~ErrorReport() {}
};

void
DispatchScriptErrorEvent(nsPIDOMWindowInner* win, JS::RootingContext* rootingCx,
                         xpc::ErrorReport* xpcReport, JS::Handle<JS::Value> exception);
JSObject*
FindExceptionStackForConsoleReport(nsPIDOMWindowInner* win,
                                   JS::HandleValue exceptionValue);




extern void
GetCurrentCompartmentName(JSContext*, nsCString& name);

void AddGCCallback(xpcGCCallback cb);
void RemoveGCCallback(xpcGCCallback cb);

inline bool
AreNonLocalConnectionsDisabled()
{
    static int disabledForTest = -1;
    if (disabledForTest == -1) {
        char *s = getenv("MOZ_DISABLE_NONLOCAL_CONNECTIONS");
        if (s) {
            disabledForTest = *s != '0';
        } else {
            disabledForTest = 0;
        }
    }
    return disabledForTest;
}

inline bool
IsInAutomation()
{
    const char* prefName =
      "security.turn_off_all_security_so_that_viruses_can_take_over_this_computer";
    return mozilla::Preferences::GetBool(prefName) &&
        AreNonLocalConnectionsDisabled();
}

}

namespace mozilla {
namespace dom {





bool IsChromeOrXBL(JSContext* cx, JSObject* );




bool ThreadSafeIsChromeOrXBL(JSContext* cx, JSObject* obj);

}
}

class nsICycleCollectorListener;
class nsScriptNameSpaceManager;

namespace JS {
class AutoValueVector;
}

namespace mozilla {
template <class> class Maybe;
struct CycleCollectorResults;
}







class nsJSContext : public nsIScriptContext
{
public:
  nsJSContext(bool aGCOnDestruction, nsIScriptGlobalObject* aGlobalObject);

  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; virtual void DeleteCycleCollectable(void); typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:
  class cycleCollection : public nsXPCOMCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = false) : nsXPCOMCycleCollectionParticipant(aSkip) {} private: public: virtual nsresult TraverseNative(void *p, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "nsJSContext"; }; virtual void DeleteCycleCollectable(void *p) override { DowncastCCParticipant<nsJSContext>(p)->DeleteCycleCollectable(); } static nsJSContext* Downcast(nsISupports* s) { return static_cast<nsJSContext*>(static_cast<nsIScriptContext*>(s)); } static nsISupports* Upcast(nsJSContext *p) { return static_cast<nsISupports*>(static_cast<nsIScriptContext*>(p)); } template<typename T> friend nsISupports* ToSupports(T* p, cycleCollection* dummy); virtual void Unlink(void *p) override; virtual void Trace(void *p, const TraceCallbacks &cb, void *closure) override; static constexpr nsXPCOMCycleCollectionParticipant* GetParticipant() { return &nsJSContext::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;


  virtual nsIScriptGlobalObject *GetGlobalObject() override;
  inline nsIScriptGlobalObject *GetGlobalObjectRef() { return mGlobalObjectRef; }

  virtual nsresult InitContext() override;
  virtual bool IsContextInitialized() override;

  virtual nsresult SetProperty(JS::Handle<JSObject*> aTarget, const char* aPropName, nsISupports* aVal) override;

  virtual bool GetProcessingScriptTag() override;
  virtual void SetProcessingScriptTag(bool aResult) override;

  virtual nsresult InitClasses(JS::Handle<JSObject*> aGlobalObj) override;

  virtual void WillInitializeContext() override;
  virtual void DidInitializeContext() override;

  virtual void SetWindowProxy(JS::Handle<JSObject*> aWindowProxy) override;
  virtual JSObject* GetWindowProxy() override;

  static void LoadStart();
  static void LoadEnd();

  enum IsShrinking {
    ShrinkingGC,
    NonShrinkingGC
  };

  enum IsIncremental {
    IncrementalGC,
    NonIncrementalGC
  };


  void EnsureStatics();

  static void GarbageCollectNow(JS::gcreason::Reason reason,
                                IsIncremental aIncremental = NonIncrementalGC,
                                IsShrinking aShrinking = NonShrinkingGC,
                                int64_t aSliceMillis = 0);



  static void CycleCollectNow(nsICycleCollectorListener *aListener = nullptr,
                              int32_t aExtraForgetSkippableCalls = 0);


  static void RunCycleCollectorSlice();


  static void RunCycleCollectorWorkSlice(int64_t aWorkBudget);

  static void BeginCycleCollectionCallback();
  static void EndCycleCollectionCallback(mozilla::CycleCollectorResults &aResults);


  static uint32_t GetMaxCCSliceTimeSinceClear();
  static void ClearMaxCCSliceTime();

  static void RunNextCollectorTimer();


  static void PokeGC(JS::gcreason::Reason aReason, JSObject* aObj, int aDelay = 0);
  static void KillGCTimer();

  static void PokeShrinkingGC();
  static void KillShrinkingGCTimer();

  static void MaybePokeCC();
  static void KillCCTimer();
  static void KillICCTimer();
  static void KillFullGCTimer();
  static void KillInterSliceGCTimer();


  static void LikelyShortLivingObjectCreated();

  static uint32_t CleanupsSinceLastGC();

  nsIScriptGlobalObject* GetCachedGlobalObject()
  {


    JSObject* global = GetWindowProxy();
    return global ? mGlobalObjectRef.get() : nullptr;
  }

  static void NotifyDidPaint();
protected:
  virtual ~nsJSContext();


  nsresult ConvertSupportsTojsvals(nsISupports *aArgs,
                                   JS::Handle<JSObject*> aScope,
                                   JS::AutoValueVector &aArgsOut);

  nsresult AddSupportsPrimitiveTojsvals(nsISupports *aArg, JS::Value *aArgv);

private:
  void Destroy();

  JS::Heap<JSObject*> mWindowProxy;

  bool mIsInitialized;
  bool mGCOnDestruction;
  bool mProcessingScriptTag;

  PRTime mModalStateTime;
  uint32_t mModalStateDepth;



  nsCOMPtr<nsIScriptGlobalObject> mGlobalObjectRef;

  static bool DOMOperationCallback(JSContext *cx);
};

namespace mozilla {
namespace dom {

void StartupJSEnvironment();
void ShutdownJSEnvironment();


nsScriptNameSpaceManager* GetNameSpaceManager();


nsScriptNameSpaceManager* PeekNameSpaceManager();


class AsyncErrorReporter final : public mozilla::Runnable
{
public:

  explicit AsyncErrorReporter(xpc::ErrorReport* aReport)
    : mReport(aReport)
  {}

  virtual nsresult Run() override
  {
    mReport->LogToConsole();
    return NS_OK;
  }

protected:
  RefPtr<xpc::ErrorReport> mReport;
};

}
}
class nsIJSArgArray : public nsIArray
{
public:
  template<typename T, typename U> struct COMTypeInfo;



  virtual nsresult GetArgs(uint32_t *argc, void **argv) = 0;
};

template<typename T> struct nsIJSArgArray::COMTypeInfo<nsIJSArgArray, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIJSArgArray::COMTypeInfo<nsIJSArgArray, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0xb6acdac8, 0xf5c6, 0x432c, { 0xa8, 0x6e, 0x33, 0xee, 0xb1, 0xb0, 0xcd, 0xdc } };




namespace mozilla {
namespace dom {





class CallbackObject : public nsISupports
{
public:
  template<typename T, typename U> struct COMTypeInfo;

  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; virtual void DeleteCycleCollectable(void); typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:
  class cycleCollection : public nsXPCOMCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = true) : nsXPCOMCycleCollectionParticipant(true) {} private: public: virtual nsresult TraverseNative(void *p, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "CallbackObject"; }; virtual void DeleteCycleCollectable(void *p) override { DowncastCCParticipant<CallbackObject>(p)->DeleteCycleCollectable(); } static CallbackObject* Downcast(nsISupports* s) { return static_cast<CallbackObject*>(static_cast<CallbackObject*>(s)); } static nsISupports* Upcast(CallbackObject *p) { return static_cast<nsISupports*>(static_cast<CallbackObject*>(p)); } template<typename T> friend nsISupports* ToSupports(T* p, cycleCollection* dummy); virtual void Unlink(void *p) override; virtual void Trace(void *p, const TraceCallbacks &cb, void *closure) override; virtual bool CanSkipReal(void *p, bool aRemovingAllowed) override; virtual bool CanSkipInCCReal(void *p) override; virtual bool CanSkipThisReal(void *p) override; static constexpr nsXPCOMCycleCollectionParticipant* GetParticipant() { return &CallbackObject::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;
  explicit CallbackObject(JSContext* aCx, JS::Handle<JSObject*> aCallback,
                          nsIGlobalObject* aIncumbentGlobal)
  {
    if (aCx && JS::ContextOptionsRef(aCx).asyncStack()) {
      JS::RootedObject stack(aCx);
      if (!JS::CaptureCurrentStack(aCx, &stack)) {
        JS_ClearPendingException(aCx);
      }
      Init(aCallback, stack, aIncumbentGlobal);
    } else {
      Init(aCallback, nullptr, aIncumbentGlobal);
    }
  }




  explicit CallbackObject(JS::Handle<JSObject*> aCallback,
                          JS::Handle<JSObject*> aAsyncStack,
                          nsIGlobalObject* aIncumbentGlobal)
  {
    Init(aCallback, aAsyncStack, aIncumbentGlobal);
  }
  JS::Handle<JSObject*> CallbackOrNull() const
  {
    mCallback.exposeToActiveJS();
    return CallbackPreserveColor();
  }

  JSObject* GetCreationStack() const
  {
    return mCreationStack;
  }

  void MarkForCC()
  {
    mCallback.exposeToActiveJS();
    mCreationStack.exposeToActiveJS();
  }
  JS::Handle<JSObject*> CallbackPreserveColor() const
  {


    return JS::Handle<JSObject*>::fromMarkedLocation(mCallback.address());
  }






  JS::Handle<JSObject*> CallbackKnownNotGray() const
  {
    do { } while (0);
    return CallbackPreserveColor();
  }

  nsIGlobalObject* IncumbentGlobalOrNull() const
  {
    return mIncumbentGlobal;
  }

  enum ExceptionHandling {

    eReportExceptions,



    eRethrowContentExceptions,




    eRethrowExceptions
  };

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return aMallocSizeOf(this);
  }

protected:
  virtual ~CallbackObject()
  {
    DropJSObjects();
  }

  explicit CallbackObject(CallbackObject* aCallbackObject)
  {
    Init(aCallbackObject->mCallback, aCallbackObject->mCreationStack,
         aCallbackObject->mIncumbentGlobal);
  }

  bool operator==(const CallbackObject& aOther) const
  {
    JSObject* wrappedThis = CallbackPreserveColor();
    JSObject* wrappedOther = aOther.CallbackPreserveColor();
    if (!wrappedThis || !wrappedOther) {
      return this == &aOther;
    }

    JSObject* thisObj = js::UncheckedUnwrap(wrappedThis);
    JSObject* otherObj = js::UncheckedUnwrap(wrappedOther);
    return thisObj == otherObj;
  }

  class JSObjectsDropper final
  {
  public:
    explicit JSObjectsDropper(CallbackObject* aHolder)
      : mHolder(aHolder)
    {}

    ~JSObjectsDropper()
    {
      mHolder->DropJSObjects();
    }

  private:
    RefPtr<CallbackObject> mHolder;
  };

private:
  inline void InitNoHold(JSObject* aCallback, JSObject* aCreationStack,
                         nsIGlobalObject* aIncumbentGlobal)
  {
    do { } while (0);


    mCallback = aCallback;
    mCreationStack = aCreationStack;
    if (aIncumbentGlobal) {
      mIncumbentGlobal = aIncumbentGlobal;
      mIncumbentJSGlobal = aIncumbentGlobal->GetGlobalJSObject();
    }
  }

  inline void Init(JSObject* aCallback, JSObject* aCreationStack,
                   nsIGlobalObject* aIncumbentGlobal)
  {
    InitNoHold(aCallback, aCreationStack, aIncumbentGlobal);
    mozilla::HoldJSObjects(this);
  }

  inline void ClearJSReferences()
  {
    mCallback = nullptr;
    mCreationStack = nullptr;
    mIncumbentJSGlobal = nullptr;
  }

  CallbackObject(const CallbackObject&) = delete;
  CallbackObject& operator =(const CallbackObject&) = delete;

protected:
  void DropJSObjects()
  {
    do { } while (0);
    if (mCallback) {
      ClearJSReferences();
      mozilla::DropJSObjects(this);
    }
  }


  void Trace(JSTracer* aTracer);





  void FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx);







  struct FastCallbackConstructor {
  };






  CallbackObject(JS::Handle<JSObject*> aCallback,
                 const FastCallbackConstructor&)
  {
    InitNoHold(aCallback, nullptr, nullptr);
  }





  JS::Heap<JSObject*> mCallback;
  JS::Heap<JSObject*> mCreationStack;
  nsCOMPtr<nsIGlobalObject> mIncumbentGlobal;
  JS::TenuredHeap<JSObject*> mIncumbentJSGlobal;

  class CallSetup
  {






  public:







    CallSetup(CallbackObject* aCallback, ErrorResult& aRv,
              const char* aExecutionReason,
              ExceptionHandling aExceptionHandling,
              JSCompartment* aCompartment = nullptr,
              bool aIsJSImplementedWebIDL = false);
    ~CallSetup();

    JSContext* GetContext() const
    {
      return mCx;
    }

  private:

    CallSetup(const CallSetup&) = delete;

    bool ShouldRethrowException(JS::Handle<JS::Value> aException);


    JSContext* mCx;



    JSCompartment* mCompartment;


    Maybe<AutoEntryScript> mAutoEntryScript;
    Maybe<AutoIncumbentScript> mAutoIncumbentScript;

    Maybe<JS::Rooted<JSObject*> > mRootedCallable;


    Maybe<JS::Rooted<JSObject*>> mAsyncStack;
    Maybe<JS::AutoSetAsyncStackForNewCalls> mAsyncStackSetter;





    Maybe<JSAutoCompartment> mAc;



    ErrorResult& mErrorResult;
    const ExceptionHandling mExceptionHandling;
    const bool mIsMainThread;
  };
};

template<class WebIDLCallbackT, class XPCOMCallbackT>
class CallbackObjectHolder;

template<class T, class U>
void ImplCycleCollectionUnlink(CallbackObjectHolder<T, U>& aField);

class CallbackObjectHolderBase
{
protected:

  already_AddRefed<nsISupports> ToXPCOMCallback(CallbackObject* aCallback,
                                                const nsIID& aIID) const;
};

template<class WebIDLCallbackT, class XPCOMCallbackT>
class CallbackObjectHolder : CallbackObjectHolderBase
{
public:
  explicit CallbackObjectHolder(WebIDLCallbackT* aCallback)
    : mPtrBits(reinterpret_cast<uintptr_t>(aCallback))
  {
    ns_if_addref(aCallback);
  }

  explicit CallbackObjectHolder(XPCOMCallbackT* aCallback)
    : mPtrBits(reinterpret_cast<uintptr_t>(aCallback) | XPCOMCallbackFlag)
  {
    ns_if_addref(aCallback);
  }

  CallbackObjectHolder(CallbackObjectHolder&& aOther)
    : mPtrBits(aOther.mPtrBits)
  {
    aOther.mPtrBits = 0;
    static_assert(sizeof(CallbackObjectHolder) == sizeof(void*),
                  "This object is expected to be as small as a pointer, and it "
                  "is currently passed by value in various places. If it is "
                  "bloating, we may want to pass it by reference then.");
  }

  CallbackObjectHolder(const CallbackObjectHolder& aOther) = delete;

  CallbackObjectHolder()
    : mPtrBits(0)
  {}

  ~CallbackObjectHolder()
  {
    UnlinkSelf();
  }

  void operator=(WebIDLCallbackT* aCallback)
  {
    UnlinkSelf();
    mPtrBits = reinterpret_cast<uintptr_t>(aCallback);
    ns_if_addref(aCallback);
  }

  void operator=(XPCOMCallbackT* aCallback)
  {
    UnlinkSelf();
    mPtrBits = reinterpret_cast<uintptr_t>(aCallback) | XPCOMCallbackFlag;
    ns_if_addref(aCallback);
  }

  void operator=(CallbackObjectHolder&& aOther)
  {
    UnlinkSelf();
    mPtrBits = aOther.mPtrBits;
    aOther.mPtrBits = 0;
  }

  void operator=(const CallbackObjectHolder& aOther) = delete;

  nsISupports* GetISupports() const
  {
    return reinterpret_cast<nsISupports*>(mPtrBits & ~XPCOMCallbackFlag);
  }


  explicit operator bool() const
  {
    return GetISupports();
  }

  CallbackObjectHolder Clone() const
  {
    CallbackObjectHolder result;
    result.mPtrBits = mPtrBits;
    ns_if_addref(GetISupports());
    return result;
  }



  bool HasWebIDLCallback() const
  {
    return !(mPtrBits & XPCOMCallbackFlag);
  }

  WebIDLCallbackT* GetWebIDLCallback() const
  {
    do { } while (0);
    return reinterpret_cast<WebIDLCallbackT*>(mPtrBits);
  }

  XPCOMCallbackT* GetXPCOMCallback() const
  {
    do { } while (0);
    return reinterpret_cast<XPCOMCallbackT*>(mPtrBits & ~XPCOMCallbackFlag);
  }

  bool operator==(WebIDLCallbackT* aOtherCallback) const
  {
    if (!aOtherCallback) {

      return !GetISupports();
    }

    if (!HasWebIDLCallback() || !GetWebIDLCallback()) {


      return false;
    }

    return *GetWebIDLCallback() == *aOtherCallback;
  }

  bool operator==(XPCOMCallbackT* aOtherCallback) const
  {
    return (!aOtherCallback && !GetISupports()) ||
      (!HasWebIDLCallback() && GetXPCOMCallback() == aOtherCallback);
  }

  bool operator==(const CallbackObjectHolder& aOtherCallback) const
  {
    if (aOtherCallback.HasWebIDLCallback()) {
      return *this == aOtherCallback.GetWebIDLCallback();
    }

    return *this == aOtherCallback.GetXPCOMCallback();
  }


  already_AddRefed<XPCOMCallbackT> ToXPCOMCallback() const
  {
    if (!HasWebIDLCallback()) {
      RefPtr<XPCOMCallbackT> callback = GetXPCOMCallback();
      return callback.forget();
    }

    nsCOMPtr<nsISupports> supp =
      CallbackObjectHolderBase::ToXPCOMCallback(GetWebIDLCallback(),
                                                (XPCOMCallbackT::template COMTypeInfo<XPCOMCallbackT, void>::kIID));
    if (supp) {

      return supp.forget().downcast<XPCOMCallbackT>();
    }
    return nullptr;
  }


  already_AddRefed<WebIDLCallbackT> ToWebIDLCallback() const
  {
    if (HasWebIDLCallback()) {
      RefPtr<WebIDLCallbackT> callback = GetWebIDLCallback();
      return callback.forget();
    }
    return nullptr;
  }

private:
  static const uintptr_t XPCOMCallbackFlag = 1u;

  friend void
  ImplCycleCollectionUnlink<WebIDLCallbackT,
                            XPCOMCallbackT>(CallbackObjectHolder& aField);

  void UnlinkSelf()
  {

    nsISupports* ptr = GetISupports();
    do { if (ptr) { (ptr)->Release(); (ptr) = 0; } } while (0);
    mPtrBits = 0;
  }

  uintptr_t mPtrBits;
};

template<typename T> struct CallbackObject::COMTypeInfo<CallbackObject, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID CallbackObject::COMTypeInfo<CallbackObject, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0xbe74c190, 0x6d76, 0x4991, { 0x84, 0xb9, 0x65, 0x06, 0x99, 0xe6, 0x93, 0x2b } };

template<class T, class U>
inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            CallbackObjectHolder<T, U>& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  if (aField) {
    CycleCollectionNoteChild(aCallback, aField.GetISupports(), aName, aFlags);
  }
}

template<class T, class U>
void
ImplCycleCollectionUnlink(CallbackObjectHolder<T, U>& aField)
{
  aField.UnlinkSelf();
}





template<typename T>
class RootedCallback : public JS::Rooted<T>
{
public:
  explicit RootedCallback(JSContext* cx)
    : JS::Rooted<T>(cx)
    , mCx(cx)
  {}



  template<typename S>
  void operator=(S* arg)
  {
    this->get().operator=(arg);
  }



  void operator=(decltype(nullptr) arg)
  {
    this->get().operator=(arg);
  }


  JS::Handle<JSObject*> CallbackOrNull() const
  {
    return this->get()->CallbackOrNull();
  }

  ~RootedCallback()
  {




    if (IsInitialized(this->get())) {
      this->get()->FinishSlowJSInitIfMoreThanOneOwner(mCx);
    }
  }

private:
  template<typename U>
  static bool IsInitialized(U& aArg);

  template<typename U>
  static bool IsInitialized(RefPtr<U>& aRefPtr)
  {
    return aRefPtr;
  }

  template<typename U>
  static bool IsInitialized(OwningNonNull<U>& aOwningNonNull)
  {
    return aOwningNonNull.isInitialized();
  }

  JSContext* mCx;
};

}
}

namespace mozilla {
namespace dom {

class CallbackFunction : public CallbackObject
{
public:

  explicit CallbackFunction(JSContext* aCx, JS::Handle<JSObject*> aCallable,
                            nsIGlobalObject* aIncumbentGlobal)
    : CallbackObject(aCx, aCallable, aIncumbentGlobal)
  {
  }


  explicit CallbackFunction(JS::Handle<JSObject*> aCallable,
                            JS::Handle<JSObject*> aAsyncStack,
                            nsIGlobalObject* aIncumbentGlobal)
    : CallbackObject(aCallable, aAsyncStack, aIncumbentGlobal)
  {
  }

  JS::Handle<JSObject*> CallableOrNull() const
  {
    return CallbackOrNull();
  }

  JS::Handle<JSObject*> CallablePreserveColor() const
  {
    return CallbackPreserveColor();
  }

  bool HasGrayCallable() const
  {

    return mCallback && JS::ObjectIsMarkedGray(mCallback);
  }

protected:
  explicit CallbackFunction(CallbackFunction* aCallbackFunction)
    : CallbackObject(aCallbackFunction)
  {
  }


  CallbackFunction(JS::Handle<JSObject*> aCallable,
                   const FastCallbackConstructor&)
    : CallbackObject(aCallable, FastCallbackConstructor())
  {
  }
};

}
}








struct JSContext;

namespace js {


extern bool
ToBooleanSlow(JS::HandleValue v);


extern bool
ToNumberSlow(JSContext* cx, JS::HandleValue v, double* dp);


extern bool
ToInt8Slow(JSContext *cx, JS::HandleValue v, int8_t *out);


extern bool
ToUint8Slow(JSContext *cx, JS::HandleValue v, uint8_t *out);


extern bool
ToInt16Slow(JSContext *cx, JS::HandleValue v, int16_t *out);


extern bool
ToInt32Slow(JSContext* cx, JS::HandleValue v, int32_t* out);


extern bool
ToUint32Slow(JSContext* cx, JS::HandleValue v, uint32_t* out);


extern bool
ToUint16Slow(JSContext* cx, JS::HandleValue v, uint16_t* out);


extern bool
ToInt64Slow(JSContext* cx, JS::HandleValue v, int64_t* out);


extern bool
ToUint64Slow(JSContext* cx, JS::HandleValue v, uint64_t* out);


extern JSString*
ToStringSlow(JSContext* cx, JS::HandleValue v);


extern JSObject*
ToObjectSlow(JSContext* cx, JS::HandleValue v, bool reportScanStack);

}

namespace JS {

namespace detail {







extern void
AssertArgumentsAreSane(JSContext* cx, HandleValue v);





}
extern bool
OrdinaryToPrimitive(JSContext* cx, HandleObject obj, JSType type, MutableHandleValue vp);


__attribute__((always_inline)) inline bool
ToBoolean(HandleValue v)
{
    if (v.isBoolean())
        return v.toBoolean();
    if (v.isInt32())
        return v.toInt32() != 0;
    if (v.isNullOrUndefined())
        return false;
    if (v.isDouble()) {
        double d = v.toDouble();
        return !mozilla::IsNaN(d) && d != 0;
    }
    if (v.isSymbol())
        return true;


    return js::ToBooleanSlow(v);
}


__attribute__((always_inline)) inline bool
ToNumber(JSContext* cx, HandleValue v, double* out)
{
    detail::AssertArgumentsAreSane(cx, v);

    if (v.isNumber()) {
        *out = v.toNumber();
        return true;
    }
    return js::ToNumberSlow(cx, v, out);
}


inline double
ToInteger(double d)
{
    if (d == 0)
        return d;

    if (!mozilla::IsFinite(d)) {
        if (mozilla::IsNaN(d))
            return 0;
        return d;
    }

    return d < 0 ? ceil(d) : floor(d);
}


__attribute__((always_inline)) inline bool
ToInt32(JSContext* cx, JS::HandleValue v, int32_t* out)
{
    detail::AssertArgumentsAreSane(cx, v);

    if (v.isInt32()) {
        *out = v.toInt32();
        return true;
    }
    return js::ToInt32Slow(cx, v, out);
}


__attribute__((always_inline)) inline bool
ToUint32(JSContext* cx, HandleValue v, uint32_t* out)
{
    detail::AssertArgumentsAreSane(cx, v);

    if (v.isInt32()) {
        *out = uint32_t(v.toInt32());
        return true;
    }
    return js::ToUint32Slow(cx, v, out);
}


__attribute__((always_inline)) inline bool
ToInt16(JSContext *cx, JS::HandleValue v, int16_t *out)
{
    detail::AssertArgumentsAreSane(cx, v);

    if (v.isInt32()) {
        *out = int16_t(v.toInt32());
        return true;
    }
    return js::ToInt16Slow(cx, v, out);
}


__attribute__((always_inline)) inline bool
ToUint16(JSContext* cx, HandleValue v, uint16_t* out)
{
    detail::AssertArgumentsAreSane(cx, v);

    if (v.isInt32()) {
        *out = uint16_t(v.toInt32());
        return true;
    }
    return js::ToUint16Slow(cx, v, out);
}


__attribute__((always_inline)) inline bool
ToInt8(JSContext *cx, JS::HandleValue v, int8_t *out)
{
    detail::AssertArgumentsAreSane(cx, v);

    if (v.isInt32()) {
        *out = int8_t(v.toInt32());
        return true;
    }
    return js::ToInt8Slow(cx, v, out);
}


__attribute__((always_inline)) inline bool
ToUint8(JSContext *cx, JS::HandleValue v, uint8_t *out)
{
    detail::AssertArgumentsAreSane(cx, v);

    if (v.isInt32()) {
        *out = uint8_t(v.toInt32());
        return true;
    }
    return js::ToUint8Slow(cx, v, out);
}





__attribute__((always_inline)) inline bool
ToInt64(JSContext* cx, HandleValue v, int64_t* out)
{
    detail::AssertArgumentsAreSane(cx, v);

    if (v.isInt32()) {
        *out = int64_t(v.toInt32());
        return true;
    }
    return js::ToInt64Slow(cx, v, out);
}





__attribute__((always_inline)) inline bool
ToUint64(JSContext* cx, HandleValue v, uint64_t* out)
{
    detail::AssertArgumentsAreSane(cx, v);

    if (v.isInt32()) {
        *out = uint64_t(v.toInt32());
        return true;
    }
    return js::ToUint64Slow(cx, v, out);
}


__attribute__((always_inline)) inline JSString*
ToString(JSContext* cx, HandleValue v)
{
    detail::AssertArgumentsAreSane(cx, v);

    if (v.isString())
        return v.toString();
    return js::ToStringSlow(cx, v);
}


inline JSObject*
ToObject(JSContext* cx, HandleValue v)
{
    detail::AssertArgumentsAreSane(cx, v);

    if (v.isObject())
        return &v.toObject();
    return js::ToObjectSlow(cx, v, false);
}

namespace detail {
template<typename ResultType>
inline ResultType
ToUintWidth(double d)
{
    static_assert(mozilla::IsUnsigned<ResultType>::value,
                  "ResultType must be an unsigned type");

    uint64_t bits = mozilla::BitwiseCast<uint64_t>(d);
    unsigned DoubleExponentShift = mozilla::FloatingPoint<double>::kExponentShift;



    int_fast16_t exp =
        int_fast16_t((bits & mozilla::FloatingPoint<double>::kExponentBits) >> DoubleExponentShift) -
        int_fast16_t(mozilla::FloatingPoint<double>::kExponentBias);



    if (exp < 0)
        return 0;

    uint_fast16_t exponent = mozilla::AssertedCast<uint_fast16_t>(exp);







    const size_t ResultWidth = 8 * sizeof(ResultType);
    if (exponent >= DoubleExponentShift + ResultWidth)
        return 0;




    static_assert(sizeof(ResultType) <= sizeof(uint64_t),
                  "Left-shifting below would lose upper bits");
    ResultType result = (exponent > DoubleExponentShift)
                        ? ResultType(bits << (exponent - DoubleExponentShift))
                        : ResultType(bits >> (DoubleExponentShift - exponent));
    if (exponent < ResultWidth) {
        ResultType implicitOne = ResultType(1) << exponent;
        result &= implicitOne - 1;
        result += implicitOne;
    }


    return (bits & mozilla::FloatingPoint<double>::kSignBit) ? ~result + 1 : result;
}

template<typename ResultType>
inline ResultType
ToIntWidth(double d)
{
    static_assert(mozilla::IsSigned<ResultType>::value,
                  "ResultType must be a signed type");

    const ResultType MaxValue = (1ULL << (8 * sizeof(ResultType) - 1)) - 1;
    const ResultType MinValue = -MaxValue - 1;

    typedef typename mozilla::MakeUnsigned<ResultType>::Type UnsignedResult;
    UnsignedResult u = ToUintWidth<UnsignedResult>(d);
    if (u <= UnsignedResult(MaxValue))
        return static_cast<ResultType>(u);
    return (MinValue + static_cast<ResultType>(u - MaxValue)) - 1;
}

}


inline int32_t
ToInt32(double d)
{
    return detail::ToIntWidth<int32_t>(d);

}


inline uint32_t
ToUint32(double d)
{
    return detail::ToUintWidth<uint32_t>(d);
}


inline int8_t
ToInt8(double d)
{
    return detail::ToIntWidth<int8_t>(d);
}


inline int8_t
ToUint8(double d)
{
    return detail::ToUintWidth<uint8_t>(d);
}


inline int16_t
ToInt16(double d)
{
    return detail::ToIntWidth<int16_t>(d);
}

inline uint16_t
ToUint16(double d)
{
    return detail::ToUintWidth<uint16_t>(d);
}


inline int64_t
ToInt64(double d)
{
    return detail::ToIntWidth<int64_t>(d);
}


inline uint64_t
ToUint64(double d)
{
    return detail::ToUintWidth<uint64_t>(d);
}

}




class nsISupports;

namespace mozilla {




typedef void* (*DeferredFinalizeAppendFunction)(void* aPointers, void* aThing);





typedef bool (*DeferredFinalizeFunction)(uint32_t aSlice, void* aData);

void DeferredFinalize(DeferredFinalizeAppendFunction aAppendFunc,
                      DeferredFinalizeFunction aFunc,
                      void* aThing);

void DeferredFinalize(nsISupports* aSupports);

}


namespace mozilla {
template<typename T,
         size_t IdealSegmentSize = 4096,
         typename AllocPolicy = MallocAllocPolicy>
class SegmentedVector : private AllocPolicy
{
  template<size_t SegmentCapacity>
  struct SegmentImpl
    : public mozilla::LinkedListElement<SegmentImpl<SegmentCapacity>>
  {
    SegmentImpl() : mLength(0) {}

    ~SegmentImpl()
    {
      for (uint32_t i = 0; i < mLength; i++) {
        (*this)[i].~T();
      }
    }

    uint32_t Length() const { return mLength; }

    T* Elems() { return reinterpret_cast<T*>(&mStorage.mBuf); }

    T& operator[](size_t aIndex)
    {
      do { } while (0);
      return Elems()[aIndex];
    }

    const T& operator[](size_t aIndex) const
    {
      do { } while (0);
      return Elems()[aIndex];
    }

    template<typename U>
    void Append(U&& aU)
    {
      do { } while (0);

      mLength++;
      T* elem = &(*this)[mLength - 1];
      new (elem) T(mozilla::Forward<U>(aU));
    }

    void PopLast()
    {
      do { } while (0);
      (*this)[mLength - 1].~T();
      mLength--;
    }

    uint32_t mLength;


    union Storage
    {
      char mBuf[sizeof(T) * SegmentCapacity];
      mozilla::AlignedElem<mozilla::AlignmentFinder<T>::alignment> mAlign;
    } mStorage;

    static_assert(mozilla::AlignmentFinder<T>::alignment == mozilla::AlignmentFinder<Storage>::alignment,
                  "SegmentedVector provides incorrect alignment");
  };




  static const size_t kSingleElementSegmentSize = sizeof(SegmentImpl<1>);
  static const size_t kSegmentCapacity =
    kSingleElementSegmentSize <= IdealSegmentSize
    ? (IdealSegmentSize - kSingleElementSegmentSize) / sizeof(T) + 1
    : 1;

  typedef SegmentImpl<kSegmentCapacity> Segment;

public:




  explicit SegmentedVector(size_t aIdealSegmentSize = 0)
  {



    do { } while (0);



  }

  ~SegmentedVector() { Clear(); }

  bool IsEmpty() const { return !mSegments.getFirst(); }



  size_t Length() const
  {
    size_t n = 0;
    for (auto segment = mSegments.getFirst();
         segment;
         segment = segment->getNext()) {
      n += segment->Length();
    }
    return n;
  }



  template<typename U>
  __attribute__ ((warn_unused_result)) bool Append(U&& aU)
  {
    Segment* last = mSegments.getLast();
    if (!last || last->Length() == kSegmentCapacity) {
      last = this->template pod_malloc<Segment>(1);
      if (!last) {
        return false;
      }
      new (last) Segment();
      mSegments.insertBack(last);
    }
    last->Append(mozilla::Forward<U>(aU));
    return true;
  }



  template<typename U>
  void InfallibleAppend(U&& aU)
  {
    bool ok = Append(mozilla::Forward<U>(aU));
    do { static_assert(mozilla::detail::AssertionConditionType<decltype(ok)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(ok))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "ok" ")"); do { *((volatile int*) __null) = 183; ::abort(); } while (0); } } while (0);
  }

  void Clear()
  {
    Segment* segment;
    while ((segment = mSegments.popFirst())) {
      segment->~Segment();
      this->free_(segment);
    }
  }

  T& GetLast()
  {
    do { } while (0);
    Segment* last = mSegments.getLast();
    return (*last)[last->Length() - 1];
  }

  const T& GetLast() const
  {
    do { } while (0);
    Segment* last = mSegments.getLast();
    return (*last)[last->Length() - 1];
  }

  void PopLast()
  {
    do { } while (0);
    Segment* last = mSegments.getLast();
    last->PopLast();
    if (!last->Length()) {
      mSegments.popLast();
      last->~Segment();
      this->free_(last);
    }
  }



  void PopLastN(uint32_t aNumElements)
  {
    do { } while (0);

    Segment* last;




    do {
      last = mSegments.getLast();


      if (!last) {
        return;
      }



      uint32_t segmentLen = last->Length();
      if (segmentLen > aNumElements) {
        break;
      }


      mSegments.popLast();
      last->~Segment();
      this->free_(last);

      do { } while (0);
      aNumElements -= segmentLen;
      if (aNumElements == 0) {
        return;
      }
    } while (true);



    do { } while (0);
    do { } while (0);
    do { } while (0);
    do { } while (0);
    for (uint32_t i = 0; i < aNumElements; ++i) {
      last->PopLast();
    }
    do { } while (0);
  }
  class IterImpl
  {
    friend class SegmentedVector;

    Segment* mSegment;
    size_t mIndex;

    explicit IterImpl(SegmentedVector* aVector)
      : mSegment(aVector->mSegments.getFirst())
      , mIndex(0)
    {}

  public:
    bool Done() const { return !mSegment; }

    T& Get()
    {
      do { } while (0);
      return (*mSegment)[mIndex];
    }

    const T& Get() const
    {
      do { } while (0);
      return (*mSegment)[mIndex];
    }

    void Next()
    {
      do { } while (0);
      mIndex++;
      if (mIndex == mSegment->Length()) {
        mSegment = mSegment->getNext();
        mIndex = 0;
      }
    }
  };

  IterImpl Iter() { return IterImpl(this); }





  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return mSegments.sizeOfExcludingThis(aMallocSizeOf);
  }


  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
  }

private:
  mozilla::LinkedList<Segment> mSegments;
};

}
class nsCycleCollectionNoteRootCallback;
class nsIException;
class nsIRunnable;
class nsThread;
class nsWrapperCache;

namespace js {
struct Class;
}

namespace mozilla {

class JSGCThingParticipant: public nsCycleCollectionParticipant
{
public:
  constexpr JSGCThingParticipant()
    : nsCycleCollectionParticipant(false) {}

  virtual void Root(void*) override
  {
    do { } while (0);
  }

  virtual void Unlink(void*) override
  {
    do { } while (0);
  }

  virtual void Unroot(void*) override
  {
    do { } while (0);
  }

  virtual void DeleteCycleCollectable(void* aPtr) override
  {
    do { } while (0);
  }

  virtual nsresult TraverseNative(void* aPtr, nsCycleCollectionTraversalCallback& aCb)
    override;

  virtual const char* ClassName() override { return "JSGCThingParticipant"; };
};

class JSZoneParticipant : public nsCycleCollectionParticipant
{
public:
  constexpr JSZoneParticipant(): nsCycleCollectionParticipant(false)
  {
  }

  virtual void Root(void*) override
  {
    do { } while (0);
  }

  virtual void Unlink(void*) override
  {
    do { } while (0);
  }

  virtual void Unroot(void*) override
  {
    do { } while (0);
  }

  virtual void DeleteCycleCollectable(void*) override
  {
    do { } while (0);
  }

  virtual nsresult TraverseNative(void* aPtr, nsCycleCollectionTraversalCallback& aCb)
    override;

  virtual const char* ClassName() override { return "JSZoneParticipant"; };
};

class IncrementalFinalizeRunnable;


struct CycleCollectorResults
{
  CycleCollectorResults()
  {


    Init();
  }

  void Init()
  {
    mForcedGC = false;
    mMergedZones = false;
    mAnyManual = false;
    mVisitedRefCounted = 0;
    mVisitedGCed = 0;
    mFreedRefCounted = 0;
    mFreedGCed = 0;
    mFreedJSZones = 0;
    mNumSlices = 1;


  }

  bool mForcedGC;
  bool mMergedZones;
  bool mAnyManual;
  uint32_t mVisitedRefCounted;
  uint32_t mVisitedGCed;
  uint32_t mFreedRefCounted;
  uint32_t mFreedGCed;
  uint32_t mFreedJSZones;
  uint32_t mNumSlices;
};

class CycleCollectedJSContext
{
  friend class JSGCThingParticipant;
  friend class JSZoneParticipant;
  friend class IncrementalFinalizeRunnable;
protected:
  CycleCollectedJSContext();
  virtual ~CycleCollectedJSContext();


  nsresult Initialize(JSRuntime* aParentRuntime,
                      uint32_t aMaxBytes,
                      uint32_t aMaxNurseryBytes);

  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;
  void UnmarkSkippableJSHolders();

  virtual void
  TraverseAdditionalNativeRoots(nsCycleCollectionNoteRootCallback& aCb) {}
  virtual void TraceAdditionalNativeGrayRoots(JSTracer* aTracer) {}

  virtual void CustomGCCallback(JSGCStatus aStatus) {}
  virtual void CustomOutOfMemoryCallback() {}
  virtual void CustomLargeAllocationFailureCallback() {}

  std::queue<nsCOMPtr<nsIRunnable>> mPromiseMicroTaskQueue;
  std::queue<nsCOMPtr<nsIRunnable>> mDebuggerPromiseMicroTaskQueue;

private:
  void
  DescribeGCThing(bool aIsMarked, JS::GCCellPtr aThing,
                  nsCycleCollectionTraversalCallback& aCb) const;

  virtual bool
  DescribeCustomObjects(JSObject* aObject, const js::Class* aClasp,
                        char (&aName)[72]) const
  {
    return false;
  }

  void
  NoteGCThingJSChildren(JS::GCCellPtr aThing,
                        nsCycleCollectionTraversalCallback& aCb) const;

  void
  NoteGCThingXPCOMChildren(const js::Class* aClasp, JSObject* aObj,
                           nsCycleCollectionTraversalCallback& aCb) const;

  virtual bool
  NoteCustomGCThingXPCOMChildren(const js::Class* aClasp, JSObject* aObj,
                                 nsCycleCollectionTraversalCallback& aCb) const
  {
    return false;
  }

  enum TraverseSelect {
    TRAVERSE_CPP,
    TRAVERSE_FULL
  };

  void
  TraverseGCThing(TraverseSelect aTs, JS::GCCellPtr aThing,
                  nsCycleCollectionTraversalCallback& aCb);

  void
  TraverseZone(JS::Zone* aZone, nsCycleCollectionTraversalCallback& aCb);

  static void
  TraverseObjectShim(void* aData, JS::GCCellPtr aThing);

  void TraverseNativeRoots(nsCycleCollectionNoteRootCallback& aCb);

  static void TraceBlackJS(JSTracer* aTracer, void* aData);
  static void TraceGrayJS(JSTracer* aTracer, void* aData);
  static void GCCallback(JSContext* aContext, JSGCStatus aStatus, void* aData);
  static void GCSliceCallback(JSContext* aContext, JS::GCProgress aProgress,
                              const JS::GCDescription& aDesc);
  static void GCNurseryCollectionCallback(JSContext* aContext,
                                          JS::GCNurseryProgress aProgress,
                                          JS::gcreason::Reason aReason);
  static void OutOfMemoryCallback(JSContext* aContext, void* aData);
  static void LargeAllocationFailureCallback(void* aData);



  static size_t SizeofExternalStringCallback(JSString* aStr,
                                             mozilla::MallocSizeOf aMallocSizeOf);

  static bool ContextCallback(JSContext* aCx, unsigned aOperation,
                              void* aData);
  static JSObject* GetIncumbentGlobalCallback(JSContext* aCx);
  static bool EnqueuePromiseJobCallback(JSContext* aCx,
                                        JS::HandleObject aJob,
                                        JS::HandleObject aAllocationSite,
                                        JS::HandleObject aIncumbentGlobal,
                                        void* aData);
  static void PromiseRejectionTrackerCallback(JSContext* aCx,
                                              JS::HandleObject aPromise,
                                              PromiseRejectionHandlingState state,
                                              void* aData);

  virtual void TraceNativeBlackRoots(JSTracer* aTracer) { };
  void TraceNativeGrayRoots(JSTracer* aTracer);

  void AfterProcessMicrotask(uint32_t aRecursionDepth);
public:
  void ProcessStableStateQueue();
private:
  void ProcessMetastableStateQueue(uint32_t aRecursionDepth);

public:
  enum DeferredFinalizeType {
    FinalizeIncrementally,
    FinalizeNow,
  };

  void FinalizeDeferredThings(DeferredFinalizeType aType);



  enum class OOMState : uint32_t {

    OK,
    Reporting,
    Reported,





    Recovered
  };

private:
  void AnnotateAndSetOutOfMemory(OOMState* aStatePtr, OOMState aNewState);
  void OnGC(JSGCStatus aStatus);
  void OnOutOfMemory();
  void OnLargeAllocationFailure();

public:
  void AddJSHolder(void* aHolder, nsScriptObjectTracer* aTracer);
  void RemoveJSHolder(void* aHolder);





  already_AddRefed<nsIException> GetPendingException() const;
  void SetPendingException(nsIException* aException);

  std::queue<nsCOMPtr<nsIRunnable>>& GetPromiseMicroTaskQueue();
  std::queue<nsCOMPtr<nsIRunnable>>& GetDebuggerPromiseMicroTaskQueue();

  nsCycleCollectionParticipant* GCThingParticipant();
  nsCycleCollectionParticipant* ZoneParticipant();

  nsresult TraverseRoots(nsCycleCollectionNoteRootCallback& aCb);
  virtual bool UsefulToMergeZones() const;
  void FixWeakMappingGrayBits() const;
  void CheckGrayBits() const;
  bool AreGCGrayBitsValid() const;
  void GarbageCollect(uint32_t aReason) const;

  void NurseryWrapperAdded(nsWrapperCache* aCache);
  void NurseryWrapperPreserved(JSObject* aWrapper);
  void JSObjectsTenured();

  void DeferredFinalize(DeferredFinalizeAppendFunction aAppendFunc,
                        DeferredFinalizeFunction aFunc,
                        void* aThing);
  void DeferredFinalize(nsISupports* aSupports);

  void DumpJSHeap(FILE* aFile);

  virtual void PrepareForForgetSkippable() = 0;
  virtual void BeginCycleCollectionCallback() = 0;
  virtual void EndCycleCollectionCallback(CycleCollectorResults& aResults) = 0;
  virtual void DispatchDeferredDeletion(bool aContinuation, bool aPurge = false) = 0;

  JSContext* Context() const
  {
    do { } while (0);
    return mJSContext;
  }

  JS::RootingContext* RootingCx() const
  {
    do { } while (0);
    return JS::RootingContext::get(mJSContext);
  }

  bool MicroTaskCheckpointDisabled() const
  {
    return mDisableMicroTaskCheckpoint;
  }

  void DisableMicroTaskCheckpoint(bool aDisable)
  {
    mDisableMicroTaskCheckpoint = aDisable;
  }

  class AutoDisableMicroTaskCheckpoint
  {
    public:
    AutoDisableMicroTaskCheckpoint()
    : mCCJSCX(CycleCollectedJSContext::Get())
    {
      mOldValue = mCCJSCX->MicroTaskCheckpointDisabled();
      mCCJSCX->DisableMicroTaskCheckpoint(true);
    }

    ~AutoDisableMicroTaskCheckpoint()
    {
      mCCJSCX->DisableMicroTaskCheckpoint(mOldValue);
    }

    CycleCollectedJSContext* mCCJSCX;
    bool mOldValue;
  };

protected:
  JSContext* MaybeContext() const { return mJSContext; }

public:

  virtual void BeforeProcessTask(bool aMightBlock) { };
  virtual void AfterProcessTask(uint32_t aRecursionDepth);


  void AfterProcessMicrotask();

  uint32_t RecursionDepth();


  void RunInStableState(already_AddRefed<nsIRunnable>&& aRunnable);


  void RunInMetastableState(already_AddRefed<nsIRunnable>&& aRunnable);



  static CycleCollectedJSContext* Get();


  void AddZoneWaitingForGC(JS::Zone* aZone)
  {
    mZonesWaitingForGC.PutEntry(aZone);
  }





  void PrepareWaitingZonesForGC();


  virtual void DispatchToMicroTask(already_AddRefed<nsIRunnable> aRunnable);







  JS::PersistentRooted<JS::GCVector<JSObject*, 0, js::SystemAllocPolicy>> mUncaughtRejections;




  JS::PersistentRooted<JS::GCVector<JSObject*, 0, js::SystemAllocPolicy>> mConsumedRejections;
  nsTArray<nsCOMPtr<nsISupports >> mUncaughtRejectionObservers;

private:
  JSGCThingParticipant mGCThingCycleCollectorGlobal;

  JSZoneParticipant mJSZoneCycleCollectorGlobal;

  JSContext* mJSContext;

  JS::GCSliceCallback mPrevGCSliceCallback;
  JS::GCNurseryCollectionCallback mPrevGCNurseryCollectionCallback;

  nsDataHashtable<nsPtrHashKey<void>, nsScriptObjectTracer*> mJSHolders;

  typedef nsDataHashtable<nsFuncPtrHashKey<DeferredFinalizeFunction>, void*>
    DeferredFinalizerTable;
  DeferredFinalizerTable mDeferredFinalizerTable;

  RefPtr<IncrementalFinalizeRunnable> mFinalizeRunnable;

  nsCOMPtr<nsIException> mPendingException;
  nsThread* mOwningThread;

  struct RunInMetastableStateData
  {
    nsCOMPtr<nsIRunnable> mRunnable;
    uint32_t mRecursionDepth;
  };

  nsTArray<nsCOMPtr<nsIRunnable>> mStableStateEvents;
  nsTArray<RunInMetastableStateData> mMetastableStateEvents;
  uint32_t mBaseRecursionDepth;
  bool mDoingStableStates;

  bool mDisableMicroTaskCheckpoint;

  OOMState mOutOfMemoryState;
  OOMState mLargeAllocationFailureState;

  static const size_t kSegmentSize = 512;
  SegmentedVector<nsWrapperCache*, kSegmentSize, InfallibleAllocPolicy>
    mNurseryObjects;
  SegmentedVector<JS::PersistentRooted<JSObject*>, kSegmentSize,
                  InfallibleAllocPolicy>
    mPreservedNurseryObjects;

  nsTHashtable<nsPtrHashKey<JS::Zone>> mZonesWaitingForGC;

  struct EnvironmentPreparer : public js::ScriptEnvironmentPreparer {
    void invoke(JS::HandleObject scope, Closure& closure) override;
  };
  EnvironmentPreparer mEnvironmentPreparer;
};

void TraceScriptHolder(nsISupports* aHolder, JSTracer* aTracer);


inline bool AddToCCKind(JS::TraceKind aKind)
{
  return aKind == JS::TraceKind::Object ||
         aKind == JS::TraceKind::Script ||
         aKind == JS::TraceKind::Scope ||
         aKind == JS::TraceKind::RegExpShared;
}

bool
GetBuildId(JS::BuildIdCharVector* aBuildID);

}








namespace mozilla {
namespace dom {
namespace prototypes {

namespace id {

enum ID : uint16_t
{
  _ID_Start = 0,
  ANGLE_instanced_arrays = _ID_Start,
  AccessibleNode,
  Addon,
  AddonEvent,
  AddonInstall,
  AddonManager,
  AnalyserNode,
  Animation,
  AnimationEffectReadOnly,
  AnimationEffectTiming,
  AnimationEffectTimingReadOnly,
  AnimationEvent,
  AnimationPlaybackEvent,
  AnimationTimeline,
  AnonymousContent,
  Attr,
  AudioBuffer,
  AudioBufferSourceNode,
  AudioContext,
  AudioDestinationNode,
  AudioListener,
  AudioNode,
  AudioParam,
  AudioProcessingEvent,
  AudioScheduledSourceNode,
  AudioStreamTrack,
  AudioTrack,
  AudioTrackList,
  AudioWorkletGlobalScope,
  AutocompleteErrorEvent,
  BarProp,
  BaseAudioContext,
  BatteryManager,
  BeforeUnloadEvent,
  BiquadFilterNode,
  Blob,
  BlobEvent,
  BoxObject,
  BroadcastChannel,
  BrowserElementAudioChannel,
  BrowserFeedWriter,
  CDATASection,
  CSS2Properties,
  CSSAnimation,
  CSSConditionRule,
  CSSCounterStyleRule,
  CSSFontFaceRule,
  CSSFontFeatureValuesRule,
  CSSGroupingRule,
  CSSImportRule,
  CSSKeyframeRule,
  CSSKeyframesRule,
  CSSLexer,
  CSSMediaRule,
  CSSMozDocumentRule,
  CSSNamespaceRule,
  CSSPageRule,
  CSSPrimitiveValue,
  CSSPseudoElement,
  CSSRule,
  CSSRuleList,
  CSSStyleDeclaration,
  CSSStyleRule,
  CSSStyleSheet,
  CSSSupportsRule,
  CSSTransition,
  CSSValue,
  CSSValueList,
  Cache,
  CacheStorage,
  CanvasCaptureMediaStream,
  CanvasGradient,
  CanvasPattern,
  CanvasRenderingContext2D,
  CaretPosition,
  CaretStateChangedEvent,
  ChannelMergerNode,
  ChannelSplitterNode,
  CharacterData,
  CheckerboardReportService,
  ChromeNodeList,
  ChromeWorker,
  Client,
  Clients,
  ClipboardEvent,
  CloseEvent,
  CommandEvent,
  Comment,
  CompositionEvent,
  ConstantSourceNode,
  ContainerBoxObject,
  ConvolverNode,
  Coordinates,
  CreateOfferRequest,
  Crypto,
  CryptoKey,
  CustomElementRegistry,
  CustomEvent,
  DOMCursor,
  DOMError,
  DOMException,
  DOMImplementation,
  DOMMatrix,
  DOMMatrixReadOnly,
  DOMParser,
  DOMPoint,
  DOMPointReadOnly,
  DOMQuad,
  DOMRect,
  DOMRectList,
  DOMRectReadOnly,
  DOMRequest,
  DOMStringList,
  DOMStringMap,
  DOMTokenList,
  DataChannel,
  DataContainerEvent,
  DataTransfer,
  DataTransferItem,
  DataTransferItemList,
  DedicatedWorkerGlobalScope,
  DelayNode,
  DesktopNotification,
  DesktopNotificationCenter,
  DeviceAcceleration,
  DeviceLightEvent,
  DeviceMotionEvent,
  DeviceOrientationEvent,
  DeviceProximityEvent,
  DeviceRotationRate,
  Directory,
  Document,
  DocumentFragment,
  DocumentTimeline,
  DocumentType,
  DominatorTree,
  DragEvent,
  DynamicsCompressorNode,
  EXT_blend_minmax,
  EXT_color_buffer_float,
  EXT_color_buffer_half_float,
  EXT_disjoint_timer_query,
  EXT_frag_depth,
  EXT_sRGB,
  EXT_shader_texture_lod,
  EXT_texture_filter_anisotropic,
  Element,
  ErrorEvent,
  Event,
  EventSource,
  EventTarget,
  Exception,
  ExtendableEvent,
  ExtendableMessageEvent,
  External,
  FetchController,
  FetchEvent,
  FetchObserver,
  FetchSignal,
  File,
  FileList,
  FileReader,
  FileReaderSync,
  FileSystem,
  FileSystemDirectoryEntry,
  FileSystemDirectoryReader,
  FileSystemEntry,
  FileSystemFileEntry,
  FlyWebDiscoveryManager,
  FlyWebFetchEvent,
  FlyWebPublishedServer,
  FlyWebWebSocketEvent,
  FocusEvent,
  FontFace,
  FontFaceSet,
  FontFaceSetIterator,
  FontFaceSetLoadEvent,
  FormData,
  FormDataIterator,
  GainNode,
  Gamepad,
  GamepadAxisMoveEvent,
  GamepadButton,
  GamepadButtonEvent,
  GamepadEvent,
  GamepadHapticActuator,
  GamepadPose,
  GamepadServiceTest,
  Geolocation,
  GetUserMediaRequest,
  Grid,
  GridArea,
  GridDimension,
  GridLine,
  GridLines,
  GridTrack,
  GridTracks,
  GroupedHistoryEvent,
  HTMLAllCollection,
  HTMLAnchorElement,
  HTMLAppletElement,
  HTMLAreaElement,
  HTMLAudioElement,
  HTMLBRElement,
  HTMLBaseElement,
  HTMLBodyElement,
  HTMLButtonElement,
  HTMLCanvasElement,
  HTMLCollection,
  HTMLContentElement,
  HTMLDListElement,
  HTMLDataElement,
  HTMLDataListElement,
  HTMLDetailsElement,
  HTMLDialogElement,
  HTMLDirectoryElement,
  HTMLDivElement,
  HTMLDocument,
  HTMLElement,
  HTMLEmbedElement,
  HTMLFieldSetElement,
  HTMLFontElement,
  HTMLFormControlsCollection,
  HTMLFormElement,
  HTMLFrameElement,
  HTMLFrameSetElement,
  HTMLHRElement,
  HTMLHeadElement,
  HTMLHeadingElement,
  HTMLHtmlElement,
  HTMLIFrameElement,
  HTMLImageElement,
  HTMLInputElement,
  HTMLLIElement,
  HTMLLabelElement,
  HTMLLegendElement,
  HTMLLinkElement,
  HTMLMapElement,
  HTMLMediaElement,
  HTMLMenuElement,
  HTMLMenuItemElement,
  HTMLMetaElement,
  HTMLMeterElement,
  HTMLModElement,
  HTMLOListElement,
  HTMLObjectElement,
  HTMLOptGroupElement,
  HTMLOptionElement,
  HTMLOptionsCollection,
  HTMLOutputElement,
  HTMLParagraphElement,
  HTMLParamElement,
  HTMLPictureElement,
  HTMLPreElement,
  HTMLProgressElement,
  HTMLQuoteElement,
  HTMLScriptElement,
  HTMLSelectElement,
  HTMLShadowElement,
  HTMLSourceElement,
  HTMLSpanElement,
  HTMLStyleElement,
  HTMLTableCaptionElement,
  HTMLTableCellElement,
  HTMLTableColElement,
  HTMLTableElement,
  HTMLTableRowElement,
  HTMLTableSectionElement,
  HTMLTemplateElement,
  HTMLTextAreaElement,
  HTMLTimeElement,
  HTMLTitleElement,
  HTMLTrackElement,
  HTMLUListElement,
  HTMLUnknownElement,
  HTMLVideoElement,
  HashChangeEvent,
  Headers,
  HeadersIterator,
  HeapSnapshot,
  HiddenPluginEvent,
  History,
  IDBCursor,
  IDBCursorWithValue,
  IDBDatabase,
  IDBFactory,
  IDBFileHandle,
  IDBFileRequest,
  IDBIndex,
  IDBKeyRange,
  IDBLocaleAwareKeyRange,
  IDBMutableFile,
  IDBObjectStore,
  IDBOpenDBRequest,
  IDBRequest,
  IDBTransaction,
  IDBVersionChangeEvent,
  IIRFilterNode,
  IdleDeadline,
  ImageBitmap,
  ImageBitmapRenderingContext,
  ImageCapture,
  ImageCaptureError,
  ImageCaptureErrorEvent,
  ImageData,
  ImageDocument,
  InputEvent,
  InstallTriggerImpl,
  IntersectionObserver,
  IntersectionObserverEntry,
  IntlUtils,
  KeyboardEvent,
  KeyframeEffect,
  KeyframeEffectReadOnly,
  LegacyMozTCPSocket,
  ListBoxObject,
  LocalMediaStream,
  Location,
  MOZ_debug_get,
  MediaDeviceInfo,
  MediaDevices,
  MediaElementAudioSourceNode,
  MediaEncryptedEvent,
  MediaError,
  MediaKeyError,
  MediaKeyMessageEvent,
  MediaKeySession,
  MediaKeyStatusMap,
  MediaKeyStatusMapIterator,
  MediaKeySystemAccess,
  MediaKeys,
  MediaList,
  MediaQueryList,
  MediaRecorder,
  MediaSource,
  MediaStream,
  MediaStreamAudioDestinationNode,
  MediaStreamAudioSourceNode,
  MediaStreamError,
  MediaStreamEvent,
  MediaStreamList,
  MediaStreamTrack,
  MediaStreamTrackEvent,
  MenuBoxObject,
  MessageChannel,
  MessageEvent,
  MessagePort,
  MimeType,
  MimeTypeArray,
  MouseEvent,
  MouseScrollEvent,
  MozCanvasPrintState,
  MozPowerManager,
  MozSelfSupport,
  MozTimeManager,
  MozWakeLock,
  MutationEvent,
  MutationObserver,
  MutationRecord,
  NamedNodeMap,
  Navigator,
  NetworkInformation,
  Node,
  NodeIterator,
  NodeList,
  Notification,
  NotificationEvent,
  NotifyPaintEvent,
  OES_element_index_uint,
  OES_standard_derivatives,
  OES_texture_float,
  OES_texture_float_linear,
  OES_texture_half_float,
  OES_texture_half_float_linear,
  OES_vertex_array_object,
  OfflineAudioCompletionEvent,
  OfflineAudioContext,
  OfflineResourceList,
  OffscreenCanvas,
  OnlyForUseInConstructor,
  OscillatorNode,
  PageTransitionEvent,
  PaintRequest,
  PaintRequestList,
  PaintWorkletGlobalScope,
  PannerNode,
  Path2D,
  PeerConnectionImpl,
  PeerConnectionObserver,
  Performance,
  PerformanceEntry,
  PerformanceEntryEvent,
  PerformanceMark,
  PerformanceMeasure,
  PerformanceNavigation,
  PerformanceObserver,
  PerformanceObserverEntryList,
  PerformanceResourceTiming,
  PerformanceTiming,
  PeriodicWave,
  PermissionStatus,
  Permissions,
  Plugin,
  PluginArray,
  PluginCrashedEvent,
  PointerEvent,
  PopStateEvent,
  PopupBlockedEvent,
  PopupBoxObject,
  Position,
  PositionError,
  PrecompiledScript,
  Presentation,
  PresentationAvailability,
  PresentationConnection,
  PresentationConnectionAvailableEvent,
  PresentationConnectionCloseEvent,
  PresentationConnectionList,
  PresentationDeviceInfoManager,
  PresentationReceiver,
  PresentationRequest,
  ProcessingInstruction,
  ProgressEvent,
  PromiseNativeHandler,
  PushEvent,
  PushManager,
  PushManagerImpl,
  PushMessageData,
  PushSubscription,
  PushSubscriptionOptions,
  RGBColor,
  RTCCertificate,
  RTCDTMFSender,
  RTCDTMFToneChangeEvent,
  RTCDataChannelEvent,
  RTCIceCandidate,
  RTCIdentityProviderRegistrar,
  RTCPeerConnection,
  RTCPeerConnectionIceEvent,
  RTCPeerConnectionStatic,
  RTCRtpReceiver,
  RTCRtpSender,
  RTCSessionDescription,
  RTCStatsReport,
  RTCTrackEvent,
  RadioNodeList,
  Range,
  RecordErrorEvent,
  Rect,
  Request,
  Response,
  SEChannel,
  SEManager,
  SEReader,
  SEResponse,
  SESession,
  SVGAElement,
  SVGAngle,
  SVGAnimateElement,
  SVGAnimateMotionElement,
  SVGAnimateTransformElement,
  SVGAnimatedAngle,
  SVGAnimatedBoolean,
  SVGAnimatedEnumeration,
  SVGAnimatedInteger,
  SVGAnimatedLength,
  SVGAnimatedLengthList,
  SVGAnimatedNumber,
  SVGAnimatedNumberList,
  SVGAnimatedPreserveAspectRatio,
  SVGAnimatedRect,
  SVGAnimatedString,
  SVGAnimatedTransformList,
  SVGAnimationElement,
  SVGCircleElement,
  SVGClipPathElement,
  SVGComponentTransferFunctionElement,
  SVGDefsElement,
  SVGDescElement,
  SVGElement,
  SVGEllipseElement,
  SVGFEBlendElement,
  SVGFEColorMatrixElement,
  SVGFEComponentTransferElement,
  SVGFECompositeElement,
  SVGFEConvolveMatrixElement,
  SVGFEDiffuseLightingElement,
  SVGFEDisplacementMapElement,
  SVGFEDistantLightElement,
  SVGFEDropShadowElement,
  SVGFEFloodElement,
  SVGFEFuncAElement,
  SVGFEFuncBElement,
  SVGFEFuncGElement,
  SVGFEFuncRElement,
  SVGFEGaussianBlurElement,
  SVGFEImageElement,
  SVGFEMergeElement,
  SVGFEMergeNodeElement,
  SVGFEMorphologyElement,
  SVGFEOffsetElement,
  SVGFEPointLightElement,
  SVGFESpecularLightingElement,
  SVGFESpotLightElement,
  SVGFETileElement,
  SVGFETurbulenceElement,
  SVGFilterElement,
  SVGForeignObjectElement,
  SVGGElement,
  SVGGeometryElement,
  SVGGradientElement,
  SVGGraphicsElement,
  SVGImageElement,
  SVGLength,
  SVGLengthList,
  SVGLineElement,
  SVGLinearGradientElement,
  SVGMPathElement,
  SVGMarkerElement,
  SVGMaskElement,
  SVGMatrix,
  SVGMetadataElement,
  SVGNumber,
  SVGNumberList,
  SVGPathElement,
  SVGPathSeg,
  SVGPathSegArcAbs,
  SVGPathSegArcRel,
  SVGPathSegClosePath,
  SVGPathSegCurvetoCubicAbs,
  SVGPathSegCurvetoCubicRel,
  SVGPathSegCurvetoCubicSmoothAbs,
  SVGPathSegCurvetoCubicSmoothRel,
  SVGPathSegCurvetoQuadraticAbs,
  SVGPathSegCurvetoQuadraticRel,
  SVGPathSegCurvetoQuadraticSmoothAbs,
  SVGPathSegCurvetoQuadraticSmoothRel,
  SVGPathSegLinetoAbs,
  SVGPathSegLinetoHorizontalAbs,
  SVGPathSegLinetoHorizontalRel,
  SVGPathSegLinetoRel,
  SVGPathSegLinetoVerticalAbs,
  SVGPathSegLinetoVerticalRel,
  SVGPathSegList,
  SVGPathSegMovetoAbs,
  SVGPathSegMovetoRel,
  SVGPatternElement,
  SVGPoint,
  SVGPointList,
  SVGPolygonElement,
  SVGPolylineElement,
  SVGPreserveAspectRatio,
  SVGRadialGradientElement,
  SVGRect,
  SVGRectElement,
  SVGSVGElement,
  SVGScriptElement,
  SVGSetElement,
  SVGStopElement,
  SVGStringList,
  SVGStyleElement,
  SVGSwitchElement,
  SVGSymbolElement,
  SVGTSpanElement,
  SVGTextContentElement,
  SVGTextElement,
  SVGTextPathElement,
  SVGTextPositioningElement,
  SVGTitleElement,
  SVGTransform,
  SVGTransformList,
  SVGUseElement,
  SVGViewElement,
  ScopedCredential,
  ScopedCredentialInfo,
  Screen,
  ScreenOrientation,
  ScriptProcessorNode,
  ScrollAreaEvent,
  ScrollBoxObject,
  ScrollViewChangeEvent,
  Selection,
  ServiceWorker,
  ServiceWorkerContainer,
  ServiceWorkerGlobalScope,
  ServiceWorkerRegistration,
  ShadowRoot,
  SharedWorker,
  SharedWorkerGlobalScope,
  SimpleGestureEvent,
  SourceBuffer,
  SourceBufferList,
  SpeechGrammar,
  SpeechGrammarList,
  SpeechRecognition,
  SpeechRecognitionAlternative,
  SpeechRecognitionError,
  SpeechRecognitionEvent,
  SpeechRecognitionResult,
  SpeechRecognitionResultList,
  SpeechSynthesis,
  SpeechSynthesisErrorEvent,
  SpeechSynthesisEvent,
  SpeechSynthesisUtterance,
  SpeechSynthesisVoice,
  StereoPannerNode,
  Storage,
  StorageEvent,
  StorageManager,
  StyleRuleChangeEvent,
  StyleSheet,
  StyleSheetApplicableStateChangeEvent,
  StyleSheetChangeEvent,
  StyleSheetList,
  SubtleCrypto,
  TCPServerSocket,
  TCPServerSocketEvent,
  TCPSocket,
  TCPSocketErrorEvent,
  TCPSocketEvent,
  TestCImplementedInterface,
  TestCImplementedInterface2,
  TestChildInterface,
  TestCppKeywordNamedMethodsInterface,
  TestDeprecatedInterface,
  TestExampleInterface,
  TestExampleProxyInterface,
  TestExampleWorkerInterface,
  TestFunctions,
  TestHTMLConstructorInterface,
  TestIndexedAndNamedGetterAndSetterInterface,
  TestIndexedAndNamedGetterInterface,
  TestIndexedAndNamedSetterInterface,
  TestIndexedGetterAndSetterAndNamedGetterInterface,
  TestIndexedGetterInterface,
  TestIndexedSetterInterface,
  TestInterface,
  TestInterfaceIterableDouble,
  TestInterfaceIterableDoubleIterator,
  TestInterfaceIterableDoubleUnion,
  TestInterfaceIterableDoubleUnionIterator,
  TestInterfaceIterableSingle,
  TestInterfaceJS,
  TestInterfaceJSMaplike,
  TestInterfaceMaplike,
  TestInterfaceMaplikeObject,
  TestInterfaceSetlike,
  TestInterfaceSetlikeNode,
  TestInterfaceWithPromiseConstructorArg,
  TestJSImplInterface,
  TestJSImplInterface2,
  TestJSImplInterface3,
  TestJSImplInterface4,
  TestJSImplInterface5,
  TestJSImplInterface6,
  TestJSImplNoInterfaceObject,
  TestNamedDeleterInterface,
  TestNamedDeleterWithRetvalInterface,
  TestNamedGetterInterface,
  TestNamedSetterInterface,
  TestNavigator,
  TestNavigatorWithConstructor,
  TestNonWrapperCacheInterface,
  TestParentInterface,
  TestRenamedInterface,
  TestSecureContextInterface,
  TestWorkerExposedInterface,
  Text,
  TextClause,
  TextDecoder,
  TextEncoder,
  TextMetrics,
  TextTrack,
  TextTrackCue,
  TextTrackCueList,
  TextTrackList,
  TimeEvent,
  TimeRanges,
  Touch,
  TouchEvent,
  TouchList,
  TrackEvent,
  TransitionEvent,
  TreeBoxObject,
  TreeColumn,
  TreeColumns,
  TreeWalker,
  U2F,
  UDPMessageEvent,
  UDPSocket,
  UIEvent,
  URL,
  URLSearchParams,
  URLSearchParamsIterator,
  UserProximityEvent,
  VRDisplay,
  VRDisplayCapabilities,
  VRDisplayEvent,
  VREyeParameters,
  VRFieldOfView,
  VRFrameData,
  VRMockController,
  VRMockDisplay,
  VRPose,
  VRServiceTest,
  VRStageParameters,
  VTTCue,
  VTTRegion,
  ValidityState,
  VideoPlaybackQuality,
  VideoStreamTrack,
  VideoTrack,
  VideoTrackList,
  WEBGL_color_buffer_float,
  WEBGL_compressed_texture_astc,
  WEBGL_compressed_texture_atc,
  WEBGL_compressed_texture_etc,
  WEBGL_compressed_texture_etc1,
  WEBGL_compressed_texture_pvrtc,
  WEBGL_compressed_texture_s3tc,
  WEBGL_debug_renderer_info,
  WEBGL_debug_shaders,
  WEBGL_depth_texture,
  WEBGL_draw_buffers,
  WEBGL_lose_context,
  WaveShaperNode,
  WebAuthentication,
  WebAuthnAssertion,
  WebAuthnAttestation,
  WebGL2RenderingContext,
  WebGLActiveInfo,
  WebGLBuffer,
  WebGLContextEvent,
  WebGLFramebuffer,
  WebGLProgram,
  WebGLQuery,
  WebGLRenderbuffer,
  WebGLRenderingContext,
  WebGLSampler,
  WebGLShader,
  WebGLShaderPrecisionFormat,
  WebGLSync,
  WebGLTexture,
  WebGLTransformFeedback,
  WebGLUniformLocation,
  WebGLVertexArrayObject,
  WebKitCSSMatrix,
  WebSocket,
  WheelEvent,
  Window,
  WindowClient,
  WindowRoot,
  Worker,
  WorkerDebuggerGlobalScope,
  WorkerGlobalScope,
  WorkerLocation,
  WorkerNavigator,
  Worklet,
  WorkletGlobalScope,
  XMLDocument,
  XMLHttpRequest,
  XMLHttpRequestEventTarget,
  XMLHttpRequestUpload,
  XMLSerializer,
  XMLStylesheetProcessingInstruction,
  XPathEvaluator,
  XPathExpression,
  XPathResult,
  XSLTProcessor,
  XULCommandEvent,
  XULDocument,
  XULElement,
  mozRTCIceCandidate,
  mozRTCPeerConnection,
  mozRTCSessionDescription,
  _ID_Count
};

}

typedef id::ID ID;

static_assert(id::_ID_Count < (uint64_t(1) << (sizeof(((JSJitInfo*)nullptr)->protoID) * 8)), "Too many prototypes!");

}
}
}



static_assert(8 < (uint64_t(1) << (sizeof(((JSJitInfo*)nullptr)->depth) * 8)), "Some inheritance chain is too long!");

namespace mozilla {
namespace dom {
namespace constructors {

namespace id {

enum ID : uint16_t
{
  _ID_Start = prototypes::id::_ID_Count,
  AccessibleNode = _ID_Start,
  Addon,
  AddonEvent,
  AddonInstall,
  AddonManager,
  AddonManagerPermissions,
  AnalyserNode,
  Animation,
  AnimationEffectReadOnly,
  AnimationEffectTiming,
  AnimationEffectTimingReadOnly,
  AnimationEvent,
  AnimationPlaybackEvent,
  AnimationTimeline,
  AnonymousContent,
  Attr,
  AudioBuffer,
  AudioBufferSourceNode,
  AudioContext,
  AudioDestinationNode,
  AudioListener,
  AudioNode,
  AudioParam,
  AudioProcessingEvent,
  AudioScheduledSourceNode,
  AudioStreamTrack,
  AudioTrack,
  AudioTrackList,
  AudioWorkletGlobalScope,
  AutocompleteErrorEvent,
  BarProp,
  BaseAudioContext,
  BatteryManager,
  BeforeUnloadEvent,
  BiquadFilterNode,
  Blob,
  BlobEvent,
  BoxObject,
  BroadcastChannel,
  BrowserElementAudioChannel,
  BrowserFeedWriter,
  CDATASection,
  CSS,
  CSS2Properties,
  CSSAnimation,
  CSSConditionRule,
  CSSCounterStyleRule,
  CSSFontFaceRule,
  CSSFontFeatureValuesRule,
  CSSGroupingRule,
  CSSImportRule,
  CSSKeyframeRule,
  CSSKeyframesRule,
  CSSLexer,
  CSSMediaRule,
  CSSMozDocumentRule,
  CSSNamespaceRule,
  CSSPageRule,
  CSSPrimitiveValue,
  CSSPseudoElement,
  CSSRule,
  CSSRuleList,
  CSSStyleDeclaration,
  CSSStyleRule,
  CSSStyleSheet,
  CSSSupportsRule,
  CSSTransition,
  CSSValue,
  CSSValueList,
  Cache,
  CacheStorage,
  CanvasCaptureMediaStream,
  CanvasGradient,
  CanvasPattern,
  CanvasRenderingContext2D,
  CaretPosition,
  CaretStateChangedEvent,
  ChannelMergerNode,
  ChannelSplitterNode,
  CharacterData,
  CheckerboardReportService,
  ChromeNodeList,
  ChromeUtils,
  ChromeWindow,
  ChromeWorker,
  Client,
  Clients,
  ClipboardEvent,
  CloseEvent,
  CommandEvent,
  Comment,
  CompositionEvent,
  ConstantSourceNode,
  ConvolverNode,
  CreateOfferRequest,
  Crypto,
  CryptoKey,
  CustomElementRegistry,
  CustomEvent,
  DOMCursor,
  DOMError,
  DOMException,
  DOMImplementation,
  DOMMatrix,
  DOMMatrixReadOnly,
  DOMParser,
  DOMPoint,
  DOMPointReadOnly,
  DOMQuad,
  DOMRect,
  DOMRectList,
  DOMRectReadOnly,
  DOMRequest,
  DOMStringList,
  DOMStringMap,
  DOMTokenList,
  DataChannel,
  DataContainerEvent,
  DataTransfer,
  DataTransferItem,
  DataTransferItemList,
  DedicatedWorkerGlobalScope,
  DelayNode,
  DesktopNotification,
  DesktopNotificationCenter,
  DeviceLightEvent,
  DeviceMotionEvent,
  DeviceOrientationEvent,
  DeviceProximityEvent,
  Directory,
  Document,
  DocumentFragment,
  DocumentTimeline,
  DocumentType,
  DominatorTree,
  DragEvent,
  DynamicsCompressorNode,
  Element,
  ErrorEvent,
  Event,
  EventSource,
  EventTarget,
  ExtendableEvent,
  ExtendableMessageEvent,
  External,
  FetchController,
  FetchEvent,
  FetchObserver,
  FetchSignal,
  File,
  FileList,
  FileReader,
  FileReaderSync,
  FileSystem,
  FileSystemDirectoryEntry,
  FileSystemDirectoryReader,
  FileSystemEntry,
  FileSystemFileEntry,
  FlyWebDiscoveryManager,
  FlyWebFetchEvent,
  FlyWebPublishedServer,
  FlyWebWebSocketEvent,
  FocusEvent,
  FontFace,
  FontFaceSet,
  FontFaceSetLoadEvent,
  FormData,
  GainNode,
  Gamepad,
  GamepadAxisMoveEvent,
  GamepadButton,
  GamepadButtonEvent,
  GamepadEvent,
  GamepadHapticActuator,
  GamepadPose,
  GamepadServiceTest,
  Grid,
  GridArea,
  GridDimension,
  GridLine,
  GridLines,
  GridTrack,
  GridTracks,
  GroupedHistoryEvent,
  HTMLAllCollection,
  HTMLAnchorElement,
  HTMLAppletElement,
  HTMLAreaElement,
  HTMLAudioElement,
  HTMLBRElement,
  HTMLBaseElement,
  HTMLBodyElement,
  HTMLButtonElement,
  HTMLCanvasElement,
  HTMLCollection,
  HTMLContentElement,
  HTMLDListElement,
  HTMLDataElement,
  HTMLDataListElement,
  HTMLDetailsElement,
  HTMLDialogElement,
  HTMLDirectoryElement,
  HTMLDivElement,
  HTMLDocument,
  HTMLElement,
  HTMLEmbedElement,
  HTMLFieldSetElement,
  HTMLFontElement,
  HTMLFormControlsCollection,
  HTMLFormElement,
  HTMLFrameElement,
  HTMLFrameSetElement,
  HTMLHRElement,
  HTMLHeadElement,
  HTMLHeadingElement,
  HTMLHtmlElement,
  HTMLIFrameElement,
  HTMLImageElement,
  HTMLInputElement,
  HTMLLIElement,
  HTMLLabelElement,
  HTMLLegendElement,
  HTMLLinkElement,
  HTMLMapElement,
  HTMLMediaElement,
  HTMLMenuElement,
  HTMLMenuItemElement,
  HTMLMetaElement,
  HTMLMeterElement,
  HTMLModElement,
  HTMLOListElement,
  HTMLObjectElement,
  HTMLOptGroupElement,
  HTMLOptionElement,
  HTMLOptionsCollection,
  HTMLOutputElement,
  HTMLParagraphElement,
  HTMLParamElement,
  HTMLPictureElement,
  HTMLPreElement,
  HTMLProgressElement,
  HTMLQuoteElement,
  HTMLScriptElement,
  HTMLSelectElement,
  HTMLShadowElement,
  HTMLSourceElement,
  HTMLSpanElement,
  HTMLStyleElement,
  HTMLTableCaptionElement,
  HTMLTableCellElement,
  HTMLTableColElement,
  HTMLTableElement,
  HTMLTableRowElement,
  HTMLTableSectionElement,
  HTMLTemplateElement,
  HTMLTextAreaElement,
  HTMLTimeElement,
  HTMLTitleElement,
  HTMLTrackElement,
  HTMLUListElement,
  HTMLUnknownElement,
  HTMLVideoElement,
  HashChangeEvent,
  Headers,
  HeapSnapshot,
  HiddenPluginEvent,
  History,
  IDBCursor,
  IDBCursorWithValue,
  IDBDatabase,
  IDBFactory,
  IDBFileHandle,
  IDBFileRequest,
  IDBIndex,
  IDBKeyRange,
  IDBLocaleAwareKeyRange,
  IDBMutableFile,
  IDBObjectStore,
  IDBOpenDBRequest,
  IDBRequest,
  IDBTransaction,
  IDBVersionChangeEvent,
  IIRFilterNode,
  IdleDeadline,
  ImageBitmap,
  ImageBitmapRenderingContext,
  ImageCapture,
  ImageCaptureErrorEvent,
  ImageData,
  ImageDocument,
  InputEvent,
  InstallTriggerImpl,
  IntersectionObserver,
  IntersectionObserverEntry,
  KeyEvent,
  KeyboardEvent,
  KeyframeEffect,
  KeyframeEffectReadOnly,
  LocalMediaStream,
  Location,
  MediaDeviceInfo,
  MediaDevices,
  MediaElementAudioSourceNode,
  MediaEncryptedEvent,
  MediaError,
  MediaKeyError,
  MediaKeyMessageEvent,
  MediaKeySession,
  MediaKeyStatusMap,
  MediaKeySystemAccess,
  MediaKeys,
  MediaList,
  MediaQueryList,
  MediaRecorder,
  MediaSource,
  MediaStream,
  MediaStreamAudioDestinationNode,
  MediaStreamAudioSourceNode,
  MediaStreamEvent,
  MediaStreamList,
  MediaStreamTrack,
  MediaStreamTrackEvent,
  MenuBoxObject,
  MessageChannel,
  MessageEvent,
  MessagePort,
  MimeType,
  MimeTypeArray,
  MouseEvent,
  MouseScrollEvent,
  MozCanvasPrintState,
  MozPowerManager,
  MozSelfSupport,
  MozTimeManager,
  MozWakeLock,
  MutationEvent,
  MutationObserver,
  MutationRecord,
  NamedNodeMap,
  Navigator,
  NetworkInformation,
  Node,
  NodeFilter,
  NodeIterator,
  NodeList,
  Notification,
  NotificationEvent,
  NotifyPaintEvent,
  OfflineAudioCompletionEvent,
  OfflineAudioContext,
  OfflineResourceList,
  OffscreenCanvas,
  OnlyForUseInConstructor,
  OscillatorNode,
  PageTransitionEvent,
  PaintRequest,
  PaintRequestList,
  PaintWorkletGlobalScope,
  PannerNode,
  Path2D,
  PeerConnectionImpl,
  PeerConnectionObserver,
  Performance,
  PerformanceEntry,
  PerformanceEntryEvent,
  PerformanceMark,
  PerformanceMeasure,
  PerformanceNavigation,
  PerformanceObserver,
  PerformanceObserverEntryList,
  PerformanceResourceTiming,
  PerformanceTiming,
  PeriodicWave,
  PermissionStatus,
  Permissions,
  Plugin,
  PluginArray,
  PluginCrashedEvent,
  PointerEvent,
  PopStateEvent,
  PopupBlockedEvent,
  PopupBoxObject,
  PrecompiledScript,
  Presentation,
  PresentationAvailability,
  PresentationConnection,
  PresentationConnectionAvailableEvent,
  PresentationConnectionCloseEvent,
  PresentationConnectionList,
  PresentationDeviceInfoManager,
  PresentationReceiver,
  PresentationRequest,
  ProcessingInstruction,
  ProgressEvent,
  PromiseDebugging,
  PushEvent,
  PushManager,
  PushManagerImpl,
  PushMessageData,
  PushSubscription,
  PushSubscriptionOptions,
  RGBColor,
  RTCCertificate,
  RTCDTMFSender,
  RTCDTMFToneChangeEvent,
  RTCDataChannelEvent,
  RTCIceCandidate,
  RTCPeerConnection,
  RTCPeerConnectionIceEvent,
  RTCPeerConnectionStatic,
  RTCRtpReceiver,
  RTCRtpSender,
  RTCSessionDescription,
  RTCStatsReport,
  RTCTrackEvent,
  RadioNodeList,
  Range,
  RecordErrorEvent,
  Rect,
  Request,
  Response,
  SEChannel,
  SEReader,
  SEResponse,
  SESession,
  SVGAElement,
  SVGAngle,
  SVGAnimateElement,
  SVGAnimateMotionElement,
  SVGAnimateTransformElement,
  SVGAnimatedAngle,
  SVGAnimatedBoolean,
  SVGAnimatedEnumeration,
  SVGAnimatedInteger,
  SVGAnimatedLength,
  SVGAnimatedLengthList,
  SVGAnimatedNumber,
  SVGAnimatedNumberList,
  SVGAnimatedPreserveAspectRatio,
  SVGAnimatedRect,
  SVGAnimatedString,
  SVGAnimatedTransformList,
  SVGAnimationElement,
  SVGCircleElement,
  SVGClipPathElement,
  SVGComponentTransferFunctionElement,
  SVGDefsElement,
  SVGDescElement,
  SVGElement,
  SVGEllipseElement,
  SVGFEBlendElement,
  SVGFEColorMatrixElement,
  SVGFEComponentTransferElement,
  SVGFECompositeElement,
  SVGFEConvolveMatrixElement,
  SVGFEDiffuseLightingElement,
  SVGFEDisplacementMapElement,
  SVGFEDistantLightElement,
  SVGFEDropShadowElement,
  SVGFEFloodElement,
  SVGFEFuncAElement,
  SVGFEFuncBElement,
  SVGFEFuncGElement,
  SVGFEFuncRElement,
  SVGFEGaussianBlurElement,
  SVGFEImageElement,
  SVGFEMergeElement,
  SVGFEMergeNodeElement,
  SVGFEMorphologyElement,
  SVGFEOffsetElement,
  SVGFEPointLightElement,
  SVGFESpecularLightingElement,
  SVGFESpotLightElement,
  SVGFETileElement,
  SVGFETurbulenceElement,
  SVGFilterElement,
  SVGForeignObjectElement,
  SVGGElement,
  SVGGeometryElement,
  SVGGradientElement,
  SVGGraphicsElement,
  SVGImageElement,
  SVGLength,
  SVGLengthList,
  SVGLineElement,
  SVGLinearGradientElement,
  SVGMPathElement,
  SVGMarkerElement,
  SVGMaskElement,
  SVGMatrix,
  SVGMetadataElement,
  SVGNumber,
  SVGNumberList,
  SVGPathElement,
  SVGPathSeg,
  SVGPathSegArcAbs,
  SVGPathSegArcRel,
  SVGPathSegClosePath,
  SVGPathSegCurvetoCubicAbs,
  SVGPathSegCurvetoCubicRel,
  SVGPathSegCurvetoCubicSmoothAbs,
  SVGPathSegCurvetoCubicSmoothRel,
  SVGPathSegCurvetoQuadraticAbs,
  SVGPathSegCurvetoQuadraticRel,
  SVGPathSegCurvetoQuadraticSmoothAbs,
  SVGPathSegCurvetoQuadraticSmoothRel,
  SVGPathSegLinetoAbs,
  SVGPathSegLinetoHorizontalAbs,
  SVGPathSegLinetoHorizontalRel,
  SVGPathSegLinetoRel,
  SVGPathSegLinetoVerticalAbs,
  SVGPathSegLinetoVerticalRel,
  SVGPathSegList,
  SVGPathSegMovetoAbs,
  SVGPathSegMovetoRel,
  SVGPatternElement,
  SVGPoint,
  SVGPointList,
  SVGPolygonElement,
  SVGPolylineElement,
  SVGPreserveAspectRatio,
  SVGRadialGradientElement,
  SVGRect,
  SVGRectElement,
  SVGSVGElement,
  SVGScriptElement,
  SVGSetElement,
  SVGStopElement,
  SVGStringList,
  SVGStyleElement,
  SVGSwitchElement,
  SVGSymbolElement,
  SVGTSpanElement,
  SVGTextContentElement,
  SVGTextElement,
  SVGTextPathElement,
  SVGTextPositioningElement,
  SVGTitleElement,
  SVGTransform,
  SVGTransformList,
  SVGUnitTypes,
  SVGUseElement,
  SVGViewElement,
  SVGZoomAndPan,
  ScopedCredential,
  ScopedCredentialInfo,
  Screen,
  ScreenOrientation,
  ScriptProcessorNode,
  ScrollAreaEvent,
  ScrollViewChangeEvent,
  Selection,
  ServiceWorker,
  ServiceWorkerContainer,
  ServiceWorkerGlobalScope,
  ServiceWorkerRegistration,
  ShadowRoot,
  SharedWorker,
  SharedWorkerGlobalScope,
  SimpleGestureEvent,
  SourceBuffer,
  SourceBufferList,
  SpeechGrammar,
  SpeechGrammarList,
  SpeechRecognition,
  SpeechRecognitionAlternative,
  SpeechRecognitionError,
  SpeechRecognitionEvent,
  SpeechRecognitionResult,
  SpeechRecognitionResultList,
  SpeechSynthesis,
  SpeechSynthesisErrorEvent,
  SpeechSynthesisEvent,
  SpeechSynthesisUtterance,
  SpeechSynthesisVoice,
  StereoPannerNode,
  Storage,
  StorageEvent,
  StorageManager,
  StyleRuleChangeEvent,
  StyleSheet,
  StyleSheetApplicableStateChangeEvent,
  StyleSheetChangeEvent,
  StyleSheetList,
  SubtleCrypto,
  TCPServerSocket,
  TCPServerSocketEvent,
  TCPSocket,
  TCPSocketErrorEvent,
  TCPSocketEvent,
  TestCImplementedInterface,
  TestCImplementedInterface2,
  TestChildInterface,
  TestCppKeywordNamedMethodsInterface,
  TestDeprecatedInterface,
  TestExampleInterface,
  TestExampleProxyInterface,
  TestExampleWorkerInterface,
  TestFunctions,
  TestHTMLConstructorInterface,
  TestIndexedAndNamedGetterAndSetterInterface,
  TestIndexedAndNamedGetterInterface,
  TestIndexedAndNamedSetterInterface,
  TestIndexedGetterAndSetterAndNamedGetterInterface,
  TestIndexedGetterInterface,
  TestIndexedSetterInterface,
  TestInterface,
  TestInterfaceIterableDouble,
  TestInterfaceIterableDoubleUnion,
  TestInterfaceIterableSingle,
  TestInterfaceJS,
  TestInterfaceJSMaplike,
  TestInterfaceMaplike,
  TestInterfaceMaplikeObject,
  TestInterfaceSetlike,
  TestInterfaceSetlikeNode,
  TestInterfaceWithPromiseConstructorArg,
  TestJSImplInterface,
  TestJSImplInterface2,
  TestJSImplInterface3,
  TestJSImplInterface4,
  TestJSImplInterface5,
  TestJSImplInterface6,
  TestNamedDeleterInterface,
  TestNamedDeleterWithRetvalInterface,
  TestNamedGetterInterface,
  TestNamedSetterInterface,
  TestNamespace,
  TestNavigator,
  TestNavigatorWithConstructor,
  TestNonWrapperCacheInterface,
  TestParentInterface,
  TestProtoObjectHackedNamespace,
  TestRenamedInterface,
  TestRenamedNamespace,
  TestSecureContextInterface,
  TestWorkerExposedInterface,
  Text,
  TextClause,
  TextDecoder,
  TextEncoder,
  TextMetrics,
  TextTrack,
  TextTrackCue,
  TextTrackCueList,
  TextTrackList,
  ThreadSafeChromeUtils,
  TimeEvent,
  TimeRanges,
  Touch,
  TouchEvent,
  TouchList,
  TrackEvent,
  TransitionEvent,
  TreeColumn,
  TreeColumns,
  TreeWalker,
  U2F,
  UDPMessageEvent,
  UDPSocket,
  UIEvent,
  URL,
  URLSearchParams,
  UserProximityEvent,
  VRDisplay,
  VRDisplayCapabilities,
  VRDisplayEvent,
  VREyeParameters,
  VRFieldOfView,
  VRFrameData,
  VRMockController,
  VRMockDisplay,
  VRPose,
  VRServiceTest,
  VRStageParameters,
  VTTCue,
  VTTRegion,
  ValidityState,
  VideoPlaybackQuality,
  VideoStreamTrack,
  VideoTrack,
  VideoTrackList,
  WaveShaperNode,
  WebAuthentication,
  WebAuthnAssertion,
  WebAuthnAttestation,
  WebGL2RenderingContext,
  WebGLActiveInfo,
  WebGLBuffer,
  WebGLContextEvent,
  WebGLFramebuffer,
  WebGLProgram,
  WebGLQuery,
  WebGLRenderbuffer,
  WebGLRenderingContext,
  WebGLSampler,
  WebGLShader,
  WebGLShaderPrecisionFormat,
  WebGLSync,
  WebGLTexture,
  WebGLTransformFeedback,
  WebGLUniformLocation,
  WebGLVertexArrayObject,
  WebKitCSSMatrix,
  WebSocket,
  WebrtcGlobalInformation,
  WheelEvent,
  Window,
  WindowClient,
  WindowRoot,
  Worker,
  WorkerDebuggerGlobalScope,
  WorkerGlobalScope,
  WorkerLocation,
  WorkerNavigator,
  Worklet,
  WorkletGlobalScope,
  XMLDocument,
  XMLHttpRequest,
  XMLHttpRequestEventTarget,
  XMLHttpRequestUpload,
  XMLSerializer,
  XMLStylesheetProcessingInstruction,
  XPathEvaluator,
  XPathExpression,
  XPathResult,
  XSLTProcessor,
  XULCommandEvent,
  XULDocument,
  XULElement,
  console,
  mozRTCIceCandidate,
  mozRTCPeerConnection,
  mozRTCSessionDescription,
  _ID_Count
};

}

typedef id::ID ID;

}
}
}

namespace mozilla {
namespace dom {
namespace namedpropertiesobjects {

namespace id {

enum ID : uint16_t
{
  _ID_Start = constructors::id::_ID_Count,
  Window = _ID_Start,
  _ID_Count
};

}

typedef id::ID ID;

}
}
}

namespace mozilla {
namespace dom {
template <prototypes::ID PrototypeID>
struct PrototypeTraits;
template <>
struct PrototypeTraits<prototypes::id::ANGLE_instanced_arrays>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::AccessibleNode>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Addon>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::AddonEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::AddonInstall>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::AddonManager>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::AnalyserNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::Animation>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::AnimationEffectReadOnly>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::AnimationEffectTiming>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::AnimationEffectTimingReadOnly>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::AnimationEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::AnimationPlaybackEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::AnimationTimeline>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::AnonymousContent>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Attr>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::AudioBuffer>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::AudioBufferSourceNode>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::AudioContext>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::AudioDestinationNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::AudioListener>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::AudioNode>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::AudioParam>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::AudioProcessingEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::AudioScheduledSourceNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::AudioStreamTrack>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::AudioTrack>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::AudioTrackList>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::AudioWorkletGlobalScope>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::AutocompleteErrorEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::BarProp>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::BaseAudioContext>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::BatteryManager>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::BeforeUnloadEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::BiquadFilterNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::Blob>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::BlobEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::BoxObject>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::BroadcastChannel>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::BrowserElementAudioChannel>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::BrowserFeedWriter>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CDATASection>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSS2Properties>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSAnimation>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSConditionRule>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSCounterStyleRule>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSFontFaceRule>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSFontFeatureValuesRule>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSGroupingRule>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSImportRule>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSKeyframeRule>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSKeyframesRule>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSLexer>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSMediaRule>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSMozDocumentRule>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSNamespaceRule>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSPageRule>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSPrimitiveValue>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSPseudoElement>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSRule>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSRuleList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSStyleDeclaration>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSStyleRule>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSStyleSheet>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSSupportsRule>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSTransition>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSValue>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CSSValueList>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::Cache>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CacheStorage>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CanvasCaptureMediaStream>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::CanvasGradient>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CanvasPattern>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CanvasRenderingContext2D>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CaretPosition>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CaretStateChangedEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::ChannelMergerNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::ChannelSplitterNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::CharacterData>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::CheckerboardReportService>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::ChromeNodeList>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::ChromeWorker>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::Client>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Clients>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::ClipboardEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CloseEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::CommandEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::Comment>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::CompositionEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::ConstantSourceNode>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::ContainerBoxObject>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::ConvolverNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::Coordinates>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CreateOfferRequest>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Crypto>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CryptoKey>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CustomElementRegistry>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::CustomEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMCursor>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMError>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMException>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMImplementation>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMMatrix>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMMatrixReadOnly>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMParser>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMPoint>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMPointReadOnly>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMQuad>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMRect>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMRectList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMRectReadOnly>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMRequest>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMStringList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMStringMap>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DOMTokenList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DataChannel>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::DataContainerEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::DataTransfer>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DataTransferItem>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DataTransferItemList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DedicatedWorkerGlobalScope>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::DelayNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::DesktopNotification>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::DesktopNotificationCenter>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DeviceAcceleration>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DeviceLightEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::DeviceMotionEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::DeviceOrientationEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::DeviceProximityEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::DeviceRotationRate>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Directory>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Document>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::DocumentFragment>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::DocumentTimeline>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::DocumentType>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::DominatorTree>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::DragEvent>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::DynamicsCompressorNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::EXT_blend_minmax>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::EXT_color_buffer_float>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::EXT_color_buffer_half_float>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::EXT_disjoint_timer_query>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::EXT_frag_depth>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::EXT_sRGB>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::EXT_shader_texture_lod>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::EXT_texture_filter_anisotropic>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Element>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::ErrorEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::Event>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::EventSource>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::EventTarget>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Exception>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::ExtendableEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::ExtendableMessageEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::External>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::FetchController>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::FetchEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::FetchObserver>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::FetchSignal>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::File>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::FileList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::FileReader>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::FileReaderSync>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::FileSystem>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::FileSystemDirectoryEntry>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::FileSystemDirectoryReader>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::FileSystemEntry>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::FileSystemFileEntry>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::FlyWebDiscoveryManager>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::FlyWebFetchEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::FlyWebPublishedServer>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::FlyWebWebSocketEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::FocusEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::FontFace>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::FontFaceSet>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::FontFaceSetIterator>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::FontFaceSetLoadEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::FormData>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::FormDataIterator>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::GainNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::Gamepad>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::GamepadAxisMoveEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::GamepadButton>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::GamepadButtonEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::GamepadEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::GamepadHapticActuator>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::GamepadPose>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::GamepadServiceTest>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Geolocation>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::GetUserMediaRequest>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Grid>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::GridArea>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::GridDimension>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::GridLine>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::GridLines>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::GridTrack>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::GridTracks>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::GroupedHistoryEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLAllCollection>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLAnchorElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLAppletElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLAreaElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLAudioElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLBRElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLBaseElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLBodyElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLButtonElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLCanvasElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLCollection>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLContentElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLDListElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLDataElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLDataListElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLDetailsElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLDialogElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLDirectoryElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLDivElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLDocument>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLElement>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLEmbedElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLFieldSetElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLFontElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLFormControlsCollection>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLFormElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLFrameElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLFrameSetElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLHRElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLHeadElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLHeadingElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLHtmlElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLIFrameElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLImageElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLInputElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLLIElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLLabelElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLLegendElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLLinkElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLMapElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLMediaElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLMenuElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLMenuItemElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLMetaElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLMeterElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLModElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLOListElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLObjectElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLOptGroupElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLOptionElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLOptionsCollection>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLOutputElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLParagraphElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLParamElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLPictureElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLPreElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLProgressElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLQuoteElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLScriptElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLSelectElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLShadowElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLSourceElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLSpanElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLStyleElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLTableCaptionElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLTableCellElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLTableColElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLTableElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLTableRowElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLTableSectionElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLTemplateElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLTextAreaElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLTimeElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLTitleElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLTrackElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLUListElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLUnknownElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::HTMLVideoElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::HashChangeEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::Headers>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::HeadersIterator>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::HeapSnapshot>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::HiddenPluginEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::History>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBCursor>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBCursorWithValue>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBDatabase>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBFactory>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBFileHandle>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBFileRequest>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBIndex>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBKeyRange>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBLocaleAwareKeyRange>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBMutableFile>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBObjectStore>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBOpenDBRequest>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBRequest>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBTransaction>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::IDBVersionChangeEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::IIRFilterNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::IdleDeadline>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::ImageBitmap>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::ImageBitmapRenderingContext>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::ImageCapture>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::ImageCaptureError>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::ImageCaptureErrorEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::ImageData>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::ImageDocument>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::InputEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::InstallTriggerImpl>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::IntersectionObserver>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::IntersectionObserverEntry>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::IntlUtils>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::KeyboardEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::KeyframeEffect>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::KeyframeEffectReadOnly>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::LegacyMozTCPSocket>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::ListBoxObject>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::LocalMediaStream>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::Location>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MOZ_debug_get>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaDeviceInfo>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaDevices>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaElementAudioSourceNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaEncryptedEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaError>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaKeyError>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaKeyMessageEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaKeySession>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaKeyStatusMap>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaKeyStatusMapIterator>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaKeySystemAccess>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaKeys>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaQueryList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaRecorder>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaSource>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaStream>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaStreamAudioDestinationNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaStreamAudioSourceNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaStreamError>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaStreamEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaStreamList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaStreamTrack>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MediaStreamTrackEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MenuBoxObject>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MessageChannel>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MessageEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MessagePort>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MimeType>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MimeTypeArray>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MouseEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::MouseScrollEvent>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::MozCanvasPrintState>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MozPowerManager>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MozSelfSupport>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MozTimeManager>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MozWakeLock>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MutationEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::MutationObserver>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::MutationRecord>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::NamedNodeMap>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Navigator>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::NetworkInformation>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::Node>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::NodeIterator>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::NodeList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Notification>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::NotificationEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::NotifyPaintEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::OES_element_index_uint>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::OES_standard_derivatives>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::OES_texture_float>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::OES_texture_float_linear>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::OES_texture_half_float>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::OES_texture_half_float_linear>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::OES_vertex_array_object>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::OfflineAudioCompletionEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::OfflineAudioContext>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::OfflineResourceList>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::OffscreenCanvas>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::OnlyForUseInConstructor>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::OscillatorNode>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::PageTransitionEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PaintRequest>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PaintRequestList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PaintWorkletGlobalScope>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PannerNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::Path2D>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PeerConnectionImpl>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PeerConnectionObserver>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Performance>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PerformanceEntry>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PerformanceEntryEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PerformanceMark>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PerformanceMeasure>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PerformanceNavigation>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PerformanceObserver>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PerformanceObserverEntryList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PerformanceResourceTiming>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PerformanceTiming>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PeriodicWave>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PermissionStatus>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::Permissions>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Plugin>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PluginArray>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PluginCrashedEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PointerEvent>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::PopStateEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PopupBlockedEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PopupBoxObject>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::Position>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PositionError>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PrecompiledScript>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Presentation>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PresentationAvailability>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PresentationConnection>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PresentationConnectionAvailableEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PresentationConnectionCloseEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PresentationConnectionList>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PresentationDeviceInfoManager>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PresentationReceiver>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PresentationRequest>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::ProcessingInstruction>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::ProgressEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::PromiseNativeHandler>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PushEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::PushManager>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PushManagerImpl>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PushMessageData>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PushSubscription>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::PushSubscriptionOptions>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::RGBColor>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::RTCCertificate>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::RTCDTMFSender>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::RTCDTMFToneChangeEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::RTCDataChannelEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::RTCIceCandidate>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::RTCIdentityProviderRegistrar>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::RTCPeerConnection>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::RTCPeerConnectionIceEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::RTCPeerConnectionStatic>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::RTCRtpReceiver>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::RTCRtpSender>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::RTCSessionDescription>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::RTCStatsReport>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::RTCTrackEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::RadioNodeList>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::Range>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::RecordErrorEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::Rect>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Request>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Response>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SEChannel>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SEManager>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SEReader>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SEResponse>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SESession>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAngle>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimateElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimateMotionElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimateTransformElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimatedAngle>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimatedBoolean>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimatedEnumeration>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimatedInteger>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimatedLength>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimatedLengthList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimatedNumber>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimatedNumberList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimatedPreserveAspectRatio>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimatedRect>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimatedString>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimatedTransformList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGAnimationElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGCircleElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGClipPathElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGComponentTransferFunctionElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGDefsElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGDescElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGElement>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGEllipseElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEBlendElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEColorMatrixElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEComponentTransferElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFECompositeElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEConvolveMatrixElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEDiffuseLightingElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEDisplacementMapElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEDistantLightElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEDropShadowElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEFloodElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEFuncAElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEFuncBElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEFuncGElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEFuncRElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEGaussianBlurElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEImageElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEMergeElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEMergeNodeElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEMorphologyElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEOffsetElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFEPointLightElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFESpecularLightingElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFESpotLightElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFETileElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFETurbulenceElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGFilterElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGForeignObjectElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGGElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGGeometryElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGGradientElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGGraphicsElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGImageElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGLength>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGLengthList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGLineElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGLinearGradientElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGMPathElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGMarkerElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGMaskElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGMatrix>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGMetadataElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGNumber>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGNumberList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathElement>
{
  enum
  {
    Depth = 6
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSeg>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegArcAbs>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegArcRel>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegClosePath>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicAbs>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicRel>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothAbs>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothRel>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticAbs>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticRel>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticSmoothAbs>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticSmoothRel>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegLinetoAbs>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegLinetoHorizontalAbs>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegLinetoHorizontalRel>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegLinetoRel>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegLinetoVerticalAbs>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegLinetoVerticalRel>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegMovetoAbs>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPathSegMovetoRel>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPatternElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPoint>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPointList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPolygonElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPolylineElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGPreserveAspectRatio>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGRadialGradientElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGRect>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGRectElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGSVGElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGScriptElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGSetElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGStopElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGStringList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGStyleElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGSwitchElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGSymbolElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGTSpanElement>
{
  enum
  {
    Depth = 7
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGTextContentElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGTextElement>
{
  enum
  {
    Depth = 7
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGTextPathElement>
{
  enum
  {
    Depth = 6
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGTextPositioningElement>
{
  enum
  {
    Depth = 6
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGTitleElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGTransform>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGTransformList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGUseElement>
{
  enum
  {
    Depth = 5
  };
};
template <>
struct PrototypeTraits<prototypes::id::SVGViewElement>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::ScopedCredential>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::ScopedCredentialInfo>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Screen>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::ScreenOrientation>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::ScriptProcessorNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::ScrollAreaEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::ScrollBoxObject>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::ScrollViewChangeEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::Selection>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::ServiceWorker>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::ServiceWorkerContainer>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::ServiceWorkerGlobalScope>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::ServiceWorkerRegistration>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::ShadowRoot>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::SharedWorker>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SharedWorkerGlobalScope>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::SimpleGestureEvent>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::SourceBuffer>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SourceBufferList>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SpeechGrammar>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SpeechGrammarList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SpeechRecognition>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SpeechRecognitionAlternative>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SpeechRecognitionError>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SpeechRecognitionEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SpeechRecognitionResult>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SpeechRecognitionResultList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SpeechSynthesis>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SpeechSynthesisErrorEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::SpeechSynthesisEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SpeechSynthesisUtterance>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::SpeechSynthesisVoice>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::StereoPannerNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::Storage>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::StorageEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::StorageManager>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::StyleRuleChangeEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::StyleSheet>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::StyleSheetApplicableStateChangeEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::StyleSheetChangeEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::StyleSheetList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::SubtleCrypto>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TCPServerSocket>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TCPServerSocketEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TCPSocket>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TCPSocketErrorEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TCPSocketEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestCImplementedInterface>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestCImplementedInterface2>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestChildInterface>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestCppKeywordNamedMethodsInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestDeprecatedInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestExampleInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestExampleProxyInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestExampleWorkerInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestFunctions>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestHTMLConstructorInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterAndSetterInterface>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedAndNamedSetterInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedGetterInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedSetterInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestInterfaceIterableDouble>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestInterfaceIterableDoubleIterator>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestInterfaceIterableDoubleUnion>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestInterfaceIterableDoubleUnionIterator>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestInterfaceIterableSingle>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestInterfaceJS>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestInterfaceJSMaplike>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestInterfaceMaplike>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestInterfaceMaplikeObject>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestInterfaceSetlike>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestInterfaceSetlikeNode>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestInterfaceWithPromiseConstructorArg>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestJSImplInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestJSImplInterface2>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestJSImplInterface3>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestJSImplInterface4>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestJSImplInterface5>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestJSImplInterface6>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestJSImplNoInterfaceObject>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestNamedDeleterInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestNamedDeleterWithRetvalInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestNamedGetterInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestNamedSetterInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestNavigator>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestNavigatorWithConstructor>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestNonWrapperCacheInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestParentInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestRenamedInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestSecureContextInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TestWorkerExposedInterface>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Text>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::TextClause>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TextDecoder>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TextEncoder>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TextMetrics>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TextTrack>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TextTrackCue>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TextTrackCueList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TextTrackList>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TimeEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TimeRanges>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Touch>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TouchEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::TouchList>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TrackEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TransitionEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TreeBoxObject>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::TreeColumn>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TreeColumns>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::TreeWalker>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::U2F>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::UDPMessageEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::UDPSocket>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::UIEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::URL>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::URLSearchParams>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::URLSearchParamsIterator>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::UserProximityEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::VRDisplay>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::VRDisplayCapabilities>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::VRDisplayEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::VREyeParameters>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::VRFieldOfView>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::VRFrameData>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::VRMockController>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::VRMockDisplay>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::VRPose>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::VRServiceTest>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::VRStageParameters>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::VTTCue>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::VTTRegion>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::ValidityState>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::VideoPlaybackQuality>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::VideoStreamTrack>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::VideoTrack>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::VideoTrackList>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::WEBGL_color_buffer_float>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WEBGL_compressed_texture_astc>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WEBGL_compressed_texture_atc>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WEBGL_compressed_texture_etc>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WEBGL_compressed_texture_etc1>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WEBGL_compressed_texture_pvrtc>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WEBGL_compressed_texture_s3tc>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WEBGL_debug_renderer_info>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WEBGL_debug_shaders>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WEBGL_depth_texture>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WEBGL_draw_buffers>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WEBGL_lose_context>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WaveShaperNode>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebAuthentication>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebAuthnAssertion>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebAuthnAttestation>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGL2RenderingContext>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLActiveInfo>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLBuffer>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLContextEvent>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLFramebuffer>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLProgram>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLQuery>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLRenderbuffer>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLRenderingContext>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLSampler>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLShader>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLShaderPrecisionFormat>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLSync>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLTexture>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLTransformFeedback>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLUniformLocation>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebGLVertexArrayObject>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebKitCSSMatrix>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::WebSocket>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::WheelEvent>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::Window>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::WindowClient>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::WindowRoot>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::Worker>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::WorkerDebuggerGlobalScope>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::WorkerGlobalScope>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::WorkerLocation>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WorkerNavigator>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::Worklet>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::WorkletGlobalScope>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::XMLDocument>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::XMLHttpRequest>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::XMLHttpRequestUpload>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::XMLSerializer>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::XMLStylesheetProcessingInstruction>
{
  enum
  {
    Depth = 4
  };
};
template <>
struct PrototypeTraits<prototypes::id::XPathEvaluator>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::XPathExpression>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::XPathResult>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::XSLTProcessor>
{
  enum
  {
    Depth = 0
  };
};
template <>
struct PrototypeTraits<prototypes::id::XULCommandEvent>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::XULDocument>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::XULElement>
{
  enum
  {
    Depth = 3
  };
};
template <>
struct PrototypeTraits<prototypes::id::mozRTCIceCandidate>
{
  enum
  {
    Depth = 1
  };
};
template <>
struct PrototypeTraits<prototypes::id::mozRTCPeerConnection>
{
  enum
  {
    Depth = 2
  };
};
template <>
struct PrototypeTraits<prototypes::id::mozRTCSessionDescription>
{
  enum
  {
    Depth = 1
  };
};
extern const char *NamesOfInterfacesWithProtos(unsigned int aIndex);
}
}



class nsCycleCollectionParticipant;
namespace mozilla {
namespace dom {
inline bool
IsSecureContextOrObjectIsFromSecureContext(JSContext* aCx, JSObject* aObj)
{
  return JS::CompartmentCreationOptionsRef(js::GetContextCompartment(aCx)).secureContext() ||
         JS::CompartmentCreationOptionsRef(js::GetObjectCompartment(aObj)).secureContext();
}

typedef bool
(* ResolveOwnProperty)(JSContext* cx, JS::Handle<JSObject*> wrapper,
                       JS::Handle<JSObject*> obj, JS::Handle<jsid> id,
                       JS::MutableHandle<JS::PropertyDescriptor> desc);

typedef bool
(* EnumerateOwnProperties)(JSContext* cx, JS::Handle<JSObject*> wrapper,
                           JS::Handle<JSObject*> obj,
                           JS::AutoIdVector& props);

typedef bool
(* DeleteNamedProperty)(JSContext* cx, JS::Handle<JSObject*> wrapper,
                        JS::Handle<JSObject*> obj, JS::Handle<jsid> id,
                        JS::ObjectOpResult& opresult);



bool
IsNonExposedGlobal(JSContext* aCx, JSObject* aGlobal,
                   uint32_t aNonExposedGlobals);

struct ConstantSpec
{
  const char* name;
  JS::Value value;
};

typedef bool (*PropertyEnabled)(JSContext* cx, JSObject* global);

namespace GlobalNames {



static const uint32_t Window = 1u << 0;
static const uint32_t BackstagePass = 1u << 1;
static const uint32_t DedicatedWorkerGlobalScope = 1u << 2;
static const uint32_t SharedWorkerGlobalScope = 1u << 3;
static const uint32_t ServiceWorkerGlobalScope = 1u << 4;
static const uint32_t WorkerDebuggerGlobalScope = 1u << 5;
static const uint32_t WorkletGlobalScope = 1u << 6;
}

struct PrefableDisablers {
  inline bool isEnabled(JSContext* cx, JS::Handle<JSObject*> obj) const {
    if (nonExposedGlobals &&
        IsNonExposedGlobal(cx, js::GetGlobalForObjectCrossCompartment(obj),
                           nonExposedGlobals)) {
      return false;
    }
    if (!enabled) {
      return false;
    }
    if (secureContext && !IsSecureContextOrObjectIsFromSecureContext(cx, obj)) {
      return false;
    }
    if (enabledFunc &&
        !enabledFunc(cx, js::GetGlobalForObjectCrossCompartment(obj))) {
      return false;
    }
    return true;
  }



  bool enabled;


  const bool secureContext;


  const uint16_t nonExposedGlobals;




  const PropertyEnabled enabledFunc;
};

template<typename T>
struct Prefable {
  inline bool isEnabled(JSContext* cx, JS::Handle<JSObject*> obj) const {
    if ((__builtin_expect(!!(!disablers), 1))) {
      return true;
    }
    return disablers->isEnabled(cx, obj);
  }



  PrefableDisablers* const disablers;




  const T* const specs;
};
template <int N>
struct NativePropertiesN {




  struct Trio {
    const void* const mPrefables;
    const jsid* const mIds;
    const void* const mSpecs;
  };

  const int32_t iteratorAliasMethodIndex;

  constexpr const NativePropertiesN<7>* Upcast() const {
    return reinterpret_cast<const NativePropertiesN<7>*>(this);
  }
  public: const uint32_t mHasStaticMethods:1; const uint32_t mStaticMethodsOffset:3; private: const Trio* StaticMethodsTrio() const { do { } while (0); return &trios[mStaticMethodsOffset]; } public: bool HasStaticMethods() const { return mHasStaticMethods; } const Prefable<const JSFunctionSpec>* StaticMethods() const { return static_cast<const Prefable<const JSFunctionSpec>*> ( StaticMethodsTrio()->mPrefables); } const jsid* StaticMethodIds() const { return StaticMethodsTrio()->mIds; } const JSFunctionSpec* StaticMethodSpecs() const { return static_cast<const JSFunctionSpec*>( StaticMethodsTrio()->mSpecs); }
  public: const uint32_t mHasStaticAttributes:1; const uint32_t mStaticAttributesOffset:3; private: const Trio* StaticAttributesTrio() const { do { } while (0); return &trios[mStaticAttributesOffset]; } public: bool HasStaticAttributes() const { return mHasStaticAttributes; } const Prefable<const JSPropertySpec>* StaticAttributes() const { return static_cast<const Prefable<const JSPropertySpec>*> ( StaticAttributesTrio()->mPrefables); } const jsid* StaticAttributeIds() const { return StaticAttributesTrio()->mIds; } const JSPropertySpec* StaticAttributeSpecs() const { return static_cast<const JSPropertySpec*>( StaticAttributesTrio()->mSpecs); }
  public: const uint32_t mHasMethods:1; const uint32_t mMethodsOffset:3; private: const Trio* MethodsTrio() const { do { } while (0); return &trios[mMethodsOffset]; } public: bool HasMethods() const { return mHasMethods; } const Prefable<const JSFunctionSpec>* Methods() const { return static_cast<const Prefable<const JSFunctionSpec>*> ( MethodsTrio()->mPrefables); } const jsid* MethodIds() const { return MethodsTrio()->mIds; } const JSFunctionSpec* MethodSpecs() const { return static_cast<const JSFunctionSpec*>( MethodsTrio()->mSpecs); }
  public: const uint32_t mHasAttributes:1; const uint32_t mAttributesOffset:3; private: const Trio* AttributesTrio() const { do { } while (0); return &trios[mAttributesOffset]; } public: bool HasAttributes() const { return mHasAttributes; } const Prefable<const JSPropertySpec>* Attributes() const { return static_cast<const Prefable<const JSPropertySpec>*> ( AttributesTrio()->mPrefables); } const jsid* AttributeIds() const { return AttributesTrio()->mIds; } const JSPropertySpec* AttributeSpecs() const { return static_cast<const JSPropertySpec*>( AttributesTrio()->mSpecs); }
  public: const uint32_t mHasUnforgeableMethods:1; const uint32_t mUnforgeableMethodsOffset:3; private: const Trio* UnforgeableMethodsTrio() const { do { } while (0); return &trios[mUnforgeableMethodsOffset]; } public: bool HasUnforgeableMethods() const { return mHasUnforgeableMethods; } const Prefable<const JSFunctionSpec>* UnforgeableMethods() const { return static_cast<const Prefable<const JSFunctionSpec>*> ( UnforgeableMethodsTrio()->mPrefables); } const jsid* UnforgeableMethodIds() const { return UnforgeableMethodsTrio()->mIds; } const JSFunctionSpec* UnforgeableMethodSpecs() const { return static_cast<const JSFunctionSpec*>( UnforgeableMethodsTrio()->mSpecs); }
  public: const uint32_t mHasUnforgeableAttributes:1; const uint32_t mUnforgeableAttributesOffset:3; private: const Trio* UnforgeableAttributesTrio() const { do { } while (0); return &trios[mUnforgeableAttributesOffset]; } public: bool HasUnforgeableAttributes() const { return mHasUnforgeableAttributes; } const Prefable<const JSPropertySpec>* UnforgeableAttributes() const { return static_cast<const Prefable<const JSPropertySpec>*> ( UnforgeableAttributesTrio()->mPrefables); } const jsid* UnforgeableAttributeIds() const { return UnforgeableAttributesTrio()->mIds; } const JSPropertySpec* UnforgeableAttributeSpecs() const { return static_cast<const JSPropertySpec*>( UnforgeableAttributesTrio()->mSpecs); }
  public: const uint32_t mHasConstants:1; const uint32_t mConstantsOffset:3; private: const Trio* ConstantsTrio() const { do { } while (0); return &trios[mConstantsOffset]; } public: bool HasConstants() const { return mHasConstants; } const Prefable<const ConstantSpec>* Constants() const { return static_cast<const Prefable<const ConstantSpec>*> ( ConstantsTrio()->mPrefables); } const jsid* ConstantIds() const { return ConstantsTrio()->mIds; } const ConstantSpec* ConstantSpecs() const { return static_cast<const ConstantSpec*>( ConstantsTrio()->mSpecs); }



  const Trio trios[N];
};



static_assert(sizeof(NativePropertiesN<1>) == 8 + 3*sizeof(void*), "1 size");
static_assert(sizeof(NativePropertiesN<2>) == 8 + 6*sizeof(void*), "2 size");
static_assert(sizeof(NativePropertiesN<3>) == 8 + 9*sizeof(void*), "3 size");
static_assert(sizeof(NativePropertiesN<4>) == 8 + 12*sizeof(void*), "4 size");
static_assert(sizeof(NativePropertiesN<5>) == 8 + 15*sizeof(void*), "5 size");
static_assert(sizeof(NativePropertiesN<6>) == 8 + 18*sizeof(void*), "6 size");
static_assert(sizeof(NativePropertiesN<7>) == 8 + 21*sizeof(void*), "7 size");


typedef NativePropertiesN<7> NativeProperties;

struct NativePropertiesHolder
{
  const NativeProperties* regular;
  const NativeProperties* chromeOnly;
};




struct NativePropertyHooks
{


  ResolveOwnProperty mResolveOwnProperty;


  EnumerateOwnProperties mEnumerateOwnProperties;
  DeleteNamedProperty mDeleteNamedProperty;


  NativePropertiesHolder mNativeProperties;




  prototypes::ID mPrototypeID;




  constructors::ID mConstructorID;



  const NativePropertyHooks* mProtoHooks;



  const JSClass* mXrayExpandoClass;
};

enum DOMObjectType : uint8_t {
  eInstance,
  eGlobalInstance,
  eInterface,
  eInterfacePrototype,
  eGlobalInterfacePrototype,
  eNamedPropertiesObject
};

inline
bool
IsInstance(DOMObjectType type)
{
  return type == eInstance || type == eGlobalInstance;
}

inline
bool
IsInterfacePrototype(DOMObjectType type)
{
  return type == eInterfacePrototype || type == eGlobalInterfacePrototype;
}

typedef JSObject* (*AssociatedGlobalGetter)(JSContext* aCx,
                                            JS::Handle<JSObject*> aObj);

typedef JSObject* (*ProtoGetter)(JSContext* aCx);
typedef JS::Handle<JSObject*> (*ProtoHandleGetter)(JSContext* aCx);


struct DOMJSClass
{



  const js::Class mBase;



  const prototypes::ID mInterfaceChain[8];





  const bool mDOMObjectIsISupports;

  const NativePropertyHooks* mNativeHooks;




  AssociatedGlobalGetter mGetAssociatedGlobal;
  ProtoHandleGetter mGetProto;




  nsCycleCollectionParticipant* mParticipant;

  static const DOMJSClass* FromJSClass(const JSClass* base) {
    do { } while (0);
    return reinterpret_cast<const DOMJSClass*>(base);
  }

  static const DOMJSClass* FromJSClass(const js::Class* base) {
    return FromJSClass(Jsvalify(base));
  }

  const JSClass* ToJSClass() const { return Jsvalify(&mBase); }
};


struct DOMIfaceAndProtoJSClass
{




  const js::Class mBase;



  DOMObjectType mType;




  bool wantsInterfaceHasInstance;

  const prototypes::ID mPrototypeID;
  const uint32_t mDepth;

  const NativePropertyHooks* mNativeHooks;



  const char* mToString;

  ProtoGetter mGetParentProto;

  static const DOMIfaceAndProtoJSClass* FromJSClass(const JSClass* base) {
    do { } while (0);
    return reinterpret_cast<const DOMIfaceAndProtoJSClass*>(base);
  }
  static const DOMIfaceAndProtoJSClass* FromJSClass(const js::Class* base) {
    return FromJSClass(Jsvalify(base));
  }

  const JSClass* ToJSClass() const { return Jsvalify(&mBase); }
};

class ProtoAndIfaceCache;

inline bool
DOMGlobalHasProtoAndIFaceCache(JSObject* global)
{
  do { } while (0);

  return !js::GetReservedSlot(global, (5 + JSProto_LIMIT * 2 + 46)).isUndefined();
}

inline bool
HasProtoAndIfaceCache(JSObject* global)
{
  if (!(js::GetObjectClass(global)->flags & (1<<7))) {
    return false;
  }
  return DOMGlobalHasProtoAndIFaceCache(global);
}

inline ProtoAndIfaceCache*
GetProtoAndIfaceCache(JSObject* global)
{
  do { } while (0);
  return static_cast<ProtoAndIfaceCache*>(
    js::GetReservedSlot(global, (5 + JSProto_LIMIT * 2 + 46)).toPrivate());
}

}
}
namespace mozilla {
namespace dom {

enum {
  JSPROXYSLOT_EXPANDO = 0
};

template<typename T> struct Prefable;

class BaseDOMProxyHandler : public js::BaseProxyHandler
{
public:
  explicit constexpr BaseDOMProxyHandler(const void* aProxyFamily, bool aHasPrototype = false)
    : js::BaseProxyHandler(aProxyFamily, aHasPrototype)
  {}



  bool getOwnPropertyDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy,
                                JS::Handle<jsid> id,
                                JS::MutableHandle<JS::PropertyDescriptor> desc) const override;
  virtual bool ownPropertyKeys(JSContext* cx, JS::Handle<JSObject*> proxy,
                               JS::AutoIdVector &props) const override;

  virtual bool getPrototypeIfOrdinary(JSContext* cx, JS::Handle<JSObject*> proxy,
                                      bool* isOrdinary,
                                      JS::MutableHandle<JSObject*> proto) const override;





  virtual bool getOwnEnumerablePropertyKeys(JSContext* cx, JS::Handle<JSObject*> proxy,
                                            JS::AutoIdVector &props) const override;

  bool watch(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id,
             JS::Handle<JSObject*> callable) const override;
  bool unwatch(JSContext* cx, JS::Handle<JSObject*> proxy,
               JS::Handle<jsid> id) const override;

protected:




  virtual bool ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy,
                            unsigned flags,
                            JS::AutoIdVector& props) const = 0;





  virtual bool getOwnPropDescriptor(JSContext* cx,
                                    JS::Handle<JSObject*> proxy,
                                    JS::Handle<jsid> id,
                                    bool ignoreNamedProps,
                                    JS::MutableHandle<JS::PropertyDescriptor> desc) const = 0;
};

class DOMProxyHandler : public BaseDOMProxyHandler
{
public:
  constexpr DOMProxyHandler()
    : BaseDOMProxyHandler(&family)
  {}

  bool defineProperty(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id,
                      JS::Handle<JS::PropertyDescriptor> desc,
                      JS::ObjectOpResult &result) const override
  {
    bool unused;
    return defineProperty(cx, proxy, id, desc, result, &unused);
  }
  virtual bool defineProperty(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id,
                              JS::Handle<JS::PropertyDescriptor> desc,
                              JS::ObjectOpResult &result, bool *defined) const;
  bool delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id,
               JS::ObjectOpResult &result) const override;
  bool preventExtensions(JSContext* cx, JS::Handle<JSObject*> proxy,
                         JS::ObjectOpResult& result) const override;
  bool isExtensible(JSContext *cx, JS::Handle<JSObject*> proxy, bool *extensible)
                    const override;
  bool set(JSContext *cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id,
           JS::Handle<JS::Value> v, JS::Handle<JS::Value> receiver, JS::ObjectOpResult &result)
           const override;






  virtual bool setCustom(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id,
                         JS::Handle<JS::Value> v, bool *done) const;




  static JSObject* GetExpandoObject(JSObject* obj);
  static void ClearExternalRefsForWrapperRelease(JSObject* obj);
  static JSObject* GetAndClearExpandoObject(JSObject* obj);





  static JSObject* EnsureExpandoObject(JSContext* cx,
                                       JS::Handle<JSObject*> obj);

  static const char family;
};



class ShadowingDOMProxyHandler : public DOMProxyHandler
{
  virtual void trace(JSTracer* trc, JSObject* proxy) const override;
};

inline bool IsDOMProxy(JSObject *obj)
{
    const js::Class* clasp = js::GetObjectClass(obj);
    return clasp->isProxy() &&
           js::GetProxyHandler(obj)->family() == &DOMProxyHandler::family;
}

inline const DOMProxyHandler*
GetDOMProxyHandler(JSObject* obj)
{
  do { } while (0);
  return static_cast<const DOMProxyHandler*>(js::GetProxyHandler(obj));
}

extern jsid s_length_id;



inline uint32_t
GetArrayIndexFromId(JSContext* cx, JS::Handle<jsid> id)
{



  if ((__builtin_expect(!!(JSID_IS_INT(id)), 1))) {
    return JSID_TO_INT(id);
  }
  if ((__builtin_expect(!!(id == s_length_id), 1))) {
    return (4294967295U);
  }
  if ((__builtin_expect(!!(!JSID_IS_ATOM(id)), 0))) {
    return (4294967295U);
  }

  JSLinearString* str = js::AtomToLinearString(JSID_TO_ATOM(id));
  char16_t s;
  {
    JS::AutoCheckCannotGC nogc;
    if (js::LinearStringHasLatin1Chars(str)) {
      s = *js::GetLatin1LinearStringChars(nogc, str);
    } else {
      s = *js::GetTwoByteLinearStringChars(nogc, str);
    }
  }
  if ((__builtin_expect(!!((unsigned)s >= 'a' && (unsigned)s <= 'z'), 1)))
    return (4294967295U);

  uint32_t i;
  return js::StringIsArrayIndex(str, &i) ? i : (4294967295U);
}

inline bool
IsArrayIndex(uint32_t index)
{
  return index < (4294967295U);
}

inline void
FillPropertyDescriptor(JS::MutableHandle<JS::PropertyDescriptor> desc,
                       JSObject* obj, bool readonly, bool enumerable = true)
{
  desc.object().set(obj);
  desc.setAttributes((readonly ? 0x02 : 0) |
                     (enumerable ? 0x01 : 0));
  desc.setGetter(nullptr);
  desc.setSetter(nullptr);
}

inline void
FillPropertyDescriptor(JS::MutableHandle<JS::PropertyDescriptor> desc,
                       JSObject* obj, const JS::Value& v,
                       bool readonly, bool enumerable = true)
{
  desc.value().set(v);
  FillPropertyDescriptor(desc, obj, readonly, enumerable);
}

inline void
FillPropertyDescriptor(JS::MutableHandle<JS::PropertyDescriptor> desc,
                       JSObject* obj, unsigned attributes, const JS::Value& v)
{
  desc.object().set(obj);
  desc.value().set(v);
  desc.setAttributes(attributes);
  desc.setGetter(nullptr);
  desc.setSetter(nullptr);
}

}
}
class nsIStackFrame : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetLanguage(uint32_t *aLanguage) = 0;


  virtual nsresult GetLanguageName(nsACString & aLanguageName) = 0;


  virtual nsresult GetFilename(JSContext* cx, nsAString & aFilename) = 0;


  virtual nsresult GetName(JSContext* cx, nsAString & aName) = 0;


  virtual nsresult GetLineNumber(JSContext* cx, int32_t *aLineNumber) = 0;


  virtual nsresult GetColumnNumber(JSContext* cx, int32_t *aColumnNumber) = 0;


  virtual nsresult GetSourceLine(nsACString & aSourceLine) = 0;


  virtual nsresult GetAsyncCause(JSContext* cx, nsAString & aAsyncCause) = 0;


  virtual nsresult GetAsyncCaller(JSContext* cx, nsIStackFrame * *aAsyncCaller) = 0;


  virtual nsresult GetCaller(JSContext* cx, nsIStackFrame * *aCaller) = 0;


  virtual nsresult GetFormattedStack(JSContext* cx, nsAString & aFormattedStack) = 0;


  virtual nsresult GetNativeSavedFrame(JS::MutableHandleValue aNativeSavedFrame) = 0;


  virtual nsresult ToString(JSContext* cx, nsACString & _retval) = 0;

};

  template<typename T> struct nsIStackFrame::COMTypeInfo<nsIStackFrame, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIStackFrame::COMTypeInfo<nsIStackFrame, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x28bfb2a2, 0x5ea6, 0x4738, { 0x91, 0x8b, 0x04, 0x9d, 0xc4, 0xd5, 0x1f, 0x0b }};
class nsIException : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetMessageMoz(nsACString & aMessage) = 0;


  virtual nsresult GetResult(nsresult *aResult) = 0;


  virtual nsresult GetName(nsACString & aName) = 0;


  virtual nsresult GetFilename(JSContext* cx, nsAString & aFilename) = 0;


  virtual nsresult GetLineNumber(JSContext* cx, uint32_t *aLineNumber) = 0;


  virtual nsresult GetColumnNumber(uint32_t *aColumnNumber) = 0;


  virtual nsresult GetLocation(nsIStackFrame * *aLocation) = 0;


  virtual nsresult GetData(nsISupports * *aData) = 0;


  virtual nsresult ToString(JSContext* cx, nsACString & _retval) = 0;

};

  template<typename T> struct nsIException::COMTypeInfo<nsIException, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIException::COMTypeInfo<nsIException, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x4371b5bf, 0x6845, 0x487f, { 0x8d, 0x9d, 0x3f, 0x1e, 0x4a, 0x9b, 0xad, 0xd2 }};



class nsIStackFrame;
class nsPIDOMWindowInner;
template <class T>
struct already_AddRefed;

namespace mozilla {
namespace dom {

class Exception;



bool
Throw(JSContext* cx, nsresult rv, const nsACString& message = EmptyCString());


void
ThrowAndReport(nsPIDOMWindowInner* aWindow, nsresult aRv);



void
ThrowExceptionObject(JSContext* aCx, Exception* aException);
void
ThrowExceptionObject(JSContext* aCx, nsIException* aException);






already_AddRefed<Exception>
CreateException(nsresult aRv, const nsACString& aMessage = EmptyCString());




already_AddRefed<nsIStackFrame>
GetCurrentJSStack(int32_t aMaxDepth = -1);


namespace exceptions {

already_AddRefed<nsIStackFrame>
CreateStack(JSContext* aCx, JS::StackCapture&& aCaptureMode);

}
}
}
namespace mozilla {
namespace dom {







class NonRefcountedDOMObject
{
protected:
  NonRefcountedDOMObject()
  {
                                          ;
  }
  ~NonRefcountedDOMObject()
  {
                                          ;
  }
};

}
}

namespace mozilla {
namespace dom {

template<typename T>
class RootedDictionary final : public T,
                                         private JS::CustomAutoRooter
{
public:
  template <typename CX>
  explicit RootedDictionary(const CX& cx ) :
    T(),
    JS::CustomAutoRooter(cx )
  {
  }

  virtual void trace(JSTracer *trc) override
  {
    this->TraceDictionary(trc);
  }
};

template<typename T>
class NullableRootedDictionary final : public Nullable<T>,
                                                 private JS::CustomAutoRooter
{
public:
  template <typename CX>
  explicit NullableRootedDictionary(const CX& cx ) :
    Nullable<T>(),
    JS::CustomAutoRooter(cx )
  {
  }

  virtual void trace(JSTracer *trc) override
  {
    if (!this->IsNull()) {
      this->Value().TraceDictionary(trc);
    }
  }
};

}
}





enum nsCompatibility {
  eCompatibility_FullStandards = 1,
  eCompatibility_AlmostStandards = 2,
  eCompatibility_NavQuirks = 3
};


class nsIContent;
class nsIDocument;

namespace mozilla {
namespace css {
class Rule;
}
}





typedef uint32_t nsUpdateType;






class nsIDocumentObserver : public nsIMutationObserver
{
public:
  template<typename T, typename U> struct COMTypeInfo;





  virtual void BeginUpdate(nsIDocument *aDocument,
                           nsUpdateType aUpdateType) = 0;





  virtual void EndUpdate(nsIDocument *aDocument, nsUpdateType aUpdateType) = 0;




  virtual void BeginLoad(nsIDocument *aDocument) = 0;






  virtual void EndLoad(nsIDocument *aDocument) = 0;
  virtual void ContentStateChanged(nsIDocument* aDocument,
                                   nsIContent* aContent,
                                   mozilla::EventStates aStateMask) = 0;







  virtual void DocumentStatesChanged(nsIDocument* aDocument,
                                     mozilla::EventStates aStateMask) = 0;
  virtual void StyleSheetAdded(mozilla::StyleSheet* aStyleSheet,
                               bool aDocumentSheet) = 0;
  virtual void StyleSheetRemoved(mozilla::StyleSheet* aStyleSheet,
                                 bool aDocumentSheet) = 0;
  virtual void StyleSheetApplicableStateChanged(mozilla::StyleSheet* aStyleSheet) = 0;
  virtual void StyleRuleChanged(mozilla::StyleSheet* aStyleSheet) = 0;
  virtual void StyleRuleAdded(mozilla::StyleSheet* aStyleSheet) = 0;
  virtual void StyleRuleRemoved(mozilla::StyleSheet* aStyleSheet) = 0;
};

template<typename T> struct nsIDocumentObserver::COMTypeInfo<nsIDocumentObserver, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDocumentObserver::COMTypeInfo<nsIDocumentObserver, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x71041fa3, 0x6dd7, 0x4cde, { 0xbb, 0x76, 0xae, 0xcc, 0x69, 0xe1, 0x75, 0x78 } };
class nsISimpleEnumerator;

class nsIRequestObserver;

class nsIInterfaceRequestor;

class nsIRequestContext;
class nsILoadGroup : public nsIRequest {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetGroupObserver(nsIRequestObserver * *aGroupObserver) = 0;
  virtual nsresult SetGroupObserver(nsIRequestObserver *aGroupObserver) = 0;


  virtual nsresult GetDefaultLoadRequest(nsIRequest * *aDefaultLoadRequest) = 0;
  virtual nsresult SetDefaultLoadRequest(nsIRequest *aDefaultLoadRequest) = 0;


  virtual nsresult AddRequest(nsIRequest *aRequest, nsISupports *aContext) = 0;


  virtual nsresult RemoveRequest(nsIRequest *aRequest, nsISupports *aContext, nsresult aStatus) = 0;


  virtual nsresult GetRequests(nsISimpleEnumerator * *aRequests) = 0;


  virtual nsresult GetActiveCount(uint32_t *aActiveCount) = 0;


  virtual nsresult GetNotificationCallbacks(nsIInterfaceRequestor * *aNotificationCallbacks) = 0;
  virtual nsresult SetNotificationCallbacks(nsIInterfaceRequestor *aNotificationCallbacks) = 0;


  virtual nsresult GetRequestContextID(uint64_t *aRequestContextID) = 0;


  virtual nsresult GetDefaultLoadFlags(nsLoadFlags *aDefaultLoadFlags) = 0;
  virtual nsresult SetDefaultLoadFlags(nsLoadFlags aDefaultLoadFlags) = 0;


  virtual nsresult GetUserAgentOverrideCache(nsACString & aUserAgentOverrideCache) = 0;
  virtual nsresult SetUserAgentOverrideCache(const nsACString & aUserAgentOverrideCache) = 0;

};

  template<typename T> struct nsILoadGroup::COMTypeInfo<nsILoadGroup, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsILoadGroup::COMTypeInfo<nsILoadGroup, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xf0c87725, 0x7a35, 0x463c, { 0x9c, 0xeb, 0x2c, 0x07, 0xf2, 0x34, 0x06, 0xcc }};

class nsIRequest;
class nsIRequestObserver : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult OnStartRequest(nsIRequest *aRequest, nsISupports *aContext) = 0;


  virtual nsresult OnStopRequest(nsIRequest *aRequest, nsISupports *aContext, nsresult aStatusCode) = 0;

};

  template<typename T> struct nsIRequestObserver::COMTypeInfo<nsIRequestObserver, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIRequestObserver::COMTypeInfo<nsIRequestObserver, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xfd91e2e0, 0x1481, 0x11d3, { 0x93, 0x33, 0x00, 0x10, 0x4b, 0xa0, 0xfd, 0x40 }};






class nsIInputStream;
class nsIStreamListener : public nsIRequestObserver {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult OnDataAvailable(nsIRequest *aRequest, nsISupports *aContext, nsIInputStream *aInputStream, uint64_t aOffset, uint32_t aCount) = 0;

};

  template<typename T> struct nsIStreamListener::COMTypeInfo<nsIStreamListener, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIStreamListener::COMTypeInfo<nsIStreamListener, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x3b4c8a77, 0x76ba, 0x4610, { 0xb3, 0x16, 0x67, 0x8c, 0x73, 0xa3, 0xb8, 0x8c }};
class nsScanner;
class nsITokenizer : public nsISupports {
public:
  template<typename T, typename U> struct COMTypeInfo;

  virtual nsresult WillTokenize(bool aIsFinalChunk)=0;
  virtual nsresult ConsumeToken(nsScanner& aScanner,bool& aFlushTokens)=0;
};

template<typename T> struct nsITokenizer::COMTypeInfo<nsITokenizer, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsITokenizer::COMTypeInfo<nsITokenizer, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0Xae98a348, 0X5e91, 0X41a8, { 0Xa5, 0Xb4, 0Xd2, 0X20, 0Xf3, 0X1f, 0Xc4, 0Xab } };





enum eAutoDetectResult {
    eUnknownDetect,
    eValidDetect,
    ePrimaryDetect,
    eInvalidDetect
};

enum nsDTDMode {
    eDTDMode_unknown = 0,
    eDTDMode_quirks,
    eDTDMode_almost_standards,
    eDTDMode_full_standards,
    eDTDMode_autodetect,
    eDTDMode_fragment
};


class nsIContentSink;
class CParserContext;

class nsIDTD : public nsISupports
{
public:

    template<typename T, typename U> struct COMTypeInfo;

    virtual nsresult WillBuildModel(const CParserContext& aParserContext,
                              nsITokenizer* aTokenizer,
                              nsIContentSink* aSink) = 0;







    virtual nsresult DidBuildModel(nsresult anErrorCode) = 0;
    virtual nsresult BuildModel(nsITokenizer* aTokenizer, nsIContentSink* aSink) = 0;
    virtual bool CanContain(int32_t aParent,int32_t aChild) const = 0;
    virtual bool IsContainer(int32_t aTag) const = 0;
    virtual void Terminate() = 0;

    virtual int32_t GetType() = 0;





    virtual nsDTDMode GetMode() const = 0;
};

template<typename T> struct nsIDTD::COMTypeInfo<nsIDTD, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDTD::COMTypeInfo<nsIDTD, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x3de05873, 0xefa7, 0x410d, { 0xa4, 0x61, 0x80, 0x33, 0xaf, 0xd9, 0xe3, 0x26 } };



class nsParserBase : public nsISupports
{
  public:
    virtual bool IsParserEnabled() { return true; }
    virtual nsresult GetChannel(nsIChannel** aChannel) {
      *aChannel = nullptr;
      return NS_OK;
    }
};





class nsIContentSink;
class nsIRequestObserver;
class nsString;
class nsIURI;
class nsIChannel;

enum eParserCommands {
  eViewNormal,
  eViewSource,
  eViewFragment,
  eViewErrors
};

enum eParserDocType {
  ePlainText = 0,
  eXML,
  eHTML_Quirks,
  eHTML_Strict
};

enum eStreamState {eNone,eOnStart,eOnDataAvail,eOnStop};
class nsIParser : public nsParserBase {
  public:

    template<typename T, typename U> struct COMTypeInfo;







    virtual void SetContentSink(nsIContentSink* aSink)=0;







    virtual nsIContentSink* GetContentSink(void)=0;
    virtual void GetCommand(nsCString& aCommand)=0;
    virtual void SetCommand(const char* aCommand)=0;
    virtual void SetCommand(eParserCommands aParserCommand)=0;
    virtual void SetDocumentCharset(const nsACString& aCharset, int32_t aSource)=0;
    virtual void GetDocumentCharset(nsACString& oCharset, int32_t& oSource)=0;







    virtual nsresult GetChannel(nsIChannel** aChannel) override = 0;







    virtual nsresult GetDTD(nsIDTD** aDTD) = 0;




    virtual nsIStreamListener* GetStreamListener() = 0;
    virtual nsresult ContinueInterruptedParsing() = 0;


    virtual void BlockParser() = 0;





    virtual void UnblockParser() = 0;




    virtual void ContinueInterruptedParsingAsync() = 0;

    virtual bool IsParserEnabled() override = 0;
    virtual bool IsComplete() = 0;

    virtual nsresult Parse(nsIURI* aURL,
                     nsIRequestObserver* aListener = nullptr,
                     void* aKey = 0,
                     nsDTDMode aMode = eDTDMode_autodetect) = 0;

    virtual nsresult Terminate(void) = 0;
    virtual nsresult ParseFragment(const nsAString& aSourceBuffer,
                             nsTArray<nsString>& aTagStack) = 0;







    virtual nsresult BuildModel(void) = 0;
    virtual nsresult CancelParsingEvents() = 0;

    virtual void Reset() = 0;




    virtual bool IsInsertionPointDefined() = 0;





    virtual void PushDefinedInsertionPoint() = 0;






    virtual void PopDefinedInsertionPoint() = 0;




    virtual void MarkAsNotScriptCreated(const char* aCommand) = 0;




    virtual bool IsScriptCreated() = 0;
};

template<typename T> struct nsIParser::COMTypeInfo<nsIParser, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIParser::COMTypeInfo<nsIParser, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x2c4ad90a, 0x740e, 0x4212, { 0xba, 0x3f, 0xfe, 0xac, 0xda, 0x4b, 0x92, 0x9e } };

class nsIServiceManager : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetService(const nsCID & aClass, const nsIID & aIID, void **result) = 0;


  virtual nsresult GetServiceByContractID(const char * aContractID, const nsIID & aIID, void **result) = 0;


  virtual nsresult IsServiceInstantiated(const nsCID & aClass, const nsIID & aIID, bool *_retval) = 0;


  virtual nsresult IsServiceInstantiatedByContractID(const char * aContractID, const nsIID & aIID, bool *_retval) = 0;

};

  template<typename T> struct nsIServiceManager::COMTypeInfo<nsIServiceManager, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIServiceManager::COMTypeInfo<nsIServiceManager, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x8bb35ed9, 0xe332, 0x462d, { 0x91, 0x55, 0x4a, 0x00, 0x2a, 0xb5, 0xc9, 0x58 }};
class nsIFactory : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult CreateInstance(nsISupports *aOuter, const nsIID & iid, void **result) = 0;


  virtual nsresult LockFactory(bool lock) = 0;

};

  template<typename T> struct nsIFactory::COMTypeInfo<nsIFactory, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIFactory::COMTypeInfo<nsIFactory, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x00000001, 0x0000, 0x0000, { 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }};


nsresult CallCreateInstance(const nsCID& aClass, nsISupports* aDelegate,
                            const nsIID& aIID, void** aResult);

nsresult CallCreateInstance(const char* aContractID, nsISupports* aDelegate,
                            const nsIID& aIID, void** aResult);

nsresult CallGetClassObject(const nsCID& aClass, const nsIID& aIID,
                            void** aResult);

nsresult CallGetClassObject(const char* aContractID, const nsIID& aIID,
                            void** aResult);


class nsCreateInstanceByCID final : public nsCOMPtr_helper
{
public:
  nsCreateInstanceByCID(const nsCID& aCID, nsresult* aErrorPtr)
    : mCID(aCID)
    , mErrorPtr(aErrorPtr)
  {
  }

  virtual nsresult operator()(const nsIID&, void**) const
    override;

private:
  const nsCID& mCID;
  nsresult* mErrorPtr;
};

class nsCreateInstanceByContractID final : public nsCOMPtr_helper
{
public:
  nsCreateInstanceByContractID(const char* aContractID, nsresult* aErrorPtr)
    : mContractID(aContractID)
    , mErrorPtr(aErrorPtr)
  {
  }

  virtual nsresult operator()(const nsIID&, void**) const override;

private:
  const char* mContractID;
  nsresult* mErrorPtr;
};

class nsCreateInstanceFromFactory final : public nsCOMPtr_helper
{
public:
  nsCreateInstanceFromFactory(nsIFactory* aFactory, nsresult* aErrorPtr)
    : mFactory(aFactory)
    , mErrorPtr(aErrorPtr)
  {
  }

  virtual nsresult operator()(const nsIID&, void**) const override;

private:
  nsIFactory* mFactory;
  nsresult* mErrorPtr;
};


inline const nsCreateInstanceByCID
do_CreateInstance(const nsCID& aCID, nsresult* aError = 0)
{
  return nsCreateInstanceByCID(aCID, aError);
}

inline const nsCreateInstanceByContractID
do_CreateInstance(const char* aContractID, nsresult* aError = 0)
{
  return nsCreateInstanceByContractID(aContractID, aError);
}

inline const nsCreateInstanceFromFactory
do_CreateInstance(nsIFactory* aFactory, nsresult* aError = 0)
{
  return nsCreateInstanceFromFactory(aFactory, aError);
}


class nsGetClassObjectByCID final : public nsCOMPtr_helper
{
public:
  nsGetClassObjectByCID(const nsCID& aCID, nsresult* aErrorPtr)
    : mCID(aCID)
    , mErrorPtr(aErrorPtr)
  {
  }

  virtual nsresult operator()(const nsIID&, void**) const override;

private:
  const nsCID& mCID;
  nsresult* mErrorPtr;
};

class nsGetClassObjectByContractID final : public nsCOMPtr_helper
{
public:
  nsGetClassObjectByContractID(const char* aContractID, nsresult* aErrorPtr)
    : mContractID(aContractID)
    , mErrorPtr(aErrorPtr)
  {
  }

  virtual nsresult operator()(const nsIID&, void**) const override;

private:
  const char* mContractID;
  nsresult* mErrorPtr;
};
inline const nsGetClassObjectByCID
do_GetClassObject(const nsCID& aCID, nsresult* aError = 0)
{
  return nsGetClassObjectByCID(aCID, aError);
}

inline const nsGetClassObjectByContractID
do_GetClassObject(const char* aContractID, nsresult* aError = 0)
{
  return nsGetClassObjectByContractID(aContractID, aError);
}


template<class DestinationType>
inline nsresult
CallCreateInstance(const nsCID& aClass,
                   nsISupports* aDelegate,
                   DestinationType** aDestination)
{
  do { } while(0);

  return CallCreateInstance(aClass, aDelegate,
                            (DestinationType::template COMTypeInfo<DestinationType, void>::kIID),
                            reinterpret_cast<void**>(aDestination));
}

template<class DestinationType>
inline nsresult
CallCreateInstance(const nsCID& aClass, DestinationType** aDestination)
{
  do { } while(0);

  return CallCreateInstance(aClass, nullptr,
                            (DestinationType::template COMTypeInfo<DestinationType, void>::kIID),
                            reinterpret_cast<void**>(aDestination));
}

template<class DestinationType>
inline nsresult
CallCreateInstance(const char* aContractID,
                   nsISupports* aDelegate,
                   DestinationType** aDestination)
{
  do { } while(0);
  do { } while(0);

  return CallCreateInstance(aContractID,
                            aDelegate,
                            (DestinationType::template COMTypeInfo<DestinationType, void>::kIID),
                            reinterpret_cast<void**>(aDestination));
}

template<class DestinationType>
inline nsresult
CallCreateInstance(const char* aContractID, DestinationType** aDestination)
{
  do { } while(0);
  do { } while(0);

  return CallCreateInstance(aContractID, nullptr,
                            (DestinationType::template COMTypeInfo<DestinationType, void>::kIID),
                            reinterpret_cast<void**>(aDestination));
}

template<class DestinationType>
inline nsresult
CallCreateInstance(nsIFactory* aFactory,
                   nsISupports* aDelegate,
                   DestinationType** aDestination)
{
  do { } while(0);
  do { } while(0);

  return aFactory->CreateInstance(aDelegate,
                                  (DestinationType::template COMTypeInfo<DestinationType, void>::kIID),
                                  reinterpret_cast<void**>(aDestination));
}

template<class DestinationType>
inline nsresult
CallCreateInstance(nsIFactory* aFactory, DestinationType** aDestination)
{
  do { } while(0);
  do { } while(0);

  return aFactory->CreateInstance(nullptr,
                                  (DestinationType::template COMTypeInfo<DestinationType, void>::kIID),
                                  reinterpret_cast<void**>(aDestination));
}

template<class DestinationType>
inline nsresult
CallGetClassObject(const nsCID& aClass, DestinationType** aDestination)
{
  do { } while(0);

  return CallGetClassObject(aClass, (DestinationType::template COMTypeInfo<DestinationType, void>::kIID),
                            reinterpret_cast<void**>(aDestination));
}

template<class DestinationType>
inline nsresult
CallGetClassObject(const char* aContractID, DestinationType** aDestination)
{
  do { } while(0);

  return CallGetClassObject(aContractID, (DestinationType::template COMTypeInfo<DestinationType, void>::kIID),
                            reinterpret_cast<void**>(aDestination));
}


inline const nsGetServiceByCID
do_GetService(const nsCID& aCID)
{
  return nsGetServiceByCID(aCID);
}

inline const nsGetServiceByCIDWithError
do_GetService(const nsCID& aCID, nsresult* aError)
{
  return nsGetServiceByCIDWithError(aCID, aError);
}

inline const nsGetServiceByContractID
do_GetService(const char* aContractID)
{
  return nsGetServiceByContractID(aContractID);
}

inline const nsGetServiceByContractIDWithError
do_GetService(const char* aContractID, nsresult* aError)
{
  return nsGetServiceByContractIDWithError(aContractID, aError);
}

class nsGetServiceFromCategory final : public nsCOMPtr_helper
{
public:
  nsGetServiceFromCategory(const char* aCategory, const char* aEntry,
                           nsresult* aErrorPtr)
    : mCategory(aCategory)
    , mEntry(aEntry)
    , mErrorPtr(aErrorPtr)
  {
  }

  virtual nsresult operator()(const nsIID&, void**) const
    override;
protected:
  const char* mCategory;
  const char* mEntry;
  nsresult* mErrorPtr;
};

inline const nsGetServiceFromCategory
do_GetServiceFromCategory(const char* aCategory, const char* aEntry,
                          nsresult* aError = 0)
{
  return nsGetServiceFromCategory(aCategory, aEntry, aError);
}

nsresult CallGetService(const nsCID& aClass, const nsIID& aIID, void** aResult);

nsresult CallGetService(const char* aContractID, const nsIID& aIID,
                        void** aResult);


template<class DestinationType>
inline nsresult
CallGetService(const nsCID& aClass,
               DestinationType** aDestination)
{
  do { } while(0);

  return CallGetService(aClass,
                        (DestinationType::template COMTypeInfo<DestinationType, void>::kIID),
                        reinterpret_cast<void**>(aDestination));
}

template<class DestinationType>
inline nsresult
CallGetService(const char* aContractID,
               DestinationType** aDestination)
{
  do { } while(0);
  do { } while(0);

  return CallGetService(aContractID,
                        (DestinationType::template COMTypeInfo<DestinationType, void>::kIID),
                        reinterpret_cast<void**>(aDestination));
}
class nsIUUIDGenerator : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GenerateUUID(nsID **_retval) = 0;


  virtual nsresult GenerateUUIDInPlace(nsID *id) = 0;

};

  template<typename T> struct nsIUUIDGenerator::COMTypeInfo<nsIUUIDGenerator, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIUUIDGenerator::COMTypeInfo<nsIUUIDGenerator, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x138ad1b2, 0xc694, 0x41cc, { 0xb2, 0x01, 0x33, 0x3c, 0xe9, 0x36, 0xd8, 0xb8 }};



class nsURIHashKey : public PLDHashEntryHdr
{
public:
    typedef nsIURI* KeyType;
    typedef const nsIURI* KeyTypePointer;

    explicit nsURIHashKey(const nsIURI* aKey) :
        mKey(const_cast<nsIURI*>(aKey)) { ; }
    nsURIHashKey(const nsURIHashKey& toCopy) :
        mKey(toCopy.mKey) { ; }
    ~nsURIHashKey() { ; }

    nsIURI* GetKey() const { return mKey; }

    bool KeyEquals(const nsIURI* aKey) const {
        bool eq;
        if (!mKey) {
            return !aKey;
        }
        if (((bool)(__builtin_expect(!!(!NS_FAILED_impl(mKey->Equals(const_cast<nsIURI*>(aKey), &eq))), 1)))) {
            return eq;
        }
        return false;
    }

    static const nsIURI* KeyToPointer(nsIURI* aKey) { return aKey; }
    static PLDHashNumber HashKey(const nsIURI* aKey) {
        if (!aKey) {

            return mozilla::HashString(EmptyCString());
        }
        nsAutoCString spec;


        mozilla::Unused << const_cast<nsIURI*>(aKey)->GetSpec(spec);
        return mozilla::HashString(spec);
    }

    enum { ALLOW_MEMMOVE = true };

protected:
    nsCOMPtr<nsIURI> mKey;
};


namespace mozilla {

enum UseCounter : int16_t {
  eUseCounter_UNKNOWN = -1,








eUseCounter_SVGSVGElement_getElementById,
eUseCounter_SVGSVGElement_currentScale_getter, eUseCounter_SVGSVGElement_currentScale_setter,
eUseCounter_property_Fill,
eUseCounter_property_FillOpacity,
eUseCounter_PushManager_subscribe,
eUseCounter_PushSubscription_unsubscribe,
eUseCounter_Window_sidebar_getter, eUseCounter_Window_sidebar_setter,
eUseCounter_External_addSearchEngine,
eUseCounter_OfflineResourceList_swapCache,
eUseCounter_OfflineResourceList_update,
eUseCounter_OfflineResourceList_status_getter, eUseCounter_OfflineResourceList_status_setter,
eUseCounter_OfflineResourceList_onchecking_getter, eUseCounter_OfflineResourceList_onchecking_setter,
eUseCounter_OfflineResourceList_onerror_getter, eUseCounter_OfflineResourceList_onerror_setter,
eUseCounter_OfflineResourceList_onnoupdate_getter, eUseCounter_OfflineResourceList_onnoupdate_setter,
eUseCounter_OfflineResourceList_ondownloading_getter, eUseCounter_OfflineResourceList_ondownloading_setter,
eUseCounter_OfflineResourceList_onprogress_getter, eUseCounter_OfflineResourceList_onprogress_setter,
eUseCounter_OfflineResourceList_onupdateready_getter, eUseCounter_OfflineResourceList_onupdateready_setter,
eUseCounter_OfflineResourceList_oncached_getter, eUseCounter_OfflineResourceList_oncached_setter,
eUseCounter_OfflineResourceList_onobsolete_getter, eUseCounter_OfflineResourceList_onobsolete_setter,
eUseCounter_IDBDatabase_createMutableFile,
eUseCounter_IDBDatabase_mozCreateFileHandle,
eUseCounter_IDBMutableFile_open,
eUseCounter_IDBMutableFile_getFile,
eUseCounter_DataTransfer_addElement,
eUseCounter_DataTransfer_mozItemCount_getter, eUseCounter_DataTransfer_mozItemCount_setter,
eUseCounter_DataTransfer_mozCursor_getter, eUseCounter_DataTransfer_mozCursor_setter,
eUseCounter_DataTransfer_mozTypesAt,
eUseCounter_DataTransfer_mozClearDataAt,
eUseCounter_DataTransfer_mozSetDataAt,
eUseCounter_DataTransfer_mozGetDataAt,
eUseCounter_DataTransfer_mozUserCancelled_getter, eUseCounter_DataTransfer_mozUserCancelled_setter,
eUseCounter_DataTransfer_mozSourceNode_getter, eUseCounter_DataTransfer_mozSourceNode_setter,






eUseCounter_GetAttributeNode,
eUseCounter_SetAttributeNode,
eUseCounter_GetAttributeNodeNS,
eUseCounter_SetAttributeNodeNS,
eUseCounter_RemoveAttributeNode,
eUseCounter_CreateAttribute,
eUseCounter_CreateAttributeNS,
eUseCounter_NodeValue,
eUseCounter_TextContent,
eUseCounter_EnablePrivilege,
eUseCounter_DOMExceptionCode,
eUseCounter_NoExposedProps,
eUseCounter_MutationEvent,
eUseCounter_Components,
eUseCounter_PrefixedVisibilityAPI,
eUseCounter_NodeIteratorDetach,
eUseCounter_LenientThis,
eUseCounter_GetPreventDefault,
eUseCounter_GetSetUserData,
eUseCounter_MozGetAsFile,
eUseCounter_UseOfCaptureEvents,
eUseCounter_UseOfReleaseEvents,
eUseCounter_UseOfDOM3LoadMethod,
eUseCounter_ChromeUseOfDOM3LoadMethod,
eUseCounter_ShowModalDialog,
eUseCounter_Window_Content,
eUseCounter_SyncXMLHttpRequest,
eUseCounter_DataContainerEvent,
eUseCounter_Window_Controllers,
eUseCounter_ImportXULIntoContent,
eUseCounter_PannerNodeDoppler,
eUseCounter_NavigatorGetUserMedia,
eUseCounter_WebrtcDeprecatedPrefix,
eUseCounter_RTCPeerConnectionGetStreams,
eUseCounter_AppCache,
eUseCounter_PrefixedImageSmoothingEnabled,
eUseCounter_PrefixedFullscreenAPI,
eUseCounter_LenientSetter,
eUseCounter_FileLastModifiedDate,
eUseCounter_ImageBitmapRenderingContext_TransferImageBitmap,
eUseCounter_URLCreateObjectURL_MediaStream,
eUseCounter_XMLBaseAttribute,
eUseCounter_XMLBaseAttributeForStyleAttr,


  eUseCounter_Count
};

}


class nsContentList;
class nsIAtom;
class nsIContent;
class nsINode;

class nsString;
class nsAString;

namespace mozilla {
namespace dom {
class Element;
}
}
typedef bool (*nsContentListMatchFunc)(mozilla::dom::Element* aElement,
                                       int32_t aNamespaceID,
                                       nsIAtom* aAtom,
                                       void* aData);

typedef void (*nsContentListDestroyFunc)(void* aData);






typedef void* (*nsFuncStringContentListDataAllocator)(nsINode* aRootNode,
                                                      const nsString* aString);






already_AddRefed<nsContentList>
NS_GetContentList(nsINode* aRootNode,
                  int32_t aMatchNameSpaceId,
                  const nsAString& aTagname);

already_AddRefed<nsContentList>
NS_GetFuncStringNodeList(nsINode* aRootNode,
                         nsContentListMatchFunc aFunc,
                         nsContentListDestroyFunc aDestroyFunc,
                         nsFuncStringContentListDataAllocator aDataAllocator,
                         const nsAString& aString);
already_AddRefed<nsContentList>
NS_GetFuncStringHTMLCollection(nsINode* aRootNode,
                               nsContentListMatchFunc aFunc,
                               nsContentListDestroyFunc aDestroyFunc,
                               nsFuncStringContentListDataAllocator aDataAllocator,
                               const nsAString& aString);
namespace mozilla {
enum class LogLevel {
  Disabled = 0,
  Error,
  Warning,
  Info,
  Debug,
  Verbose,
};




LogLevel ToLogLevel(int32_t aLevel);

class LogModule
{
public:
  ~LogModule() { ::free(mName); }
  static LogModule* Get(const char* aName);

  static void Init();




  static void SetLogFile(const char* aFilename);







  static uint32_t GetLogFile(char *aBuffer, size_t aLength);




  static void SetAddTimestamp(bool aAddTimestamp);




  static void SetIsSync(bool aIsSync);




  bool ShouldLog(LogLevel aLevel) const { return mLevel >= aLevel; }




  LogLevel Level() const { return mLevel; }




  void SetLevel(LogLevel level) { mLevel = level; }




  void Printv(LogLevel aLevel, const char* aFmt, va_list aArgs) const;




  const char* Name() const { return mName; }

private:
  friend class LogModuleManager;

  explicit LogModule(const char* aName, LogLevel aLevel)
    : mName(strdup(aName)), mLevel(aLevel)
  {
  }

  LogModule(LogModule&) = delete;
  LogModule& operator=(const LogModule&) = delete;

  char* mName;
  Atomic<LogLevel, Relaxed> mLevel;
};
class LazyLogModule final
{
public:
  explicit constexpr LazyLogModule(const char* aLogName)
    : mLogName(aLogName)
    , mLog(nullptr)
  {
  }

  operator LogModule*()
  {




    LogModule* tmp = mLog;
    if ((__builtin_expect(!!(!tmp), 0))) {
      tmp = LogModule::Get(mLogName);
      mLog = tmp;
    }

    return tmp;
  }

private:
  const char* const mLogName;
  Atomic<LogModule*, ReleaseAcquire> mLog;
};

namespace detail {

inline bool log_test(const LogModule* module, LogLevel level) {
  do { } while (0);
  return module && module->ShouldLog(level);
}

void log_print(const LogModule* aModule,
               LogLevel aLevel,
               const char* aFmt, ...) __attribute__ ((format (printf, 3, 4)));
}

}







class nsIObserver;

class nsISimpleEnumerator;
class nsIObserverService : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult AddObserver(nsIObserver *anObserver, const char * aTopic, bool ownsWeak) = 0;


  virtual nsresult RemoveObserver(nsIObserver *anObserver, const char * aTopic) = 0;


  virtual nsresult NotifyObservers(nsISupports *aSubject, const char * aTopic, const char16_t * someData) = 0;


  virtual nsresult EnumerateObservers(const char * aTopic, nsISimpleEnumerator * *_retval) = 0;

};

  template<typename T> struct nsIObserverService::COMTypeInfo<nsIObserverService, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIObserverService::COMTypeInfo<nsIObserverService, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xd07f5192, 0xe3d1, 0x11d2, { 0x8a, 0xcd, 0x00, 0x10, 0x5a, 0x1b, 0x88, 0x60 }};









class nsIChromeRegistry;

class nsIToolkitChromeRegistry;

class nsIXULChromeRegistry;

class nsIXULOverlayProvider;

class nsIIOService;

class nsIObserverService;

class nsIStringBundleService;

class nsIXPConnect;

class inIDOMUtils;

class nsIPermissionManager;;

class nsIServiceWorkerManager;;

class nsIAsyncShutdownService;

class nsIUUIDGenerator;;

class nsIGfxInfo;;



namespace mozilla {


class IHistory;



}



namespace mozilla {
namespace services {













already_AddRefed<nsIChromeRegistry> GetChromeRegistryService();

already_AddRefed<nsIToolkitChromeRegistry> GetToolkitChromeRegistryService();

already_AddRefed<nsIXULChromeRegistry> GetXULChromeRegistryService();

already_AddRefed<nsIXULOverlayProvider> GetXULOverlayProviderService();

already_AddRefed<nsIIOService> GetIOService();

already_AddRefed<nsIObserverService> GetObserverService();

already_AddRefed<nsIStringBundleService> GetStringBundleService();

already_AddRefed<nsIXPConnect> GetXPConnect();

already_AddRefed<inIDOMUtils> GetInDOMUtils();

already_AddRefed<nsIPermissionManager> GetPermissionManager();;

already_AddRefed<nsIServiceWorkerManager> GetServiceWorkerManager();;

already_AddRefed<nsIAsyncShutdownService> GetAsyncShutdown();

already_AddRefed<nsIUUIDGenerator> GetUUIDGenerator();;

already_AddRefed<nsIGfxInfo> GetGfxInfo();;






already_AddRefed<IHistory> GetHistoryService();



}
}






struct nsExpirationState
{
  enum
  {
    NOT_TRACKED = (1U << 4) - 1,
    MAX_INDEX_IN_GENERATION = (1U << 28) - 1
  };

  nsExpirationState() : mGeneration(NOT_TRACKED) {}
  bool IsTracked() { return mGeneration != NOT_TRACKED; }




  uint32_t mGeneration:4;
  uint32_t mIndexInGeneration:28;
};
template<typename T, uint32_t K, typename Mutex, typename AutoLock>
class ExpirationTrackerImpl
{
public:
  ExpirationTrackerImpl(uint32_t aTimerPeriod,
                        const char* aName,
                        nsIEventTarget* aEventTarget = nullptr)
    : mTimerPeriod(aTimerPeriod)
    , mNewestGeneration(0)
    , mInAgeOneGeneration(false)
    , mName(aName)
    , mEventTarget(aEventTarget)
  {
    static_assert(K >= 2 && K <= nsExpirationState::NOT_TRACKED,
                  "Unsupported number of generations (must be 2 <= K <= 15)");
    do { } while (0);
    if (mEventTarget) {
      bool current = false;




      if ((__builtin_expect(!!(((bool)(__builtin_expect(!!(NS_FAILED_impl(mEventTarget->IsOnCurrentThread(&current))), 0))) || !current), 0))) {

        do { AnnotateMozCrashReason("MOZ_CRASH(" "Provided event target must be on the main thread" ")"); do { *((volatile int*) __null) = 126; ::abort(); } while (0); } while (0);
      }
    }
    mObserver = new ExpirationTrackerObserver();
    mObserver->Init(this);
  }

  virtual ~ExpirationTrackerImpl()
  {
    do { } while (0);
    if (mTimer) {
      mTimer->Cancel();
    }
    mObserver->Destroy();
  }






  nsresult AddObjectLocked(T* aObj, const AutoLock& aAutoLock)
  {
    nsExpirationState* state = aObj->GetExpirationState();
    do { } while(0);

    nsTArray<T*>& generation = mGenerations[mNewestGeneration];
    uint32_t index = generation.Length();
    if (index > nsExpirationState::MAX_INDEX_IN_GENERATION) {
      do { } while(0);
      return NS_ERROR_OUT_OF_MEMORY;
    }
    if (index == 0) {

      nsresult rv = CheckStartTimerLocked(aAutoLock);
      if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {
        return rv;
      }
    }
    if (!generation.AppendElement(aObj)) {
      return NS_ERROR_OUT_OF_MEMORY;
    }
    state->mGeneration = mNewestGeneration;
    state->mIndexInGeneration = index;
    return NS_OK;
  }




  void RemoveObjectLocked(T* aObj, const AutoLock& aAutoLock)
  {
    nsExpirationState* state = aObj->GetExpirationState();
    do { } while(0);
    nsTArray<T*>& generation = mGenerations[state->mGeneration];
    uint32_t index = state->mIndexInGeneration;
    do { } while(0);


    uint32_t last = generation.Length() - 1;
    T* lastObj = generation[last];
    generation[index] = lastObj;
    lastObj->GetExpirationState()->mIndexInGeneration = index;
    generation.RemoveElementAt(last);
    state->mGeneration = nsExpirationState::NOT_TRACKED;





  }





  nsresult MarkUsedLocked(T* aObj, const AutoLock& aAutoLock)
  {
    nsExpirationState* state = aObj->GetExpirationState();
    if (mNewestGeneration == state->mGeneration) {
      return NS_OK;
    }
    RemoveObjectLocked(aObj, aAutoLock);
    return AddObjectLocked(aObj, aAutoLock);
  }





  void AgeOneGenerationLocked(const AutoLock& aAutoLock)
  {
    if (mInAgeOneGeneration) {
      do { } while(0);
      return;
    }

    mInAgeOneGeneration = true;
    uint32_t reapGeneration =
      mNewestGeneration > 0 ? mNewestGeneration - 1 : K - 1;
    nsTArray<T*>& generation = mGenerations[reapGeneration];
    size_t index = generation.Length();
    for (;;) {


      index = XPCOM_MIN(index, generation.Length());
      if (index == 0) {
        break;
      }
      --index;
      NotifyExpiredLocked(generation[index], aAutoLock);
    }


    if (!generation.IsEmpty()) {
      do { } while(0);
    }


    generation.Compact();
    mNewestGeneration = reapGeneration;
    mInAgeOneGeneration = false;
  }
  void AgeAllGenerationsLocked(const AutoLock& aAutoLock)
  {
    uint32_t i;
    for (i = 0; i < K; ++i) {
      AgeOneGenerationLocked(aAutoLock);
    }
  }

  class Iterator
  {
  private:
    ExpirationTrackerImpl<T, K, Mutex, AutoLock>* mTracker;
    uint32_t mGeneration;
    uint32_t mIndex;
  public:
    Iterator(ExpirationTrackerImpl<T, K, Mutex, AutoLock>* aTracker,
             AutoLock& aAutoLock)
      : mTracker(aTracker)
      , mGeneration(0)
      , mIndex(0)
    {
    }

    T* Next()
    {
      while (mGeneration < K) {
        nsTArray<T*>* generation = &mTracker->mGenerations[mGeneration];
        if (mIndex < generation->Length()) {
          ++mIndex;
          return (*generation)[mIndex - 1];
        }
        ++mGeneration;
        mIndex = 0;
      }
      return nullptr;
    }
  };

  friend class Iterator;

  bool IsEmptyLocked(const AutoLock& aAutoLock)
  {
    for (uint32_t i = 0; i < K; ++i) {
      if (!mGenerations[i].IsEmpty()) {
        return false;
      }
    }
    return true;
  }

protected:
  virtual void NotifyExpiredLocked(T*, const AutoLock&) = 0;

  virtual Mutex& GetMutex() = 0;

private:
  class ExpirationTrackerObserver;
  RefPtr<ExpirationTrackerObserver> mObserver;
  nsTArray<T*> mGenerations[K];
  nsCOMPtr<nsITimer> mTimer;
  uint32_t mTimerPeriod;
  uint32_t mNewestGeneration;
  bool mInAgeOneGeneration;
  const char* const mName;
  const nsCOMPtr<nsIEventTarget> mEventTarget;





  class ExpirationTrackerObserver final : public nsIObserver
  {
  public:
    void Init(ExpirationTrackerImpl<T, K, Mutex, AutoLock>* aObj)
    {
      mOwner = aObj;
      nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
      if (obs) {
        obs->AddObserver(this, "memory-pressure", false);
      }
    }
    void Destroy()
    {
      mOwner = nullptr;
      nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
      if (obs) {
        obs->RemoveObserver(this, "memory-pressure");
      }
    }
    public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:
    virtual nsresult Observe(nsISupports *aSubject, const char * aTopic, const char16_t * aData) override;
  private:
    ExpirationTrackerImpl<T, K, Mutex, AutoLock>* mOwner;
  };

  void HandleLowMemory() {
    AutoLock lock(GetMutex());
    AgeAllGenerationsLocked(lock);
  }

  void HandleTimeout() {
    AutoLock lock(GetMutex());
    AgeOneGenerationLocked(lock);

    if (IsEmptyLocked(lock)) {
      mTimer->Cancel();
      mTimer = nullptr;
    }
  }

  static void TimerCallback(nsITimer* aTimer, void* aThis)
  {
    ExpirationTrackerImpl* tracker = static_cast<ExpirationTrackerImpl*>(aThis);
    tracker->HandleTimeout();
  }

  nsresult CheckStartTimerLocked(const AutoLock& aAutoLock)
  {
    if (mTimer || !mTimerPeriod) {
      return NS_OK;
    }
    mTimer = do_CreateInstance("@mozilla.org/timer;1");
    if (!mTimer) {
      return NS_ERROR_OUT_OF_MEMORY;
    }
    if (mEventTarget) {
      mTimer->SetTarget(mEventTarget);
    } else if (!NS_IsMainThread()) {


      nsCOMPtr<nsIEventTarget> target = do_GetMainThread();
      do { if ((__builtin_expect(!!(!(target)), 0))) { do { } while(0); return NS_ERROR_UNEXPECTED; } } while(0);
      mTimer->SetTarget(target);
    }
    mTimer->InitWithNamedFuncCallback(TimerCallback, this, mTimerPeriod,
                                      nsITimer::TYPE_REPEATING_SLACK, mName);
    return NS_OK;
  }
};

namespace detail {

class PlaceholderLock {
public:
  void Lock() {}
  void Unlock() {}
};

class PlaceholderAutoLock {
public:
  explicit PlaceholderAutoLock(PlaceholderLock&) { }
  ~PlaceholderAutoLock() = default;

};

template<typename T, uint32_t K>
using SingleThreadedExpirationTracker =
  ExpirationTrackerImpl<T, K, PlaceholderLock, PlaceholderAutoLock>;

}

template<typename T, uint32_t K>
class nsExpirationTracker : protected ::detail::SingleThreadedExpirationTracker<T, K>
{
  typedef ::detail::PlaceholderLock Lock;
  typedef ::detail::PlaceholderAutoLock AutoLock;

  Lock mLock;

  AutoLock FakeLock() {
    return AutoLock(mLock);
  }

  Lock& GetMutex() override
  {
    return mLock;
  }

  void NotifyExpiredLocked(T* aObject, const AutoLock&) override
  {
    NotifyExpired(aObject);
  }

protected:
  virtual void NotifyExpired(T* aObj) = 0;

public:
  nsExpirationTracker(uint32_t aTimerPeriod,
                      const char* aName,
                      nsIEventTarget* aEventTarget = nullptr)
    : ::detail::SingleThreadedExpirationTracker<T, K>(aTimerPeriod,
                                                      aName,
                                                      aEventTarget)
  { }

  virtual ~nsExpirationTracker()
  { }

  nsresult AddObject(T* aObj)
  {
    return this->AddObjectLocked(aObj, FakeLock());
  }

  void RemoveObject(T* aObj)
  {
    this->RemoveObjectLocked(aObj, FakeLock());
  }

  nsresult MarkUsed(T* aObj)
  {
    return this->MarkUsedLocked(aObj, FakeLock());
  }

  void AgeOneGeneration()
  {
    this->AgeOneGenerationLocked(FakeLock());
  }

  void AgeAllGenerations()
  {
    this->AgeAllGenerationsLocked(FakeLock());
  }

  class Iterator
  {
  private:
    AutoLock mAutoLock;
    typename ExpirationTrackerImpl<T, K, Lock, AutoLock>::Iterator mIterator;
  public:
    explicit Iterator(nsExpirationTracker<T, K>* aTracker)
      : mAutoLock(aTracker->GetMutex())
      , mIterator(aTracker, mAutoLock)
    {
    }

    T* Next()
    {
      return mIterator.Next();
    }
  };

  friend class Iterator;

  bool IsEmpty()
  {
    return this->IsEmptyLocked(FakeLock());
  }
};

template<typename T, uint32_t K, typename Mutex, typename AutoLock>
nsresult
ExpirationTrackerImpl<T, K, Mutex, AutoLock>::
ExpirationTrackerObserver::Observe(
    nsISupports* aSubject, const char* aTopic, const char16_t* aData)
{
  if (!strcmp(aTopic, "memory-pressure") && mOwner) {
    mOwner->HandleLowMemory();
  }
  return NS_OK;
}

template<class T, uint32_t K, typename Mutex, typename AutoLock>
MozExternalRefCountType
ExpirationTrackerImpl<T, K, Mutex, AutoLock>::
ExpirationTrackerObserver::AddRef(void)
{
  do { } while (0);
  ((void)0);
  ++mRefCnt;
                                                                          ;
  return mRefCnt;
}

template<class T, uint32_t K, typename Mutex, typename AutoLock>
MozExternalRefCountType
ExpirationTrackerImpl<T, K, Mutex, AutoLock>::
ExpirationTrackerObserver::Release(void)
{
  do { } while (0);
  ((void)0);
  --mRefCnt;
                                                            ;
  if (mRefCnt == 0) {
    ((void)0);
    mRefCnt = 1;
    delete (this);
    return 0;
  }
  return mRefCnt;
}

template<class T, uint32_t K, typename Mutex, typename AutoLock>
nsresult
ExpirationTrackerImpl<T, K, Mutex, AutoLock>::
ExpirationTrackerObserver::QueryInterface(
    const nsIID& aIID, void** aInstancePtr)
{
  do { } while(0);

  nsresult rv = NS_ERROR_FAILURE;
  static_assert( sizeof("(nsIObserver)") != sizeof("()") && (11) > 10 && (int)(0.01) == 0, "MOZ_STATIC_ASSERT_VALID_ARG_COUNT requires 1 to 50 arguments"); static const QITableEntry table[] = { { &(nsIObserver::COMTypeInfo<nsIObserver, void>::kIID), int32_t(reinterpret_cast<char*>( static_cast<nsIObserver*>((ExpirationTrackerObserver*) 0x1000)) - reinterpret_cast<char*>((ExpirationTrackerObserver*) 0x1000)) }, { &(nsISupports::COMTypeInfo<nsISupports, void>::kIID), int32_t(reinterpret_cast<char*>( static_cast<nsISupports*>( static_cast<nsIObserver*>( (ExpirationTrackerObserver*) 0x1000))) - reinterpret_cast<char*>((ExpirationTrackerObserver*) 0x1000)) }, { nullptr, 0 } }; static_assert((sizeof(table)/sizeof(table[0])) > 1, "need at least 1 interface"); rv = NS_TableDrivenQI(static_cast<void*>(this), aIID, aInstancePtr, table);
  return rv;
}
class nsIDocument;
struct nsIDocumentAtoms;

namespace mozilla {
namespace dom {

struct ElementCreationOptionsAtoms;
struct NativePropertyHooks;
class ProtoAndIfaceCache;

}
}

namespace mozilla {
namespace dom {

enum class VisibilityState : uint8_t {
  Hidden,
  Visible,
  Prerender,
  EndGuard_
};

namespace VisibilityStateValues {
extern const EnumEntry strings[4];
}

bool
ToJSValue(JSContext* aCx, VisibilityState aArgument, JS::MutableHandle<JS::Value> aValue);


enum class FlashClassification : uint8_t {
  Unclassified,
  Unknown,
  Allowed,
  Denied,
  EndGuard_
};

namespace FlashClassificationValues {
extern const EnumEntry strings[5];
}

bool
ToJSValue(JSContext* aCx, FlashClassification aArgument, JS::MutableHandle<JS::Value> aValue);


struct ElementCreationOptions : public DictionaryBase
{
                        Optional<nsString> mIs;
                        Optional<nsString> mPseudo;

  ElementCreationOptions();

  explicit inline ElementCreationOptions(const FastDictionaryInitializer& )
  {

  }

  explicit inline ElementCreationOptions(const ElementCreationOptions& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  ElementCreationOptions&
  operator=(const ElementCreationOptions& aOther);

private:
  static bool
  InitIds(JSContext* cx, ElementCreationOptionsAtoms* atomsCache);
};

namespace binding_detail {
struct FastElementCreationOptions : public ElementCreationOptions
{
  inline FastElementCreationOptions()
    : ElementCreationOptions(FastDictionaryInitializer())
  {

  }
};
}


class ElementCreationOptionsOrString
{
  friend class ElementCreationOptionsOrStringArgument;
  enum Type
  {
    eUninitialized,
    eElementCreationOptions,
    eString
  };

  union Value
  {
    UnionMember<binding_detail::FastElementCreationOptions > mElementCreationOptions;
    UnionMember<binding_detail::FakeString > mString;

  };

  Type mType;
  Value mValue;

  ElementCreationOptionsOrString(const ElementCreationOptionsOrString&) = delete;
  ElementCreationOptionsOrString& operator=(const ElementCreationOptionsOrString&) = delete;
public:
  explicit inline ElementCreationOptionsOrString()
    : mType(eUninitialized)
  {
  }

  inline ~ElementCreationOptionsOrString()
  {
    Uninit();
  }

  inline binding_detail::FastElementCreationOptions&
  RawSetAsElementCreationOptions()
  {
    if (mType == eElementCreationOptions) {
      return mValue.mElementCreationOptions.Value();
    }
    do { } while (0);
    mType = eElementCreationOptions;
    return mValue.mElementCreationOptions.SetValue();
  }

  inline binding_detail::FastElementCreationOptions&
  SetAsElementCreationOptions()
  {
    if (mType == eElementCreationOptions) {
      return mValue.mElementCreationOptions.Value();
    }
    Uninit();
    mType = eElementCreationOptions;
    return mValue.mElementCreationOptions.SetValue();
  }

  inline bool
  IsElementCreationOptions() const
  {
    return mType == eElementCreationOptions;
  }

  inline binding_detail::FastElementCreationOptions&
  GetAsElementCreationOptions()
  {
    do { } while (0);
    return mValue.mElementCreationOptions.Value();
  }

  inline const ElementCreationOptions&
  GetAsElementCreationOptions() const
  {
    do { } while (0);
    return mValue.mElementCreationOptions.Value();
  }

  inline binding_detail::FakeString&
  RawSetAsString()
  {
    if (mType == eString) {
      return mValue.mString.Value();
    }
    do { } while (0);
    mType = eString;
    return mValue.mString.SetValue();
  }

  inline binding_detail::FakeString&
  SetAsString()
  {
    if (mType == eString) {
      return mValue.mString.Value();
    }
    Uninit();
    mType = eString;
    return mValue.mString.SetValue();
  }

  inline bool
  IsString() const
  {
    return mType == eString;
  }

  inline binding_detail::FakeString&
  GetAsString()
  {
    do { } while (0);
    return mValue.mString.Value();
  }

  inline const nsAString&
  GetAsString() const
  {
    do { } while (0);
    return mValue.mString.Value();
  }

  inline void
  Uninit()
  {
    switch (mType) {
      case eUninitialized: {
        break;
      }
      case eElementCreationOptions: {
        DestroyElementCreationOptions();
        break;
      }
      case eString: {
        DestroyString();
        break;
      }
    }
  }

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

private:
  inline void
  DestroyElementCreationOptions()
  {
    do { } while (0);
    mValue.mElementCreationOptions.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyString()
  {
    do { } while (0);
    mValue.mString.Destroy();
    mType = eUninitialized;
  }
};


class OwningElementCreationOptionsOrString : public AllOwningUnionBase
{
  friend void ImplCycleCollectionUnlink(OwningElementCreationOptionsOrString& aUnion);
  enum Type
  {
    eUninitialized,
    eElementCreationOptions,
    eString
  };

  union Value
  {
    UnionMember<ElementCreationOptions > mElementCreationOptions;
    UnionMember<nsString > mString;

  };

  Type mType;
  Value mValue;

public:
  explicit inline OwningElementCreationOptionsOrString()
    : mType(eUninitialized)
  {
  }

  explicit inline OwningElementCreationOptionsOrString(const OwningElementCreationOptionsOrString& aOther)
    : mType(eUninitialized)
  {
    *this = aOther;
  }

  inline ~OwningElementCreationOptionsOrString()
  {
    Uninit();
  }

  ElementCreationOptions&
  RawSetAsElementCreationOptions();

  ElementCreationOptions&
  SetAsElementCreationOptions();

  bool
  TrySetToElementCreationOptions(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsElementCreationOptions() const
  {
    return mType == eElementCreationOptions;
  }

  inline ElementCreationOptions&
  GetAsElementCreationOptions()
  {
    do { } while (0);
    return mValue.mElementCreationOptions.Value();
  }

  inline ElementCreationOptions const &
  GetAsElementCreationOptions() const
  {
    do { } while (0);
    return mValue.mElementCreationOptions.Value();
  }

  nsString&
  RawSetAsString();

  nsString&
  SetAsString();

  bool
  TrySetToString(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline void
  SetStringData(const nsString::char_type* aData, nsString::size_type aLength)
  {
    RawSetAsString().Assign(aData, aLength);
  }

  inline bool
  IsString() const
  {
    return mType == eString;
  }

  inline nsString&
  GetAsString()
  {
    do { } while (0);
    return mValue.mString.Value();
  }

  inline nsString const &
  GetAsString() const
  {
    do { } while (0);
    return mValue.mString.Value();
  }

  void
  Uninit();

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceUnion(JSTracer* trc);

  OwningElementCreationOptionsOrString&
  operator=(const OwningElementCreationOptionsOrString& aOther);

private:
  void
  DestroyElementCreationOptions();

  void
  DestroyString();
};


namespace DocumentBinding {

  typedef nsIDocument NativeType;

  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, nsIDocument* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetProtoObjectHandle(JSContext* aCx);

  JSObject*
  GetProtoObject(JSContext* aCx);

  JS::Handle<JSObject*>
  GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true);

  JSObject*
  GetConstructorObject(JSContext* aCx);

}



}
}








class gfxUserFontSet;
class imgIRequest;
class nsAString;
class nsBindingManager;
class nsIDocShell;
class nsDocShell;
class nsDOMNavigationTiming;
class nsFrameLoader;
class nsHTMLCSSStyleSheet;
class nsHTMLDocument;
class nsHTMLStyleSheet;
class nsIAtom;
class nsIBFCacheEntry;
class nsIChannel;
class nsIContent;
class nsIContentSink;
class nsIDocShell;
class nsIDocShellTreeItem;
class nsIDocumentEncoder;
class nsIDocumentObserver;
class nsIDOMDocument;
class nsIDOMDocumentType;
class nsIDOMElement;
class nsIDOMNodeFilter;
class nsIDOMNodeList;
class nsIHTMLCollection;
class nsILayoutHistoryState;
class nsILoadContext;
class nsIObjectLoadingContent;
class nsIObserver;
class nsIPresShell;
class nsIPrincipal;
class nsIRequest;
class nsIRunnable;
class nsIStreamListener;
class nsIStructuredCloneContainer;
class nsIURI;
class nsIVariant;
class nsViewManager;
class nsPresContext;
class nsRange;
class nsScriptLoader;
class nsSMILAnimationController;
class nsSVGElement;
class nsTextNode;
class nsWindowSizes;
class nsDOMCaretPosition;
class nsViewportInfo;
class nsIGlobalObject;
struct nsCSSSelectorList;

namespace mozilla {
class AbstractThread;
class CSSStyleSheet;
class ErrorResult;
class EventStates;
class PendingAnimationTracker;
class StyleSetHandle;
template<typename> class OwningNonNull;

namespace css {
class Loader;
class ImageLoader;
class Rule;
}

namespace dom {
class Animation;
class AnonymousContent;
class Attr;
class BoxObject;
class CDATASection;
class Comment;
struct CustomElementDefinition;
class DocGroup;
class DocumentFragment;
class DocumentTimeline;
class DocumentType;
class DOMImplementation;
class DOMIntersectionObserver;
class DOMStringList;
class Element;
struct ElementCreationOptions;
struct ElementRegistrationOptions;
class Event;
class EventTarget;
class FontFaceSet;
class FrameRequestCallback;
struct FullscreenRequest;
class ImageTracker;
class ImportManager;
class HTMLBodyElement;
struct LifecycleCallbackArgs;
class Link;
class Location;
class MediaQueryList;
class GlobalObject;
class NodeFilter;
class NodeIterator;
enum class OrientationType : uint8_t;
class ProcessingInstruction;
class Promise;
class StyleSheetList;
class SVGDocument;
class SVGSVGElement;
class Touch;
class TouchList;
class TreeWalker;
class XPathEvaluator;
class XPathExpression;
class XPathNSResolver;
class XPathResult;
template<typename> class Sequence;

template<typename, typename> class CallbackObjectHolder;
typedef CallbackObjectHolder<NodeFilter, nsIDOMNodeFilter> NodeFilterHolder;

enum class CallerType : uint32_t;

}
}






enum DocumentFlavor {
  DocumentFlavorLegacyGuess,
  DocumentFlavorHTML,
  DocumentFlavorSVG,
  DocumentFlavorPlain,
};


enum class HSTSPrimingState {
  eNO_HSTS_PRIMING = 0,
  eHSTS_PRIMING_ALLOW = 1,
  eHSTS_PRIMING_BLOCK = 2
};
class nsContentList;





class nsIDocument : public nsINode,
                    public mozilla::dom::DispatcherTrait
{
  typedef mozilla::dom::GlobalObject GlobalObject;

public:
  typedef mozilla::net::ReferrerPolicy ReferrerPolicyEnum;
  typedef mozilla::dom::Element Element;
  typedef mozilla::dom::FullscreenRequest FullscreenRequest;

  template<typename T, typename U> struct COMTypeInfo;


  nsIDocument();




  class PageUnloadingEventTimeStamp
  {
    nsCOMPtr<nsIDocument> mDocument;
    bool mSet;

  public:
    explicit PageUnloadingEventTimeStamp(nsIDocument* aDocument)
      : mDocument(aDocument)
      , mSet(false)
    {
      do { } while (0);
      if (mDocument->mPageUnloadingEventTimeStamp.IsNull()) {
        mDocument->SetPageUnloadingEventTimeStamp();
        mSet = true;
      }
    }

    ~PageUnloadingEventTimeStamp()
    {
      if (mSet) {
        mDocument->CleanUnloadEventsTimeStamp();
      }
    }
  };
  virtual nsresult StartDocumentLoad(const char* aCommand,
                                     nsIChannel* aChannel,
                                     nsILoadGroup* aLoadGroup,
                                     nsISupports* aContainer,
                                     nsIStreamListener **aDocListener,
                                     bool aReset,
                                     nsIContentSink* aSink = nullptr) = 0;
  virtual void StopDocumentLoad() = 0;

  virtual void SetSuppressParserErrorElement(bool aSuppress) {}
  virtual bool SuppressParserErrorElement() { return false; }

  virtual void SetSuppressParserErrorConsoleMessages(bool aSuppress) {}
  virtual bool SuppressParserErrorConsoleMessages() { return false; }







  virtual void NotifyPossibleTitleChange(bool aBoundTitleElement) = 0;
  nsIURI* GetDocumentURI() const
  {
    return mDocumentURI;
  }
  nsIURI* GetOriginalURI() const
  {
    return mOriginalURI;
  }





  virtual void SetDocumentURI(nsIURI* aURI) = 0;





  virtual void SetChromeXHRDocURI(nsIURI* aURI) = 0;





  virtual void SetChromeXHRDocBaseURI(nsIURI* aURI) = 0;




  virtual void ApplySettingsFromCSP(bool aSpeculative) = 0;

  virtual already_AddRefed<nsIParser> CreatorParserOrNull() = 0;





  ReferrerPolicyEnum GetReferrerPolicy() const
  {
    return mReferrerPolicy;
  }




  uint32_t ReferrerPolicy() const
  {
    return GetReferrerPolicy();
  }






  bool GetBlockAllMixedContent(bool aPreload) const
  {
    if (aPreload) {
      return mBlockAllMixedContentPreloads;
    }
    return mBlockAllMixedContent;
  }
  bool GetUpgradeInsecureRequests(bool aPreload) const
  {
    if (aPreload) {
      return mUpgradeInsecurePreloads;
    }
    return mUpgradeInsecureRequests;
  }

  void SetReferrer(const nsACString& aReferrer) {
    mReferrer = aReferrer;
  }





  HSTSPrimingState GetHSTSPrimingStateForLocation(nsIURI* aContentLocation) const
  {
    HSTSPrimingState state;
    if (mHSTSPrimingURIList.Get(aContentLocation, &state)) {
      return state;
    }
    return HSTSPrimingState::eNO_HSTS_PRIMING;
  }






  void AddHSTSPrimingLocation(nsIURI* aContentLocation, HSTSPrimingState aState)
  {
    mHSTSPrimingURIList.Put(aContentLocation, aState);
  }

  void ClearHSTSPrimingLocation(nsIURI* aContentLocation)
  {
    mHSTSPrimingURIList.Remove(aContentLocation);
  }




  virtual void SetPrincipal(nsIPrincipal *aPrincipal) = 0;




  already_AddRefed<nsILoadGroup> GetDocumentLoadGroup() const
  {
    nsCOMPtr<nsILoadGroup> group = do_QueryReferent(mDocumentLoadGroup);
    return group.forget();
  }







  nsIURI* GetFallbackBaseURI() const
  {
    if (mIsSrcdocDocument && mParentDocument) {
      return mParentDocument->GetDocBaseURI();
    }
    return mDocumentURI;
  }
  nsIURI* GetDocBaseURI() const
  {
    if (mDocumentBaseURI) {
      return mDocumentBaseURI;
    }
    return GetFallbackBaseURI();
  }
  virtual already_AddRefed<nsIURI> GetBaseURI(bool aTryUseXHRDocBaseURI = false) const override;

  virtual void SetBaseURI(nsIURI* aURI) = 0;




  virtual void GetBaseTarget(nsAString &aBaseTarget) = 0;
  void SetBaseTarget(const nsString& aBaseTarget) {
    mBaseTarget = aBaseTarget;
  }




  const nsCString& GetDocumentCharacterSet() const
  {
    return mCharacterSet;
  }





  virtual void SetDocumentCharacterSet(const nsACString& aCharSetID) = 0;

  int32_t GetDocumentCharacterSetSource() const
  {
    return mCharacterSetSource;
  }



  void SetDocumentCharacterSetSource(int32_t aCharsetSource)
  {
    mCharacterSetSource = aCharsetSource;
  }




  virtual nsresult AddCharSetObserver(nsIObserver* aObserver) = 0;




  virtual void RemoveCharSetObserver(nsIObserver* aObserver) = 0;
  typedef bool (* IDTargetObserver)(Element* aOldElement,
                                      Element* aNewelement, void* aData);
  virtual Element* AddIDTargetObserver(nsIAtom* aID, IDTargetObserver aObserver,
                                       void* aData, bool aForImage) = 0;




  virtual void RemoveIDTargetObserver(nsIAtom* aID, IDTargetObserver aObserver,
                                      void* aData, bool aForImage) = 0;






  virtual nsresult GetContentType(nsAString& aContentType) = 0;




  virtual void SetContentType(const nsAString& aContentType) = 0;




  void GetContentLanguage(nsAString& aContentLanguage) const
  {
    CopyASCIItoUTF16(mContentLanguage, aContentLanguage);
  }
  bool GetBidiEnabled() const
  {
    return mBidiEnabled;
  }







  void SetBidiEnabled()
  {
    mBidiEnabled = true;
  }




  bool GetMathMLEnabled() const
  {
    return mMathMLEnabled;
  }

  void SetMathMLEnabled()
  {
    mMathMLEnabled = true;
  }




  bool IsInitialDocument() const
  {
    return mIsInitialDocumentInWindow;
  }





  void SetIsInitialDocument(bool aIsInitialDocument)
  {
    mIsInitialDocumentInWindow = aIsInitialDocument;
  }






  void IgnoreDocGroupMismatches()
  {
    mIgnoreDocGroupMismatches = true;
  }





  uint32_t GetBidiOptions() const
  {
    return mBidiOptions;
  }







  void SetBidiOptions(uint32_t aBidiOptions)
  {
    mBidiOptions = aBidiOptions;
  }




  bool GetHasMixedActiveContentLoaded()
  {
    return mHasMixedActiveContentLoaded;
  }




  void SetHasMixedActiveContentLoaded(bool aHasMixedActiveContentLoaded)
  {
    mHasMixedActiveContentLoaded = aHasMixedActiveContentLoaded;
  }




  bool GetHasMixedActiveContentBlocked()
  {
    return mHasMixedActiveContentBlocked;
  }




  void SetHasMixedActiveContentBlocked(bool aHasMixedActiveContentBlocked)
  {
    mHasMixedActiveContentBlocked = aHasMixedActiveContentBlocked;
  }




  bool GetHasMixedDisplayContentLoaded()
  {
    return mHasMixedDisplayContentLoaded;
  }




  void SetHasMixedDisplayContentLoaded(bool aHasMixedDisplayContentLoaded)
  {
    mHasMixedDisplayContentLoaded = aHasMixedDisplayContentLoaded;
  }




  bool GetHasMixedDisplayContentBlocked()
  {
    return mHasMixedDisplayContentBlocked;
  }




  void SetHasReferrerPolicyCSP(bool aHasReferrerPolicyCSP)
  {
    mHasReferrerPolicyCSP = aHasReferrerPolicyCSP;
  }




  void SetHasMixedDisplayContentBlocked(bool aHasMixedDisplayContentBlocked)
  {
    mHasMixedDisplayContentBlocked = aHasMixedDisplayContentBlocked;
  }




  void SetHasMixedContentObjectSubrequest(bool aHasMixedContentObjectSubrequest)
  {
    mHasMixedContentObjectSubrequest = aHasMixedContentObjectSubrequest;
  }




  void SetHasCSP(bool aHasCSP)
  {
    mHasCSP = aHasCSP;
  }




  void SetHasUnsafeInlineCSP(bool aHasUnsafeInlineCSP)
  {
    mHasUnsafeInlineCSP = aHasUnsafeInlineCSP;
  }




  void SetHasUnsafeEvalCSP(bool aHasUnsafeEvalCSP)
  {
    mHasUnsafeEvalCSP = aHasUnsafeEvalCSP;
  }




  bool GetHasTrackingContentBlocked()
  {
    return mHasTrackingContentBlocked;
  }




  void SetHasTrackingContentBlocked(bool aHasTrackingContentBlocked)
  {
    mHasTrackingContentBlocked = aHasTrackingContentBlocked;
  }




  bool GetHasTrackingContentLoaded()
  {
    return mHasTrackingContentLoaded;
  }




  void SetHasTrackingContentLoaded(bool aHasTrackingContentLoaded)
  {
    mHasTrackingContentLoaded = aHasTrackingContentLoaded;
  }





  uint32_t GetSandboxFlags() const
  {
    return mSandboxFlags;
  }




  void GetSandboxFlagsAsString(nsAString& aFlags);





  void SetSandboxFlags(uint32_t sandboxFlags)
  {
    mSandboxFlags = sandboxFlags;
  }





  virtual void GetHeaderData(nsIAtom* aHeaderField, nsAString& aData) const = 0;
  virtual void SetHeaderData(nsIAtom* aheaderField, const nsAString& aData) = 0;
  virtual already_AddRefed<nsIPresShell> CreateShell(
      nsPresContext* aContext,
      nsViewManager* aViewManager,
      mozilla::StyleSetHandle aStyleSet) = 0;
  virtual void DeleteShell() = 0;

  nsIPresShell* GetShell() const
  {
    return GetBFCacheEntry() ? nullptr : mPresShell;
  }



  void DisallowBFCaching()
  {
    do { } while(0);
    mBFCacheDisallowed = true;
  }

  bool IsBFCachingAllowed() const
  {
    return !mBFCacheDisallowed;
  }

  void SetBFCacheEntry(nsIBFCacheEntry* aEntry)
  {
    do { } while(0);


    mBFCacheEntry = aEntry;
  }

  nsIBFCacheEntry* GetBFCacheEntry() const
  {
    return mBFCacheEntry;
  }






  nsIDocument *GetParentDocument() const
  {
    return mParentDocument;
  }




  void SetParentDocument(nsIDocument* aParent)
  {
    mParentDocument = aParent;
    if (aParent) {
      mIgnoreDocGroupMismatches = aParent->mIgnoreDocGroupMismatches;
    }
  }




  virtual bool GetAllowPlugins () = 0;




  virtual nsresult SetSubDocumentFor(Element* aContent,
                                     nsIDocument* aSubDoc) = 0;




  virtual nsIDocument *GetSubDocumentFor(nsIContent *aContent) const = 0;




  virtual Element* FindContentForSubDocument(nsIDocument* aDocument) const = 0;




  mozilla::dom::DocumentType* GetDoctype() const;




  Element* GetRootElement() const;
  virtual nsViewportInfo GetViewportInfo(const mozilla::ScreenIntSize& aDisplaySize) = 0;




  virtual bool WillIgnoreCharsetOverride() {
    return true;
  }




  bool IsSrcdocDocument() const {
    return mIsSrcdocDocument;
  }




  void SetIsSrcdocDocument(bool aIsSrcdocDocument) {
    mIsSrcdocDocument = aIsSrcdocDocument;
  }






  nsresult GetSrcdocData(nsAString& aSrcdocData);

  bool DidDocumentOpen() {
    return mDidDocumentOpen;
  }

  already_AddRefed<mozilla::dom::AnonymousContent>
  InsertAnonymousContent(mozilla::dom::Element& aElement,
                         mozilla::ErrorResult& aError);
  void RemoveAnonymousContent(mozilla::dom::AnonymousContent& aContent,
                              mozilla::ErrorResult& aError);






  Element* GetAnonRootIfInAnonymousContentContainer(nsINode* aNode) const;
  nsTArray<RefPtr<mozilla::dom::AnonymousContent>>& GetAnonymousContents() {
    return mAnonymousContents;
  }

  static nsresult GenerateDocumentId(nsAString& aId);
  nsresult GetOrCreateId(nsAString& aId);
  void SetId(const nsAString& aId);

  mozilla::TimeStamp GetPageUnloadingEventTimeStamp() const
  {
    if (!mParentDocument) {
      return mPageUnloadingEventTimeStamp;
    }

    mozilla::TimeStamp parentTimeStamp(mParentDocument->GetPageUnloadingEventTimeStamp());
    if (parentTimeStamp.IsNull()) {
      return mPageUnloadingEventTimeStamp;
    }

    if (!mPageUnloadingEventTimeStamp ||
        parentTimeStamp < mPageUnloadingEventTimeStamp) {
      return parentTimeStamp;
    }

    return mPageUnloadingEventTimeStamp;
  }

  virtual void NotifyLayerManagerRecreated() = 0;
  virtual void ScheduleSVGForPresAttrEvaluation(nsSVGElement* aSVG) = 0;

  virtual void UnscheduleSVGForPresAttrEvaluation(nsSVGElement* aSVG) = 0;


  virtual void ResolveScheduledSVGPresAttrs() = 0;

protected:
  virtual Element *GetRootElementInternal() const = 0;

  void SetPageUnloadingEventTimeStamp()
  {
    do { } while (0);
    mPageUnloadingEventTimeStamp = mozilla::TimeStamp::NowLoRes();
  }

  void CleanUnloadEventsTimeStamp()
  {
    do { } while (0);
    mPageUnloadingEventTimeStamp = mozilla::TimeStamp();
  }

private:
  class SelectorCacheKey
  {
    public:
      explicit SelectorCacheKey(const nsAString& aString) : mKey(aString)
      {
                                        ;
      }

      nsString mKey;
      nsExpirationState mState;

      nsExpirationState* GetExpirationState() { return &mState; }

      ~SelectorCacheKey()
      {
                                        ;
      }
  };

  class SelectorCacheKeyDeleter;

public:
  class SelectorCache final
    : public nsExpirationTracker<SelectorCacheKey, 4>
  {
    public:
      explicit SelectorCache(nsIEventTarget* aEventTarget);


      void CacheList(const nsAString& aSelector, nsCSSSelectorList* aSelectorList);

      virtual void NotifyExpired(SelectorCacheKey* aSelector) override;






      bool GetList(const nsAString& aSelector, nsCSSSelectorList** aList)
      {
        return mTable.Get(aSelector, aList);
      }

      ~SelectorCache();

    private:
      nsClassHashtable<nsStringHashKey, nsCSSSelectorList> mTable;
  };

  SelectorCache& GetSelectorCache() {
    if (!mSelectorCache) {
      mSelectorCache =
        new SelectorCache(EventTargetFor(mozilla::TaskCategory::Other));
    }
    return *mSelectorCache;
  }


  Element* GetHtmlElement() const;


  Element* GetHtmlChildElement(nsIAtom* aTag);


  mozilla::dom::HTMLBodyElement* GetBodyElement();


  Element* GetHeadElement() {
    return GetHtmlChildElement(nsGkAtoms::head);
  }
  virtual void EnsureOnDemandBuiltInUASheet(mozilla::StyleSheet* aSheet) = 0;







  virtual int32_t GetNumberOfStyleSheets() const = 0;







  virtual mozilla::StyleSheet* GetStyleSheetAt(int32_t aIndex) const = 0;
  virtual void InsertStyleSheetAt(mozilla::StyleSheet* aSheet,
                                  int32_t aIndex) = 0;







  virtual int32_t GetIndexOfStyleSheet(
      const mozilla::StyleSheet* aSheet) const = 0;
  virtual void UpdateStyleSheets(
      nsTArray<RefPtr<mozilla::StyleSheet>>& aOldSheets,
      nsTArray<RefPtr<mozilla::StyleSheet>>& aNewSheets) = 0;




  virtual void AddStyleSheet(mozilla::StyleSheet* aSheet) = 0;




  virtual void RemoveStyleSheet(mozilla::StyleSheet* aSheet) = 0;





  virtual void SetStyleSheetApplicableState(mozilla::StyleSheet* aSheet,
                                            bool aApplicable) = 0;

  enum additionalSheetType {
    eAgentSheet,
    eUserSheet,
    eAuthorSheet,
    AdditionalSheetTypeCount
  };

  virtual nsresult LoadAdditionalStyleSheet(additionalSheetType aType,
                                            nsIURI* aSheetURI) = 0;
  virtual nsresult AddAdditionalStyleSheet(additionalSheetType aType,
                                           mozilla::StyleSheet* aSheet) = 0;
  virtual void RemoveAdditionalStyleSheet(additionalSheetType aType,
                                          nsIURI* sheetURI) = 0;
  virtual mozilla::StyleSheet* GetFirstAdditionalAuthorSheet() = 0;
  template<typename T>
  size_t FindDocStyleSheetInsertionPoint(const nsTArray<RefPtr<T>>& aDocSheets,
                                         T* aSheet);




  mozilla::css::Loader* CSSLoader() const {
    return mCSSLoader;
  }

  mozilla::StyleBackendType GetStyleBackendType() const {
    if (mStyleBackendType == mozilla::StyleBackendType::None) {
      const_cast<nsIDocument*>(this)->UpdateStyleBackendType();
    }
    do { } while (0);
    return mStyleBackendType;
  }

  void UpdateStyleBackendType();

  bool IsStyledByServo() const {
    return GetStyleBackendType() == mozilla::StyleBackendType::Servo;
  }




  mozilla::css::ImageLoader* StyleImageLoader() const {
    return mStyleImageLoader;
  }






  virtual nsIChannel* GetChannel() const = 0;





  nsHTMLStyleSheet* GetAttributeStyleSheet() const {
    return mAttrStyleSheet;
  }





  nsHTMLCSSStyleSheet* GetInlineStyleSheet() const {
    return mStyleAttrStyleSheet;
  }

  virtual void SetScriptGlobalObject(nsIScriptGlobalObject* aGlobalObject) = 0;
  nsIScriptGlobalObject*
    GetScriptHandlingObject(bool& aHasHadScriptHandlingObject) const
  {
    aHasHadScriptHandlingObject = mHasHadScriptHandlingObject;
    return mScriptGlobalObject ? mScriptGlobalObject.get() :
                                 GetScriptHandlingObjectInternal();
  }
  virtual void SetScriptHandlingObject(nsIScriptGlobalObject* aScriptObject) = 0;
  virtual nsIGlobalObject* GetScopeObject() const = 0;
  virtual void SetScopeObject(nsIGlobalObject* aGlobal) = 0;




  nsPIDOMWindowOuter *GetWindow() const
  {
    return mWindow ? mWindow->GetOuterWindow() : GetWindowInternal();
  }

  bool IsInBackgroundWindow() const
  {
    auto* outer = mWindow ? mWindow->GetOuterWindow() : nullptr;
    return outer && outer->IsBackground();
  }






  nsPIDOMWindowInner* GetInnerWindow() const
  {
    return mRemovedFromDocShell ? nullptr : mWindow;
  }




  uint64_t OuterWindowID() const
  {
    nsPIDOMWindowOuter* window = GetWindow();
    return window ? window->WindowID() : 0;
  }




  uint64_t InnerWindowID() const
  {
    nsPIDOMWindowInner* window = GetInnerWindow();
    return window ? window->WindowID() : 0;
  }




  virtual nsScriptLoader* ScriptLoader() = 0;




  virtual void AddToIdTable(Element* aElement, nsIAtom* aId) = 0;
  virtual void RemoveFromIdTable(Element* aElement, nsIAtom* aId) = 0;
  virtual void AddToNameTable(Element* aElement, nsIAtom* aName) = 0;
  virtual void RemoveFromNameTable(Element* aElement, nsIAtom* aName) = 0;




  virtual nsTArray<Element*> GetFullscreenStack() const = 0;
  virtual void AsyncRequestFullScreen(
    mozilla::UniquePtr<FullscreenRequest>&& aRequest) = 0;







  virtual nsresult
    RemoteFrameFullscreenChanged(nsIDOMElement* aFrameElement) = 0;
   virtual nsresult RemoteFrameFullscreenReverted() = 0;






  virtual void RestorePreviousFullScreenState() = 0;





  virtual bool IsFullscreenLeaf() = 0;






  virtual nsIDocument* GetFullscreenRoot() = 0;





  virtual void SetFullscreenRoot(nsIDocument* aRoot) = 0;
  static void ExitFullscreenInDocTree(nsIDocument* aDocument);
  static void AsyncExitFullscreen(nsIDocument* aDocument);






  static bool HandlePendingFullscreenRequests(nsIDocument* aDocument);





  void DispatchFullscreenError(const char* aMessage);

  virtual void RequestPointerLock(Element* aElement,
                                  mozilla::dom::CallerType aCallerType) = 0;

  static void UnlockPointer(nsIDocument* aDoc = nullptr);



  virtual void SetCurrentOrientation(mozilla::dom::OrientationType aType,
                                     uint16_t aAngle) = 0;
  virtual uint16_t CurrentOrientationAngle() const = 0;
  virtual mozilla::dom::OrientationType CurrentOrientationType() const = 0;
  virtual void SetOrientationPendingPromise(mozilla::dom::Promise* aPromise) = 0;
  virtual mozilla::dom::Promise* GetOrientationPendingPromise() const = 0;
  virtual void AddObserver(nsIDocumentObserver* aObserver) = 0;





  virtual bool RemoveObserver(nsIDocumentObserver* aObserver) = 0;





  virtual void BeginUpdate(nsUpdateType aUpdateType) = 0;
  virtual void EndUpdate(nsUpdateType aUpdateType) = 0;
  virtual void BeginLoad() = 0;
  virtual void EndLoad() = 0;

  enum ReadyState { READYSTATE_UNINITIALIZED = 0, READYSTATE_LOADING = 1, READYSTATE_INTERACTIVE = 3, READYSTATE_COMPLETE = 4};
  virtual void SetReadyStateInternal(ReadyState rs) = 0;
  ReadyState GetReadyStateEnum()
  {
    return mReadyState;
  }



  virtual void ContentStateChanged(nsIContent* aContent,
                                   mozilla::EventStates aStateMask) = 0;




  virtual void DocumentStatesChanged(mozilla::EventStates aStateMask) = 0;



  virtual void StyleRuleChanged(mozilla::StyleSheet* aStyleSheet,
                                mozilla::css::Rule* aStyleRule) = 0;
  virtual void StyleRuleAdded(mozilla::StyleSheet* aStyleSheet,
                              mozilla::css::Rule* aStyleRule) = 0;
  virtual void StyleRuleRemoved(mozilla::StyleSheet* aStyleSheet,
                                mozilla::css::Rule* aStyleRule) = 0;





  virtual void FlushPendingNotifications(mozilla::FlushType aType) = 0;







  virtual void FlushExternalResources(mozilla::FlushType aType) = 0;

  nsBindingManager* BindingManager() const
  {
    return mNodeInfoManager->GetBindingManager();
  }





  nsNodeInfoManager* NodeInfoManager() const
  {
    return mNodeInfoManager;
  }






  virtual void Reset(nsIChannel* aChannel, nsILoadGroup* aLoadGroup) = 0;






  virtual void ResetToURI(nsIURI *aURI, nsILoadGroup* aLoadGroup,
                          nsIPrincipal* aPrincipal) = 0;





  virtual void SetContainer(nsDocShell* aContainer);




  virtual nsISupports* GetContainer() const;




  nsILoadContext* GetLoadContext() const;




  nsIDocShell* GetDocShell() const;







  virtual void SetXMLDeclaration(const char16_t *aVersion,
                                 const char16_t *aEncoding,
                                 const int32_t aStandalone) = 0;
  virtual void GetXMLDeclaration(nsAString& aVersion,
                                 nsAString& aEncoding,
                                 nsAString& Standalone) = 0;







  bool IsHTMLDocument() const
  {
    return mType == eHTML;
  }
  bool IsHTMLOrXHTML() const
  {
    return mType == eHTML || mType == eXHTML;
  }
  bool IsXMLDocument() const
  {
    return !IsHTMLDocument();
  }
  bool IsSVGDocument() const
  {
    return mType == eSVG;
  }
  bool IsXULDocument() const
  {
    return mType == eXUL;
  }
  bool IsUnstyledDocument()
  {
    return IsLoadedAsData() || IsLoadedAsInteractiveData();
  }
  bool LoadsFullXULStyleSheetUpFront()
  {
    return IsXULDocument() || AllowXULXBL();
  }

  virtual bool IsScriptEnabled() = 0;





  virtual already_AddRefed<Element> CreateElem(const nsAString& aName,
                                               nsIAtom* aPrefix,
                                               int32_t aNamespaceID,
                                               const nsAString* aIs = nullptr) = 0;
  nsISupports *GetSecurityInfo()
  {
    return mSecurityInfo;
  }





  virtual nsIChannel* GetFailedChannel() const = 0;





  virtual void SetFailedChannel(nsIChannel* aChannel) = 0;





  int32_t GetDefaultNamespaceID() const
  {
    return mDefaultElementType;
  }

  void DeleteAllProperties();
  void DeleteAllPropertiesFor(nsINode* aNode);

  nsPropertyTable* PropertyTable(uint16_t aCategory) {
    if (aCategory == 0)
      return &mPropertyTable;
    return GetExtraPropertyTable(aCategory);
  }
  uint32_t GetPropertyTableCount()
  { return mExtraPropertyTables.Length() + 1; }




  void SetPartID(uint32_t aID) {
    mPartID = aID;
  }




  uint32_t GetPartID() const {
    return mPartID;
  }





  virtual void Sanitize() = 0;






  typedef bool (*nsSubDocEnumFunc)(nsIDocument *aDocument, void *aData);
  virtual void EnumerateSubDocuments(nsSubDocEnumFunc aCallback,
                                     void *aData) = 0;
  virtual bool CanSavePresentation(nsIRequest *aNewRequest) = 0;






  virtual void Destroy() = 0;







  virtual void RemovedFromDocShell() = 0;






  virtual already_AddRefed<nsILayoutHistoryState> GetLayoutHistoryState() const = 0;
  virtual void BlockOnload() = 0;






  virtual void UnblockOnload(bool aFireSync) = 0;

  void BlockDOMContentLoaded()
  {
    ++mBlockDOMContentLoaded;
  }

  virtual void UnblockDOMContentLoaded() = 0;
  virtual void OnPageShow(bool aPersisted,
                          mozilla::dom::EventTarget* aDispatchStartTarget) = 0;
  virtual void OnPageHide(bool aPersisted,
                          mozilla::dom::EventTarget* aDispatchStartTarget) = 0;
  virtual void AddStyleRelevantLink(mozilla::dom::Link* aLink) = 0;






  virtual void ForgetLink(mozilla::dom::Link* aLink) = 0;






  virtual void ClearBoxObjectFor(nsIContent *aContent) = 0;





  virtual already_AddRefed<mozilla::dom::BoxObject>
    GetBoxObjectFor(mozilla::dom::Element* aElement,
                    mozilla::ErrorResult& aRv) = 0;





  already_AddRefed<mozilla::dom::MediaQueryList>
    MatchMedia(const nsAString& aMediaQueryList);

  const PRCList* MediaQueryLists() const {
    return &mDOMMediaQueryLists;
  }




  nsCompatibility GetCompatibilityMode() const {
    return mCompatMode;
  }





  bool HaveFiredDOMTitleChange() const {
    return mHaveFiredTitleChange;
  }




  virtual Element*
    GetAnonymousElementByAttribute(nsIContent* aElement,
                                   nsIAtom* aAttrName,
                                   const nsAString& aAttrValue) const = 0;







  virtual Element* ElementFromPointHelper(float aX, float aY,
                                          bool aIgnoreRootScrollFrame,
                                          bool aFlushLayout) = 0;

  enum ElementsFromPointFlags {
    IGNORE_ROOT_SCROLL_FRAME = 1,
    FLUSH_LAYOUT = 2,
    IS_ELEMENT_FROM_POINT = 4
  };

  virtual void ElementsFromPointHelper(float aX, float aY,
                                       uint32_t aFlags,
                                       nsTArray<RefPtr<mozilla::dom::Element>>& aElements) = 0;

  virtual nsresult NodesFromRectHelper(float aX, float aY,
                                       float aTopSize, float aRightSize,
                                       float aBottomSize, float aLeftSize,
                                       bool aIgnoreRootScrollFrame,
                                       bool aFlushLayout,
                                       nsIDOMNodeList** aReturn) = 0;




  virtual void FlushSkinBindings() = 0;
  void MayDispatchMutationEvent(nsINode* aTarget)
  {
    if (mSubtreeModifiedDepth > 0) {
      mSubtreeModifiedTargets.AppendObject(aTarget);
    }
  }





  void MarkUncollectableForCCGeneration(uint32_t aGeneration)
  {
    mMarkedCCGeneration = aGeneration;
  }




  uint32_t GetMarkedCCGeneration()
  {
    return mMarkedCCGeneration;
  }

  bool IsLoadedAsData()
  {
    return mLoadedAsData;
  }

  bool IsLoadedAsInteractiveData()
  {
    return mLoadedAsInteractiveData;
  }

  bool MayStartLayout()
  {
    return mMayStartLayout;
  }

  virtual void SetMayStartLayout(bool aMayStartLayout)
  {
    mMayStartLayout = aMayStartLayout;
  }

  already_AddRefed<nsIDocumentEncoder> GetCachedEncoder();

  void SetCachedEncoder(already_AddRefed<nsIDocumentEncoder> aEncoder);


  virtual nsresult InitializeFrameLoader(nsFrameLoader* aLoader) = 0;


  virtual nsresult FinalizeFrameLoader(nsFrameLoader* aLoader, nsIRunnable* aFinalizer) = 0;

  virtual void TryCancelFrameLoaderInitialization(nsIDocShell* aShell) = 0;





  bool IsRootDisplayDocument() const
  {
    return !mParentDocument && !mDisplayDocument;
  }

  bool IsBeingUsedAsImage() const {
    return mIsBeingUsedAsImage;
  }

  void SetIsBeingUsedAsImage() {
    mIsBeingUsedAsImage = true;
  }

  bool IsResourceDoc() const {
    return IsBeingUsedAsImage() ||
      mHasDisplayDocument;
  }







  nsIDocument* GetDisplayDocument() const
  {
    return mDisplayDocument;
  }





  void SetDisplayDocument(nsIDocument* aDisplayDocument)
  {
    do { } while (0);




    do { } while (0);
    do { } while (0);
    do { } while (0);

    mDisplayDocument = aDisplayDocument;
    mHasDisplayDocument = !!aDisplayDocument;
  }
  class ExternalResourceLoad : public nsISupports
  {
  public:
    virtual ~ExternalResourceLoad() {}

    void AddObserver(nsIObserver* aObserver) {
      do { } while (0);
      mObservers.AppendElement(aObserver);
    }

    const nsTArray< nsCOMPtr<nsIObserver> > & Observers() {
      return mObservers;
    }
  protected:
    AutoTArray< nsCOMPtr<nsIObserver>, 8 > mObservers;
  };
  virtual nsIDocument*
    RequestExternalResource(nsIURI* aURI,
                            nsINode* aRequestingNode,
                            ExternalResourceLoad** aPendingLoad) = 0;






  virtual void EnumerateExternalResources(nsSubDocEnumFunc aCallback,
                                          void* aData) = 0;






  bool IsShowing() const { return mIsShowing; }




  bool IsVisible() const { return mVisible; }





  bool IsVisibleConsideringAncestors() const;







  bool IsActive() const { return mDocumentContainer && !mRemovedFromDocShell; }
  bool IsCurrentActiveDocument() const
  {
    nsPIDOMWindowInner* inner = GetInnerWindow();
    return inner && inner->IsCurrentInnerWindow() && inner->GetDoc() == this;
  }







  void RegisterActivityObserver(nsISupports* aSupports);
  bool UnregisterActivityObserver(nsISupports* aSupports);

  typedef void (* ActivityObserverEnumerator)(nsISupports*, void*);
  void EnumerateActivityObservers(ActivityObserverEnumerator aEnumerator,
                                  void* aData);




  bool HasAnimationController() { return !!mAnimationController; }




  virtual nsSMILAnimationController* GetAnimationController() = 0;





  virtual mozilla::PendingAnimationTracker* GetPendingAnimationTracker() = 0;




  virtual mozilla::PendingAnimationTracker*
  GetOrCreatePendingAnimationTracker() = 0;





  virtual void SuppressEventHandling(uint32_t aIncrease = 1) = 0;






  virtual void UnsuppressEventHandlingAndFireEvents(bool aFireEvents) = 0;

  uint32_t EventHandlingSuppressed() const { return mEventsSuppressed; }

  bool IsEventHandlingEnabled() {
    return !EventHandlingSuppressed() && mScriptGlobalObject;
  }




  void BeginEvaluatingExternalScript() { ++mExternalScriptsBeingEvaluated; }




  void EndEvaluatingExternalScript() { --mExternalScriptsBeingEvaluated; }

  bool IsDNSPrefetchAllowed() const { return mAllowDNSPrefetch; }





  bool AllowXULXBL() {
    return mAllowXULXBL == eTriTrue ? true :
           mAllowXULXBL == eTriFalse ? false :
           InternalAllowXULXBL();
  }

  void ForceEnableXULXBL() {
    mAllowXULXBL = eTriTrue;
  }





  virtual nsIDocument* GetTemplateContentsOwner() = 0;
  bool IsStaticDocument() { return mIsStaticDocument; }
  virtual already_AddRefed<nsIDocument>
  CreateStaticClone(nsIDocShell* aCloneContainer);





  nsIDocument* GetOriginalDocument()
  {
    do { } while (0);
    return mOriginalDocument;
  }





  void UnlinkOriginalDocumentIfStatic();
  virtual void PreloadPictureOpened() = 0;

  virtual void PreloadPictureClosed() = 0;

  virtual void PreloadPictureImageSource(const nsAString& aSrcsetAttr,
                                         const nsAString& aSizesAttr,
                                         const nsAString& aTypeAttr,
                                         const nsAString& aMediaAttr) = 0;
  virtual already_AddRefed<nsIURI>
    ResolvePreloadImage(nsIURI *aBaseURI,
                        const nsAString& aSrcAttr,
                        const nsAString& aSrcsetAttr,
                        const nsAString& aSizesAttr) = 0;






  virtual void MaybePreLoadImage(nsIURI* uri,
                                 const nsAString& aCrossOriginAttr,
                                 ReferrerPolicyEnum aReferrerPolicy) = 0;





  virtual void ForgetImagePreload(nsIURI* aURI) = 0;






  virtual void PreloadStyle(nsIURI* aURI, const nsAString& aCharset,
                            const nsAString& aCrossOriginAttr,
                            ReferrerPolicyEnum aReferrerPolicy,
                            const nsAString& aIntegrity) = 0;
  virtual nsresult LoadChromeSheetSync(nsIURI* aURI, bool aIsAgentSheet,
                                       RefPtr<mozilla::StyleSheet>* aSheet) = 0;
  virtual bool IsDocumentRightToLeft() { return false; }




  virtual void MaybePreconnect(nsIURI* uri,
                               mozilla::CORSMode aCORSMode) = 0;

  enum DocumentTheme {
    Doc_Theme_Uninitialized,
    Doc_Theme_None,
    Doc_Theme_Neutral,
    Doc_Theme_Dark,
    Doc_Theme_Bright
  };





  void SetStateObject(nsIStructuredCloneContainer *scContainer);







  virtual int GetDocumentLWTheme() { return Doc_Theme_None; }






  virtual mozilla::EventStates GetDocumentState() = 0;
  virtual mozilla::EventStates ThreadSafeGetDocumentState() const = 0;

  virtual nsISupports* GetCurrentContentSink() = 0;

  virtual void SetScrollToRef(nsIURI *aDocumentURI) = 0;
  virtual void ScrollToRef() = 0;
  virtual void ResetScrolledToRefAlready() = 0;
  virtual void SetChangeScrollPosWhenScrollingToRef(bool aValue) = 0;







  virtual Element* GetElementById(const nsAString& aElementId) = 0;





  virtual const nsTArray<Element*>* GetAllElementsForId(const nsAString& aElementId) const = 0;
  virtual Element* LookupImageElement(const nsAString& aElementId) = 0;

  virtual mozilla::dom::DocumentTimeline* Timeline() = 0;
  virtual mozilla::LinkedList<mozilla::dom::DocumentTimeline>& Timelines() = 0;

  virtual void GetAnimations(
      nsTArray<RefPtr<mozilla::dom::Animation>>& aAnimations) = 0;

  mozilla::dom::SVGSVGElement* GetSVGRootElement() const;

  nsresult ScheduleFrameRequestCallback(mozilla::dom::FrameRequestCallback& aCallback,
                                        int32_t *aHandle);
  void CancelFrameRequestCallback(int32_t aHandle);

  typedef nsTArray<RefPtr<mozilla::dom::FrameRequestCallback>> FrameRequestCallbackList;




  void TakeFrameRequestCallbacks(FrameRequestCallbackList& aCallbacks);






  bool ShouldThrottleFrameRequests();


  bool InUnlinkOrDeletion() { return mInUnlinkOrDeletion; }

  mozilla::dom::ImageTracker* ImageTracker();

  virtual nsresult AddPlugin(nsIObjectLoadingContent* aPlugin) = 0;
  virtual void RemovePlugin(nsIObjectLoadingContent* aPlugin) = 0;
  virtual void GetPlugins(nsTArray<nsIObjectLoadingContent*>& aPlugins) = 0;

  virtual nsresult AddResponsiveContent(nsIContent* aContent) = 0;
  virtual void RemoveResponsiveContent(nsIContent* aContent) = 0;
  virtual void NotifyMediaFeatureValuesChanged() = 0;

  virtual nsresult GetStateObject(nsIVariant** aResult) = 0;

  virtual nsDOMNavigationTiming* GetNavigationTiming() const = 0;

  virtual nsresult SetNavigationTiming(nsDOMNavigationTiming* aTiming) = 0;

  virtual Element* FindImageMap(const nsAString& aNormalizedMapName) = 0;


  void RegisterPendingLinkUpdate(mozilla::dom::Link* aLink);



  void UnregisterPendingLinkUpdate(mozilla::dom::Link* aElement);



  void FlushPendingLinkUpdates();


  enum DeprecatedOperations {

eGetAttributeNode,
eSetAttributeNode,
eGetAttributeNodeNS,
eSetAttributeNodeNS,
eRemoveAttributeNode,
eCreateAttribute,
eCreateAttributeNS,
eNodeValue,
eTextContent,
eEnablePrivilege,
eDOMExceptionCode,
eNoExposedProps,
eMutationEvent,
eComponents,
ePrefixedVisibilityAPI,
eNodeIteratorDetach,
eLenientThis,
eGetPreventDefault,
eGetSetUserData,
eMozGetAsFile,
eUseOfCaptureEvents,
eUseOfReleaseEvents,
eUseOfDOM3LoadMethod,
eChromeUseOfDOM3LoadMethod,
eShowModalDialog,
eWindow_Content,
eSyncXMLHttpRequest,
eDataContainerEvent,
eWindow_Controllers,
eImportXULIntoContent,
ePannerNodeDoppler,
eNavigatorGetUserMedia,
eWebrtcDeprecatedPrefix,
eRTCPeerConnectionGetStreams,
eAppCache,
ePrefixedImageSmoothingEnabled,
ePrefixedFullscreenAPI,
eLenientSetter,
eFileLastModifiedDate,
eImageBitmapRenderingContext_TransferImageBitmap,
eURLCreateObjectURL_MediaStream,
eXMLBaseAttribute,
eXMLBaseAttributeForStyleAttr,
 eDeprecatedOperationCount
  };

  bool HasWarnedAbout(DeprecatedOperations aOperation) const;
  void WarnOnceAbout(DeprecatedOperations aOperation,
                     bool asError = false) const;


  enum DocumentWarnings {

eIgnoringWillChangeOverBudget,
ePreventDefaultFromPassiveListener,
eSVGReferenceLoop,
eSVGReferenceChainLengthExceeded,
 eDocumentWarningCount
  };

  bool HasWarnedAbout(DocumentWarnings aWarning) const;
  void WarnOnceAbout(DocumentWarnings aWarning,
                     bool asError = false,
                     const char16_t **aParams = nullptr,
                     uint32_t aParamsLength = 0) const;

  virtual void PostVisibilityUpdateEvent() = 0;

  bool IsSyntheticDocument() const { return mIsSyntheticDocument; }





  virtual void DocAddSizeOfExcludingThis(nsWindowSizes* aWindowSizes) const;



  virtual void DocAddSizeOfIncludingThis(nsWindowSizes* aWindowSizes) const;

  bool MayHaveDOMMutationObservers()
  {
    return mMayHaveDOMMutationObservers;
  }

  void SetMayHaveDOMMutationObservers()
  {
    mMayHaveDOMMutationObservers = true;
  }

  bool MayHaveAnimationObservers()
  {
    return mMayHaveAnimationObservers;
  }

  void SetMayHaveAnimationObservers()
  {
    mMayHaveAnimationObservers = true;
  }

  bool IsInSyncOperation()
  {
    return mInSyncOperationCount != 0;
  }

  void SetIsInSyncOperation(bool aSync)
  {
    if (aSync) {
      ++mInSyncOperationCount;
    } else {
      --mInSyncOperationCount;
    }
  }

  bool CreatingStaticClone() const
  {
    return mCreatingStaticClone;
  }





  already_AddRefed<Element> CreateHTMLElement(nsIAtom* aTag);


  nsIGlobalObject* GetParentObject() const
  {
    return GetScopeObject();
  }
  static already_AddRefed<nsIDocument>
    Constructor(const GlobalObject& aGlobal,
                mozilla::ErrorResult& rv);
  virtual mozilla::dom::DOMImplementation*
    GetImplementation(mozilla::ErrorResult& rv) = 0;
  __attribute__ ((warn_unused_result)) nsresult GetURL(nsString& retval) const;
  __attribute__ ((warn_unused_result)) nsresult GetDocumentURI(nsString& retval) const;




  void GetDocumentURIFromJS(nsString& aDocumentURI,
                            mozilla::dom::CallerType aCallerType,
                            mozilla::ErrorResult& aRv) const;
  void GetCompatMode(nsString& retval) const;
  void GetCharacterSet(nsAString& retval) const;


  Element* GetDocumentElement() const
  {
    return GetRootElement();
  }

  enum ElementCallbackType {
    eCreated,
    eAttached,
    eDetached,
    eAttributeChanged
  };

  nsIDocument* GetTopLevelContentDocument();

  virtual void
    RegisterElement(JSContext* aCx, const nsAString& aName,
                    const mozilla::dom::ElementRegistrationOptions& aOptions,
                    JS::MutableHandle<JSObject*> aRetval,
                    mozilla::ErrorResult& rv) = 0;
  virtual already_AddRefed<mozilla::dom::CustomElementRegistry>
    GetCustomElementRegistry() = 0;

  already_AddRefed<nsContentList>
  GetElementsByTagName(const nsAString& aTagName)
  {
    return NS_GetContentList(this, -1, aTagName);
  }
  already_AddRefed<nsContentList>
    GetElementsByTagNameNS(const nsAString& aNamespaceURI,
                           const nsAString& aLocalName,
                           mozilla::ErrorResult& aResult);
  already_AddRefed<nsContentList>
    GetElementsByClassName(const nsAString& aClasses);

  virtual already_AddRefed<Element>
    CreateElement(const nsAString& aTagName,
                  const mozilla::dom::ElementCreationOptionsOrString& aOptions,
                  mozilla::ErrorResult& rv) = 0;
  virtual already_AddRefed<Element>
    CreateElementNS(const nsAString& aNamespaceURI,
                    const nsAString& aQualifiedName,
                    const mozilla::dom::ElementCreationOptionsOrString& aOptions,
                    mozilla::ErrorResult& rv) = 0;
  already_AddRefed<mozilla::dom::DocumentFragment>
    CreateDocumentFragment() const;
  already_AddRefed<nsTextNode> CreateTextNode(const nsAString& aData) const;
  already_AddRefed<mozilla::dom::Comment>
    CreateComment(const nsAString& aData) const;
  already_AddRefed<mozilla::dom::ProcessingInstruction>
    CreateProcessingInstruction(const nsAString& target, const nsAString& data,
                                mozilla::ErrorResult& rv) const;
  already_AddRefed<nsINode>
    ImportNode(nsINode& aNode, bool aDeep, mozilla::ErrorResult& rv) const;
  nsINode* AdoptNode(nsINode& aNode, mozilla::ErrorResult& rv);
  already_AddRefed<mozilla::dom::Event>
    CreateEvent(const nsAString& aEventType, mozilla::ErrorResult& rv) const;
  already_AddRefed<nsRange> CreateRange(mozilla::ErrorResult& rv);
  already_AddRefed<mozilla::dom::NodeIterator>
    CreateNodeIterator(nsINode& aRoot, uint32_t aWhatToShow,
                       mozilla::dom::NodeFilter* aFilter,
                       mozilla::ErrorResult& rv) const;
  already_AddRefed<mozilla::dom::NodeIterator>
    CreateNodeIterator(nsINode& aRoot, uint32_t aWhatToShow,
                       mozilla::dom::NodeFilterHolder aFilter,
                       mozilla::ErrorResult& rv) const;
  already_AddRefed<mozilla::dom::TreeWalker>
    CreateTreeWalker(nsINode& aRoot, uint32_t aWhatToShow,
                     mozilla::dom::NodeFilter* aFilter, mozilla::ErrorResult& rv) const;
  already_AddRefed<mozilla::dom::TreeWalker>
    CreateTreeWalker(nsINode& aRoot, uint32_t aWhatToShow,
                     mozilla::dom::NodeFilterHolder aFilter,
                     mozilla::ErrorResult& rv) const;


  already_AddRefed<mozilla::dom::CDATASection>
    CreateCDATASection(const nsAString& aData, mozilla::ErrorResult& rv);
  already_AddRefed<mozilla::dom::Attr>
    CreateAttribute(const nsAString& aName, mozilla::ErrorResult& rv);
  already_AddRefed<mozilla::dom::Attr>
    CreateAttributeNS(const nsAString& aNamespaceURI,
                      const nsAString& aQualifiedName,
                      mozilla::ErrorResult& rv);
  void GetInputEncoding(nsAString& aInputEncoding) const;
  already_AddRefed<mozilla::dom::Location> GetLocation() const;
  void GetReferrer(nsAString& aReferrer) const;
  void GetLastModified(nsAString& aLastModified) const;
  void GetReadyState(nsAString& aReadyState) const;



  virtual void GetTitle(nsString& aTitle) = 0;
  virtual void SetTitle(const nsAString& aTitle, mozilla::ErrorResult& rv) = 0;
  void GetDir(nsAString& aDirection) const;
  void SetDir(const nsAString& aDirection);
  nsPIDOMWindowOuter* GetDefaultView() const
  {
    return GetWindow();
  }
  Element* GetActiveElement();
  bool HasFocus(mozilla::ErrorResult& rv) const;
  mozilla::TimeStamp LastFocusTime() const;
  void SetLastFocusTime(const mozilla::TimeStamp& aFocusTime);

  bool MozSyntheticDocument() const
  {
    return IsSyntheticDocument();
  }
  Element* GetCurrentScript();
  void ReleaseCapture() const;
  virtual void MozSetImageElement(const nsAString& aImageElementId,
                                  Element* aElement) = 0;
  nsIURI* GetDocumentURIObject() const;

  virtual bool FullscreenEnabled(mozilla::dom::CallerType aCallerType) = 0;
  virtual Element* GetFullscreenElement() = 0;
  bool Fullscreen()
  {
    return !!GetFullscreenElement();
  }
  void ExitFullscreen();
  Element* GetPointerLockElement();
  void ExitPointerLock()
  {
    UnlockPointer(this);
  }

  bool Hidden() const
  {
    return mVisibilityState != mozilla::dom::VisibilityState::Visible;
  }
  mozilla::dom::VisibilityState VisibilityState() const
  {
    return mVisibilityState;
  }

  virtual mozilla::dom::StyleSheetList* StyleSheets() = 0;
  void GetSelectedStyleSheetSet(nsAString& aSheetSet);
  virtual void SetSelectedStyleSheetSet(const nsAString& aSheetSet) = 0;
  virtual void GetLastStyleSheetSet(nsString& aSheetSet) = 0;
  void GetPreferredStyleSheetSet(nsAString& aSheetSet);
  virtual mozilla::dom::DOMStringList* StyleSheetSets() = 0;
  virtual void EnableStyleSheetsForSet(const nsAString& aSheetSet) = 0;
  Element* ElementFromPoint(float aX, float aY);
  void ElementsFromPoint(float aX,
                         float aY,
                         nsTArray<RefPtr<mozilla::dom::Element>>& aElements);
  already_AddRefed<nsDOMCaretPosition>
    CaretPositionFromPoint(float aX, float aY);

  Element* GetScrollingElement();


  nsINodeList* GetAnonymousNodes(Element& aElement);
  Element* GetAnonymousElementByAttribute(Element& aElement,
                                          const nsAString& aAttrName,
                                          const nsAString& aAttrValue);
  Element* GetBindingParent(nsINode& aNode);
  void LoadBindingDocument(const nsAString& aURI,
                           nsIPrincipal& aSubjectPrincipal,
                           mozilla::ErrorResult& rv);
  void LoadBindingDocument(const nsAString& aURI,
                           const mozilla::Maybe<nsIPrincipal*>& aSubjectPrincipal,
                           mozilla::ErrorResult& rv);
  mozilla::dom::XPathExpression*
    CreateExpression(const nsAString& aExpression,
                     mozilla::dom::XPathNSResolver* aResolver,
                     mozilla::ErrorResult& rv);
  nsINode* CreateNSResolver(nsINode& aNodeResolver);
  already_AddRefed<mozilla::dom::XPathResult>
    Evaluate(JSContext* aCx, const nsAString& aExpression, nsINode& aContextNode,
             mozilla::dom::XPathNSResolver* aResolver, uint16_t aType,
             JS::Handle<JSObject*> aResult, mozilla::ErrorResult& rv);

  already_AddRefed<mozilla::dom::Touch>
    CreateTouch(nsGlobalWindow* aView, mozilla::dom::EventTarget* aTarget,
                int32_t aIdentifier, int32_t aPageX, int32_t aPageY,
                int32_t aScreenX, int32_t aScreenY, int32_t aClientX,
                int32_t aClientY, int32_t aRadiusX, int32_t aRadiusY,
                float aRotationAngle, float aForce);
  already_AddRefed<mozilla::dom::TouchList> CreateTouchList();
  already_AddRefed<mozilla::dom::TouchList>
    CreateTouchList(mozilla::dom::Touch& aTouch,
                    const mozilla::dom::Sequence<mozilla::OwningNonNull<mozilla::dom::Touch> >& aTouches);
  already_AddRefed<mozilla::dom::TouchList>
    CreateTouchList(const mozilla::dom::Sequence<mozilla::OwningNonNull<mozilla::dom::Touch> >& aTouches);

  void SetStyleSheetChangeEventsEnabled(bool aValue)
  {
    mStyleSheetChangeEventsEnabled = aValue;
  }

  bool StyleSheetChangeEventsEnabled() const
  {
    return mStyleSheetChangeEventsEnabled;
  }

  void ObsoleteSheet(nsIURI *aSheetURI, mozilla::ErrorResult& rv);

  void ObsoleteSheet(const nsAString& aSheetURI, mozilla::ErrorResult& rv);

  already_AddRefed<mozilla::dom::Promise> BlockParsing(mozilla::dom::Promise& aPromise,
                                                       mozilla::ErrorResult& aRv);

  already_AddRefed<nsIURI> GetMozDocumentURIIfNotForErrorPages();


  nsIHTMLCollection* Children();
  uint32_t ChildElementCount();

  virtual nsHTMLDocument* AsHTMLDocument() { return nullptr; }
  virtual mozilla::dom::SVGDocument* AsSVGDocument() { return nullptr; }



  virtual nsIDocument* MasterDocument() = 0;
  virtual void SetMasterDocument(nsIDocument* master) = 0;
  virtual bool IsMasterDocument() = 0;
  virtual mozilla::dom::ImportManager* ImportManager() = 0;

  virtual bool HasSubImportLink(nsINode* aLink) = 0;
  virtual uint32_t IndexOfSubImportLink(nsINode* aLink) = 0;
  virtual void AddSubImportLink(nsINode* aLink) = 0;
  virtual nsINode* GetSubImportLink(uint32_t aIdx) = 0;






  void AddBlockedTrackingNode(nsINode *node)
  {
    if (!node) {
      return;
    }

    nsWeakPtr weakNode = do_GetWeakReference(node);

    if (weakNode) {
      mBlockedTrackingNodes.AppendElement(weakNode);
    }
  }

  gfxUserFontSet* GetUserFontSet(bool aFlushUserFontSet = true);
  void FlushUserFontSet();
  void RebuildUserFontSet();
  mozilla::dom::FontFaceSet* GetFonts() { return mFontFaceSet; }


  mozilla::dom::FontFaceSet* Fonts();

  bool DidFireDOMContentLoaded() const { return mDidFireDOMContentLoaded; }

  void SetDocumentUseCounter(mozilla::UseCounter aUseCounter)
  {
    if (!mUseCounters[aUseCounter]) {
      mUseCounters[aUseCounter] = true;
    }
  }

  void SetPageUseCounter(mozilla::UseCounter aUseCounter);

  void SetDocumentAndPageUseCounter(mozilla::UseCounter aUseCounter)
  {
    SetDocumentUseCounter(aUseCounter);
    SetPageUseCounter(aUseCounter);
  }

  void PropagateUseCounters(nsIDocument* aParentDocument);

  void SetUserHasInteracted(bool aUserHasInteracted)
  {
    mUserHasInteracted = aUserHasInteracted;
  }

  bool UserHasInteracted()
  {
    return mUserHasInteracted;
  }

  bool HasScriptsBlockedBySandbox();

  bool InlineScriptAllowedByCSP();

  void ReportHasScrollLinkedEffect();
  bool HasScrollLinkedEffect() const
  {
    return mHasScrollLinkedEffect;
  }

  mozilla::dom::DocGroup* GetDocGroup() const;

  virtual void AddIntersectionObserver(
    mozilla::dom::DOMIntersectionObserver* aObserver) = 0;
  virtual void RemoveIntersectionObserver(
    mozilla::dom::DOMIntersectionObserver* aObserver) = 0;

  virtual void UpdateIntersectionObservations() = 0;
  virtual void ScheduleIntersectionObserverNotification() = 0;
  virtual void NotifyIntersectionObservers() = 0;


  virtual nsresult Dispatch(const char* aName,
                            mozilla::TaskCategory aCategory,
                            already_AddRefed<nsIRunnable>&& aRunnable) override;

  virtual nsIEventTarget*
  EventTargetFor(mozilla::TaskCategory aCategory) const override;

  virtual mozilla::AbstractThread*
  AbstractMainThreadFor(mozilla::TaskCategory aCategory) override;




  void NoteScriptTrackingStatus(const nsACString& aURL, bool isTracking);
  bool IsScriptTracking(const nsACString& aURL) const;

  bool PrerenderHref(nsIURI* aHref);



  virtual mozilla::dom::FlashClassification DocumentFlashClassification() = 0;
  virtual bool IsThirdParty() = 0;

protected:
  bool GetUseCounter(mozilla::UseCounter aUseCounter)
  {
    return mUseCounters[aUseCounter];
  }

  void SetChildDocumentUseCounter(mozilla::UseCounter aUseCounter)
  {
    if (!mChildDocumentUseCounters[aUseCounter]) {
      mChildDocumentUseCounters[aUseCounter] = true;
    }
  }

  bool GetChildDocumentUseCounter(mozilla::UseCounter aUseCounter)
  {
    return mChildDocumentUseCounters[aUseCounter];
  }

private:
  mutable std::bitset<eDeprecatedOperationCount> mDeprecationWarnedAbout;
  mutable std::bitset<eDocumentWarningCount> mDocWarningWarnedAbout;

  nsAutoPtr<SelectorCache> mSelectorCache;

protected:
  ~nsIDocument();
  nsPropertyTable* GetExtraPropertyTable(uint16_t aCategory);


  virtual nsPIDOMWindowOuter* GetWindowInternal() const = 0;


  virtual nsIScriptGlobalObject* GetScriptHandlingObjectInternal() const = 0;


  virtual bool InternalAllowXULXBL() = 0;






  virtual void WillDispatchMutationEvent(nsINode* aTarget) = 0;
  virtual void MutationEventDispatched(nsINode* aTarget) = 0;
  friend class mozAutoSubtreeModified;

  virtual Element* GetNameSpaceElement() override
  {
    return GetRootElement();
  }

  void SetContentTypeInternal(const nsACString& aType);

  nsCString GetContentTypeInternal() const
  {
    return mContentType;
  }

  mozilla::dom::XPathEvaluator* XPathEvaluator();

  void HandleRebuildUserFontSet() {
    mPostedFlushUserFontSet = false;
    FlushUserFontSet();
  }

  const nsString& GetId() const
  {
    return mId;
  }






  void UpdateFrameRequestCallbackSchedulingState(nsIPresShell* aOldShell = nullptr);

  nsCString mReferrer;
  nsString mLastModified;

  nsCOMPtr<nsIURI> mDocumentURI;
  nsCOMPtr<nsIURI> mOriginalURI;
  nsCOMPtr<nsIURI> mChromeXHRDocURI;
  nsCOMPtr<nsIURI> mDocumentBaseURI;
  nsCOMPtr<nsIURI> mChromeXHRDocBaseURI;

  nsWeakPtr mDocumentLoadGroup;

  bool mReferrerPolicySet;
  ReferrerPolicyEnum mReferrerPolicy;

  bool mBlockAllMixedContent;
  bool mBlockAllMixedContentPreloads;
  bool mUpgradeInsecureRequests;
  bool mUpgradeInsecurePreloads;




  nsDataHashtable<nsURIHashKey, HSTSPrimingState> mHSTSPrimingURIList;

  mozilla::WeakPtr<nsDocShell> mDocumentContainer;

  nsCString mCharacterSet;
  int32_t mCharacterSetSource;


  nsIDocument* mParentDocument;


  mozilla::dom::Element* mCachedRootElement;



  nsNodeInfoManager* mNodeInfoManager;
  RefPtr<mozilla::css::Loader> mCSSLoader;
  RefPtr<mozilla::css::ImageLoader> mStyleImageLoader;
  RefPtr<nsHTMLStyleSheet> mAttrStyleSheet;
  RefPtr<nsHTMLCSSStyleSheet> mStyleAttrStyleSheet;


  RefPtr<mozilla::dom::ImageTracker> mImageTracker;






  nsAutoPtr<nsTHashtable<nsPtrHashKey<nsISupports> > > mActivityObservers;




  nsTHashtable<nsPtrHashKey<mozilla::dom::Link> > mLinksToUpdate;


  RefPtr<nsSMILAnimationController> mAnimationController;


  nsPropertyTable mPropertyTable;
  nsTArray<nsAutoPtr<nsPropertyTable> > mExtraPropertyTables;


  nsCOMPtr<nsIHTMLCollection> mChildrenCollection;


  RefPtr<mozilla::dom::FontFaceSet> mFontFaceSet;



  mozilla::TimeStamp mLastFocusTime;


  bool mBidiEnabled : 1;

  bool mMathMLEnabled : 1;





  bool mIsInitialDocumentInWindow : 1;

  bool mIgnoreDocGroupMismatches : 1;



  bool mLoadedAsData : 1;




  bool mLoadedAsInteractiveData : 1;



  bool mMayStartLayout : 1;


  bool mHaveFiredTitleChange : 1;





  bool mIsShowing : 1;




  bool mVisible : 1;


  bool mHasReferrerPolicyCSP : 1;




  bool mRemovedFromDocShell : 1;



  bool mAllowDNSPrefetch : 1;


  bool mIsStaticDocument : 1;


  bool mCreatingStaticClone : 1;


  bool mInUnlinkOrDeletion : 1;


  bool mHasHadScriptHandlingObject : 1;


  bool mIsBeingUsedAsImage : 1;



  bool mIsSyntheticDocument : 1;


  bool mHasLinksToUpdate : 1;


  bool mMayHaveDOMMutationObservers : 1;


  bool mMayHaveAnimationObservers : 1;


  bool mHasMixedActiveContentLoaded : 1;


  bool mHasMixedActiveContentBlocked : 1;


  bool mHasMixedDisplayContentLoaded : 1;


  bool mHasMixedDisplayContentBlocked : 1;


  bool mHasMixedContentObjectSubrequest : 1;


  bool mHasCSP : 1;


  bool mHasUnsafeEvalCSP : 1;


  bool mHasUnsafeInlineCSP : 1;


  bool mHasTrackingContentBlocked : 1;


  bool mHasTrackingContentLoaded : 1;


  bool mBFCacheDisallowed : 1;

  bool mHasHadDefaultView : 1;


  bool mStyleSheetChangeEventsEnabled : 1;


  bool mIsSrcdocDocument : 1;




  bool mDidDocumentOpen : 1;





  bool mHasDisplayDocument : 1;


  bool mFontFaceSetDirty : 1;


  bool mGetUserFontSetCalled : 1;


  bool mPostedFlushUserFontSet : 1;



  bool mDidFireDOMContentLoaded : 1;


  bool mHasScrollLinkedEffect : 1;




  bool mFrameRequestCallbacksScheduled : 1;


  nsCompatibility mCompatMode;


  ReadyState mReadyState;



  mozilla::StyleBackendType mStyleBackendType;



  mozilla::dom::VisibilityState mVisibilityState;
  static_assert(sizeof(mozilla::dom::VisibilityState) == sizeof(uint8_t),
                "Error size of mVisibilityState and mDummy");




  enum Type {
    eUnknown,
    eHTML,
    eXHTML,
    eGenericXML,
    eSVG,
    eXUL
  };

  Type mType;

  uint8_t mDefaultElementType;

  enum Tri {
    eTriUnset = 0,
    eTriFalse,
    eTriTrue
  };

  Tri mAllowXULXBL;
  nsCOMPtr<nsIScriptGlobalObject> mScriptGlobalObject;



  nsCOMPtr<nsIDocument> mOriginalDocument;



  uint32_t mBidiOptions;




  uint32_t mSandboxFlags;

  nsCString mContentLanguage;


  nsCOMPtr<nsIChannel> mChannel;
private:
  nsCString mContentType;
  nsString mId;
protected:


  nsCOMPtr<nsISupports> mSecurityInfo;



  nsCOMPtr<nsIChannel> mFailedChannel;



  uint32_t mPartID;



  uint32_t mMarkedCCGeneration;

  nsIPresShell* mPresShell;

  nsCOMArray<nsINode> mSubtreeModifiedTargets;
  uint32_t mSubtreeModifiedDepth;




  nsCOMPtr<nsIDocument> mDisplayDocument;

  uint32_t mEventsSuppressed;





  uint32_t mExternalScriptsBeingEvaluated;




  int32_t mFrameRequestCallbackCounter;


  uint32_t mStaticCloneCount;






  nsTArray<nsWeakPtr> mBlockedTrackingNodes;



  nsPIDOMWindowInner* mWindow;

  nsCOMPtr<nsIDocumentEncoder> mCachedEncoder;

  struct FrameRequest;

  nsTArray<FrameRequest> mFrameRequestCallbacks;



  nsIBFCacheEntry *mBFCacheEntry;


  nsString mBaseTarget;

  nsCOMPtr<nsIStructuredCloneContainer> mStateObjectContainer;
  nsCOMPtr<nsIVariant> mStateObjectCached;

  uint32_t mInSyncOperationCount;

  RefPtr<mozilla::dom::XPathEvaluator> mXPathEvaluator;

  nsTArray<RefPtr<mozilla::dom::AnonymousContent>> mAnonymousContents;

  uint32_t mBlockDOMContentLoaded;


  PRCList mDOMMediaQueryLists;


  std::bitset<mozilla::eUseCounter_Count> mUseCounters;

  std::bitset<mozilla::eUseCounter_Count> mChildDocumentUseCounters;


  std::bitset<mozilla::eUseCounter_Count> mNotifiedPageForUseCounter;


  bool mUserHasInteracted;

  mozilla::TimeStamp mPageUnloadingEventTimeStamp;

  RefPtr<mozilla::dom::DocGroup> mDocGroup;




  nsTHashtable<nsCStringHashKey> mTrackingScripts;
};

template<typename T> struct nsIDocument::COMTypeInfo<nsIDocument, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDocument::COMTypeInfo<nsIDocument, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0xce1f7627, 0x7109, 0x4977, { 0xba, 0x77, 0x49, 0x0f, 0xfd, 0xe0, 0x7a, 0xaa } };






class mozAutoSubtreeModified
{
public:






  mozAutoSubtreeModified(nsIDocument* aSubtreeOwner, nsINode* aTarget)
  {
    UpdateTarget(aSubtreeOwner, aTarget);
  }

  ~mozAutoSubtreeModified()
  {
    UpdateTarget(nullptr, nullptr);
  }

  void UpdateTarget(nsIDocument* aSubtreeOwner, nsINode* aTarget)
  {
    if (mSubtreeOwner) {
      mSubtreeOwner->MutationEventDispatched(mTarget);
    }

    mTarget = aTarget;
    mSubtreeOwner = aSubtreeOwner;
    if (mSubtreeOwner) {
      mSubtreeOwner->WillDispatchMutationEvent(mTarget);
    }
  }

private:
  nsCOMPtr<nsINode> mTarget;
  nsCOMPtr<nsIDocument> mSubtreeOwner;
};

class nsAutoSyncOperation
{
public:
  explicit nsAutoSyncOperation(nsIDocument* aDocument);
  ~nsAutoSyncOperation();
private:
  nsCOMArray<nsIDocument> mDocuments;
  uint32_t mMicroTaskLevel;
};


nsresult
NS_NewHTMLDocument(nsIDocument** aInstancePtrResult, bool aLoadedAsData = false);

nsresult
NS_NewXMLDocument(nsIDocument** aInstancePtrResult, bool aLoadedAsData = false,
                  bool aIsPlainDocument = false);

nsresult
NS_NewSVGDocument(nsIDocument** aInstancePtrResult);

nsresult
NS_NewImageDocument(nsIDocument** aInstancePtrResult);

nsresult
NS_NewVideoDocument(nsIDocument** aInstancePtrResult);




nsresult
NS_NewDOMDocument(nsIDOMDocument** aInstancePtrResult,
                  const nsAString& aNamespaceURI,
                  const nsAString& aQualifiedName,
                  nsIDOMDocumentType* aDoctype,
                  nsIURI* aDocumentURI,
                  nsIURI* aBaseURI,
                  nsIPrincipal* aPrincipal,
                  bool aLoadedAsData,
                  nsIGlobalObject* aEventObject,
                  DocumentFlavor aFlavor);



nsresult
NS_NewXBLDocument(nsIDOMDocument** aInstancePtrResult,
                  nsIURI* aDocumentURI,
                  nsIURI* aBaseURI,
                  nsIPrincipal* aPrincipal);

nsresult
NS_NewPluginDocument(nsIDocument** aInstancePtrResult);

inline nsIDocument*
nsINode::GetOwnerDocument() const
{
  nsIDocument* ownerDoc = OwnerDoc();

  return ownerDoc != this ? ownerDoc : nullptr;
}

inline nsINode*
nsINode::OwnerDocAsNode() const
{
  return OwnerDoc();
}

inline mozilla::dom::ParentObject
nsINode::GetParentObject() const
{
  mozilla::dom::ParentObject p(OwnerDoc());


  p.mUseXBLScope = IsInAnonymousSubtree() && !IsAnonymousContentInSVGUseSubtree();
  return p;
}


namespace mozilla {
class TimeStamp;

namespace dom {
class Promise;
}

}

class nsIProfilerStartParams;

enum TracingKind {
  TRACING_EVENT,
  TRACING_INTERVAL_START,
  TRACING_INTERVAL_END,
};

class ProfilerBacktrace;

struct ProfilerBacktraceDestructor
{
  void operator()(ProfilerBacktrace*);
};
using UniqueProfilerBacktrace =
  mozilla::UniquePtr<ProfilerBacktrace, ProfilerBacktraceDestructor>;
void profiler_tracing(const char* aCategory, const char* aInfo, TracingKind aKind = TRACING_EVENT);

void profiler_tracing(const char* aCategory, const char* aInfo, UniqueProfilerBacktrace aCause, TracingKind aKind = TRACING_EVENT);






void profiler_init(void* stackTop);




void profiler_shutdown();







void profiler_start(int aEntries, double aInterval, const char** aFeatures, uint32_t aFeatureCount, const char** aThreadNameFilters, uint32_t aFilterCount);







void profiler_stop();







void profiler_pause();
void profiler_resume();


bool profiler_is_paused();



UniqueProfilerBacktrace profiler_get_backtrace();

void profiler_get_backtrace_noalloc(char *output, size_t outputSize);
bool profiler_is_active();





bool profiler_feature_active(const char*);



void profiler_set_frame_number(int frameNumber);



mozilla::UniquePtr<char[]> profiler_get_profile(double aSinceTime = 0);




JSObject* profiler_get_profile_jsobject(JSContext* aCx, double aSinceTime = 0);





void profiler_get_profile_jsobject_async(double aSinceTime = 0, mozilla::dom::Promise* = 0);




void profiler_get_start_params(int* aEntrySize, double* aInterval, mozilla::Vector<const char*>* aFeatures, mozilla::Vector<const char*>* aFilters);
extern "C" {
void profiler_save_profile_to_file(const char* aFilename);
}




const char** profiler_get_features();




void profiler_get_buffer_info_helper(uint32_t* aCurrentPosition, uint32_t* aEntries, uint32_t* aGeneration);
static inline void profiler_get_buffer_info(uint32_t* aCurrentPosition,
                                            uint32_t* aEntries,
                                            uint32_t* aGeneration)
{
  *aCurrentPosition = 0;
  *aEntries = 0;
  *aGeneration = 0;

  profiler_get_buffer_info_helper(aCurrentPosition, aEntries, aGeneration);
}



void profiler_register_thread(const char* name, void* guessStackTop);

void profiler_unregister_thread();





void profiler_thread_sleep();
void profiler_thread_wake();
bool profiler_thread_is_sleeping();




void profiler_js_interrupt_callback();



double profiler_time();

void profiler_log(const char *str);







struct JSRuntime;
class JSTracer;

namespace js {






class ProfileEntry
{
    const char * volatile string;


    const char * volatile dynamicString;


    void * volatile spOrScript;


    int32_t volatile lineOrPcOffset;


    uint32_t volatile flags_;

  public:

    enum Flags : uint32_t {




        IS_CPP_ENTRY = 0x01,



        FRAME_LABEL_COPY = 0x02,



        BEGIN_PSEUDO_JS = 0x04,



        OSR = 0x08,


        ALL = IS_CPP_ENTRY|FRAME_LABEL_COPY|BEGIN_PSEUDO_JS|OSR,


        CATEGORY_MASK = ~ALL
    };


    enum class Category : uint32_t {
        OTHER = 0x10,
        CSS = 0x20,
        JS = 0x40,
        GC = 0x80,
        CC = 0x100,
        NETWORK = 0x200,
        GRAPHICS = 0x400,
        STORAGE = 0x800,
        EVENTS = 0x1000,

        FIRST = OTHER,
        LAST = EVENTS
    };

    static_assert((static_cast<int>(Category::FIRST) & Flags::ALL) == 0,
                  "The category bitflags should not intersect with the other flags!");






    bool isCpp() const volatile { return hasFlag(IS_CPP_ENTRY); }
    bool isJs() const volatile { return !isCpp(); }

    bool isCopyLabel() const volatile { return hasFlag(FRAME_LABEL_COPY); }

    void setLabel(const char* aString) volatile { string = aString; }
    const char* label() const volatile { return string; }

    void setDynamicString(const char* aDynamicString) volatile { dynamicString = aDynamicString; }
    const char* getDynamicString() const volatile { return dynamicString; }

    void initJsFrame(JSScript* aScript, jsbytecode* aPc) volatile {
        flags_ = 0;
        spOrScript = aScript;
        setPC(aPc);
    }
    void initCppFrame(void* aSp, uint32_t aLine) volatile {
        flags_ = IS_CPP_ENTRY;
        spOrScript = aSp;
        lineOrPcOffset = static_cast<int32_t>(aLine);
    }

    void setFlag(uint32_t flag) volatile {
        do { } while (0);
        flags_ |= flag;
    }
    void unsetFlag(uint32_t flag) volatile {
        do { } while (0);
        flags_ &= ~flag;
    }
    bool hasFlag(uint32_t flag) const volatile {
        return bool(flags_ & flag);
    }

    uint32_t flags() const volatile {
        return flags_;
    }

    uint32_t category() const volatile {
        return flags_ & CATEGORY_MASK;
    }
    void setCategory(Category c) volatile {
        do { } while (0);
        do { } while (0);
        flags_ &= ~CATEGORY_MASK;
        setFlag(static_cast<uint32_t>(c));
    }

    void setOSR() volatile {
        do { } while (0);
        setFlag(OSR);
    }
    void unsetOSR() volatile {
        do { } while (0);
        unsetFlag(OSR);
    }
    bool isOSR() const volatile {
        return hasFlag(OSR);
    }

    void* stackAddress() const volatile {
        do { } while (0);
        return spOrScript;
    }
    JSScript* script() const volatile;
    uint32_t line() const volatile {
        do { } while (0);
        return static_cast<uint32_t>(lineOrPcOffset);
    }


    JSScript* rawScript() const volatile {
        do { } while (0);
        return (JSScript*)spOrScript;
    }


    jsbytecode* pc() const volatile;
    void setPC(jsbytecode* pc) volatile;

    void trace(JSTracer* trc);




    static const int32_t NullPCOffset = -1;

    static size_t offsetOfLabel() { return __builtin_offsetof(ProfileEntry, string); }
    static size_t offsetOfSpOrScript() { return __builtin_offsetof(ProfileEntry, spOrScript); }
    static size_t offsetOfLineOrPcOffset() { return __builtin_offsetof(ProfileEntry, lineOrPcOffset); }
    static size_t offsetOfFlags() { return __builtin_offsetof(ProfileEntry, flags_); }
};

void
SetContextProfilingStack(JSContext* cx, ProfileEntry* stack, uint32_t* size,
                         uint32_t max);

void
EnableContextProfilingStack(JSContext* cx, bool enabled);

void
RegisterContextProfilingEventMarker(JSContext* cx, void (*fn)(const char*));

jsbytecode*
ProfilingGetPC(JSContext* cx, JSScript* script, void* ip);

}
template <size_t N>
int VsprintfLiteral(char (&buffer)[N], const char* format, va_list args)
{
    do { } while (0);
    int result = vsnprintf(buffer, N, format, args);
    buffer[N - 1] = '\0';
    return result;
}

template <size_t N>
__attribute__ ((format (printf, 2, 3)))
int SprintfLiteral(char (&buffer)[N], const char* format, ...)
{
  va_list args;
  __builtin_va_start(args, format);
  int result = VsprintfLiteral(buffer, format, args);
  __builtin_va_end(args);
  return result;
}
namespace mozilla {







typedef sig_atomic_t sig_safe_t;


namespace detail {
template<typename T>
class ThreadLocal
{
  bool initialized() const {

    return true;



  }

public:
  __attribute__ ((warn_unused_result)) inline bool init();

  inline T get() const;

  inline void set(const T aValue);

private:

  T mValue;




};

template<typename T>
inline bool
ThreadLocal<T>::init()
{
  static_assert(mozilla::IsPointer<T>::value || mozilla::IsIntegral<T>::value,
                "mozilla::ThreadLocal must be used with a pointer or "
                "integral type");
  static_assert(sizeof(T) <= sizeof(void*),
                "mozilla::ThreadLocal can't be used for types larger than "
                "a pointer");


  return true;
}

template<typename T>
inline T
ThreadLocal<T>::get() const
{

  return mValue;
}

template<typename T>
inline void
ThreadLocal<T>::set(const T aValue)
{

  mValue = aValue;
}







}
}




class ProfilerMarkerPayload;
template<typename T>
class ProfilerLinkedList;
class SpliceableJSONWriter;
class UniqueStacks;

class ProfilerMarker
{
  friend class ProfilerLinkedList<ProfilerMarker>;

public:
  explicit ProfilerMarker(const char* aMarkerName,
                          ProfilerMarkerPayload* aPayload = nullptr,
                          double aTime = 0);
  ~ProfilerMarker();

  const char* GetMarkerName() const { return mMarkerName; }

  void StreamJSON(SpliceableJSONWriter& aWriter,
                  const mozilla::TimeStamp& aStartTime,
                  UniqueStacks& aUniqueStacks) const;

  void SetGeneration(uint32_t aGenID);

  bool HasExpired(uint32_t aGenID) const { return mGenID + 2 <= aGenID; }

  double GetTime() const;

private:
  char* mMarkerName;
  ProfilerMarkerPayload* mPayload;
  ProfilerMarker* mNext;
  double mTime;
  uint32_t mGenID;
};

template<typename T>
class ProfilerLinkedList
{
public:
  ProfilerLinkedList()
    : mHead(nullptr)
    , mTail(nullptr)
  {}

  void insert(T* aElem)
  {
    if (!mTail) {
      mHead = aElem;
      mTail = aElem;
    } else {
      mTail->mNext = aElem;
      mTail = aElem;
    }
    aElem->mNext = nullptr;
  }

  T* popHead()
  {
    if (!mHead) {
      do { } while (0);
      return nullptr;
    }

    T* head = mHead;

    mHead = head->mNext;
    if (!mHead) {
      mTail = nullptr;
    }

    return head;
  }

  const T* peek() {
    return mHead;
  }

private:
  T* mHead;
  T* mTail;
};

typedef ProfilerLinkedList<ProfilerMarker> ProfilerMarkerLinkedList;

template<typename T>
class ProfilerSignalSafeLinkedList {
public:
  ProfilerSignalSafeLinkedList()
    : mSignalLock(false)
  {}

  ~ProfilerSignalSafeLinkedList()
  {
    if (mSignalLock) {


      abort();
    }

    while (mList.peek()) {
      delete mList.popHead();
    }
  }






  void insert(T* aElement)
  {
    do { } while (0);

    mSignalLock = true;
    asm volatile("" ::: "memory");;

    mList.insert(aElement);

    asm volatile("" ::: "memory");;
    mSignalLock = false;
  }





  ProfilerLinkedList<T>* accessList()
  {
    return mSignalLock ? nullptr : &mList;
  }

private:
  ProfilerLinkedList<T> mList;



  volatile bool mSignalLock;
};


void ProfilerJSEventMarker(const char* aEvent);






struct PseudoStack
{
public:
  PseudoStack()
    : mStackPointer(0)
    , mSleep(AWAKE)
    , mContext(nullptr)
    , mJSSampling(INACTIVE)
  {
                               ;
  }

  ~PseudoStack()
  {
                               ;




    do { static_assert(mozilla::detail::AssertionConditionType<decltype(mStackPointer == 0)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(mStackPointer == 0))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "mStackPointer == 0" ")"); do { *((volatile int*) __null) = 219; ::abort(); } while (0); } } while (0);
  }



  void reinitializeOnResume()
  {




    (void)mSleep.compareExchange(SLEEPING_OBSERVED, SLEEPING_NOT_OBSERVED);
  }

  void addMarker(const char* aMarkerStr, ProfilerMarkerPayload* aPayload,
                 double aTime)
  {
    ProfilerMarker* marker = new ProfilerMarker(aMarkerStr, aPayload, aTime);
    mPendingMarkers.insert(marker);
  }


  ProfilerMarkerLinkedList* getPendingMarkers()
  {



    return mPendingMarkers.accessList();
  }

  void push(const char* aName, js::ProfileEntry::Category aCategory,
            uint32_t line)
  {
    push(aName, aCategory, nullptr, false, line, nullptr);
  }

  void push(const char* aName, js::ProfileEntry::Category aCategory,
            void* aStackAddress, bool aCopy, uint32_t line,
            const char* aDynamicString)
  {
    if (size_t(mStackPointer) >= mozilla::ArrayLength(mStack)) {
      mStackPointer++;
      return;
    }

    volatile js::ProfileEntry& entry = mStack[mStackPointer];



    entry.initCppFrame(aStackAddress, line);
    entry.setLabel(aName);
    entry.setDynamicString(aDynamicString);
    do { } while (0);
    entry.setCategory(aCategory);


    if (aCopy) {
      entry.setFlag(js::ProfileEntry::FRAME_LABEL_COPY);
    } else {
      entry.unsetFlag(js::ProfileEntry::FRAME_LABEL_COPY);
    }


    asm volatile("" ::: "memory");;
    mStackPointer++;
  }


  void pop() { mStackPointer--; }

  uint32_t stackSize() const
  {
    return std::min(mStackPointer,
                    mozilla::sig_safe_t(mozilla::ArrayLength(mStack)));
  }



  void setJSContext(JSContext* aContext)
  {


    do { } while (0);

    mContext = aContext;

    js::SetContextProfilingStack(aContext,
                                 (js::ProfileEntry*) mStack,
                                 (uint32_t*) &mStackPointer,
                                 (uint32_t) mozilla::ArrayLength(mStack));
    pollJSSampling();
  }




  void startJSSampling()
  {


    do { static_assert(mozilla::detail::AssertionConditionType<decltype(mJSSampling == INACTIVE || mJSSampling == INACTIVE_REQUESTED)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(mJSSampling == INACTIVE || mJSSampling == INACTIVE_REQUESTED))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "mJSSampling == INACTIVE || mJSSampling == INACTIVE_REQUESTED" ")"); do { *((volatile int*) __null) = 320; ::abort(); } while (0); } } while (0);

    mJSSampling = ACTIVE_REQUESTED;
  }



  void stopJSSampling()
  {


    do { static_assert(mozilla::detail::AssertionConditionType<decltype(mJSSampling == ACTIVE || mJSSampling == ACTIVE_REQUESTED)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(mJSSampling == ACTIVE || mJSSampling == ACTIVE_REQUESTED))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "mJSSampling == ACTIVE || mJSSampling == ACTIVE_REQUESTED" ")"); do { *((volatile int*) __null) = 331; ::abort(); } while (0); } } while (0);

    mJSSampling = INACTIVE_REQUESTED;
  }


  void pollJSSampling()
  {



    if (mContext) {
      if (mJSSampling.compareExchange(ACTIVE_REQUESTED, ACTIVE)) {
        js::EnableContextProfilingStack(mContext, true);
        js::RegisterContextProfilingEventMarker(mContext,
                                                &ProfilerJSEventMarker);

      } else if (mJSSampling.compareExchange(INACTIVE_REQUESTED, INACTIVE)) {
        js::EnableContextProfilingStack(mContext, false);
      }
    }
  }

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
  {
    size_t n = aMallocSizeOf(this);
    return n;
  }


  bool CanDuplicateLastSampleDueToSleep()
  {
    if (mSleep == AWAKE) {
      return false;
    }

    if (mSleep.compareExchange(SLEEPING_NOT_OBSERVED, SLEEPING_OBSERVED)) {
      return false;
    }

    return true;
  }



  void setSleeping()
  {
    do { } while (0);
    mSleep = SLEEPING_NOT_OBSERVED;
  }



  void setAwake()
  {
    do { } while (0);
    mSleep = AWAKE;
  }

  bool isSleeping() { return mSleep != AWAKE; }

private:

  PseudoStack(const PseudoStack&) = delete;
  void operator=(const PseudoStack&) = delete;

  void flushSamplerOnJSShutdown();

public:

  js::ProfileEntry volatile mStack[1024];

private:

  ProfilerSignalSafeLinkedList<ProfilerMarker> mPendingMarkers;



  mozilla::sig_safe_t mStackPointer;
  static const int AWAKE = 0;
  static const int SLEEPING_NOT_OBSERVED = 1;
  static const int SLEEPING_OBSERVED = 2;
  mozilla::Atomic<int> mSleep;

public:


  JSContext* mContext;

private:
  static const int INACTIVE = 0;
  static const int ACTIVE_REQUESTED = 1;
  static const int ACTIVE = 2;
  static const int INACTIVE_REQUESTED = 3;
  mozilla::Atomic<int> mJSSampling;
};
class mozIDOMWindowProxy;

class nsIRunnable;

class nsISimpleEnumerator;
class nsIMemoryReporterCallback : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult Callback(const nsACString & process, const nsACString & path, int32_t kind, int32_t units, int64_t amount, const nsACString & description, nsISupports *data) = 0;

};

  template<typename T> struct nsIMemoryReporterCallback::COMTypeInfo<nsIMemoryReporterCallback, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIMemoryReporterCallback::COMTypeInfo<nsIMemoryReporterCallback, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x62ef0e1c, 0xdbd6, 0x11e3, { 0xaa, 0x75, 0x3c, 0x97, 0x0e, 0x9f, 0x42, 0x38 }};
class nsIMemoryReporter : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult CollectReports(nsIMemoryReporterCallback *callback, nsISupports *data, bool anonymize) = 0;

  enum {
    KIND_NONHEAP = 0,
    KIND_HEAP = 1,
    KIND_OTHER = 2,
    UNITS_BYTES = 0,
    UNITS_COUNT = 1,
    UNITS_COUNT_CUMULATIVE = 2,
    UNITS_PERCENTAGE = 3
  };

};

  template<typename T> struct nsIMemoryReporter::COMTypeInfo<nsIMemoryReporter, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIMemoryReporter::COMTypeInfo<nsIMemoryReporter, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x92a36db1, 0x46bd, 0x4fe6, { 0x98, 0x8e, 0x47, 0xdb, 0x47, 0x23, 0x6d, 0x8b }};
class nsIFinishReportingCallback : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult Callback(nsISupports *data) = 0;

};

  template<typename T> struct nsIFinishReportingCallback::COMTypeInfo<nsIFinishReportingCallback, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIFinishReportingCallback::COMTypeInfo<nsIFinishReportingCallback, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x548b3909, 0xc04d, 0x4ca6, { 0x84, 0x66, 0xb8, 0xbe, 0xe3, 0x83, 0x74, 0x57 }};
class nsIMemoryReporterManager : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  __attribute__ ((warn_unused_result)) virtual nsresult Init(void) = 0;


  virtual nsresult RegisterStrongReporter(nsIMemoryReporter *reporter) = 0;


  virtual nsresult RegisterStrongAsyncReporter(nsIMemoryReporter *reporter) = 0;


  virtual nsresult RegisterWeakReporter(nsIMemoryReporter *reporter) = 0;


  virtual nsresult RegisterWeakAsyncReporter(nsIMemoryReporter *reporter) = 0;


  virtual nsresult UnregisterStrongReporter(nsIMemoryReporter *reporter) = 0;


  virtual nsresult UnregisterWeakReporter(nsIMemoryReporter *reporter) = 0;


  virtual nsresult BlockRegistrationAndHideExistingReporters(void) = 0;


  virtual nsresult UnblockRegistrationAndRestoreOriginalReporters(void) = 0;


  virtual nsresult RegisterStrongReporterEvenIfBlocked(nsIMemoryReporter *aReporter) = 0;


  virtual nsresult GetReports(nsIMemoryReporterCallback *handleReport, nsISupports *handleReportData, nsIFinishReportingCallback *finishReporting, nsISupports *finishReportingData, bool anonymize) = 0;


  virtual nsresult GetReportsExtended(nsIMemoryReporterCallback *handleReport, nsISupports *handleReportData, nsIFinishReportingCallback *finishReporting, nsISupports *finishReportingData, bool anonymize, bool minimizeMemoryUsage, const nsAString & DMDDumpIdent) = 0;


  virtual nsresult GetReportsForThisProcessExtended(nsIMemoryReporterCallback *handleReport, nsISupports *handleReportData, bool anonymize, FILE *DMDFile, nsIFinishReportingCallback *finishReporting, nsISupports *finishReportingData) = 0;


  virtual nsresult EndReport(void) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetVsize(int64_t *aVsize) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetVsizeMaxContiguous(int64_t *aVsizeMaxContiguous) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetResident(int64_t *aResident) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetResidentFast(int64_t *aResidentFast) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetResidentPeak(int64_t *aResidentPeak) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetResidentUnique(int64_t *aResidentUnique) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetHeapAllocated(int64_t *aHeapAllocated) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetHeapOverheadFraction(int64_t *aHeapOverheadFraction) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetJSMainRuntimeGCHeap(int64_t *aJSMainRuntimeGCHeap) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetJSMainRuntimeTemporaryPeak(int64_t *aJSMainRuntimeTemporaryPeak) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetJSMainRuntimeCompartmentsSystem(int64_t *aJSMainRuntimeCompartmentsSystem) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetJSMainRuntimeCompartmentsUser(int64_t *aJSMainRuntimeCompartmentsUser) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetImagesContentUsedUncompressed(int64_t *aImagesContentUsedUncompressed) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetStorageSQLite(int64_t *aStorageSQLite) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetLowMemoryEventsVirtual(int64_t *aLowMemoryEventsVirtual) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetLowMemoryEventsPhysical(int64_t *aLowMemoryEventsPhysical) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetGhostWindows(int64_t *aGhostWindows) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetPageFaultsHard(int64_t *aPageFaultsHard) = 0;


  virtual nsresult GetHasMozMallocUsableSize(bool *aHasMozMallocUsableSize) = 0;
  inline bool GetHasMozMallocUsableSize()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetHasMozMallocUsableSize(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetIsDMDEnabled(bool *aIsDMDEnabled) = 0;
  inline bool GetIsDMDEnabled()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetIsDMDEnabled(&result);
    do { } while (0);
    return result;
  }


  virtual nsresult GetIsDMDRunning(bool *aIsDMDRunning) = 0;
  inline bool GetIsDMDRunning()
  {
    bool result;
    mozilla::DebugOnly<nsresult> rv = GetIsDMDRunning(&result);
    do { } while (0);
    return result;
  }


  __attribute__ ((warn_unused_result)) virtual nsresult MinimizeMemoryUsage(nsIRunnable *callback) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult SizeOfTab(mozIDOMWindowProxy *window, int64_t *jsObjectsSize, int64_t *jsStringsSize, int64_t *jsOtherSize, int64_t *domSize, int64_t *styleSize, int64_t *otherSize, int64_t *totalSize, double *jsMilliseconds, double *nonJSMilliseconds) = 0;

};

  template<typename T> struct nsIMemoryReporterManager::COMTypeInfo<nsIMemoryReporterManager, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIMemoryReporterManager::COMTypeInfo<nsIMemoryReporterManager, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x2998574d, 0x8993, 0x407a, { 0xb1, 0xa5, 0x8a, 0xd7, 0x41, 0x76, 0x53, 0xe1 }};
class nsPIDOMWindowOuter;


typedef nsIMemoryReporterCallback nsIHandleReportCallback;
namespace mozilla {




extern "C" nsresult RegisterStrongMemoryReporter(nsIMemoryReporter* aReporter);
extern "C" nsresult RegisterStrongAsyncMemoryReporter(nsIMemoryReporter* aReporter);


extern "C" nsresult RegisterWeakMemoryReporter(nsIMemoryReporter* aReporter);
extern "C" nsresult RegisterWeakAsyncMemoryReporter(nsIMemoryReporter* aReporter);

extern "C" nsresult UnregisterStrongMemoryReporter(nsIMemoryReporter* aReporter);

extern "C" nsresult UnregisterWeakMemoryReporter(nsIMemoryReporter* aReporter);





typedef int64_t (*InfallibleAmountFn)();




nsresult RegisterJSMainRuntimeGCHeapDistinguishedAmount(InfallibleAmountFn aAmountFn);
nsresult RegisterJSMainRuntimeTemporaryPeakDistinguishedAmount(InfallibleAmountFn aAmountFn);
nsresult RegisterJSMainRuntimeCompartmentsSystemDistinguishedAmount(InfallibleAmountFn aAmountFn);
nsresult RegisterJSMainRuntimeCompartmentsUserDistinguishedAmount(InfallibleAmountFn aAmountFn);
nsresult RegisterImagesContentUsedUncompressedDistinguishedAmount(InfallibleAmountFn aAmountFn);
nsresult UnregisterImagesContentUsedUncompressedDistinguishedAmount();
nsresult RegisterStorageSQLiteDistinguishedAmount(InfallibleAmountFn aAmountFn);
nsresult UnregisterStorageSQLiteDistinguishedAmount();
nsresult RegisterLowMemoryEventsVirtualDistinguishedAmount(InfallibleAmountFn aAmountFn);
nsresult RegisterLowMemoryEventsPhysicalDistinguishedAmount(InfallibleAmountFn aAmountFn);
nsresult RegisterGhostWindowsDistinguishedAmount(InfallibleAmountFn aAmountFn);



typedef __attribute__ ((warn_unused_result)) nsresult (*JSSizeOfTabFn)(JSObject* aObj,
                                               size_t* aJsObjectsSize,
                                               size_t* aJsStringSize,
                                               size_t* aJsPrivateSize,
                                               size_t* aJsOtherSize);
typedef __attribute__ ((warn_unused_result)) nsresult (*NonJSSizeOfTabFn)(nsPIDOMWindowOuter* aWindow,
                                                  size_t* aDomSize,
                                                  size_t* aStyleSize,
                                                  size_t* aOtherSize);
nsresult RegisterJSSizeOfTab(JSSizeOfTabFn aSizeOfTabFn);
nsresult RegisterNonJSSizeOfTab(NonJSSizeOfTabFn aSizeOfTabFn);
}






class nsISupports;
class ProfilerMarkerPayload;
extern __thread mozilla::detail::ThreadLocal<PseudoStack*> tlsPseudoStack;

class ProfilerState;





extern ProfilerState* gPS;
static inline void*
profiler_call_enter(const char* aInfo,
                    js::ProfileEntry::Category aCategory,
                    void *aFrameAddress, bool aCopy, uint32_t line,
                    const char* aDynamicString = nullptr)
{


  do { static_assert(mozilla::detail::AssertionConditionType<decltype(gPS)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(gPS))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "gPS" ")"); do { *((volatile int*) __null) = 361; ::abort(); } while (0); } } while (0);

  PseudoStack* stack = tlsPseudoStack.get();
  if (!stack) {
    return stack;
  }
  stack->push(aInfo, aCategory, aFrameAddress, aCopy, line, aDynamicString);



  return stack;
}

static inline void
profiler_call_exit(void* aHandle)
{


  do { static_assert(mozilla::detail::AssertionConditionType<decltype(gPS)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(gPS))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "gPS" ")"); do { *((volatile int*) __null) = 379; ::abort(); } while (0); } } while (0);

  if (!aHandle) {
    return;
  }

  PseudoStack *stack = (PseudoStack*)aHandle;
  stack->pop();
}



void profiler_add_marker(const char *aMarker,
                         ProfilerMarkerPayload *aPayload = nullptr);



__attribute__((visibility("default")))
void profiler_save_profile_to_file_async(double aSinceTime,
                                         const char* aFileName);



void profiler_will_gather_OOP_profile();
void profiler_gathered_OOP_profile();
void profiler_OOP_exit_profile(const nsCString& aProfile);
namespace mozilla {

class SamplerStackFrameRAII {
public:


  SamplerStackFrameRAII(const char *aInfo,
    js::ProfileEntry::Category aCategory, uint32_t line
                                   )
  {
    do { } while (0);
    mHandle = profiler_call_enter(aInfo, aCategory, this, false, line);
  }
  ~SamplerStackFrameRAII() {
    profiler_call_exit(mHandle);
  }
private:

  void* mHandle;
};

class SamplerStackFrameDynamicRAII {
public:
  SamplerStackFrameDynamicRAII(const char* aInfo,
    js::ProfileEntry::Category aCategory, uint32_t aLine,
    const char* aDynamicString)
  {
    mHandle = profiler_call_enter(aInfo, aCategory, this, true, aLine,
                                  aDynamicString);
  }

  ~SamplerStackFrameDynamicRAII() {
    profiler_call_exit(mHandle);
  }

private:
  void* mHandle;
};

}

inline PseudoStack*
profiler_get_pseudo_stack(void)
{


  do { static_assert(mozilla::detail::AssertionConditionType<decltype(gPS)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(gPS))), 0))) { do { } while (0); AnnotateMozCrashReason("MOZ_RELEASE_ASSERT(" "gPS" ")"); do { *((volatile int*) __null) = 516; ::abort(); } while (0); } } while (0);

  return tlsPseudoStack.get();
}

void profiler_set_js_context(JSContext* aCx);
void profiler_clear_js_context();

class GeckoProfilerReporter final : public nsIMemoryReporter
{
public:
  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:

  GeckoProfilerReporter() {}

  virtual nsresult
  CollectReports(nsIHandleReportCallback* aHandleReport,
                 nsISupports* aData, bool aAnonymize) override;

private:
  ~GeckoProfilerReporter() {}
};



namespace mozilla {

class GeckoProfilerInitRAII {
public:
  explicit GeckoProfilerInitRAII(void* stackTop) {
    profiler_init(stackTop);
  }
  ~GeckoProfilerInitRAII() {
    profiler_shutdown();
  }
};

class GeckoProfilerThreadSleepRAII {
public:
  GeckoProfilerThreadSleepRAII() {
    profiler_thread_sleep();
  }
  ~GeckoProfilerThreadSleepRAII() {
    profiler_thread_wake();
  }
};



class GeckoProfilerThreadWakeRAII {
public:
  GeckoProfilerThreadWakeRAII()
    : mIssuedWake(profiler_thread_is_sleeping())
  {
    if (mIssuedWake) {
      profiler_thread_wake();
    }
  }
  ~GeckoProfilerThreadWakeRAII() {
    if (mIssuedWake) {
      do { } while (0);
      profiler_thread_sleep();
    }
  }
private:
  bool mIssuedWake;
};

class GeckoProfilerTracingRAII {
public:
  GeckoProfilerTracingRAII(const char* aCategory, const char* aInfo,
                           UniqueProfilerBacktrace aBacktrace
                                                          )
    : mCategory(aCategory)
    , mInfo(aInfo)
  {
    do { } while (0);
    profiler_tracing(mCategory, mInfo, Move(aBacktrace), TRACING_INTERVAL_START);
  }

  GeckoProfilerTracingRAII(const char* aCategory, const char* aInfo
                                                          )
    : mCategory(aCategory)
    , mInfo(aInfo)
  {
    do { } while (0);
    profiler_tracing(mCategory, mInfo, TRACING_INTERVAL_START);
  }

  ~GeckoProfilerTracingRAII() {
    profiler_tracing(mCategory, mInfo, TRACING_INTERVAL_END);
  }

protected:

  const char* mCategory;
  const char* mInfo;
};



class AutoProfilerRegister final
{
public:
  explicit AutoProfilerRegister(const char* aName)
  {
    profiler_register_thread(aName, this);
  }
  ~AutoProfilerRegister()
  {
    profiler_unregister_thread();
  }
private:
  AutoProfilerRegister(const AutoProfilerRegister&) = delete;
  AutoProfilerRegister& operator=(const AutoProfilerRegister&) = delete;
};

}





class nsIScriptContext;
class nsIScriptGlobalObject;

namespace mozilla {
namespace dom {
class AutoJSAPI;
class Element;
}
}

class nsJSUtils
{
public:
  static bool GetCallingLocation(JSContext* aContext, nsACString& aFilename,
                                 uint32_t* aLineno = nullptr,
                                 uint32_t* aColumn = nullptr);
  static bool GetCallingLocation(JSContext* aContext, nsAString& aFilename,
                                 uint32_t* aLineno = nullptr,
                                 uint32_t* aColumn = nullptr);

  static nsIScriptGlobalObject *GetStaticScriptGlobal(JSObject* aObj);

  static nsIScriptContext *GetStaticScriptContext(JSObject* aObj);
  static uint64_t GetCurrentlyRunningCodeInnerWindowID(JSContext *aContext);

  static nsresult CompileFunction(mozilla::dom::AutoJSAPI& jsapi,
                                  JS::AutoObjectVector& aScopeChain,
                                  JS::CompileOptions& aOptions,
                                  const nsACString& aName,
                                  uint32_t aArgCount,
                                  const char** aArgArray,
                                  const nsAString& aBody,
                                  JSObject** aFunctionObject);



  class ExecutionContext {


    mozilla::SamplerStackFrameRAII mSamplerRAII;


    JSContext* mCx;


    JSAutoCompartment mCompartment;


    JS::Rooted<JS::Value> mRetValue;


    JS::AutoObjectVector mScopeChain;



    nsresult mRv;



    bool mSkip;


    bool mCoerceToString;
   public:




    ExecutionContext(JSContext* aCx, JS::Handle<JSObject*> aGlobal);

    ExecutionContext(const ExecutionContext&) = delete;
    ExecutionContext(ExecutionContext&&) = delete;

    ~ExecutionContext() {

      do { } while (0);
    }



    ExecutionContext& SetCoerceToString(bool aCoerceToString) {
      mCoerceToString = aCoerceToString;
      return *this;
    }


    void SetScopeChain(const JS::AutoObjectVector& aScopeChain);
    __attribute__ ((warn_unused_result)) nsresult
    ExtractReturnValue(JS::MutableHandle<JS::Value> aRetValue);






    __attribute__ ((warn_unused_result)) nsresult SyncAndExec(void **aOffThreadToken,
                                      JS::MutableHandle<JSScript*> aScript);


    nsresult CompileAndExec(JS::CompileOptions& aCompileOptions,
                            JS::SourceBufferHolder& aSrcBuf);


    nsresult CompileAndExec(JS::CompileOptions& aCompileOptions,
                            const nsAString& aScript);
  };

  static nsresult CompileModule(JSContext* aCx,
                                JS::SourceBufferHolder& aSrcBuf,
                                JS::Handle<JSObject*> aEvaluationGlobal,
                                JS::CompileOptions &aCompileOptions,
                                JS::MutableHandle<JSObject*> aModule);

  static nsresult ModuleDeclarationInstantiation(JSContext* aCx,
                                                 JS::Handle<JSObject*> aModule);

  static nsresult ModuleEvaluation(JSContext* aCx,
                                   JS::Handle<JSObject*> aModule);



  static bool GetScopeChainForElement(JSContext* aCx,
                                      mozilla::dom::Element* aElement,
                                      JS::AutoObjectVector& aScopeChain);

  static void ResetTimeZone();
};

template<typename T>
inline bool
AssignJSString(JSContext *cx, T &dest, JSString *s)
{
  size_t len = js::GetStringLength(s);
  static_assert(js::MaxStringLength < (1 << 28),
                "Shouldn't overflow here or in SetCapacity");
  if ((__builtin_expect(!!(!dest.SetLength(len, mozilla::fallible)), 0))) {
    JS_ReportOutOfMemory(cx);
    return false;
  }
  return js::CopyStringChars(cx, dest.BeginWriting(), s, len);
}

inline void
AssignJSFlatString(nsAString &dest, JSFlatString *s)
{
  size_t len = js::GetFlatStringLength(s);
  static_assert(js::MaxStringLength < (1 << 28),
                "Shouldn't overflow here or in SetCapacity");
  dest.SetLength(len);
  js::CopyFlatStringChars(dest.BeginWriting(), s, len);
}

class nsAutoJSString : public nsAutoString
{
public:





  nsAutoJSString() {}

  bool init(JSContext* aContext, JSString* str)
  {
    return AssignJSString(aContext, *this, str);
  }

  bool init(JSContext* aContext, const JS::Value &v)
  {
    if (v.isString()) {
      return init(aContext, v.toString());
    }


    JS::Rooted<JSString*> str(aContext);
    if (v.isObject()) {
      str = JS_NewStringCopyZ(aContext, "[Object]");
    } else {
      JS::Rooted<JS::Value> rootedVal(aContext, v);
      str = JS::ToString(aContext, rootedVal);
    }

    return str && init(aContext, str);
  }

  bool init(JSContext* aContext, jsid id)
  {
    JS::Rooted<JS::Value> v(aContext);
    return JS_IdToValue(aContext, id, &v) && init(aContext, v);
  }

  bool init(const JS::Value &v);

  ~nsAutoJSString() {}
};

class nsIXPCScriptable;
class nsIClassInfo : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetInterfaces(uint32_t *count, nsIID ***array) = 0;


  virtual nsresult GetScriptableHelper(nsIXPCScriptable * *_retval) = 0;


  virtual nsresult GetContractID(char * *aContractID) = 0;


  virtual nsresult GetClassDescription(char * *aClassDescription) = 0;


  virtual nsresult GetClassID(nsCID **aClassID) = 0;

  enum {
    SINGLETON = 1U,
    THREADSAFE = 2U,
    MAIN_THREAD_ONLY = 4U,
    DOM_OBJECT = 8U,
    PLUGIN_OBJECT = 16U,
    SINGLETON_CLASSINFO = 32U,
    CONTENT_NODE = 64U,
    RESERVED = 2147483648U
  };


  virtual nsresult GetFlags(uint32_t *aFlags) = 0;


  virtual nsresult GetClassIDNoAlloc(nsCID *aClassIDNoAlloc) = 0;

};

  template<typename T> struct nsIClassInfo::COMTypeInfo<nsIClassInfo, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIClassInfo::COMTypeInfo<nsIClassInfo, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xa60569d7, 0xd401, 0x4677, { 0xba, 0x63, 0x2a, 0xa5, 0x97, 0x1a, 0xf2, 0x5d }};

struct JSFreeOp;
namespace js {
struct Class;
}
class nsIXPConnectWrappedNative;
class nsIXPCScriptable : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetClassName(char * *aClassName) = 0;


  virtual uint32_t GetScriptableFlags(void) = 0;


  virtual const js::Class * GetClass(void) = 0;


  virtual const JSClass * GetJSClass(void) = 0;


  virtual nsresult PreCreate(nsISupports *nativeObj, JSContext *cx, JSObject *globalObj, JSObject **parentObj) = 0;


  virtual nsresult GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx, JSObject *obj, jsid id, JS::Value *vp, bool *_retval) = 0;


  virtual nsresult SetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx, JSObject *obj, jsid id, JS::Value *vp, bool *_retval) = 0;


  virtual nsresult Enumerate(nsIXPConnectWrappedNative *wrapper, JSContext *cx, JSObject *obj, bool *_retval) = 0;


  virtual nsresult NewEnumerate(nsIXPConnectWrappedNative *wrapper, JSContext *cx, JSObject *obj, JS::AutoIdVector & properties, bool *_retval) = 0;


  virtual nsresult Resolve(nsIXPConnectWrappedNative *wrapper, JSContext *cx, JSObject *obj, jsid id, bool *resolvedp, bool *_retval) = 0;


  virtual nsresult Finalize(nsIXPConnectWrappedNative *wrapper, JSFreeOp *fop, JSObject *obj) = 0;


  virtual nsresult Call(nsIXPConnectWrappedNative *wrapper, JSContext *cx, JSObject *obj, const JS::CallArgs & args, bool *_retval) = 0;


  virtual nsresult Construct(nsIXPConnectWrappedNative *wrapper, JSContext *cx, JSObject *obj, const JS::CallArgs & args, bool *_retval) = 0;


  virtual nsresult HasInstance(nsIXPConnectWrappedNative *wrapper, JSContext *cx, JSObject *obj, JS::HandleValue val, bool *bp, bool *_retval) = 0;


  virtual nsresult PostCreatePrototype(JSContext *cx, JSObject *proto) = 0;





    bool WantPreCreate() { return 0 != (GetScriptableFlags() & (1 << 0)); }
    bool WantGetProperty() { return 0 != (GetScriptableFlags() & (1 << 1)); }
    bool WantSetProperty() { return 0 != (GetScriptableFlags() & (1 << 2)); }
    bool WantEnumerate() { return 0 != (GetScriptableFlags() & (1 << 3)); }
    bool WantNewEnumerate() { return 0 != (GetScriptableFlags() & (1 << 4)); }
    bool WantResolve() { return 0 != (GetScriptableFlags() & (1 << 5)); }
    bool WantFinalize() { return 0 != (GetScriptableFlags() & (1 << 6)); }
    bool WantCall() { return 0 != (GetScriptableFlags() & (1 << 7)); }
    bool WantConstruct() { return 0 != (GetScriptableFlags() & (1 << 8)); }
    bool WantHasInstance() { return 0 != (GetScriptableFlags() & (1 << 9)); }
    bool UseJSStubForAddProperty() { return 0 != (GetScriptableFlags() & (1 << 10)); }
    bool UseJSStubForDelProperty() { return 0 != (GetScriptableFlags() & (1 << 11)); }
    bool UseJSStubForSetProperty() { return 0 != (GetScriptableFlags() & (1 << 12)); }
    bool DontEnumQueryInterface() { return 0 != (GetScriptableFlags() & (1 << 13)); }
    bool DontAskInstanceForScriptable() { return 0 != (GetScriptableFlags() & (1 << 14)); }
    bool ClassInfoInterfacesOnly() { return 0 != (GetScriptableFlags() & (1 << 15)); }
    bool AllowPropModsDuringResolve() { return 0 != (GetScriptableFlags() & (1 << 16)); }
    bool AllowPropModsToPrototype() { return 0 != (GetScriptableFlags() & (1 << 17)); }
    bool IsGlobalObject() { return 0 != (GetScriptableFlags() & (1 << 18)); }
    bool DontReflectInterfaceNames() { return 0 != (GetScriptableFlags() & (1 << 19)); }

};

  template<typename T> struct nsIXPCScriptable::COMTypeInfo<nsIXPCScriptable, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIXPCScriptable::COMTypeInfo<nsIXPCScriptable, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x19b70b26, 0x7c3f, 0x437f, { 0xa0, 0x4a, 0x2a, 0x8f, 0x9e, 0x28, 0xb6, 0x17 }};
class nsXPCClassInfo : public nsIClassInfo,
                                    public nsIXPCScriptable
{
public:
  template<typename T, typename U> struct COMTypeInfo;
  virtual MozExternalRefCountType AddRef() override = 0;
  virtual MozExternalRefCountType Release() override = 0;
  virtual void PreserveWrapper(nsISupports *aNative) = 0;
};
template<typename T> struct nsXPCClassInfo::COMTypeInfo<nsXPCClassInfo, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsXPCClassInfo::COMTypeInfo<nsXPCClassInfo, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x43b67f01, 0xd4ce, 0x4b82, { 0xb3, 0xf8, 0xeb, 0xf2, 0x13, 0x60, 0xfb, 0x7e } };
inline
nsresult
CallQueryInterface(nsISupports* aSourcePtr,
                   RefPtrGetterAddRefs<nsXPCClassInfo> aDestPtr)
{
  return CallQueryInterface(aSourcePtr,
                            static_cast<nsXPCClassInfo**>(aDestPtr));
}


class xpcObjectHelper
{
public:
    explicit xpcObjectHelper(nsISupports* aObject, nsWrapperCache* aCache = nullptr)
      : mCanonical(nullptr)
      , mObject(aObject)
      , mCache(aCache)
    {
        if (!mCache) {
            if (aObject)
                CallQueryInterface(aObject, &mCache);
            else
                mCache = nullptr;
        }
    }

    nsISupports* Object()
    {
        return mObject;
    }

    nsISupports* GetCanonical()
    {
        if (!mCanonical) {
            mCanonicalStrong = do_QueryInterface(mObject);
            mCanonical = mCanonicalStrong;
        }
        return mCanonical;
    }

    already_AddRefed<nsISupports> forgetCanonical()
    {
        do { } while (0);

        if (!mCanonicalStrong)
            mCanonicalStrong = mCanonical;
        mCanonical = nullptr;
        return mCanonicalStrong.forget();
    }

    nsIClassInfo* GetClassInfo()
    {
        if (mXPCClassInfo)
          return mXPCClassInfo;
        if (!mClassInfo)
            mClassInfo = do_QueryInterface(mObject);
        return mClassInfo;
    }
    nsXPCClassInfo* GetXPCClassInfo()
    {
        if (!mXPCClassInfo) {
            CallQueryInterface(mObject, getter_AddRefs(mXPCClassInfo));
        }
        return mXPCClassInfo;
    }

    already_AddRefed<nsXPCClassInfo> forgetXPCClassInfo()
    {
        GetXPCClassInfo();

        return mXPCClassInfo.forget();
    }


    uint32_t GetScriptableFlags()
    {

        nsCOMPtr<nsIXPCScriptable> sinfo = GetXPCClassInfo();


        if (!sinfo)
            sinfo = do_QueryInterface(GetCanonical());


        do { } while (0);


        return sinfo->GetScriptableFlags();
    }

    nsWrapperCache* GetWrapperCache()
    {
        return mCache;
    }

protected:
    xpcObjectHelper(nsISupports* aObject, nsISupports* aCanonical,
                    nsWrapperCache* aCache)
      : mCanonical(aCanonical)
      , mObject(aObject)
      , mCache(aCache)
    {
        if (!mCache && aObject)
            CallQueryInterface(aObject, &mCache);
    }

    nsCOMPtr<nsISupports> mCanonicalStrong;
    nsISupports* mCanonical;



private:
    xpcObjectHelper(xpcObjectHelper& aOther) = delete;

    nsISupports* mObject;


    nsWrapperCache* mCache;
    nsCOMPtr<nsIClassInfo> mClassInfo;
    RefPtr<nsXPCClassInfo> mXPCClassInfo;
};





class qsObjectHelper : public xpcObjectHelper
{
public:
    template <class T>
    inline
    qsObjectHelper(T* aObject, nsWrapperCache* aCache)
        : xpcObjectHelper(ToSupports(aObject), ToCanonicalSupports(aObject),
                          aCache)
    {}

    template <class T>
    inline
    qsObjectHelper(nsCOMPtr<T>& aObject, nsWrapperCache* aCache)
        : xpcObjectHelper(ToSupports(aObject.get()),
                          ToCanonicalSupports(aObject.get()), aCache)
    {
        if (mCanonical) {

            mCanonicalStrong = dont_AddRef(mCanonical);
            aObject.forget();
        }
    }

    template <class T>
    inline
    qsObjectHelper(RefPtr<T>& aObject, nsWrapperCache* aCache)
        : xpcObjectHelper(ToSupports(aObject.get()),
                          ToCanonicalSupports(aObject.get()), aCache)
    {
        if (mCanonical) {

            mCanonicalStrong = dont_AddRef(mCanonical);
            aObject.forget();
        }
    }
};




inline JSObject*
nsWrapperCache::GetWrapper() const
{
    JSObject* obj = GetWrapperPreserveColor();
    if (obj) {
      JS::ExposeObjectToActiveJS(obj);
    }
    return obj;
}

inline bool
nsWrapperCache::HasKnownLiveWrapper() const
{





  JSObject* o = GetWrapperPreserveColor();
  return o && !JS::ObjectIsMarkedGray(o);
}

static void
SearchGray(JS::GCCellPtr aGCThing, const char* aName, void* aClosure)
{
  bool* hasGrayObjects = static_cast<bool*>(aClosure);
  if (!*hasGrayObjects && aGCThing && JS::GCThingIsMarkedGray(aGCThing)) {
    *hasGrayObjects = true;
  }
}

inline bool
nsWrapperCache::HasNothingToTrace(nsISupports* aThis)
{
  nsXPCOMCycleCollectionParticipant* participant = nullptr;
  CallQueryInterface(aThis, &participant);
  bool hasGrayObjects = false;
  participant->Trace(aThis, TraceCallbackFunc(SearchGray), &hasGrayObjects);
  return !hasGrayObjects;
}

inline bool
nsWrapperCache::HasKnownLiveWrapperAndDoesNotNeedTracing(nsISupports* aThis)
{
  return HasKnownLiveWrapper() && HasNothingToTrace(aThis);
}

inline void
nsWrapperCache::MarkWrapperLive()
{


  GetWrapper();
}

class nsGenericHTMLElement;
class nsIJSID;

namespace mozilla {

enum UseCounter : int16_t;

namespace dom {
template<typename KeyType, typename ValueType> class Record;

nsresult
UnwrapArgImpl(JSContext* cx, JS::Handle<JSObject*> src, const nsIID& iid,
              void** ppArg);

nsresult
UnwrapWindowProxyImpl(JSContext* cx, JS::Handle<JSObject*> src,
                      nsPIDOMWindowOuter** ppArg);


template <class Interface>
inline nsresult
UnwrapArg(JSContext* cx, JS::Handle<JSObject*> src, Interface** ppArg)
{
  return UnwrapArgImpl(cx, src, (Interface::template COMTypeInfo<Interface, void>::kIID),
                       reinterpret_cast<void**>(ppArg));
}

template <>
inline nsresult
UnwrapArg<nsPIDOMWindowOuter>(JSContext* cx, JS::Handle<JSObject*> src,
                              nsPIDOMWindowOuter** ppArg)
{
  return UnwrapWindowProxyImpl(cx, src, ppArg);
}

bool
ThrowInvalidThis(JSContext* aCx, const JS::CallArgs& aArgs,
                 bool aSecurityError, const char* aInterfaceName);

bool
ThrowInvalidThis(JSContext* aCx, const JS::CallArgs& aArgs,
                 bool aSecurityError, prototypes::ID aProtoId);


inline bool
IsDOMClass(const JSClass* clasp)
{
  return clasp->flags & (1<<4);
}

inline bool
IsDOMClass(const js::Class* clasp)
{
  return IsDOMClass(Jsvalify(clasp));
}


inline bool
IsNonProxyDOMClass(const js::Class* clasp)
{
  return IsDOMClass(clasp) && !clasp->isProxy();
}

inline bool
IsNonProxyDOMClass(const JSClass* clasp)
{
  return IsNonProxyDOMClass(js::Valueify(clasp));
}



inline bool
IsDOMIfaceAndProtoClass(const JSClass* clasp)
{
  return clasp->flags & (1<<((8 + 8)+6));
}

inline bool
IsDOMIfaceAndProtoClass(const js::Class* clasp)
{
  return IsDOMIfaceAndProtoClass(Jsvalify(clasp));
}

static_assert(0 == 0,
              "DOM_OBJECT_SLOT doesn't match the proxy private slot.  "
              "Expect bad things");
template <class T>
inline T*
UnwrapDOMObject(JSObject* obj)
{
  do { } while (0);


  JS::Value val = js::GetReservedOrProxyPrivateSlot(obj, 0);
  return static_cast<T*>(val.toPrivate());
}

template <class T>
inline T*
UnwrapPossiblyNotInitializedDOMObject(JSObject* obj)
{




  do { } while (0);


  JS::Value val = js::GetReservedOrProxyPrivateSlot(obj, 0);
  if (val.isUndefined()) {
    return nullptr;
  }
  return static_cast<T*>(val.toPrivate());
}

inline const DOMJSClass*
GetDOMClass(const js::Class* clasp)
{
  return IsDOMClass(clasp) ? DOMJSClass::FromJSClass(clasp) : nullptr;
}

inline const DOMJSClass*
GetDOMClass(JSObject* obj)
{
  return GetDOMClass(js::GetObjectClass(obj));
}

inline nsISupports*
UnwrapDOMObjectToISupports(JSObject* aObject)
{
  const DOMJSClass* clasp = GetDOMClass(aObject);
  if (!clasp || !clasp->mDOMObjectIsISupports) {
    return nullptr;
  }

  return UnwrapPossiblyNotInitializedDOMObject<nsISupports>(aObject);
}

inline bool
IsDOMObject(JSObject* obj)
{
  return IsDOMClass(js::GetObjectClass(obj));
}
template <class T, typename U>
__attribute__((always_inline)) inline nsresult
UnwrapObject(JSObject* obj, U& value, prototypes::ID protoID,
             uint32_t protoDepth)
{

  const DOMJSClass* domClass = GetDOMClass(obj);
  if (!domClass) {

    if (!js::IsWrapper(obj)) {

      return NS_ERROR_XPC_BAD_CONVERT_JS;
    }

    obj = js::CheckedUnwrap(obj, false);
    if (!obj) {
      return NS_ERROR_XPC_SECURITY_MANAGER_VETO;
    }
    do { } while (0);
    domClass = GetDOMClass(obj);
    if (!domClass) {

      return NS_ERROR_XPC_BAD_CONVERT_JS;
    }
  }




  if (domClass->mInterfaceChain[protoDepth] == protoID) {
    value = UnwrapDOMObject<T>(obj);
    return NS_OK;
  }


  return NS_ERROR_XPC_BAD_CONVERT_JS;
}

template <prototypes::ID PrototypeID, class T, typename U>
__attribute__((always_inline)) inline nsresult
UnwrapObject(JSObject* obj, U& value)
{
  return UnwrapObject<T>(obj, value, PrototypeID,
                         PrototypeTraits<PrototypeID>::Depth);
}

__attribute__((always_inline)) inline bool
IsConvertibleToDictionary(JS::Handle<JS::Value> val)
{
  return val.isNullOrUndefined() || val.isObject();
}






static_assert((size_t)constructors::id::_ID_Start ==
              (size_t)prototypes::id::_ID_Count &&
              (size_t)namedpropertiesobjects::id::_ID_Start ==
              (size_t)constructors::id::_ID_Count,
              "Overlapping or discontiguous indexes.");
const size_t kProtoAndIfaceCacheCount = namedpropertiesobjects::id::_ID_Count;

class ProtoAndIfaceCache
{






  class ArrayCache : public Array<JS::Heap<JSObject*>, kProtoAndIfaceCacheCount>
  {
  public:
    JSObject* EntrySlotIfExists(size_t i) {
      return (*this)[i];
    }

    JS::Heap<JSObject*>& EntrySlotOrCreate(size_t i) {
      return (*this)[i];
    }

    JS::Heap<JSObject*>& EntrySlotMustExist(size_t i) {
      return (*this)[i];
    }

    void Trace(JSTracer* aTracer) {
      for (size_t i = 0; i < ArrayLength(*this); ++i) {
        JS::TraceEdge(aTracer, &(*this)[i], "protoAndIfaceCache[i]");
      }
    }

    size_t SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) {
      return aMallocSizeOf(this);
    }
  };

  class PageTableCache
  {
  public:
    PageTableCache() {
      memset(&mPages, 0, sizeof(mPages));
    }

    ~PageTableCache() {
      for (size_t i = 0; i < ArrayLength(mPages); ++i) {
        delete mPages[i];
      }
    }

    JSObject* EntrySlotIfExists(size_t i) {
      do { } while (0);
      size_t pageIndex = i / kPageSize;
      size_t leafIndex = i % kPageSize;
      Page* p = mPages[pageIndex];
      if (!p) {
        return nullptr;
      }
      return (*p)[leafIndex];
    }

    JS::Heap<JSObject*>& EntrySlotOrCreate(size_t i) {
      do { } while (0);
      size_t pageIndex = i / kPageSize;
      size_t leafIndex = i % kPageSize;
      Page* p = mPages[pageIndex];
      if (!p) {
        p = new Page;
        mPages[pageIndex] = p;
      }
      return (*p)[leafIndex];
    }

    JS::Heap<JSObject*>& EntrySlotMustExist(size_t i) {
      do { } while (0);
      size_t pageIndex = i / kPageSize;
      size_t leafIndex = i % kPageSize;
      Page* p = mPages[pageIndex];
      do { } while (0);
      return (*p)[leafIndex];
    }

    void Trace(JSTracer* trc) {
      for (size_t i = 0; i < ArrayLength(mPages); ++i) {
        Page* p = mPages[i];
        if (p) {
          for (size_t j = 0; j < ArrayLength(*p); ++j) {
            JS::TraceEdge(trc, &(*p)[j], "protoAndIfaceCache[i]");
          }
        }
      }
    }

    size_t SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) {
      size_t n = aMallocSizeOf(this);
      for (size_t i = 0; i < ArrayLength(mPages); ++i) {
        n += aMallocSizeOf(mPages[i]);
      }
      return n;
    }

  private:
    static const size_t kPageSize = 16;
    typedef Array<JS::Heap<JSObject*>, kPageSize> Page;
    static const size_t kNPages = kProtoAndIfaceCacheCount / kPageSize +
      size_t(bool(kProtoAndIfaceCacheCount % kPageSize));
    Array<Page*, kNPages> mPages;
  };

public:
  enum Kind {
    WindowLike,
    NonWindowLike
  };

  explicit ProtoAndIfaceCache(Kind aKind) : mKind(aKind) {
                                      ;
    if (aKind == WindowLike) {
      mArrayCache = new ArrayCache();
    } else {
      mPageTableCache = new PageTableCache();
    }
  }

  ~ProtoAndIfaceCache() {
    if (mKind == WindowLike) {
      delete mArrayCache;
    } else {
      delete mPageTableCache;
    }
                                      ;
  }
  JSObject* EntrySlotIfExists(size_t i) {
    do { if (mKind == WindowLike) { return mArrayCache->EntrySlotIfExists (i); } else { return mPageTableCache->EntrySlotIfExists (i); } } while(0);
  }



  JS::Heap<JSObject*>& EntrySlotOrCreate(size_t i) {
    do { if (mKind == WindowLike) { return mArrayCache->EntrySlotOrCreate (i); } else { return mPageTableCache->EntrySlotOrCreate (i); } } while(0);
  }




  JS::Heap<JSObject*>& EntrySlotMustExist(size_t i) {
    do { if (mKind == WindowLike) { return mArrayCache->EntrySlotMustExist (i); } else { return mPageTableCache->EntrySlotMustExist (i); } } while(0);
  }

  void Trace(JSTracer *aTracer) {
    do { if (mKind == WindowLike) { return mArrayCache->Trace (aTracer); } else { return mPageTableCache->Trace (aTracer); } } while(0);
  }

  size_t SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) {
    size_t n = aMallocSizeOf(this);
    n += (mKind == WindowLike
          ? mArrayCache->SizeOfIncludingThis(aMallocSizeOf)
          : mPageTableCache->SizeOfIncludingThis(aMallocSizeOf));
    return n;
  }


private:
  union {
    ArrayCache *mArrayCache;
    PageTableCache *mPageTableCache;
  };
  Kind mKind;
};

inline void
AllocateProtoAndIfaceCache(JSObject* obj, ProtoAndIfaceCache::Kind aKind)
{
  do { } while (0);
  do { } while (0);

  ProtoAndIfaceCache* protoAndIfaceCache = new ProtoAndIfaceCache(aKind);

  js::SetReservedSlot(obj, (5 + JSProto_LIMIT * 2 + 46),
                      JS::PrivateValue(protoAndIfaceCache));
}
inline void
TraceProtoAndIfaceCache(JSTracer* trc, JSObject* obj)
{
  do { } while (0);
  if (!DOMGlobalHasProtoAndIFaceCache(obj))
    return;
  ProtoAndIfaceCache* protoAndIfaceCache = GetProtoAndIfaceCache(obj);
  protoAndIfaceCache->Trace(trc);
}

inline void
DestroyProtoAndIfaceCache(JSObject* obj)
{
  do { } while (0);

  if (!DOMGlobalHasProtoAndIFaceCache(obj)) {
    return;
  }

  ProtoAndIfaceCache* protoAndIfaceCache = GetProtoAndIfaceCache(obj);

  delete protoAndIfaceCache;
}




bool
DefineConstants(JSContext* cx, JS::Handle<JSObject*> obj,
                const ConstantSpec* cs);

struct JSNativeHolder
{
  JSNative mNative;
  const NativePropertyHooks* mPropertyHooks;
};

struct NamedConstructor
{
  const char* mName;
  const JSNativeHolder mHolder;
  unsigned mNargs;
};
void
CreateInterfaceObjects(JSContext* cx, JS::Handle<JSObject*> global,
                       JS::Handle<JSObject*> protoProto,
                       const js::Class* protoClass, JS::Heap<JSObject*>* protoCache,
                       JS::Handle<JSObject*> interfaceProto,
                       const js::Class* constructorClass,
                       unsigned ctorNargs, const NamedConstructor* namedConstructors,
                       JS::Heap<JSObject*>* constructorCache,
                       const NativeProperties* regularProperties,
                       const NativeProperties* chromeOnlyProperties,
                       const char* name, bool defineOnGlobal,
                       const char* const* unscopableNames,
                       bool isGlobal);
bool
DefineProperties(JSContext* cx, JS::Handle<JSObject*> obj,
                 const NativeProperties* properties,
                 const NativeProperties* chromeOnlyProperties);




bool
DefineUnforgeableMethods(JSContext* cx, JS::Handle<JSObject*> obj,
                         const Prefable<const JSFunctionSpec>* props);




bool
DefineUnforgeableAttributes(JSContext* cx, JS::Handle<JSObject*> obj,
                            const Prefable<const JSPropertySpec>* props);
template<class T>
struct NativeHasMember
{
  private: typedef char yes[1]; typedef char no[2];

  private: template<typename V> static yes& CheckGetParentObject(char (*)[sizeof(&V::GetParentObject) + 1]); template<typename V> static no& CheckGetParentObject(...); public: static bool const GetParentObject = sizeof(CheckGetParentObject<T>(nullptr)) == sizeof(yes);
  private: template<typename V> static yes& CheckWrapObject(char (*)[sizeof(&V::WrapObject) + 1]); template<typename V> static no& CheckWrapObject(...); public: static bool const WrapObject = sizeof(CheckWrapObject<T>(nullptr)) == sizeof(yes);
};

template<class T>
struct IsSmartPtr
{
  private: typedef char yes[1]; typedef char no[2];

  private: template<typename V> static yes& Checkget(char (*)[sizeof(&V::get) + 1]); template<typename V> static no& Checkget(...); public: static bool const value = sizeof(Checkget<T>(nullptr)) == sizeof(yes);
};

template<class T>
struct IsRefcounted
{
  private: typedef char yes[1]; typedef char no[2];

  private: template<typename V> static yes& CheckAddRef(char (*)[sizeof(&V::AddRef) + 1]); template<typename V> static no& CheckAddRef(...); public: static bool const HasAddref = sizeof(CheckAddRef<T>(nullptr)) == sizeof(yes);
  private: template<typename V> static yes& CheckRelease(char (*)[sizeof(&V::Release) + 1]); template<typename V> static no& CheckRelease(...); public: static bool const HasRelease = sizeof(CheckRelease<T>(nullptr)) == sizeof(yes);

public:
  static bool const value = HasAddref && HasRelease;

private:



  static_assert(!IsBaseOf<nsISupports, T>::value || IsRefcounted::value,
                "Classes derived from nsISupports are refcounted!");

};
__attribute__((always_inline)) inline bool
CouldBeDOMBinding(void*)
{
  return true;
}

__attribute__((always_inline)) inline bool
CouldBeDOMBinding(nsWrapperCache* aCache)
{
  return aCache->IsDOMBinding();
}

inline bool
TryToOuterize(JS::MutableHandle<JS::Value> rval)
{
  if (js::IsWindow(&rval.toObject())) {
    JSObject* obj = js::ToWindowProxyIfWindow(&rval.toObject());
    do { } while (0);
    rval.set(JS::ObjectValue(*obj));
  }

  return true;
}



__attribute__((always_inline)) inline
bool
MaybeWrapStringValue(JSContext* cx, JS::MutableHandle<JS::Value> rval)
{
  do { } while (0);
  JSString* str = rval.toString();
  if (JS::GetStringZone(str) != js::GetContextZone(cx)) {
    return JS_WrapValue(cx, rval);
  }
  return true;
}



__attribute__((always_inline)) inline
bool
MaybeWrapObjectValue(JSContext* cx, JS::MutableHandle<JS::Value> rval)
{
  do { } while (0);


  JSObject* obj = &rval.toObject();
  if (js::GetObjectCompartment(obj) != js::GetContextCompartment(cx)) {
    return JS_WrapValue(cx, rval);
  }



  if (IsDOMObject(obj)) {
    return TryToOuterize(rval);
  }



  return true;
}


__attribute__((always_inline)) inline
bool
MaybeWrapObjectOrNullValue(JSContext* cx, JS::MutableHandle<JS::Value> rval)
{
  do { } while (0);
  if (rval.isNull()) {
    return true;
  }
  return MaybeWrapObjectValue(cx, rval);
}


__attribute__((always_inline)) inline
bool
MaybeWrapNonDOMObjectValue(JSContext* cx, JS::MutableHandle<JS::Value> rval)
{
  do { } while (0);
  do { } while (0);
  do { } while (0);


  JSObject* obj = &rval.toObject();
  if (js::GetObjectCompartment(obj) == js::GetContextCompartment(cx)) {
    return true;
  }
  return JS_WrapValue(cx, rval);
}


__attribute__((always_inline)) inline
bool
MaybeWrapNonDOMObjectOrNullValue(JSContext* cx, JS::MutableHandle<JS::Value> rval)
{
  do { } while (0);
  if (rval.isNull()) {
    return true;
  }
  return MaybeWrapNonDOMObjectValue(cx, rval);
}




__attribute__((always_inline)) inline bool
MaybeWrapValue(JSContext* cx, JS::MutableHandle<JS::Value> rval)
{
  if (rval.isGCThing()) {
    if (rval.isString()) {
      return MaybeWrapStringValue(cx, rval);
    }
    if (rval.isObject()) {
      return MaybeWrapObjectValue(cx, rval);
    }
    do { } while (0);
    JS_MarkCrossZoneId(cx, SYMBOL_TO_JSID(rval.toSymbol()));
  }
  return true;
}

namespace binding_detail {
enum GetOrCreateReflectorWrapBehavior {
  eWrapIntoContextCompartment,
  eDontWrapIntoContextCompartment
};

template <class T>
struct TypeNeedsOuterization
{


  static const bool value =
    IsBaseOf<nsGlobalWindow, T>::value || IsSame<EventTarget, T>::value;
};
template <class T, GetOrCreateReflectorWrapBehavior wrapBehavior>
__attribute__((always_inline)) inline bool
DoGetOrCreateDOMReflector(JSContext* cx, T* value,
                          JS::Handle<JSObject*> givenProto,
                          JS::MutableHandle<JS::Value> rval)
{
  do { } while (0);
  do { } while (0);

  bool couldBeDOMBinding = CouldBeDOMBinding(value);
  JSObject* obj = value->GetWrapper();
  if (obj) {






  } else {

    if (!couldBeDOMBinding) {
      return false;
    }

    obj = value->WrapObject(cx, givenProto);
    if (!obj) {



      return false;
    }






  }
  rval.set(JS::ObjectValue(*obj));

  bool sameCompartment =
    js::GetObjectCompartment(obj) == js::GetContextCompartment(cx);
  if (sameCompartment && couldBeDOMBinding) {
    return TypeNeedsOuterization<T>::value ? TryToOuterize(rval) : true;
  }

  if (wrapBehavior == eDontWrapIntoContextCompartment) {
    if (TypeNeedsOuterization<T>::value) {
      JSAutoCompartment ac(cx, obj);
      return TryToOuterize(rval);
    }

    return true;
  }

  return JS_WrapValue(cx, rval);
}

}
template <class T>
__attribute__((always_inline)) inline bool
GetOrCreateDOMReflector(JSContext* cx, T* value,
                        JS::MutableHandle<JS::Value> rval,
                        JS::Handle<JSObject*> givenProto = nullptr)
{
  using namespace binding_detail;
  return DoGetOrCreateDOMReflector<T, eWrapIntoContextCompartment>(cx, value,
                                                                   givenProto,
                                                                   rval);
}



template <class T>
__attribute__((always_inline)) inline bool
GetOrCreateDOMReflectorNoWrap(JSContext* cx, T* value,
                              JS::MutableHandle<JS::Value> rval)
{
  using namespace binding_detail;
  return DoGetOrCreateDOMReflector<T, eDontWrapIntoContextCompartment>(cx,
                                                                       value,
                                                                       nullptr,
                                                                       rval);
}




template <class T>
inline bool
WrapNewBindingNonWrapperCachedObject(JSContext* cx,
                                     JS::Handle<JSObject*> scopeArg,
                                     T* value,
                                     JS::MutableHandle<JS::Value> rval,
                                     JS::Handle<JSObject*> givenProto = nullptr)
{
  static_assert(IsRefcounted<T>::value, "Don't pass owned classes in here.");
  do { } while (0);

  JS::Rooted<JSObject*> obj(cx);
  {


    Maybe<JSAutoCompartment> ac;



    JS::Rooted<JSObject*> scope(cx, scopeArg);
    JS::Rooted<JSObject*> proto(cx, givenProto);
    if (js::IsWrapper(scope)) {
      scope = js::CheckedUnwrap(scope, false);
      if (!scope)
        return false;
      ac.emplace(cx, scope);
      if (!JS_WrapObject(cx, &proto)) {
        return false;
      }
    }

    do { } while (0);
    if (!value->WrapObject(cx, proto, &obj)) {
      return false;
    }
  }



  rval.set(JS::ObjectValue(*obj));
  return MaybeWrapObjectValue(cx, rval);
}





template <class T>
inline bool
WrapNewBindingNonWrapperCachedObject(JSContext* cx,
                                     JS::Handle<JSObject*> scopeArg,
                                     nsAutoPtr<T>& value,
                                     JS::MutableHandle<JS::Value> rval,
                                     JS::Handle<JSObject*> givenProto = nullptr)
{
  static_assert(!IsRefcounted<T>::value, "Only pass owned classes in here.");


  if (!value) {
    do { AnnotateMozCrashReason("MOZ_CRASH(" "Don't try to wrap null objects" ")"); do { *((volatile int*) __null) = 1072; ::abort(); } while (0); } while (0);
  }

  JS::Rooted<JSObject*> obj(cx);
  {


    Maybe<JSAutoCompartment> ac;



    JS::Rooted<JSObject*> scope(cx, scopeArg);
    JS::Rooted<JSObject*> proto(cx, givenProto);
    if (js::IsWrapper(scope)) {
      scope = js::CheckedUnwrap(scope, false);
      if (!scope)
        return false;
      ac.emplace(cx, scope);
      if (!JS_WrapObject(cx, &proto)) {
        return false;
      }
    }

    do { } while (0);
    if (!value->WrapObject(cx, proto, &obj)) {
      return false;
    }

    value.forget();
  }



  rval.set(JS::ObjectValue(*obj));
  return MaybeWrapObjectValue(cx, rval);
}


template <template <typename> class SmartPtr, typename T,
          typename U=typename EnableIf<IsRefcounted<T>::value, T>::Type,
          typename V=typename EnableIf<IsSmartPtr<SmartPtr<T>>::value, T>::Type>
inline bool
WrapNewBindingNonWrapperCachedObject(JSContext* cx, JS::Handle<JSObject*> scope,
                                     const SmartPtr<T>& value,
                                     JS::MutableHandle<JS::Value> rval,
                                     JS::Handle<JSObject*> givenProto = nullptr)
{
  return WrapNewBindingNonWrapperCachedObject(cx, scope, value.get(), rval,
                                              givenProto);
}


template <typename T,
          typename U=typename EnableIf<!IsSmartPtr<T>::value, T>::Type>
inline bool
WrapNewBindingNonWrapperCachedObject(JSContext* cx, JS::Handle<JSObject*> scope,
                                     T& value,
                                     JS::MutableHandle<JS::Value> rval,
                                     JS::Handle<JSObject*> givenProto = nullptr)
{
  return WrapNewBindingNonWrapperCachedObject(cx, scope, &value, rval,
                                              givenProto);
}



bool
NativeInterface2JSObjectAndThrowIfFailed(JSContext* aCx,
                                         JS::Handle<JSObject*> aScope,
                                         JS::MutableHandle<JS::Value> aRetval,
                                         xpcObjectHelper& aHelper,
                                         const nsIID* aIID,
                                         bool aAllowNativeWrapper);





template <class T>
__attribute__((always_inline)) inline bool
HandleNewBindingWrappingFailure(JSContext* cx, JS::Handle<JSObject*> scope,
                                T* value, JS::MutableHandle<JS::Value> rval)
{
  if (JS_IsExceptionPending(cx)) {
    return false;
  }

  qsObjectHelper helper(value, GetWrapperCache(value));
  return NativeInterface2JSObjectAndThrowIfFailed(cx, scope, rval,
                                                  helper, nullptr, true);
}




template <class T, bool isSmartPtr=IsSmartPtr<T>::value>
struct HandleNewBindingWrappingFailureHelper
{
  static inline bool Wrap(JSContext* cx, JS::Handle<JSObject*> scope,
                          const T& value, JS::MutableHandle<JS::Value> rval)
  {
    return HandleNewBindingWrappingFailure(cx, scope, value.get(), rval);
  }
};

template <class T>
struct HandleNewBindingWrappingFailureHelper<T, false>
{
  static inline bool Wrap(JSContext* cx, JS::Handle<JSObject*> scope, T& value,
                          JS::MutableHandle<JS::Value> rval)
  {
    return HandleNewBindingWrappingFailure(cx, scope, &value, rval);
  }
};

template<class T>
inline bool
HandleNewBindingWrappingFailure(JSContext* cx, JS::Handle<JSObject*> scope,
                                T& value, JS::MutableHandle<JS::Value> rval)
{
  return HandleNewBindingWrappingFailureHelper<T>::Wrap(cx, scope, value, rval);
}

template<bool Fatal>
inline bool
EnumValueNotFound(JSContext* cx, JS::HandleString str, const char* type,
                  const char* sourceDescription);

template<>
inline bool
EnumValueNotFound<false>(JSContext* cx, JS::HandleString str, const char* type,
                         const char* sourceDescription)
{

  return true;
}

template<>
inline bool
EnumValueNotFound<true>(JSContext* cx, JS::HandleString str, const char* type,
                        const char* sourceDescription)
{
  JSAutoByteString deflated;
  if (!deflated.encodeUtf8(cx, str)) {
    return false;
  }
  return ThrowErrorMessage(cx, MSG_INVALID_ENUM_VALUE, sourceDescription,
                           deflated.ptr(), type);
}

template<typename CharT>
inline int
FindEnumStringIndexImpl(const CharT* chars, size_t length, const EnumEntry* values)
{
  int i = 0;
  for (const EnumEntry* value = values; value->value; ++value, ++i) {
    if (length != value->length) {
      continue;
    }

    bool equal = true;
    const char* val = value->value;
    for (size_t j = 0; j != length; ++j) {
      if (unsigned(val[j]) != unsigned(chars[j])) {
        equal = false;
        break;
      }
    }

    if (equal) {
      return i;
    }
  }

  return -1;
}

template<bool InvalidValueFatal>
inline bool
FindEnumStringIndex(JSContext* cx, JS::Handle<JS::Value> v, const EnumEntry* values,
                    const char* type, const char* sourceDescription, int* index)
{

  JS::RootedString str(cx, JS::ToString(cx, v));
  if (!str) {
    return false;
  }

  {
    size_t length;
    JS::AutoCheckCannotGC nogc;
    if (js::StringHasLatin1Chars(str)) {
      const JS::Latin1Char* chars = JS_GetLatin1StringCharsAndLength(cx, nogc, str,
                                                                     &length);
      if (!chars) {
        return false;
      }
      *index = FindEnumStringIndexImpl(chars, length, values);
    } else {
      const char16_t* chars = JS_GetTwoByteStringCharsAndLength(cx, nogc, str,
                                                                &length);
      if (!chars) {
        return false;
      }
      *index = FindEnumStringIndexImpl(chars, length, values);
    }
    if (*index >= 0) {
      return true;
    }
  }

  return EnumValueNotFound<InvalidValueFatal>(cx, str, type, sourceDescription);
}

inline nsWrapperCache*
GetWrapperCache(const ParentObject& aParentObject)
{
  return aParentObject.mWrapperCache;
}

template<class T>
inline T*
GetParentPointer(T* aObject)
{
  return aObject;
}

inline nsISupports*
GetParentPointer(const ParentObject& aObject)
{
  return aObject.mObject;
}

template <typename T>
inline bool
GetUseXBLScope(T* aParentObject)
{
  return false;
}

inline bool
GetUseXBLScope(const ParentObject& aParentObject)
{
  return aParentObject.mUseXBLScope;
}

template<class T>
inline void
ClearWrapper(T* p, nsWrapperCache* cache)
{
  cache->ClearWrapper();
}

template<class T>
inline void
ClearWrapper(T* p, void*)
{
  nsWrapperCache* cache;
  CallQueryInterface(p, &cache);
  ClearWrapper(p, cache);
}

template<class T>
inline void
UpdateWrapper(T* p, nsWrapperCache* cache, JSObject* obj, const JSObject* old)
{
  JS::AutoAssertGCCallback inCallback(obj);
  cache->UpdateWrapper(obj, old);
}

template<class T>
inline void
UpdateWrapper(T* p, void*, JSObject* obj, const JSObject* old)
{
  JS::AutoAssertGCCallback inCallback(obj);
  nsWrapperCache* cache;
  CallQueryInterface(p, &cache);
  UpdateWrapper(p, cache, obj, old);
}
bool
TryPreserveWrapper(JSObject* obj);


bool
InstanceClassHasProtoAtDepth(const js::Class* clasp,
                             uint32_t protoID, uint32_t depth);



bool
XPCOMObjectToJsval(JSContext* cx, JS::Handle<JSObject*> scope,
                   xpcObjectHelper& helper, const nsIID* iid,
                   bool allowNativeWrapper, JS::MutableHandle<JS::Value> rval);


bool
VariantToJsval(JSContext* aCx, nsIVariant* aVariant,
               JS::MutableHandle<JS::Value> aRetval);





template<class T>
inline bool
WrapObject(JSContext* cx, T* p, nsWrapperCache* cache, const nsIID* iid,
           JS::MutableHandle<JS::Value> rval)
{
  if (xpc_FastGetCachedWrapper(cx, cache, rval))
    return true;
  qsObjectHelper helper(p, cache);
  JS::Rooted<JSObject*> scope(cx, JS::CurrentGlobalOrNull(cx));
  return XPCOMObjectToJsval(cx, scope, helper, iid, true, rval);
}



template<>
inline bool
WrapObject<nsIVariant>(JSContext* cx, nsIVariant* p,
                       nsWrapperCache* cache, const nsIID* iid,
                       JS::MutableHandle<JS::Value> rval)
{
  do { } while (0);
  do { } while (0);
  return VariantToJsval(cx, p, rval);
}




template<class T>
inline bool
WrapObject(JSContext* cx, T* p, const nsIID* iid,
           JS::MutableHandle<JS::Value> rval)
{
  return WrapObject(cx, p, GetWrapperCache(p), iid, rval);
}




template<class T>
inline bool
WrapObject(JSContext* cx, T* p, JS::MutableHandle<JS::Value> rval)
{
  return WrapObject(cx, p, nullptr, rval);
}


template<class T>
inline bool
WrapObject(JSContext* cx, const nsCOMPtr<T>& p,
           const nsIID* iid, JS::MutableHandle<JS::Value> rval)
{
  return WrapObject(cx, p.get(), iid, rval);
}


template<class T>
inline bool
WrapObject(JSContext* cx, const nsCOMPtr<T>& p,
           JS::MutableHandle<JS::Value> rval)
{
  return WrapObject(cx, p, nullptr, rval);
}


template<class T>
inline bool
WrapObject(JSContext* cx, const RefPtr<T>& p,
           const nsIID* iid, JS::MutableHandle<JS::Value> rval)
{
  return WrapObject(cx, p.get(), iid, rval);
}


template<class T>
inline bool
WrapObject(JSContext* cx, const RefPtr<T>& p,
           JS::MutableHandle<JS::Value> rval)
{
  return WrapObject(cx, p, nullptr, rval);
}


template<>
inline bool
WrapObject<JSObject>(JSContext* cx, JSObject* p,
                     JS::MutableHandle<JS::Value> rval)
{
  rval.set(JS::ObjectOrNullValue(p));
  return true;
}

inline bool
WrapObject(JSContext* cx, JSObject& p, JS::MutableHandle<JS::Value> rval)
{
  rval.set(JS::ObjectValue(p));
  return true;
}





template<typename T>
static inline JSObject*
WrapNativeISupports(JSContext* cx, T* p, nsWrapperCache* cache)
{
  qsObjectHelper helper(ToSupports(p), cache);
  JS::Rooted<JSObject*> scope(cx, JS::CurrentGlobalOrNull(cx));
  JS::Rooted<JS::Value> v(cx);
  return XPCOMObjectToJsval(cx, scope, helper, nullptr, false, &v) ?
         v.toObjectOrNull() :
         nullptr;
}



template<typename T, bool isISupports=IsBaseOf<nsISupports, T>::value>
struct WrapNativeFallback
{
  static inline JSObject* Wrap(JSContext* cx, T* parent, nsWrapperCache* cache)
  {
    return nullptr;
  }
};



template<typename T >
struct WrapNativeFallback<T, true >
{
  static inline JSObject* Wrap(JSContext* cx, T* parent, nsWrapperCache* cache)
  {
    return WrapNativeISupports(cx, parent, cache);
  }
};



template<typename T, bool hasWrapObject=NativeHasMember<T>::WrapObject>
struct WrapNativeHelper
{
  static inline JSObject* Wrap(JSContext* cx, T* parent, nsWrapperCache* cache)
  {
    do { } while (0);

    JSObject* obj;
    if ((obj = cache->GetWrapper())) {

      do { } while (0);
      return obj;
    }


    if (!CouldBeDOMBinding(parent)) {

      obj = WrapNativeFallback<T>::Wrap(cx, parent, cache);
      do { } while (0);
    } else {

      obj = parent->WrapObject(cx, nullptr);
      do { } while (0);
    }

    return obj;
  }
};



template<typename T>
struct WrapNativeHelper<T, false>
{
  static inline JSObject* Wrap(JSContext* cx, T* parent, nsWrapperCache* cache)
  {
    JSObject* obj;
    if (cache && (obj = cache->GetWrapper())) {






      do { } while (0);
      return obj;
    }

    obj = WrapNativeISupports(cx, parent, cache);
    do { } while (0);
    return obj;
  }
};


template<typename T>
static inline JSObject*
FindAssociatedGlobal(JSContext* cx, T* p, nsWrapperCache* cache,
                     bool useXBLScope = false)
{
  if (!p) {
    return JS::CurrentGlobalOrNull(cx);
  }

  JSObject* obj = WrapNativeHelper<T>::Wrap(cx, p, cache);
  if (!obj) {
    return nullptr;
  }
  do { } while (0);

  obj = js::GetGlobalForObjectCrossCompartment(obj);

  if (!useXBLScope) {
    return obj;
  }




  if (xpc::IsInContentXBLScope(obj)) {
    return obj;
  }
  JS::Rooted<JSObject*> rootedObj(cx, obj);
  JSObject* xblScope = xpc::GetXBLScope(cx, rootedObj);
  do { } while (0);
  do { } while (0);
  return xblScope;
}



template<typename T>
static inline JSObject*
FindAssociatedGlobal(JSContext* cx, const T& p)
{
  return FindAssociatedGlobal(cx, GetParentPointer(p), GetWrapperCache(p), GetUseXBLScope(p));
}



template<>
inline JSObject*
FindAssociatedGlobal(JSContext* cx, nsIGlobalObject* const& p)
{
  if (!p) {
    return JS::CurrentGlobalOrNull(cx);
  }

  JSObject* global = p->GetGlobalJSObject();
  if (!global) {
    return nullptr;
  }

  do { } while (0);


  JS::ExposeObjectToActiveJS(global);
  return global;
}

template<typename T,
         bool hasAssociatedGlobal=NativeHasMember<T>::GetParentObject>
struct FindAssociatedGlobalForNative
{
  static JSObject* Get(JSContext* cx, JS::Handle<JSObject*> obj)
  {
    do { } while (0);
    T* native = UnwrapDOMObject<T>(obj);
    return FindAssociatedGlobal(cx, native->GetParentObject());
  }
};

template<typename T>
struct FindAssociatedGlobalForNative<T, false>
{
  static JSObject* Get(JSContext* cx, JS::Handle<JSObject*> obj)
  {
    do { AnnotateMozCrashReason("MOZ_CRASH(" ")"); do { *((volatile int*) __null) = 1660; ::abort(); } while (0); } while (0);
    return nullptr;
  }
};



template <class T, bool isSmartPtr=IsSmartPtr<T>::value>
struct GetOrCreateDOMReflectorHelper
{
  static inline bool GetOrCreate(JSContext* cx, const T& value,
                                 JS::Handle<JSObject*> givenProto,
                                 JS::MutableHandle<JS::Value> rval)
  {
    return GetOrCreateDOMReflector(cx, value.get(), rval, givenProto);
  }
};

template <class T>
struct GetOrCreateDOMReflectorHelper<T, false>
{
  static inline bool GetOrCreate(JSContext* cx, T& value,
                                 JS::Handle<JSObject*> givenProto,
                                 JS::MutableHandle<JS::Value> rval)
  {
    static_assert(IsRefcounted<T>::value, "Don't pass owned classes in here.");
    return GetOrCreateDOMReflector(cx, &value, rval, givenProto);
  }
};

template<class T>
inline bool
GetOrCreateDOMReflector(JSContext* cx, T& value,
                        JS::MutableHandle<JS::Value> rval,
                        JS::Handle<JSObject*> givenProto = nullptr)
{
  return GetOrCreateDOMReflectorHelper<T>::GetOrCreate(cx, value, givenProto,
                                                       rval);
}



template <class T, bool isSmartPtr=IsSmartPtr<T>::value>
struct GetOrCreateDOMReflectorNoWrapHelper
{
  static inline bool GetOrCreate(JSContext* cx, const T& value,
                                 JS::MutableHandle<JS::Value> rval)
  {
    return GetOrCreateDOMReflectorNoWrap(cx, value.get(), rval);
  }
};

template <class T>
struct GetOrCreateDOMReflectorNoWrapHelper<T, false>
{
  static inline bool GetOrCreate(JSContext* cx, T& value,
                                 JS::MutableHandle<JS::Value> rval)
  {
    return GetOrCreateDOMReflectorNoWrap(cx, &value, rval);
  }
};

template<class T>
inline bool
GetOrCreateDOMReflectorNoWrap(JSContext* cx, T& value,
                              JS::MutableHandle<JS::Value> rval)
{
  return
    GetOrCreateDOMReflectorNoWrapHelper<T>::GetOrCreate(cx, value, rval);
}

template <class T>
inline JSObject*
GetCallbackFromCallbackObject(T* aObj)
{
  return aObj->CallbackOrNull();
}




template <class T, bool isSmartPtr=IsSmartPtr<T>::value>
struct GetCallbackFromCallbackObjectHelper
{
  static inline JSObject* Get(const T& aObj)
  {
    return GetCallbackFromCallbackObject(aObj.get());
  }
};

template <class T>
struct GetCallbackFromCallbackObjectHelper<T, false>
{
  static inline JSObject* Get(T& aObj)
  {
    return GetCallbackFromCallbackObject(&aObj);
  }
};

template<class T>
inline JSObject*
GetCallbackFromCallbackObject(T& aObj)
{
  return GetCallbackFromCallbackObjectHelper<T>::Get(aObj);
}

static inline bool
AtomizeAndPinJSString(JSContext* cx, jsid& id, const char* chars)
{
  if (JSString *str = ::JS_AtomizeAndPinString(cx, chars)) {
    id = INTERNED_STRING_TO_JSID(cx, str);
    return true;
  }
  return false;
}


template <typename Spec>
static bool
InitIds(JSContext* cx, const Prefable<Spec>* prefableSpecs, jsid* ids)
{
  do { } while (0);
  do { } while (0);
  do {


    Spec* spec = prefableSpecs->specs;
    do {
      if (!JS::PropertySpecNameToPermanentId(cx, spec->name, ids)) {
        return false;
      }
    } while (++ids, (++spec)->name);



    *ids = JSID_VOID;
    ++ids;
  } while ((++prefableSpecs)->specs);

  return true;
}

bool
QueryInterface(JSContext* cx, unsigned argc, JS::Value* vp);

template <class T>
struct
WantsQueryInterface
{
  static_assert(IsBaseOf<nsISupports, T>::value,
                "QueryInterface can't work without an nsISupports.");
  static bool Enabled(JSContext* aCx, JSObject* aGlobal)
  {
    return NS_IsMainThread() && IsChromeOrXBL(aCx, aGlobal);
  }
};

void
GetInterfaceImpl(JSContext* aCx, nsIInterfaceRequestor* aRequestor,
                 nsWrapperCache* aCache, nsIJSID* aIID,
                 JS::MutableHandle<JS::Value> aRetval, ErrorResult& aError);

template<class T>
void
GetInterface(JSContext* aCx, T* aThis, nsIJSID* aIID,
             JS::MutableHandle<JS::Value> aRetval, ErrorResult& aError)
{
  GetInterfaceImpl(aCx, aThis, aThis, aIID, aRetval, aError);
}

bool
ThrowingConstructor(JSContext* cx, unsigned argc, JS::Value* vp);

bool
ThrowConstructorWithoutNew(JSContext* cx, const char* name);

bool
GetPropertyOnPrototype(JSContext* cx, JS::Handle<JSObject*> proxy,
                       JS::Handle<JS::Value> receiver, JS::Handle<jsid> id,
                       bool* found, JS::MutableHandle<JS::Value> vp);


bool
HasPropertyOnPrototype(JSContext* cx, JS::Handle<JSObject*> proxy,
                       JS::Handle<jsid> id, bool* has);






bool
AppendNamedPropertyIds(JSContext* cx, JS::Handle<JSObject*> proxy,
                       nsTArray<nsString>& names,
                       bool shadowPrototypeProperties, JS::AutoIdVector& props);

enum StringificationBehavior {
  eStringify,
  eEmpty,
  eNull
};

template<typename T>
static inline bool
ConvertJSValueToString(JSContext* cx, JS::Handle<JS::Value> v,
                       StringificationBehavior nullBehavior,
                       StringificationBehavior undefinedBehavior,
                       T& result)
{
  JSString *s;
  if (v.isString()) {
    s = v.toString();
  } else {
    StringificationBehavior behavior;
    if (v.isNull()) {
      behavior = nullBehavior;
    } else if (v.isUndefined()) {
      behavior = undefinedBehavior;
    } else {
      behavior = eStringify;
    }

    if (behavior != eStringify) {
      if (behavior == eEmpty) {
        result.Truncate();
      } else {
        result.SetIsVoid(true);
      }
      return true;
    }

    s = JS::ToString(cx, v);
    if (!s) {
      return false;
    }
  }

  return AssignJSString(cx, result, s);
}

template<typename T>
static inline bool
ConvertJSValueToString(JSContext* cx, JS::Handle<JS::Value> v, T& result)
{
  return ConvertJSValueToString(cx, v, eStringify, eStringify, result);
}

void
NormalizeUSVString(nsAString& aString);

void
NormalizeUSVString(binding_detail::FakeString& aString);

template<typename T>
static inline bool
ConvertJSValueToUSVString(JSContext* cx, JS::Handle<JS::Value> v, T& result)
{
  if (!ConvertJSValueToString(cx, v, eStringify, eStringify, result)) {
    return false;
  }

  NormalizeUSVString(result);
  return true;
}

template<typename T>
inline bool
ConvertIdToString(JSContext* cx, JS::HandleId id, T& result, bool& isSymbol)
{
  if ((__builtin_expect(!!(JSID_IS_STRING(id)), 1))) {
    if (!AssignJSString(cx, result, JSID_TO_STRING(id))) {
      return false;
    }
  } else if (JSID_IS_SYMBOL(id)) {
    isSymbol = true;
    return true;
  } else {
    JS::RootedValue nameVal(cx, js::IdToValue(id));
    if (!ConvertJSValueToString(cx, nameVal, eStringify, eStringify, result)) {
      return false;
    }
  }
  isSymbol = false;
  return true;
}

bool
ConvertJSValueToByteString(JSContext* cx, JS::Handle<JS::Value> v,
                           bool nullable, nsACString& result);

inline bool
ConvertJSValueToByteString(JSContext* cx, JS::Handle<JS::Value> v,
                           nsACString& result)
{
  return ConvertJSValueToByteString(cx, v, false, result);
}

template<typename T>
void DoTraceSequence(JSTracer* trc, FallibleTArray<T>& seq);
template<typename T>
void DoTraceSequence(JSTracer* trc, InfallibleTArray<T>& seq);



template<typename T,
         bool isDictionary=IsBaseOf<DictionaryBase, T>::value,
         bool isTypedArray=IsBaseOf<AllTypedArraysBase, T>::value,
         bool isOwningUnion=IsBaseOf<AllOwningUnionBase, T>::value>
class SequenceTracer
{
  explicit SequenceTracer() = delete;
};


template<>
class SequenceTracer<JSObject*, false, false, false>
{
  explicit SequenceTracer() = delete;

public:
  static void TraceSequence(JSTracer* trc, JSObject** objp, JSObject** end) {
    for (; objp != end; ++objp) {
      JS::UnsafeTraceRoot(trc, objp, "sequence<object>");
    }
  }
};


template<>
class SequenceTracer<JS::Value, false, false, false>
{
  explicit SequenceTracer() = delete;

public:
  static void TraceSequence(JSTracer* trc, JS::Value* valp, JS::Value* end) {
    for (; valp != end; ++valp) {
      JS::UnsafeTraceRoot(trc, valp, "sequence<any>");
    }
  }
};


template<typename T>
class SequenceTracer<Sequence<T>, false, false, false>
{
  explicit SequenceTracer() = delete;

public:
  static void TraceSequence(JSTracer* trc, Sequence<T>* seqp, Sequence<T>* end) {
    for (; seqp != end; ++seqp) {
      DoTraceSequence(trc, *seqp);
    }
  }
};


template<typename T>
class SequenceTracer<nsTArray<T>, false, false, false>
{
  explicit SequenceTracer() = delete;

public:
  static void TraceSequence(JSTracer* trc, nsTArray<T>* seqp, nsTArray<T>* end) {
    for (; seqp != end; ++seqp) {
      DoTraceSequence(trc, *seqp);
    }
  }
};


template<typename T>
class SequenceTracer<T, true, false, false>
{
  explicit SequenceTracer() = delete;

public:
  static void TraceSequence(JSTracer* trc, T* dictp, T* end) {
    for (; dictp != end; ++dictp) {
      dictp->TraceDictionary(trc);
    }
  }
};


template<typename T>
class SequenceTracer<T, false, true, false>
{
  explicit SequenceTracer() = delete;

public:
  static void TraceSequence(JSTracer* trc, T* arrayp, T* end) {
    for (; arrayp != end; ++arrayp) {
      arrayp->TraceSelf(trc);
    }
  }
};


template<typename T>
class SequenceTracer<T, false, false, true>
{
  explicit SequenceTracer() = delete;

public:
  static void TraceSequence(JSTracer* trc, T* arrayp, T* end) {
    for (; arrayp != end; ++arrayp) {
      arrayp->TraceUnion(trc);
    }
  }
};


template<typename T>
class SequenceTracer<Nullable<T>, false, false, false>
{
  explicit SequenceTracer() = delete;

public:
  static void TraceSequence(JSTracer* trc, Nullable<T>* seqp,
                            Nullable<T>* end) {
    for (; seqp != end; ++seqp) {
      if (!seqp->IsNull()) {


        T& val = seqp->Value();
        T* ptr = &val;
        SequenceTracer<T>::TraceSequence(trc, ptr, ptr+1);
      }
    }
  }
};

template<typename K, typename V>
void TraceRecord(JSTracer* trc, Record<K, V>& record)
{
  for (auto& entry : record.Entries()) {

    SequenceTracer<V>::TraceSequence(trc, &entry.mValue, &entry.mValue + 1);
  }
}


template<typename K, typename V>
class SequenceTracer<Record<K, V>, false, false, false>
{
  explicit SequenceTracer() = delete;

public:
  static void TraceSequence(JSTracer* trc, Record<K, V>* seqp,
                            Record<K, V>* end) {
    for (; seqp != end; ++seqp) {
      TraceRecord(trc, *seqp);
    }
  }
};

template<typename T>
void DoTraceSequence(JSTracer* trc, FallibleTArray<T>& seq)
{
  SequenceTracer<T>::TraceSequence(trc, seq.Elements(),
                                   seq.Elements() + seq.Length());
}

template<typename T>
void DoTraceSequence(JSTracer* trc, InfallibleTArray<T>& seq)
{
  SequenceTracer<T>::TraceSequence(trc, seq.Elements(),
                                   seq.Elements() + seq.Length());
}


template<typename T>
class SequenceRooter final : private JS::CustomAutoRooter
{
public:
  SequenceRooter(JSContext *aCx, FallibleTArray<T>* aSequence
                                                )
    : JS::CustomAutoRooter(aCx ),
      mFallibleArray(aSequence),
      mSequenceType(eFallibleArray)
  {
  }

  SequenceRooter(JSContext *aCx, InfallibleTArray<T>* aSequence
                                                )
    : JS::CustomAutoRooter(aCx ),
      mInfallibleArray(aSequence),
      mSequenceType(eInfallibleArray)
  {
  }

  SequenceRooter(JSContext *aCx, Nullable<nsTArray<T> >* aSequence
                                                )
    : JS::CustomAutoRooter(aCx ),
      mNullableArray(aSequence),
      mSequenceType(eNullableArray)
  {
  }

 private:
  enum SequenceType {
    eInfallibleArray,
    eFallibleArray,
    eNullableArray
  };

  virtual void trace(JSTracer *trc) override
  {
    if (mSequenceType == eFallibleArray) {
      DoTraceSequence(trc, *mFallibleArray);
    } else if (mSequenceType == eInfallibleArray) {
      DoTraceSequence(trc, *mInfallibleArray);
    } else {
      do { } while (0);
      if (!mNullableArray->IsNull()) {
        DoTraceSequence(trc, mNullableArray->Value());
      }
    }
  }

  union {
    InfallibleTArray<T>* mInfallibleArray;
    FallibleTArray<T>* mFallibleArray;
    Nullable<nsTArray<T> >* mNullableArray;
  };

  SequenceType mSequenceType;
};


template<typename K, typename V>
class RecordRooter final : private JS::CustomAutoRooter
{
public:
  RecordRooter(JSContext *aCx, Record<K, V>* aRecord
                                              )
    : JS::CustomAutoRooter(aCx ),
      mRecord(aRecord),
      mRecordType(eRecord)
  {
  }

  RecordRooter(JSContext *aCx, Nullable<Record<K, V>>* aRecord
                                                )
    : JS::CustomAutoRooter(aCx ),
      mNullableRecord(aRecord),
      mRecordType(eNullableRecord)
  {
  }

private:
  enum RecordType {
    eRecord,
    eNullableRecord
  };

  virtual void trace(JSTracer *trc) override
  {
    if (mRecordType == eRecord) {
      TraceRecord(trc, *mRecord);
    } else {
      do { } while (0);
      if (!mNullableRecord->IsNull()) {
        TraceRecord(trc, mNullableRecord->Value());
      }
    }
  }

  union {
    Record<K, V>* mRecord;
    Nullable<Record<K, V>>* mNullableRecord;
  };

  RecordType mRecordType;
};

template<typename T>
class RootedUnion : public T,
                             private JS::CustomAutoRooter
{
public:
  explicit RootedUnion(JSContext* cx ) :
    T(),
    JS::CustomAutoRooter(cx )
  {
  }

  virtual void trace(JSTracer *trc) override
  {
    this->TraceUnion(trc);
  }
};

template<typename T>
class NullableRootedUnion : public Nullable<T>,
                                            private JS::CustomAutoRooter
{
public:
  explicit NullableRootedUnion(JSContext* cx ) :
    Nullable<T>(),
    JS::CustomAutoRooter(cx )
  {
  }

  virtual void trace(JSTracer *trc) override
  {
    if (!this->IsNull()) {
      this->Value().TraceUnion(trc);
    }
  }
};

inline bool
IdEquals(jsid id, const char* string)
{
  return JSID_IS_STRING(id) &&
         JS_FlatStringEqualsAscii(JSID_TO_FLAT_STRING(id), string);
}

inline bool
AddStringToIDVector(JSContext* cx, JS::AutoIdVector& vector, const char* name)
{
  return vector.growBy(1) &&
         AtomizeAndPinJSString(cx, *(vector[vector.length() - 1]).address(), name);
}
enum {
  CONSTRUCTOR_NATIVE_HOLDER_RESERVED_SLOT = 0
};

bool
Constructor(JSContext* cx, unsigned argc, JS::Value* vp);
bool
XrayResolveOwnProperty(JSContext* cx, JS::Handle<JSObject*> wrapper,
                       JS::Handle<JSObject*> obj,
                       JS::Handle<jsid> id,
                       JS::MutableHandle<JS::PropertyDescriptor> desc,
                       bool& cacheOnHolder);
bool
XrayDefineProperty(JSContext* cx, JS::Handle<JSObject*> wrapper,
                   JS::Handle<JSObject*> obj, JS::Handle<jsid> id,
                   JS::Handle<JS::PropertyDescriptor> desc,
                   JS::ObjectOpResult &result,
                   bool *defined);
bool
XrayOwnPropertyKeys(JSContext* cx, JS::Handle<JSObject*> wrapper,
                    JS::Handle<JSObject*> obj,
                    unsigned flags, JS::AutoIdVector& props);
inline bool
XrayGetNativeProto(JSContext* cx, JS::Handle<JSObject*> obj,
                   JS::MutableHandle<JSObject*> protop)
{
  JS::Rooted<JSObject*> global(cx, js::GetGlobalForObjectCrossCompartment(obj));
  {
    JSAutoCompartment ac(cx, global);
    const DOMJSClass* domClass = GetDOMClass(obj);
    if (domClass) {
      ProtoHandleGetter protoGetter = domClass->mGetProto;
      if (protoGetter) {
        protop.set(protoGetter(cx));
      } else {
        protop.set(JS::GetRealmObjectPrototype(cx));
      }
    } else if (JS_ObjectIsFunction(cx, obj)) {
      do { } while (0);
      protop.set(JS::GetRealmFunctionPrototype(cx));
    } else {
      const js::Class* clasp = js::GetObjectClass(obj);
      do { } while (0);
      ProtoGetter protoGetter =
        DOMIfaceAndProtoJSClass::FromJSClass(clasp)->mGetParentProto;
      protop.set(protoGetter(cx));
    }
  }

  return JS_WrapObject(cx, protop);
}




const JSClass*
XrayGetExpandoClass(JSContext* cx, JS::Handle<JSObject*> obj);
bool
XrayDeleteNamedProperty(JSContext* cx, JS::Handle<JSObject*> wrapper,
                        JS::Handle<JSObject*> obj, JS::Handle<jsid> id,
                        JS::ObjectOpResult& opresult);
JSObject*
GetCachedSlotStorageObjectSlow(JSContext* cx, JS::Handle<JSObject*> obj,
                               bool* isXray);

inline JSObject*
GetCachedSlotStorageObject(JSContext* cx, JS::Handle<JSObject*> obj,
                           bool* isXray) {
  if (IsDOMObject(obj)) {
    *isXray = false;
    return obj;
  }

  return GetCachedSlotStorageObjectSlow(cx, obj, isXray);
}

extern NativePropertyHooks sEmptyNativePropertyHooks;

extern const js::ClassOps sBoringInterfaceObjectClassClassOps;

extern const js::ObjectOps sInterfaceObjectClassObjectOps;

inline bool
UseDOMXray(JSObject* obj)
{
  const js::Class* clasp = js::GetObjectClass(obj);
  return IsDOMClass(clasp) ||
         JS_IsNativeFunction(obj, Constructor) ||
         IsDOMIfaceAndProtoClass(clasp);
}
template<typename T>
const T& Constify(T& arg)
{
  return arg;
}


template<typename T>
T& NonNullHelper(T& aArg)
{
  return aArg;
}

template<typename T>
T& NonNullHelper(NonNull<T>& aArg)
{
  return aArg;
}

template<typename T>
const T& NonNullHelper(const NonNull<T>& aArg)
{
  return aArg;
}

template<typename T>
T& NonNullHelper(OwningNonNull<T>& aArg)
{
  return aArg;
}

template<typename T>
const T& NonNullHelper(const OwningNonNull<T>& aArg)
{
  return aArg;
}

inline
void NonNullHelper(NonNull<binding_detail::FakeString>& aArg)
{




}

inline
void NonNullHelper(const NonNull<binding_detail::FakeString>& aArg)
{




}

inline
void NonNullHelper(binding_detail::FakeString& aArg)
{




}

__attribute__((always_inline)) inline
const nsAString& NonNullHelper(const binding_detail::FakeString& aArg)
{
  return aArg;
}



nsresult
ReparentWrapper(JSContext* aCx, JS::Handle<JSObject*> aObj);




bool
InterfaceHasInstance(JSContext* cx, unsigned argc, JS::Value* vp);

bool
InterfaceHasInstance(JSContext* cx, int prototypeID, int depth,
                     JS::Handle<JSObject*> instance,
                     bool* bp);



bool
ReportLenientThisUnwrappingFailure(JSContext* cx, JSObject* obj);




bool
GetContentGlobalForJSImplementedObject(JSContext* cx, JS::Handle<JSObject*> obj,
                                       nsIGlobalObject** global);

void
ConstructJSImplementation(const char* aContractId,
                          nsIGlobalObject* aGlobal,
                          JS::MutableHandle<JSObject*> aObject,
                          ErrorResult& aRv);

already_AddRefed<nsIGlobalObject>
ConstructJSImplementation(const char* aContractId,
                          const GlobalObject& aGlobal,
                          JS::MutableHandle<JSObject*> aObject,
                          ErrorResult& aRv);







bool NonVoidByteStringToJsval(JSContext *cx, const nsACString &str,
                              JS::MutableHandle<JS::Value> rval);
inline bool ByteStringToJsval(JSContext *cx, const nsACString &str,
                              JS::MutableHandle<JS::Value> rval)
{
    if (str.IsVoid()) {
        rval.setNull();
        return true;
    }
    return NonVoidByteStringToJsval(cx, str, rval);
}

template<class T, bool isISupports=IsBaseOf<nsISupports, T>::value>
struct PreserveWrapperHelper
{
  static void PreserveWrapper(T* aObject)
  {
    aObject->PreserveWrapper(aObject, T::cycleCollection::GetParticipant());
  }
};

template<class T>
struct PreserveWrapperHelper<T, true>
{
  static void PreserveWrapper(T* aObject)
  {
    aObject->PreserveWrapper(reinterpret_cast<nsISupports*>(aObject));
  }
};

template<class T>
void PreserveWrapper(T* aObject)
{
  PreserveWrapperHelper<T>::PreserveWrapper(aObject);
}

template<class T, bool isISupports=IsBaseOf<nsISupports, T>::value>
struct CastingAssertions
{
  static bool ToSupportsIsCorrect(T*)
  {
    return true;
  }
  static bool ToSupportsIsOnPrimaryInheritanceChain(T*, nsWrapperCache*)
  {
    return true;
  }
};

template<class T>
struct CastingAssertions<T, true>
{
  static bool ToSupportsIsCorrect(T* aObject)
  {
    return ToSupports(aObject) == reinterpret_cast<nsISupports*>(aObject);
  }
  static bool ToSupportsIsOnPrimaryInheritanceChain(T* aObject,
                                                    nsWrapperCache* aCache)
  {
    return reinterpret_cast<void*>(aObject) != aCache;
  }
};

template<class T>
bool
ToSupportsIsCorrect(T* aObject)
{
  return CastingAssertions<T>::ToSupportsIsCorrect(aObject);
}

template<class T>
bool
ToSupportsIsOnPrimaryInheritanceChain(T* aObject, nsWrapperCache* aCache)
{
  return CastingAssertions<T>::ToSupportsIsOnPrimaryInheritanceChain(aObject,
                                                                     aCache);
}
template<class T>
class BindingJSObjectCreator
{
public:
  explicit BindingJSObjectCreator(JSContext* aCx)
    : mReflector(aCx)
  {
  }

  ~BindingJSObjectCreator()
  {
    if (mReflector) {
      js::SetReservedOrProxyPrivateSlot(mReflector, 0,
                                        JS::UndefinedValue());
    }
  }

  void
  CreateProxyObject(JSContext* aCx, const js::Class* aClass,
                    const DOMProxyHandler* aHandler,
                    JS::Handle<JSObject*> aProto, T* aNative,
                    JS::MutableHandle<JSObject*> aReflector)
  {
    js::ProxyOptions options;
    options.setClass(aClass);
    JS::Rooted<JS::Value> proxyPrivateVal(aCx, JS::PrivateValue(aNative));
    aReflector.set(js::NewProxyObject(aCx, aHandler, proxyPrivateVal, aProto,
                                      options));
    if (aReflector) {
      mNative = aNative;
      mReflector = aReflector;
    }
  }

  void
  CreateObject(JSContext* aCx, const JSClass* aClass,
               JS::Handle<JSObject*> aProto,
               T* aNative, JS::MutableHandle<JSObject*> aReflector)
  {
    aReflector.set(JS_NewObjectWithGivenProto(aCx, aClass, aProto));
    if (aReflector) {
      js::SetReservedSlot(aReflector, 0, JS::PrivateValue(aNative));
      mNative = aNative;
      mReflector = aReflector;
    }
  }

  void
  InitializationSucceeded()
  {
    void* dummy;
    mNative.forget(&dummy);
    mReflector = nullptr;
  }

private:
  struct OwnedNative
  {


    static_assert(IsBaseOf<NonRefcountedDOMObject, T>::value,
                  "Non-refcounted objects with DOM bindings should inherit "
                  "from NonRefcountedDOMObject.");

    OwnedNative&
    operator=(T* aNative)
    {
      return *this;
    }



    void
    forget(void**)
    {
    }
  };

  JS::Rooted<JSObject*> mReflector;
  typename Conditional<IsRefcounted<T>::value, RefPtr<T>, OwnedNative>::Type mNative;
};

template<class T>
struct DeferredFinalizerImpl
{
  typedef typename Conditional<IsSame<T, nsISupports>::value,
                               nsCOMPtr<T>,
                               typename Conditional<IsRefcounted<T>::value,
                                                    RefPtr<T>,
                                                    nsAutoPtr<T>>::Type>::Type SmartPtr;
  typedef SegmentedVector<SmartPtr> SmartPtrArray;

  static_assert(IsSame<T, nsISupports>::value || !IsBaseOf<nsISupports, T>::value,
                "nsISupports classes should all use the nsISupports instantiation");

  static inline void
  AppendAndTake(SegmentedVector<nsCOMPtr<nsISupports>>& smartPtrArray, nsISupports* ptr)
  {
    smartPtrArray.InfallibleAppend(dont_AddRef(ptr));
  }
  template<class U>
  static inline void
  AppendAndTake(SegmentedVector<RefPtr<U>>& smartPtrArray, U* ptr)
  {
    smartPtrArray.InfallibleAppend(dont_AddRef(ptr));
  }
  template<class U>
  static inline void
  AppendAndTake(SegmentedVector<nsAutoPtr<U>>& smartPtrArray, U* ptr)
  {
    smartPtrArray.InfallibleAppend(ptr);
  }

  static void*
  AppendDeferredFinalizePointer(void* aData, void* aObject)
  {
    SmartPtrArray* pointers = static_cast<SmartPtrArray*>(aData);
    if (!pointers) {
      pointers = new SmartPtrArray();
    }
    AppendAndTake(*pointers, static_cast<T*>(aObject));
    return pointers;
  }
  static bool
  DeferredFinalize(uint32_t aSlice, void* aData)
  {
    do { } while (0);
    SmartPtrArray* pointers = static_cast<SmartPtrArray*>(aData);
    uint32_t oldLen = pointers->Length();
    if (oldLen < aSlice) {
      aSlice = oldLen;
    }
    uint32_t newLen = oldLen - aSlice;
    pointers->PopLastN(aSlice);
    if (newLen == 0) {
      delete pointers;
      return true;
    }
    return false;
  }
};

template<class T,
         bool isISupports=IsBaseOf<nsISupports, T>::value>
struct DeferredFinalizer
{
  static void
  AddForDeferredFinalization(T* aObject)
  {
    typedef DeferredFinalizerImpl<T> Impl;
    DeferredFinalize(Impl::AppendDeferredFinalizePointer,
                     Impl::DeferredFinalize, aObject);
  }
};

template<class T>
struct DeferredFinalizer<T, true>
{
  static void
  AddForDeferredFinalization(T* aObject)
  {
    DeferredFinalize(reinterpret_cast<nsISupports*>(aObject));
  }
};

template<class T>
static void
AddForDeferredFinalization(T* aObject)
{
  DeferredFinalizer<T>::AddForDeferredFinalization(aObject);
}




template<class T, bool isISupports=IsBaseOf<nsISupports, T>::value>
class GetCCParticipant
{

  template<class U>
  static constexpr nsCycleCollectionParticipant*
  GetHelper(int, typename U::cycleCollection* dummy=nullptr)
  {
    return T::cycleCollection::GetParticipant();
  }

  template<class U>
  static constexpr nsCycleCollectionParticipant*
  GetHelper(double)
  {
    return nullptr;
  }

public:
  static constexpr nsCycleCollectionParticipant*
  Get()
  {




    return GetHelper<T>(int());
  }
};

template<class T>
class GetCCParticipant<T, true>
{
public:
  static constexpr nsCycleCollectionParticipant*
  Get()
  {
    return nullptr;
  }
};

void
FinalizeGlobal(JSFreeOp* aFop, JSObject* aObj);

bool
ResolveGlobal(JSContext* aCx, JS::Handle<JSObject*> aObj,
              JS::Handle<jsid> aId, bool* aResolvedp);

bool
MayResolveGlobal(const JSAtomState& aNames, jsid aId, JSObject* aMaybeObj);

bool
EnumerateGlobal(JSContext* aCx, JS::Handle<JSObject*> aObj);

template <class T>
struct CreateGlobalOptions
{
  static constexpr ProtoAndIfaceCache::Kind ProtoAndIfaceCacheKind =
    ProtoAndIfaceCache::NonWindowLike;
  static void TraceGlobal(JSTracer* aTrc, JSObject* aObj)
  {
    mozilla::dom::TraceProtoAndIfaceCache(aTrc, aObj);
  }
  static bool PostCreateGlobal(JSContext* aCx, JS::Handle<JSObject*> aGlobal)
  {
    do { if ((TryPreserveWrapper(aGlobal))) { } } while (0);

    return true;
  }
};

template <>
struct CreateGlobalOptions<nsGlobalWindow>
{
  static constexpr ProtoAndIfaceCache::Kind ProtoAndIfaceCacheKind =
    ProtoAndIfaceCache::WindowLike;
  static void TraceGlobal(JSTracer* aTrc, JSObject* aObj);
  static bool PostCreateGlobal(JSContext* aCx, JS::Handle<JSObject*> aGlobal);
};

nsresult
RegisterDOMNames();
template <class T, ProtoHandleGetter GetProto>
bool
CreateGlobal(JSContext* aCx, T* aNative, nsWrapperCache* aCache,
             const JSClass* aClass, JS::CompartmentOptions& aOptions,
             JSPrincipals* aPrincipal, bool aInitStandardClasses,
             JS::MutableHandle<JSObject*> aGlobal)
{
  aOptions.creationOptions().setTrace(CreateGlobalOptions<T>::TraceGlobal);
  if (xpc::SharedMemoryEnabled()) {
    aOptions.creationOptions().setSharedMemoryAndAtomicsEnabled(true);
  }

  aGlobal.set(JS_NewGlobalObject(aCx, aClass, aPrincipal,
                                 JS::DontFireOnNewGlobalHook, aOptions));
  if (!aGlobal) {
    do { } while(0);
    return false;
  }

  JSAutoCompartment ac(aCx, aGlobal);

  {
    js::SetReservedSlot(aGlobal, 0, JS::PrivateValue(aNative));
    (aNative)->AddRef();

    aCache->SetWrapper(aGlobal);

    dom::AllocateProtoAndIfaceCache(aGlobal,
                                    CreateGlobalOptions<T>::ProtoAndIfaceCacheKind);

    if (!CreateGlobalOptions<T>::PostCreateGlobal(aCx, aGlobal)) {
      return false;
    }
  }

  if (aInitStandardClasses &&
      !JS_InitStandardClasses(aCx, aGlobal)) {
    do { } while(0);
    return false;
  }

  JS::Handle<JSObject*> proto = GetProto(aCx);
  if (!proto || !JS_SplicePrototype(aCx, aGlobal, proto)) {
    do { } while(0);
    return false;
  }

  bool succeeded;
  if (!JS_SetImmutablePrototype(aCx, aGlobal, &succeeded)) {
    return false;
  }
  do { } while (0);



  return true;
}





class PinnedStringId
{
  jsid id;

 public:
  PinnedStringId() : id(JSID_VOID) {}

  bool init(JSContext *cx, const char *string) {
    JSString* str = JS_AtomizeAndPinString(cx, string);
    if (!str)
      return false;
    id = INTERNED_STRING_TO_JSID(cx, str);
    return true;
  }

  operator const jsid& () {
    return id;
  }

  operator JS::Handle<jsid> () {

    return JS::Handle<jsid>::fromMarkedLocation(&id);
  }
};

bool
GenericBindingGetter(JSContext* cx, unsigned argc, JS::Value* vp);

bool
GenericPromiseReturningBindingGetter(JSContext* cx, unsigned argc, JS::Value* vp);

bool
GenericBindingSetter(JSContext* cx, unsigned argc, JS::Value* vp);

bool
GenericBindingMethod(JSContext* cx, unsigned argc, JS::Value* vp);

bool
GenericPromiseReturningBindingMethod(JSContext* cx, unsigned argc, JS::Value* vp);

bool
StaticMethodPromiseWrapper(JSContext* cx, unsigned argc, JS::Value* vp);
bool
ConvertExceptionToPromise(JSContext* cx,
                          JSObject* promiseScope,
                          JS::MutableHandle<JS::Value> rval);
bool
EnforceNotInPrerendering(JSContext* aCx, JSObject* aObj);




void
HandlePrerenderingViolation(nsPIDOMWindowInner* aWindow);

bool
CallerSubsumes(JSObject* aObject);

__attribute__((always_inline)) inline bool
CallerSubsumes(JS::Handle<JS::Value> aValue)
{
  if (!aValue.isObject()) {
    return true;
  }
  return CallerSubsumes(&aValue.toObject());
}

template<class T>
inline bool
WrappedJSToDictionary(JSContext* aCx, nsISupports* aObject, T& aDictionary)
{
  nsCOMPtr<nsIXPConnectWrappedJS> wrappedObj = do_QueryInterface(aObject);
  if (!wrappedObj) {
    return false;
  }

  JS::Rooted<JSObject*> obj(aCx, wrappedObj->GetJSObject());
  if (!obj) {
    return false;
  }

  JSAutoCompartment ac(aCx, obj);
  JS::Rooted<JS::Value> v(aCx, JS::ObjectValue(*obj));
  return aDictionary.Init(aCx, v);
}

template<class T>
inline bool
WrappedJSToDictionary(nsISupports* aObject, T& aDictionary)
{
  nsCOMPtr<nsIXPConnectWrappedJS> wrappedObj = do_QueryInterface(aObject);
  do { if ((__builtin_expect(!!(!(wrappedObj)), 0))) { do { } while(0); return false; } } while(0);
  JS::Rooted<JSObject*> obj(RootingCx(), wrappedObj->GetJSObject());
  do { if ((__builtin_expect(!!(!(obj)), 0))) { do { } while(0); return false; } } while(0);

  nsIGlobalObject* global = xpc::NativeGlobal(obj);
  do { if ((__builtin_expect(!!(!(global)), 0))) { do { } while(0); return false; } } while(0);



  AutoEntryScript aes(global, "WebIDL dictionary creation");

  JS::Rooted<JS::Value> v(aes.cx(), JS::ObjectValue(*obj));
  return aDictionary.Init(aes.cx(), v);
}


template<class T, class S>
inline RefPtr<T>
StrongOrRawPtr(already_AddRefed<S>&& aPtr)
{
  return aPtr.template downcast<T>();
}

template<class T,
         class ReturnType=typename Conditional<IsRefcounted<T>::value, T*,
                                               nsAutoPtr<T>>::Type>
inline ReturnType
StrongOrRawPtr(T* aPtr)
{
  return ReturnType(aPtr);
}

template<class T, template<typename> class SmartPtr, class S>
inline void
StrongOrRawPtr(SmartPtr<S>&& aPtr) = delete;

template<class T>
struct StrongPtrForMember
{
  typedef typename Conditional<IsRefcounted<T>::value,
                               RefPtr<T>, nsAutoPtr<T>>::Type Type;
};

namespace binding_detail {
inline
JSObject*
GetHackedNamespaceProtoObject(JSContext* aCx)
{
  return JS_NewPlainObject(aCx);
}
}




bool SystemGlobalResolve(JSContext* cx, JS::Handle<JSObject*> obj,
                         JS::Handle<jsid> id, bool* resolvedp);




bool SystemGlobalEnumerate(JSContext* cx, JS::Handle<JSObject*> obj);
bool ForEachHandler(JSContext* aCx, unsigned aArgc, JS::Value* aVp);






bool GetMaplikeBackingObject(JSContext* aCx, JS::Handle<JSObject*> aObj,
                             size_t aSlotIndex,
                             JS::MutableHandle<JSObject*> aBackingObj,
                             bool* aBackingObjCreated);
bool GetSetlikeBackingObject(JSContext* aCx, JS::Handle<JSObject*> aObj,
                             size_t aSlotIndex,
                             JS::MutableHandle<JSObject*> aBackingObj,
                             bool* aBackingObjCreated);



bool
GetDesiredProto(JSContext* aCx, const JS::CallArgs& aCallArgs,
                JS::MutableHandle<JSObject*> aDesiredProto);




already_AddRefed<nsGenericHTMLElement>
CreateHTMLElement(const GlobalObject& aGlobal, const JS::CallArgs& aCallArgs,
                  ErrorResult& aRv);

void
SetDocumentAndPageUseCounter(JSContext* aCx, JSObject* aObject,
                             UseCounter aUseCounter);


void
DeprecationWarning(JSContext* aCx, JSObject* aObject,
                   nsIDocument::DeprecatedOperations aOperation);

void
DeprecationWarning(const GlobalObject& aGlobal,
                   nsIDocument::DeprecatedOperations aOperation);


JSString*
InterfaceObjectToString(JSContext* aCx, JS::Handle<JSObject*> aObject,
                        unsigned );

namespace binding_detail {
JSObject* UnprivilegedJunkScopeOrWorkerGlobal();
}

}
}






namespace mozilla {
namespace dom {

class Promise;





__attribute__ ((warn_unused_result)) bool
ToJSValue(JSContext* aCx,
          const nsAString& aArgument,
          JS::MutableHandle<JS::Value> aValue);






template<typename T>
__attribute__ ((warn_unused_result))
typename EnableIf<IsSame<T, bool>::value, bool>::Type
ToJSValue(JSContext* aCx,
          T aArgument,
          JS::MutableHandle<JS::Value> aValue)
{

  do { } while (0);

  aValue.setBoolean(aArgument);
  return true;
}


inline bool
ToJSValue(JSContext* aCx,
          int32_t aArgument,
          JS::MutableHandle<JS::Value> aValue)
{

  do { } while (0);

  aValue.setInt32(aArgument);
  return true;
}

inline bool
ToJSValue(JSContext* aCx,
          uint32_t aArgument,
          JS::MutableHandle<JS::Value> aValue)
{

  do { } while (0);

  aValue.setNumber(aArgument);
  return true;
}

inline bool
ToJSValue(JSContext* aCx,
          int64_t aArgument,
          JS::MutableHandle<JS::Value> aValue)
{

  do { } while (0);

  aValue.setNumber(double(aArgument));
  return true;
}

inline bool
ToJSValue(JSContext* aCx,
          uint64_t aArgument,
          JS::MutableHandle<JS::Value> aValue)
{

  do { } while (0);

  aValue.setNumber(double(aArgument));
  return true;
}


inline bool
ToJSValue(JSContext* aCx,
          float aArgument,
          JS::MutableHandle<JS::Value> aValue)
{

  do { } while (0);

  aValue.setNumber(aArgument);
  return true;
}

inline bool
ToJSValue(JSContext* aCx,
          double aArgument,
          JS::MutableHandle<JS::Value> aValue)
{

  do { } while (0);

  aValue.setNumber(aArgument);
  return true;
}


__attribute__ ((warn_unused_result)) inline bool
ToJSValue(JSContext* aCx,
          CallbackObject& aArgument,
          JS::MutableHandle<JS::Value> aValue)
{

  do { } while (0);

  aValue.setObjectOrNull(aArgument.CallbackOrNull());

  return MaybeWrapValue(aCx, aValue);
}



template <class T>
__attribute__ ((warn_unused_result))
typename EnableIf<IsBaseOf<nsWrapperCache, T>::value, bool>::Type
ToJSValue(JSContext* aCx,
          T& aArgument,
          JS::MutableHandle<JS::Value> aValue)
{

  do { } while (0);

  do { } while (0);

  return GetOrCreateDOMReflector(aCx, aArgument, aValue);
}


template<typename T>
__attribute__ ((warn_unused_result))
typename EnableIf<IsBaseOf<AllTypedArraysBase, T>::value, bool>::Type
ToJSValue(JSContext* aCx,
          const TypedArrayCreator<T>& aArgument,
          JS::MutableHandle<JS::Value> aValue)
{

  do { } while (0);

  JSObject* obj = aArgument.Create(aCx);
  if (!obj) {
    return false;
  }
  aValue.setObject(*obj);
  return true;
}



template <class T>
__attribute__ ((warn_unused_result))
typename EnableIf<!IsBaseOf<nsWrapperCache, T>::value &&
                  !IsBaseOf<CallbackObject, T>::value &&
                  IsBaseOf<nsISupports, T>::value, bool>::Type
ToJSValue(JSContext* aCx,
          T& aArgument,
          JS::MutableHandle<JS::Value> aValue)
{

  do { } while (0);

  qsObjectHelper helper(ToSupports(&aArgument), nullptr);
  JS::Rooted<JSObject*> scope(aCx, JS::CurrentGlobalOrNull(aCx));
  return XPCOMObjectToJsval(aCx, scope, helper, nullptr, true, aValue);
}


template <typename T>
__attribute__ ((warn_unused_result)) bool
ToJSValue(JSContext* aCx,
          const nsCOMPtr<T>& aArgument,
          JS::MutableHandle<JS::Value> aValue)
{
  return ToJSValue(aCx, *aArgument.get(), aValue);
}

template <typename T>
__attribute__ ((warn_unused_result)) bool
ToJSValue(JSContext* aCx,
          const RefPtr<T>& aArgument,
          JS::MutableHandle<JS::Value> aValue)
{
  return ToJSValue(aCx, *aArgument.get(), aValue);
}

template <typename T>
__attribute__ ((warn_unused_result)) bool
ToJSValue(JSContext* aCx,
          const NonNull<T>& aArgument,
          JS::MutableHandle<JS::Value> aValue)
{
  return ToJSValue(aCx, *aArgument.get(), aValue);
}


template <class T>
__attribute__ ((warn_unused_result))
typename EnableIf<IsBaseOf<DictionaryBase, T>::value, bool>::Type
ToJSValue(JSContext* aCx,
          const T& aArgument,
          JS::MutableHandle<JS::Value> aValue)
{
  return aArgument.ToObjectInternal(aCx, aValue);
}


__attribute__ ((warn_unused_result)) inline bool
ToJSValue(JSContext* aCx, JS::Handle<JS::Value> aArgument,
          JS::MutableHandle<JS::Value> aValue)
{
  aValue.set(aArgument);
  return MaybeWrapValue(aCx, aValue);
}


__attribute__ ((warn_unused_result)) inline bool
ToJSValue(JSContext* aCx, const JS::Heap<JS::Value>& aArgument,
          JS::MutableHandle<JS::Value> aValue)
{
  aValue.set(aArgument);
  return MaybeWrapValue(aCx, aValue);
}


__attribute__ ((warn_unused_result)) inline bool
ToJSValue(JSContext* aCx, const JS::Rooted<JS::Value>& aArgument,
          JS::MutableHandle<JS::Value> aValue)
{
  aValue.set(aArgument);
  return MaybeWrapValue(aCx, aValue);
}



__attribute__ ((warn_unused_result)) inline bool
ToJSValue(JSContext* aCx, const JS::Rooted<JSObject*>& aArgument,
          JS::MutableHandle<JS::Value> aValue)
{
  aValue.setObjectOrNull(aArgument);
  return MaybeWrapObjectOrNullValue(aCx, aValue);
}



__attribute__ ((warn_unused_result)) bool
ToJSValue(JSContext* aCx,
          nsresult aArgument,
          JS::MutableHandle<JS::Value> aValue);




__attribute__ ((warn_unused_result)) bool
ToJSValue(JSContext* aCx,
          ErrorResult& aArgument,
          JS::MutableHandle<JS::Value> aValue);


template <typename T>
__attribute__ ((warn_unused_result))
typename EnableIf<IsBaseOf<AllOwningUnionBase, T>::value, bool>::Type
ToJSValue(JSContext* aCx,
          const T& aArgument,
          JS::MutableHandle<JS::Value> aValue)
{
  JS::Rooted<JSObject*> global(aCx, JS::CurrentGlobalOrNull(aCx));
  return aArgument.ToJSVal(aCx, global, aValue);
}


template <typename T>
__attribute__ ((warn_unused_result))
typename EnableIf<IsPointer<T>::value, bool>::Type
ToJSValue(JSContext* aCx,
          T aArgument,
          JS::MutableHandle<JS::Value> aValue)
{
  return ToJSValue(aCx, *aArgument, aValue);
}


__attribute__ ((warn_unused_result)) bool
ToJSValue(JSContext* aCx,
          Promise& aArgument,
          JS::MutableHandle<JS::Value> aValue);


template <typename T>
__attribute__ ((warn_unused_result)) bool
ToJSValue(JSContext* aCx,
          T* aArguments,
          size_t aLength,
          JS::MutableHandle<JS::Value> aValue)
{

  do { } while (0);

  JS::AutoValueVector v(aCx);
  if (!v.resize(aLength)) {
    return false;
  }
  for (size_t i = 0; i < aLength; ++i) {
    if (!ToJSValue(aCx, aArguments[i], v[i])) {
      return false;
    }
  }
  JSObject* arrayObj = JS_NewArrayObject(aCx, v);
  if (!arrayObj) {
    return false;
  }
  aValue.setObject(*arrayObj);
  return true;
}

template <typename T>
__attribute__ ((warn_unused_result)) bool
ToJSValue(JSContext* aCx,
          const nsTArray<T>& aArgument,
          JS::MutableHandle<JS::Value> aValue)
{
  return ToJSValue(aCx, aArgument.Elements(),
                   aArgument.Length(), aValue);
}

template <typename T>
__attribute__ ((warn_unused_result)) bool
ToJSValue(JSContext* aCx,
          const FallibleTArray<T>& aArgument,
          JS::MutableHandle<JS::Value> aValue)
{
  return ToJSValue(aCx, aArgument.Elements(),
                   aArgument.Length(), aValue);
}

template <typename T, int N>
__attribute__ ((warn_unused_result)) bool
ToJSValue(JSContext* aCx,
          const T(&aArgument)[N],
          JS::MutableHandle<JS::Value> aValue)
{
  return ToJSValue(aCx, aArgument, N, aValue);
}

}
}


class nsGlobalWindow;
struct nsGlobalWindowAtoms;
class nsPIDOMWindowOuter;

namespace mozilla {
namespace dom {

class ChromeWindow;
struct ChromeWindowAtoms;
class External;
class FrameRequestCallback;
class IdleDeadline;
class IdleRequestCallback;
struct IdleRequestOptionsAtoms;
struct NativePropertyHooks;
class OwningExternalOrWindowProxy;
class ProtoAndIfaceCache;
struct ScrollOptionsAtoms;
struct ScrollToOptionsAtoms;

}
}

namespace mozilla {
namespace dom {

enum class ScrollBehavior : uint8_t {
  Auto,
  Instant,
  Smooth,
  EndGuard_
};

namespace ScrollBehaviorValues {
extern const EnumEntry strings[4];
}

bool
ToJSValue(JSContext* aCx, ScrollBehavior aArgument, JS::MutableHandle<JS::Value> aValue);


void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback, OwningExternalOrWindowProxy& aUnion, const char* aName, uint32_t aFlags = 0);


void
ImplCycleCollectionUnlink(OwningExternalOrWindowProxy& aUnion);


class ExternalOrWindowProxy
{
  friend class ExternalOrWindowProxyArgument;
  enum Type
  {
    eUninitialized,
    eExternal,
    eWindowProxy
  };

  union Value
  {
    UnionMember<NonNull<mozilla::dom::External> > mExternal;
    UnionMember<nsPIDOMWindowOuter* > mWindowProxy;

  };

  Type mType;
  Value mValue;

  ExternalOrWindowProxy(const ExternalOrWindowProxy&) = delete;
  ExternalOrWindowProxy& operator=(const ExternalOrWindowProxy&) = delete;
public:
  explicit inline ExternalOrWindowProxy()
    : mType(eUninitialized)
  {
  }

  inline ~ExternalOrWindowProxy()
  {
    Uninit();
  }

  inline NonNull<mozilla::dom::External>&
  RawSetAsExternal()
  {
    if (mType == eExternal) {
      return mValue.mExternal.Value();
    }
    do { } while (0);
    mType = eExternal;
    return mValue.mExternal.SetValue();
  }

  inline NonNull<mozilla::dom::External>&
  SetAsExternal()
  {
    if (mType == eExternal) {
      return mValue.mExternal.Value();
    }
    Uninit();
    mType = eExternal;
    return mValue.mExternal.SetValue();
  }

  inline bool
  IsExternal() const
  {
    return mType == eExternal;
  }

  inline NonNull<mozilla::dom::External>&
  GetAsExternal()
  {
    do { } while (0);
    return mValue.mExternal.Value();
  }

  inline mozilla::dom::External&
  GetAsExternal() const
  {
    do { } while (0);
    return mValue.mExternal.Value();
  }

  inline nsPIDOMWindowOuter*&
  RawSetAsWindowProxy()
  {
    if (mType == eWindowProxy) {
      return mValue.mWindowProxy.Value();
    }
    do { } while (0);
    mType = eWindowProxy;
    return mValue.mWindowProxy.SetValue();
  }

  inline nsPIDOMWindowOuter*&
  SetAsWindowProxy()
  {
    if (mType == eWindowProxy) {
      return mValue.mWindowProxy.Value();
    }
    Uninit();
    mType = eWindowProxy;
    return mValue.mWindowProxy.SetValue();
  }

  inline bool
  IsWindowProxy() const
  {
    return mType == eWindowProxy;
  }

  inline nsPIDOMWindowOuter*&
  GetAsWindowProxy()
  {
    do { } while (0);
    return mValue.mWindowProxy.Value();
  }

  inline nsPIDOMWindowOuter*
  GetAsWindowProxy() const
  {
    do { } while (0);
    return mValue.mWindowProxy.Value();
  }

  inline void
  Uninit()
  {
    switch (mType) {
      case eUninitialized: {
        break;
      }
      case eExternal: {
        DestroyExternal();
        break;
      }
      case eWindowProxy: {
        DestroyWindowProxy();
        break;
      }
    }
  }

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

private:
  inline void
  DestroyExternal()
  {
    do { } while (0);
    mValue.mExternal.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyWindowProxy()
  {
    do { } while (0);
    mValue.mWindowProxy.Destroy();
    mType = eUninitialized;
  }
};


class OwningExternalOrWindowProxy : public AllOwningUnionBase
{
  friend void ImplCycleCollectionUnlink(OwningExternalOrWindowProxy& aUnion);
  enum Type
  {
    eUninitialized,
    eExternal,
    eWindowProxy
  };

  union Value
  {
    UnionMember<OwningNonNull<mozilla::dom::External> > mExternal;
    UnionMember<RefPtr<nsPIDOMWindowOuter> > mWindowProxy;

  };

  Type mType;
  Value mValue;

public:
  explicit inline OwningExternalOrWindowProxy()
    : mType(eUninitialized)
  {
  }

  explicit inline OwningExternalOrWindowProxy(const OwningExternalOrWindowProxy& aOther)
    : mType(eUninitialized)
  {
    *this = aOther;
  }

  inline ~OwningExternalOrWindowProxy()
  {
    Uninit();
  }

  OwningNonNull<mozilla::dom::External>&
  RawSetAsExternal();

  OwningNonNull<mozilla::dom::External>&
  SetAsExternal();

  bool
  TrySetToExternal(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsExternal() const
  {
    return mType == eExternal;
  }

  inline OwningNonNull<mozilla::dom::External>&
  GetAsExternal()
  {
    do { } while (0);
    return mValue.mExternal.Value();
  }

  inline OwningNonNull<mozilla::dom::External> const &
  GetAsExternal() const
  {
    do { } while (0);
    return mValue.mExternal.Value();
  }

  RefPtr<nsPIDOMWindowOuter>&
  RawSetAsWindowProxy();

  RefPtr<nsPIDOMWindowOuter>&
  SetAsWindowProxy();

  bool
  TrySetToWindowProxy(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsWindowProxy() const
  {
    return mType == eWindowProxy;
  }

  inline RefPtr<nsPIDOMWindowOuter>&
  GetAsWindowProxy()
  {
    do { } while (0);
    return mValue.mWindowProxy.Value();
  }

  inline RefPtr<nsPIDOMWindowOuter> const &
  GetAsWindowProxy() const
  {
    do { } while (0);
    return mValue.mWindowProxy.Value();
  }

  void
  Uninit();

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceUnion(JSTracer* trc);

  OwningExternalOrWindowProxy&
  operator=(const OwningExternalOrWindowProxy& aOther);

private:
  void
  DestroyExternal();

  void
  DestroyWindowProxy();
};


struct IdleRequestOptions : public DictionaryBase
{
                        Optional<uint32_t> mTimeout;

  IdleRequestOptions();

  explicit inline IdleRequestOptions(const FastDictionaryInitializer& )
  {

  }

  explicit inline IdleRequestOptions(const IdleRequestOptions& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  IdleRequestOptions&
  operator=(const IdleRequestOptions& aOther);

private:
  static bool
  InitIds(JSContext* cx, IdleRequestOptionsAtoms* atomsCache);
};

namespace binding_detail {
struct FastIdleRequestOptions : public IdleRequestOptions
{
  inline FastIdleRequestOptions()
    : IdleRequestOptions(FastDictionaryInitializer())
  {

  }
};
}


struct ScrollOptions : public DictionaryBase
{
                        ScrollBehavior mBehavior;

  ScrollOptions();

  explicit inline ScrollOptions(const FastDictionaryInitializer& )
  {

  }

  explicit inline ScrollOptions(const ScrollOptions& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  ScrollOptions&
  operator=(const ScrollOptions& aOther);

private:
  static bool
  InitIds(JSContext* cx, ScrollOptionsAtoms* atomsCache);
};

namespace binding_detail {
struct FastScrollOptions : public ScrollOptions
{
  inline FastScrollOptions()
    : ScrollOptions(FastDictionaryInitializer())
  {

  }
};
}


struct ScrollToOptions : public ScrollOptions
{
                        Optional<double> mLeft;
                        Optional<double> mTop;

  ScrollToOptions();

  explicit inline ScrollToOptions(const FastDictionaryInitializer& )
    : ScrollOptions(FastDictionaryInitializer())
  {

  }

  explicit inline ScrollToOptions(const ScrollToOptions& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  ScrollToOptions&
  operator=(const ScrollToOptions& aOther);

private:
  static bool
  InitIds(JSContext* cx, ScrollToOptionsAtoms* atomsCache);
};

namespace binding_detail {
struct FastScrollToOptions : public ScrollToOptions
{
  inline FastScrollToOptions()
    : ScrollToOptions(FastDictionaryInitializer())
  {

  }
};
}


class FrameRequestCallback : public CallbackFunction
{
public:
  explicit inline FrameRequestCallback(JSContext* aCx, JS::Handle<JSObject*> aCallback, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aIncumbentGlobal)
  {
    do { } while (0);
  }

  explicit inline FrameRequestCallback(JS::Handle<JSObject*> aCallback, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, FastCallbackConstructor())
  {
    do { } while (0);
  }

  explicit inline FrameRequestCallback(JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aAsyncStack, aIncumbentGlobal)
  {
    do { } while (0);
  }

  explicit inline FrameRequestCallback(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline void
  Call(const T& thisVal, double time, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JSCompartment* aCompartment = nullptr)
  {
    do { } while (0);
    if (!aExecutionReason) {
      aExecutionReason = "FrameRequestCallback";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aCompartment);
    if (!s.GetContext()) {
      do { } while (0);
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetContext(), thisValJS, time, aRv);
  }

  inline void
  Call(double time, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JSCompartment* aCompartment = nullptr)
  {
    do { } while (0);
    if (!aExecutionReason) {
      aExecutionReason = "FrameRequestCallback";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aCompartment);
    if (!s.GetContext()) {
      do { } while (0);
      return;
    }
    return Call(s.GetContext(), JS::UndefinedHandleValue, time, aRv);
  }

  template <typename T>
  inline void
  Call(const T& thisVal, double time, const char* aExecutionReason = nullptr)
  {
    IgnoredErrorResult rv;
    return Call(thisVal, time, rv, aExecutionReason);
  }

  inline void
  Call(double time, const char* aExecutionReason = nullptr)
  {
    IgnoredErrorResult rv;
    return Call(time, rv, aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const FrameRequestCallback& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  void Call(JSContext* cx, JS::Handle<JS::Value> aThisVal, double time, ErrorResult& aRv);
};


class IdleRequestCallback : public CallbackFunction
{
public:
  explicit inline IdleRequestCallback(JSContext* aCx, JS::Handle<JSObject*> aCallback, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aIncumbentGlobal)
  {
    do { } while (0);
  }

  explicit inline IdleRequestCallback(JS::Handle<JSObject*> aCallback, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, FastCallbackConstructor())
  {
    do { } while (0);
  }

  explicit inline IdleRequestCallback(JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aAsyncStack, aIncumbentGlobal)
  {
    do { } while (0);
  }

  explicit inline IdleRequestCallback(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline void
  Call(const T& thisVal, IdleDeadline& deadline, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JSCompartment* aCompartment = nullptr)
  {
    do { } while (0);
    if (!aExecutionReason) {
      aExecutionReason = "IdleRequestCallback";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aCompartment);
    if (!s.GetContext()) {
      do { } while (0);
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetContext(), thisValJS, deadline, aRv);
  }

  inline void
  Call(IdleDeadline& deadline, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JSCompartment* aCompartment = nullptr)
  {
    do { } while (0);
    if (!aExecutionReason) {
      aExecutionReason = "IdleRequestCallback";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aCompartment);
    if (!s.GetContext()) {
      do { } while (0);
      return;
    }
    return Call(s.GetContext(), JS::UndefinedHandleValue, deadline, aRv);
  }

  template <typename T>
  inline void
  Call(const T& thisVal, IdleDeadline& deadline, const char* aExecutionReason = nullptr)
  {
    IgnoredErrorResult rv;
    return Call(thisVal, deadline, rv, aExecutionReason);
  }

  inline void
  Call(IdleDeadline& deadline, const char* aExecutionReason = nullptr)
  {
    IgnoredErrorResult rv;
    return Call(deadline, rv, aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const IdleRequestCallback& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  void Call(JSContext* cx, JS::Handle<JS::Value> aThisVal, IdleDeadline& deadline, ErrorResult& aRv);
};


namespace binding_detail {
class FastFrameRequestCallback : public FrameRequestCallback
{
public:
  explicit inline FastFrameRequestCallback(JS::Handle<JSObject*> aCallback)
    : FrameRequestCallback(aCallback, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    FrameRequestCallback::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    FrameRequestCallback::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
}


namespace binding_detail {
class FastIdleRequestCallback : public IdleRequestCallback
{
public:
  explicit inline FastIdleRequestCallback(JS::Handle<JSObject*> aCallback)
    : IdleRequestCallback(aCallback, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    IdleRequestCallback::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    IdleRequestCallback::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
}


namespace ChromeWindowBinding {

  typedef mozilla::dom::ChromeWindow NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true);

  JSObject*
  GetConstructorObject(JSContext* aCx);

}



namespace WindowBinding {

  typedef nsGlobalWindow NativeType;

  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, nsGlobalWindow* aObject, nsWrapperCache* aCache, JS::CompartmentOptions& aOptions, JSPrincipals* aPrincipal, bool aInitStandardClasses, JS::MutableHandle<JSObject*> aReflector);
  extern const NativePropertyHooks sNativePropertyHooks[];

  bool
  ClearCachedDocumentValue(JSContext* aCx, nsGlobalWindow* aObject);

  bool
  ClearCachedPerformanceValue(JSContext* aCx, nsGlobalWindow* aObject);

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetProtoObjectHandle(JSContext* aCx);

  JS::Handle<JSObject*>
  GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true);

  JSObject*
  GetConstructorObject(JSContext* aCx);

  inline bool IsPermitted(JSFlatString* prop, char16_t propFirstChar, bool set)
  {
    switch (propFirstChar) {
      case 'b': {
        if (!set && JS_FlatStringEqualsAscii(prop, "blur")) {
          return true;
        }
        break;
      }
      case 'c': {
        if (!set && JS_FlatStringEqualsAscii(prop, "close")) {
          return true;
        }
        if (!set && JS_FlatStringEqualsAscii(prop, "closed")) {
          return true;
        }
        break;
      }
      case 'f': {
        if (!set && JS_FlatStringEqualsAscii(prop, "focus")) {
          return true;
        }
        if (!set && JS_FlatStringEqualsAscii(prop, "frames")) {
          return true;
        }
        break;
      }
      case 'l': {
        if (!set && JS_FlatStringEqualsAscii(prop, "length")) {
          return true;
        }
        if (JS_FlatStringEqualsAscii(prop, "location")) {
          return true;
        }
        break;
      }
      case 'o': {
        if (!set && JS_FlatStringEqualsAscii(prop, "opener")) {
          return true;
        }
        break;
      }
      case 'p': {
        if (!set && JS_FlatStringEqualsAscii(prop, "parent")) {
          return true;
        }
        if (!set && JS_FlatStringEqualsAscii(prop, "postMessage")) {
          return true;
        }
        break;
      }
      case 's': {
        if (!set && JS_FlatStringEqualsAscii(prop, "self")) {
          return true;
        }
        break;
      }
      case 't': {
        if (!set && JS_FlatStringEqualsAscii(prop, "top")) {
          return true;
        }
        break;
      }
      case 'w': {
        if (!set && JS_FlatStringEqualsAscii(prop, "window")) {
          return true;
        }
        break;
      }
    }

    return false;
  }

}



}
}


struct nsStyleDisplay;

namespace mozilla {

struct ScrollbarStyles
{


  uint8_t mHorizontal;
  uint8_t mVertical;


  uint8_t mScrollBehavior;


  uint8_t mScrollSnapTypeX;
  uint8_t mScrollSnapTypeY;
  nsStyleCoord mScrollSnapPointsX;
  nsStyleCoord mScrollSnapPointsY;
  nsStyleCoord::CalcValue mScrollSnapDestinationX;
  nsStyleCoord::CalcValue mScrollSnapDestinationY;

  ScrollbarStyles(uint8_t aH, uint8_t aV)
    : mHorizontal(aH), mVertical(aV),
      mScrollBehavior(0),
      mScrollSnapTypeX(0),
      mScrollSnapTypeY(0),
      mScrollSnapPointsX(nsStyleCoord(eStyleUnit_None)),
      mScrollSnapPointsY(nsStyleCoord(eStyleUnit_None)) {

    mScrollSnapDestinationX.mPercent = 0;
    mScrollSnapDestinationX.mLength = nscoord(0.0f);
    mScrollSnapDestinationX.mHasPercent = false;
    mScrollSnapDestinationY.mPercent = 0;
    mScrollSnapDestinationY.mLength = nscoord(0.0f);
    mScrollSnapDestinationY.mHasPercent = false;
  }

  explicit ScrollbarStyles(const nsStyleDisplay* aDisplay);
  ScrollbarStyles(uint8_t aH, uint8_t aV, const nsStyleDisplay* aDisplay);
  ScrollbarStyles() {}
  bool operator==(const ScrollbarStyles& aStyles) const {
    return aStyles.mHorizontal == mHorizontal && aStyles.mVertical == mVertical &&
           aStyles.mScrollBehavior == mScrollBehavior &&
           aStyles.mScrollSnapTypeX == mScrollSnapTypeX &&
           aStyles.mScrollSnapTypeY == mScrollSnapTypeY &&
           aStyles.mScrollSnapPointsX == mScrollSnapPointsX &&
           aStyles.mScrollSnapPointsY == mScrollSnapPointsY &&
           aStyles.mScrollSnapDestinationX == mScrollSnapDestinationX &&
           aStyles.mScrollSnapDestinationY == mScrollSnapDestinationY;
  }
  bool operator!=(const ScrollbarStyles& aStyles) const {
    return !(*this == aStyles);
  }
  bool IsHiddenInBothDirections() const {
    return mHorizontal == 1 &&
           mVertical == 1;
  }
  bool IsSmoothScroll(dom::ScrollBehavior aBehavior) const {
    return aBehavior == dom::ScrollBehavior::Smooth ||
             (aBehavior == dom::ScrollBehavior::Auto &&
               mScrollBehavior == 1);
  }
};

}
class mozIDOMWindowProxy;

class nsIDocShell;

class nsIContent;

class nsIFrameLoader;

class nsIPrincipal;
class nsIMessageListener : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult ReceiveMessage(void) = 0;

};

  template<typename T> struct nsIMessageListener::COMTypeInfo<nsIMessageListener, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIMessageListener::COMTypeInfo<nsIMessageListener, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x2b44eb57, 0xa9c6, 0x4773, { 0x9a, 0x1e, 0xfe, 0x08, 0x18, 0x73, 0x9a, 0x4c }};
class nsIMessageListenerManager : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult AddMessageListener(const nsAString & messageName, nsIMessageListener *listener, bool listenWhenClosed) = 0;


  virtual nsresult RemoveMessageListener(const nsAString & messageName, nsIMessageListener *listener) = 0;


  virtual nsresult AddWeakMessageListener(const nsAString & messageName, nsIMessageListener *listener) = 0;


  virtual nsresult RemoveWeakMessageListener(const nsAString & messageName, nsIMessageListener *listener) = 0;


  virtual bool MarkForCC(void) = 0;

};

  template<typename T> struct nsIMessageListenerManager::COMTypeInfo<nsIMessageListenerManager, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIMessageListenerManager::COMTypeInfo<nsIMessageListenerManager, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xb949bfec, 0xbb7d, 0x47bc, { 0xb3, 0x87, 0xac, 0x6a, 0x9b, 0x65, 0x50, 0x72 }};
class nsIMessageSender : public nsIMessageListenerManager {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult SendAsyncMessage(const nsAString & messageName, JS::HandleValue obj, JS::HandleValue objects, nsIPrincipal *principal, JS::HandleValue transfers, JSContext* cx, uint8_t _argc) = 0;


  virtual nsresult GetProcessMessageManager(nsIMessageSender * *aProcessMessageManager) = 0;

};

  template<typename T> struct nsIMessageSender::COMTypeInfo<nsIMessageSender, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIMessageSender::COMTypeInfo<nsIMessageSender, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xbb5d79e4, 0xe73c, 0x45e7, { 0x96, 0x51, 0x4d, 0x71, 0x8f, 0x4b, 0x99, 0x4c }};
class nsIMessageBroadcaster : public nsIMessageListenerManager {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult BroadcastAsyncMessage(const nsAString & messageName, JS::HandleValue obj, JS::HandleValue objects, JSContext* cx, uint8_t _argc) = 0;


  virtual nsresult GetChildCount(uint32_t *aChildCount) = 0;


  virtual nsresult GetChildAt(uint32_t aIndex, nsIMessageListenerManager * *_retval) = 0;


  virtual nsresult ReleaseCachedProcesses(void) = 0;

};

  template<typename T> struct nsIMessageBroadcaster::COMTypeInfo<nsIMessageBroadcaster, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIMessageBroadcaster::COMTypeInfo<nsIMessageBroadcaster, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x4d7d62ad, 0x4725, 0x4f39, { 0x86, 0xcf, 0x8f, 0xb2, 0x2b, 0xf9, 0xc1, 0xd8 }};
class nsISyncMessageSender : public nsIMessageSender {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult SendSyncMessage(const nsAString & messageName, JS::HandleValue obj, JS::HandleValue objects, nsIPrincipal *principal, JSContext* cx, uint8_t _argc, JS::MutableHandleValue _retval) = 0;


  virtual nsresult SendRpcMessage(const nsAString & messageName, JS::HandleValue obj, JS::HandleValue objects, nsIPrincipal *principal, JSContext* cx, uint8_t _argc, JS::MutableHandleValue _retval) = 0;

};

  template<typename T> struct nsISyncMessageSender::COMTypeInfo<nsISyncMessageSender, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsISyncMessageSender::COMTypeInfo<nsISyncMessageSender, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x0e602c9e, 0x1977, 0x422a, { 0xa8, 0xe4, 0xfe, 0x0d, 0x4a, 0x4f, 0x78, 0xd0 }};
class nsIMessageManagerGlobal : public nsISyncMessageSender {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult Dump(const nsAString & aStr) = 0;


  virtual nsresult PrivateNoteIntentionalCrash(void) = 0;


  virtual nsresult Atob(const nsAString & aAsciiString, nsAString & _retval) = 0;


  virtual nsresult Btoa(const nsAString & aBase64Data, nsAString & _retval) = 0;

};

  template<typename T> struct nsIMessageManagerGlobal::COMTypeInfo<nsIMessageManagerGlobal, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIMessageManagerGlobal::COMTypeInfo<nsIMessageManagerGlobal, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x13f3555f, 0x769e, 0x44ea, { 0xb6, 0x07, 0x52, 0x39, 0x23, 0x0c, 0x31, 0x62 }};
class nsIContentFrameMessageManager : public nsIMessageManagerGlobal {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetContent(mozIDOMWindowProxy * *aContent) = 0;


  virtual nsresult GetDocShell(nsIDocShell * *aDocShell) = 0;

};

  template<typename T> struct nsIContentFrameMessageManager::COMTypeInfo<nsIContentFrameMessageManager, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIContentFrameMessageManager::COMTypeInfo<nsIContentFrameMessageManager, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x694e367c, 0xaa25, 0x4446, { 0x84, 0x99, 0x2c, 0x52, 0x7c, 0x4b, 0xd8, 0x38 }};
class nsIInProcessContentFrameMessageManager : public nsIContentFrameMessageManager {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsIContent * GetOwnerContent(void) = 0;


  virtual void CacheFrameLoader(nsIFrameLoader *aFrameLoader) = 0;

};

  template<typename T> struct nsIInProcessContentFrameMessageManager::COMTypeInfo<nsIInProcessContentFrameMessageManager, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIInProcessContentFrameMessageManager::COMTypeInfo<nsIInProcessContentFrameMessageManager, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xb39a3324, 0xb574, 0x4f85, { 0x8c, 0xdb, 0x27, 0x4d, 0x04, 0xf8, 0x07, 0xef }};
class nsIContentProcessMessageManager : public nsIMessageManagerGlobal {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetInitialProcessData(JSContext* cx, JS::MutableHandleValue aInitialProcessData) = 0;

};

  template<typename T> struct nsIContentProcessMessageManager::COMTypeInfo<nsIContentProcessMessageManager, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIContentProcessMessageManager::COMTypeInfo<nsIContentProcessMessageManager, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x6d12e467, 0x2446, 0x46db, { 0x99, 0x65, 0xe4, 0xe9, 0x3c, 0xb8, 0x7c, 0xa5 }};
class nsIFrameScriptLoader : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult LoadFrameScript(const nsAString & aURL, bool aAllowDelayedLoad, bool aRunInGlobalScope) = 0;


  virtual nsresult RemoveDelayedFrameScript(const nsAString & aURL) = 0;


  virtual nsresult GetDelayedFrameScripts(JSContext* cx, JS::MutableHandleValue _retval) = 0;

};

  template<typename T> struct nsIFrameScriptLoader::COMTypeInfo<nsIFrameScriptLoader, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIFrameScriptLoader::COMTypeInfo<nsIFrameScriptLoader, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xbf61446b, 0xba24, 0x4b1d, { 0x88, 0xc7, 0x4f, 0x94, 0x72, 0x4b, 0x9c, 0xe1 }};
class nsIProcessScriptLoader : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult LoadProcessScript(const nsAString & aURL, bool aAllowDelayedLoad) = 0;


  virtual nsresult RemoveDelayedProcessScript(const nsAString & aURL) = 0;


  virtual nsresult GetDelayedProcessScripts(JSContext* cx, JS::MutableHandleValue _retval) = 0;

};

  template<typename T> struct nsIProcessScriptLoader::COMTypeInfo<nsIProcessScriptLoader, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIProcessScriptLoader::COMTypeInfo<nsIProcessScriptLoader, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x7e1e1a20, 0xb24f, 0x11e4, { 0xab, 0x27, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66 }};
class nsIGlobalProcessScriptLoader : public nsIProcessScriptLoader {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetInitialProcessData(JSContext* cx, JS::MutableHandleValue aInitialProcessData) = 0;

};

  template<typename T> struct nsIGlobalProcessScriptLoader::COMTypeInfo<nsIGlobalProcessScriptLoader, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIGlobalProcessScriptLoader::COMTypeInfo<nsIGlobalProcessScriptLoader, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x5b390753, 0xabb3, 0x49b0, { 0xae, 0x3b, 0xb8, 0x03, 0xda, 0xb5, 0x81, 0x44 }};
namespace mozilla {
template<class T>
class AutoRestore
{
private:
  T& mLocation;
  T mValue;

public:
  explicit AutoRestore(T& aValue )
    : mLocation(aValue)
    , mValue(aValue)
  {
    do { } while (0);
  }
  ~AutoRestore()
  {
    mLocation = mValue;
  }
  T SavedValue() const
  {
    return mValue;
  }
};

}

extern "C" {
extern __attribute__((visibility("default"))) char* PR_GetEnv(const char *var);
extern __attribute__((visibility("default"))) char* PR_GetEnvSecure(const char *var);
extern __attribute__((visibility("default"))) PRStatus PR_SetEnv(const char *string);
extern __attribute__((visibility("default"))) char ** PR_DuplicateEnvironment(void);

}
class nsILanguageAtomService : public nsISupports
{
 public:
  template<typename T, typename U> struct COMTypeInfo;

  virtual nsIAtom* LookupLanguage(const nsACString &aLanguage,
                                  nsresult *aError = nullptr) = 0;
  virtual already_AddRefed<nsIAtom>
  LookupCharSet(const nsACString& aCharSet) = 0;

  virtual nsIAtom* GetLocaleLanguage() = 0;

  virtual nsIAtom* GetLanguageGroup(nsIAtom *aLanguage,
                                    nsresult *aError = nullptr) = 0;
};

template<typename T> struct nsILanguageAtomService::COMTypeInfo<nsILanguageAtomService, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsILanguageAtomService::COMTypeInfo<nsILanguageAtomService, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xcb3892a0, 0x6a76, 0x461c, { 0xb0, 0x24, 0x23, 0x0e, 0xe3, 0xe0, 0x81, 0x1a }};

namespace mozilla {

struct LangGroupFontPrefs {

  LangGroupFontPrefs()
    : mLangGroup(nullptr)
    , mMinimumFontSize(0)
    , mDefaultVariableFont(mozilla::eFamily_serif, 0)
    , mDefaultFixedFont(mozilla::eFamily_monospace, 0)
    , mDefaultSerifFont(mozilla::eFamily_serif, 0)
    , mDefaultSansSerifFont(mozilla::eFamily_sans_serif, 0)
    , mDefaultMonospaceFont(mozilla::eFamily_monospace, 0)
    , mDefaultCursiveFont(mozilla::eFamily_cursive, 0)
    , mDefaultFantasyFont(mozilla::eFamily_fantasy, 0)
  {}

  void Reset()
  {

    mNext = nullptr;


    mLangGroup = nullptr;
  }

  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const {
    size_t n = 0;
    LangGroupFontPrefs* curr = mNext;
    while (curr) {
      n += aMallocSizeOf(curr);






      curr = curr->mNext;
    }
    return n;
  }

  nsCOMPtr<nsIAtom> mLangGroup;
  nscoord mMinimumFontSize;
  nsFont mDefaultVariableFont;
  nsFont mDefaultFixedFont;
  nsFont mDefaultSerifFont;
  nsFont mDefaultSansSerifFont;
  nsFont mDefaultMonospaceFont;
  nsFont mDefaultCursiveFont;
  nsFont mDefaultFantasyFont;
  nsAutoPtr<LangGroupFontPrefs> mNext;
};







class StaticPresData
{
public:

  static void Init();
  static void Shutdown();



  static StaticPresData* Get();





  const nscoord* GetBorderWidthTable() { return mBorderWidthTable; }
  const LangGroupFontPrefs* GetFontPrefsForLangHelper(nsIAtom* aLanguage,
                                                      const LangGroupFontPrefs* aPrefs) const;
  const nsFont* GetDefaultFontHelper(uint8_t aFontID,
                                     nsIAtom* aLanguage,
                                     const LangGroupFontPrefs* aPrefs) const;





  const nsFont* GetDefaultFont(uint8_t aFontID, nsIAtom* aLanguage) const
  {
    do { } while (0);
    return GetDefaultFontHelper(aFontID, aLanguage, GetFontPrefsForLang(aLanguage));
  }
  const LangGroupFontPrefs* GetFontPrefsForLang(nsIAtom* aLanguage) const
  {
    do { } while (0);
    return GetFontPrefsForLangHelper(aLanguage, &mStaticLangGroupFontPrefs);
  }

  void ResetCachedFontPrefs() { mStaticLangGroupFontPrefs.Reset(); }

private:
  StaticPresData();
  ~StaticPresData() {}

  nsCOMPtr<nsILanguageAtomService> mLangService;
  nscoord mBorderWidthTable[3];
  LangGroupFontPrefs mStaticLangGroupFontPrefs;
};

}


class nsAString;
class nsIPrintSettings;
class nsDocShell;
class nsIDocShell;
class nsIDocument;
class nsILanguageAtomService;
class nsITheme;
class nsIContent;
class nsIFrame;
class nsFrameManager;
class nsILinkHandler;
class nsIAtom;
class nsIRunnable;
class gfxUserFontEntry;
class gfxUserFontSet;
class gfxTextPerfMetrics;
class nsPluginFrame;
class nsTransitionManager;
class nsAnimationManager;
class nsRefreshDriver;
class nsIWidget;
class nsDeviceContext;
class gfxMissingFontRecorder;

namespace mozilla {
class EffectCompositor;
class EventStateManager;
class CounterStyleManager;
class RestyleManager;
namespace layers {
class ContainerLayer;
class LayerManager;
}
namespace dom {
class Element;
}
}


enum nsPresContext_CachedBoolPrefType {
  kPresContext_UseDocumentFonts = 1,
  kPresContext_UnderlineLinks
};


enum nsPresContext_CachedIntPrefType {
  kPresContext_ScrollbarSide = 1,
  kPresContext_BidiDirection
};



const uint8_t kPresContext_DefaultVariableFont_ID = 0x00;
const uint8_t kPresContext_DefaultFixedFont_ID = 0x01;
class nsRootPresContext;




class nsPresContext : public nsIObserver,
                      public mozilla::SupportsWeakPtr<nsPresContext> {
public:
  typedef mozilla::FramePropertyTable FramePropertyTable;
  typedef mozilla::LangGroupFontPrefs LangGroupFontPrefs;
  typedef mozilla::ScrollbarStyles ScrollbarStyles;
  typedef mozilla::StaticPresData StaticPresData;

  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; virtual void DeleteCycleCollectable(void); typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:
  virtual nsresult Observe(nsISupports *aSubject, const char * aTopic, const char16_t * aData) override;
  class cycleCollection : public nsXPCOMCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = false) : nsXPCOMCycleCollectionParticipant(aSkip) {} private: public: virtual nsresult TraverseNative(void *p, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "nsPresContext"; }; virtual void DeleteCycleCollectable(void *p) override { DowncastCCParticipant<nsPresContext>(p)->DeleteCycleCollectable(); } static nsPresContext* Downcast(nsISupports* s) { return static_cast<nsPresContext*>(static_cast<nsPresContext*>(s)); } static nsISupports* Upcast(nsPresContext *p) { return static_cast<nsISupports*>(static_cast<nsPresContext*>(p)); } template<typename T> friend nsISupports* ToSupports(T* p, cycleCollection* dummy); virtual void Unlink(void *p) override; static constexpr nsXPCOMCycleCollectionParticipant* GetParticipant() { return &nsPresContext::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;


  enum nsPresContextType {
    eContext_Galley,
    eContext_PrintPreview,
    eContext_Print,
    eContext_PageLayout
  };

  nsPresContext(nsIDocument* aDocument, nsPresContextType aType);




  nsresult Init(nsDeviceContext* aDeviceContext);





  void AttachShell(nsIPresShell* aShell, mozilla::StyleBackendType aBackendType);
  void DetachShell();


  nsPresContextType Type() const { return mType; }




  nsIPresShell* PresShell() const
  {
    do { } while(0);
    return mShell;
  }

  nsIPresShell* GetPresShell() const { return mShell; }





  nsPresContext* GetParentPresContext();





  nsPresContext* GetToplevelContentDocumentPresContext();
  nsIWidget* GetNearestWidget(nsPoint* aOffset = nullptr);





  nsIWidget* GetRootWidget();






  nsRootPresContext* GetRootPresContext();

  virtual bool IsRoot() { return false; }

  nsIDocument* Document() const
  {
      do { } while(0);


      return mDocument;
  }


  mozilla::StyleSetHandle StyleSet() const { return GetPresShell()->StyleSet(); }

  nsFrameManager* FrameManager()
    { return PresShell()->FrameManager(); }

  nsCSSFrameConstructor* FrameConstructor()
    { return PresShell()->FrameConstructor(); }

  mozilla::EffectCompositor* EffectCompositor() { return mEffectCompositor; }
  nsTransitionManager* TransitionManager() { return mTransitionManager; }
  nsAnimationManager* AnimationManager() { return mAnimationManager; }

  nsRefreshDriver* RefreshDriver() { return mRefreshDriver; }

  mozilla::RestyleManager* RestyleManager() {
    do { } while (0);
    return mRestyleManager;
  }

  mozilla::CounterStyleManager* CounterStyleManager() const {
    return mCounterStyleManager;
  }
  void RebuildAllStyleData(nsChangeHint aExtraHint, nsRestyleHint aRestyleHint);




  void PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint,
                                    nsRestyleHint aRestyleHint);
  void MediaFeatureValuesChanged(nsRestyleHint aRestyleHint,
                                 nsChangeHint aChangeHint = nsChangeHint(0));





  void MediaFeatureValuesChangedAllDocuments(nsRestyleHint aRestyleHint,
                                             nsChangeHint aChangeHint = nsChangeHint(0));

  void PostMediaFeatureValuesChangedEvent();
  void HandleMediaFeatureValuesChangedEvent();
  void FlushPendingMediaFeatureValuesChanged() {
    if (mPendingMediaFeatureValuesChanged)
      MediaFeatureValuesChanged(nsRestyleHint(0));
  }






  void SizeModeChanged(nsSizeMode aSizeMode);





  nsCompatibility CompatibilityMode() const;




  void CompatibilityModeChanged();




  uint16_t ImageAnimationMode() const { return mImageAnimationMode; }
  virtual void SetImageAnimationModeExternal(uint16_t aMode);
  void SetImageAnimationModeInternal(uint16_t aMode);

  void SetImageAnimationMode(uint16_t aMode)
  { SetImageAnimationModeInternal(aMode); }
  nsIAtom* Medium() {
    if (!mIsEmulatingMedia)
      return mMedium;
    return mMediaEmulated;
  }





  void EmulateMedium(const nsAString& aMediaType);




  void StopEmulatingMedium();

  void* AllocateFromShell(size_t aSize)
  {
    if (mShell)
      return mShell->AllocateMisc(aSize);
    return nullptr;
  }

  void FreeToShell(size_t aSize, void* aFreeChunk)
  {
    do { } while(0);
    if (mShell)
      mShell->FreeMisc(aSize, aFreeChunk);
  }







  const nsFont* GetDefaultFont(uint8_t aFontID,
                               nsIAtom *aLanguage) const
  {
    nsIAtom* lang = aLanguage ? aLanguage : mLanguage.get();
    return StaticPresData::Get()->GetDefaultFontHelper(aFontID, lang,
                                                       GetFontPrefsForLang(lang));
  }



  bool GetCachedBoolPref(nsPresContext_CachedBoolPrefType aPrefType) const
  {


    switch (aPrefType) {
    case kPresContext_UseDocumentFonts:
      return mUseDocumentFonts;
    case kPresContext_UnderlineLinks:
      return mUnderlineLinks;
    default:
      do { } while(0);
    }

    return false;
  }



  int32_t GetCachedIntPref(nsPresContext_CachedIntPrefType aPrefType) const
  {


    switch (aPrefType) {
    case kPresContext_ScrollbarSide:
      return mPrefScrollbarSide;
    case kPresContext_BidiDirection:
      return mPrefBidiDirection;
    default:
      do { } while(0);
    }

    return false;
  }




  nscolor DefaultColor() const { return mDefaultColor; }
  nscolor DefaultBackgroundColor() const { return mBackgroundColor; }
  nscolor DefaultLinkColor() const { return mLinkColor; }
  nscolor DefaultActiveLinkColor() const { return mActiveLinkColor; }
  nscolor DefaultVisitedLinkColor() const { return mVisitedLinkColor; }
  nscolor FocusBackgroundColor() const { return mFocusBackgroundColor; }
  nscolor FocusTextColor() const { return mFocusTextColor; }




  nscolor BodyTextColor() const { return mBodyTextColor; }
  void SetBodyTextColor(nscolor aColor) { mBodyTextColor = aColor; }

  bool GetUseFocusColors() const { return mUseFocusColors; }
  uint8_t FocusRingWidth() const { return mFocusRingWidth; }
  bool GetFocusRingOnAnything() const { return mFocusRingOnAnything; }
  uint8_t GetFocusRingStyle() const { return mFocusRingStyle; }

  void SetContainer(nsIDocShell* aContainer);

  virtual nsISupports* GetContainerWeakExternal() const;
  nsISupports* GetContainerWeakInternal() const;

  nsISupports* GetContainerWeak() const
  { return GetContainerWeakInternal(); }





  nsIDocShell* GetDocShell() const;


  void SetLinkHandler(nsILinkHandler* aHandler) { mLinkHandler = aHandler; }
  nsILinkHandler* GetLinkHandler() { return mLinkHandler; }






  virtual void Detach();







  nsRect GetVisibleArea() const { return mVisibleArea; }





  void SetVisibleArea(const nsRect& r) {
    if (!r.IsEqualEdges(mVisibleArea)) {
      mVisibleArea = r;

      if (!IsPaginated() && HasCachedStyleData()) {
        mPendingViewportChange = true;
        PostMediaFeatureValuesChangedEvent();
      }
    }
  }





  bool IsPaginated() const { return mPaginated; }





  void SetPaginatedScrolling(bool aResult);





  bool HasPaginatedScrolling() const { return mCanPaginatedScroll; }




  nsSize GetPageSize() { return mPageSize; }
  void SetPageSize(nsSize aSize) { mPageSize = aSize; }






  bool IsRootPaginatedDocument() { return mIsRootPaginatedDocument; }
  void SetIsRootPaginatedDocument(bool aIsRootPaginatedDocument)
    { mIsRootPaginatedDocument = aIsRootPaginatedDocument; }







  float GetPageScale() { return mPageScale; }
  void SetPageScale(float aScale) { mPageScale = aScale; }
  float GetPrintPreviewScale() { return mPPScale; }
  void SetPrintPreviewScale(float aScale) { mPPScale = aScale; }

  nsDeviceContext* DeviceContext() const { return mDeviceContext; }
  mozilla::EventStateManager* EventStateManager() { return mEventManager; }
  nsIAtom* GetLanguageFromCharset() const { return mLanguage; }
  already_AddRefed<nsIAtom> GetContentLanguage() const;





  float GetSystemFontScale() const { return mSystemFontScale; }
  void SetSystemFontScale(float aFontScale) {
    do { } while (0);
    if (aFontScale == mSystemFontScale || IsPrintingOrPrintPreview()) {
      return;
    }

    mSystemFontScale = aFontScale;
    UpdateEffectiveTextZoom();
  }
  float TextZoom() const { return mTextZoom; }
  void SetTextZoom(float aZoom) {
    do { } while (0);
    if (aZoom == mTextZoom)
      return;

    mTextZoom = aZoom;
    UpdateEffectiveTextZoom();
  }

protected:
  void UpdateEffectiveTextZoom();

public:
  float EffectiveTextZoom() const { return mEffectiveTextZoom; }







  int32_t MinFontSize(nsIAtom *aLanguage) const {
    const LangGroupFontPrefs *prefs = GetFontPrefsForLang(aLanguage);
    return std::max(mBaseMinFontSize, prefs->mMinimumFontSize);
  }





  int32_t BaseMinFontSize() const {
    return mBaseMinFontSize;
  }





  void SetBaseMinFontSize(int32_t aMinFontSize) {
    if (aMinFontSize == mBaseMinFontSize)
      return;

    mBaseMinFontSize = aMinFontSize;
    if (HasCachedStyleData()) {


      MediaFeatureValuesChanged(eRestyle_ForceDescendants,
                                nsChangeHint(nsChangeHint(nsChangeHint_RepaintFrame | nsChangeHint_SyncFrameView | nsChangeHint_SchedulePaint) | nsChangeHint(nsChangeHint_NeedReflow | nsChangeHint_ReflowChangesSizeOrPosition| nsChangeHint_ClearAncestorIntrinsics | nsChangeHint_ClearDescendantIntrinsics | nsChangeHint_NeedDirtyReflow)));
    }
  }

  float GetFullZoom() { return mFullZoom; }
  void SetFullZoom(float aZoom);

  float GetOverrideDPPX() { return mOverrideDPPX; }
  void SetOverrideDPPX(float aDPPX);

  nscoord GetAutoQualityMinFontSize() {
    return DevPixelsToAppUnits(mAutoQualityMinFontSizePixelsPref);
  }
  gfxSize ScreenSizeInchesForFontInflation(bool* aChanged = nullptr);

  static int32_t AppUnitsPerCSSPixel() { return mozilla::AppUnitsPerCSSPixel(); }
  int32_t AppUnitsPerDevPixel() const;
  static int32_t AppUnitsPerCSSInch() { return mozilla::AppUnitsPerCSSInch(); }

  static nscoord CSSPixelsToAppUnits(int32_t aPixels)
  { return NSToCoordRoundWithClamp(float(aPixels) *
             float(AppUnitsPerCSSPixel())); }

  static nscoord CSSPixelsToAppUnits(float aPixels)
  { return NSToCoordRoundWithClamp(aPixels *
             float(AppUnitsPerCSSPixel())); }

  static int32_t AppUnitsToIntCSSPixels(nscoord aAppUnits)
  { return NSAppUnitsToIntPixels(aAppUnits,
             float(AppUnitsPerCSSPixel())); }

  static float AppUnitsToFloatCSSPixels(nscoord aAppUnits)
  { return NSAppUnitsToFloatPixels(aAppUnits,
             float(AppUnitsPerCSSPixel())); }

  static double AppUnitsToDoubleCSSPixels(nscoord aAppUnits)
  { return NSAppUnitsToDoublePixels(aAppUnits,
             double(AppUnitsPerCSSPixel())); }

  nscoord DevPixelsToAppUnits(int32_t aPixels) const
  { return NSIntPixelsToAppUnits(aPixels, AppUnitsPerDevPixel()); }

  int32_t AppUnitsToDevPixels(nscoord aAppUnits) const
  { return NSAppUnitsToIntPixels(aAppUnits,
             float(AppUnitsPerDevPixel())); }

  float AppUnitsToFloatDevPixels(nscoord aAppUnits)
  { return aAppUnits / float(AppUnitsPerDevPixel()); }

  int32_t CSSPixelsToDevPixels(int32_t aPixels)
  { return AppUnitsToDevPixels(CSSPixelsToAppUnits(aPixels)); }

  float CSSPixelsToDevPixels(float aPixels)
  {
    return NSAppUnitsToFloatPixels(CSSPixelsToAppUnits(aPixels),
                                   float(AppUnitsPerDevPixel()));
  }

  int32_t DevPixelsToIntCSSPixels(int32_t aPixels)
  { return AppUnitsToIntCSSPixels(DevPixelsToAppUnits(aPixels)); }

  float DevPixelsToFloatCSSPixels(int32_t aPixels)
  { return AppUnitsToFloatCSSPixels(DevPixelsToAppUnits(aPixels)); }

  mozilla::CSSToLayoutDeviceScale CSSToDevPixelScale() const
  {
    return mozilla::CSSToLayoutDeviceScale(
        float(AppUnitsPerCSSPixel()) / float(AppUnitsPerDevPixel()));
  }


  nscoord GfxUnitsToAppUnits(gfxFloat aGfxUnits) const;

  gfxFloat AppUnitsToGfxUnits(nscoord aAppUnits) const;

  gfxRect AppUnitsToGfxUnits(const nsRect& aAppRect) const
  { return gfxRect(AppUnitsToGfxUnits(aAppRect.x),
                   AppUnitsToGfxUnits(aAppRect.y),
                   AppUnitsToGfxUnits(aAppRect.width),
                   AppUnitsToGfxUnits(aAppRect.height)); }

  static nscoord CSSTwipsToAppUnits(float aTwips)
  { return NSToCoordRoundWithClamp(
      mozilla::AppUnitsPerCSSInch() * NSTwipsToUnits((aTwips), 1.0f / 72.0f)); }


  static nsMargin CSSTwipsToAppUnits(const nsIntMargin &marginInTwips)
  { return nsMargin(CSSTwipsToAppUnits(float(marginInTwips.top)),
                    CSSTwipsToAppUnits(float(marginInTwips.right)),
                    CSSTwipsToAppUnits(float(marginInTwips.bottom)),
                    CSSTwipsToAppUnits(float(marginInTwips.left))); }

  static nscoord CSSPointsToAppUnits(float aPoints)
  { return NSToCoordRound(aPoints * mozilla::AppUnitsPerCSSInch() /
                          72.0f); }

  nscoord RoundAppUnitsToNearestDevPixels(nscoord aAppUnits) const
  { return DevPixelsToAppUnits(AppUnitsToDevPixels(aAppUnits)); }
  nsIContent* UpdateViewportScrollbarStylesOverride();
  const ScrollbarStyles& GetViewportScrollbarStylesOverride()
  {
    return mViewportStyleScrollbar;
  }





  bool ElementWouldPropagateScrollbarStyles(mozilla::dom::Element* aElement);




  bool GetBackgroundImageDraw() const { return mDrawImageBackground; }
  void SetBackgroundImageDraw(bool aCanDraw)
  {
    mDrawImageBackground = aCanDraw;
  }

  bool GetBackgroundColorDraw() const { return mDrawColorBackground; }
  void SetBackgroundColorDraw(bool aCanDraw)
  {
    mDrawColorBackground = aCanDraw;
  }
  bool BidiEnabled() const { return BidiEnabledInternal(); }



  virtual bool BidiEnabledExternal() const;
  bool BidiEnabledInternal() const;






  void SetBidiEnabled() const;
  void SetVisualMode(bool aIsVisual)
  {
    mIsVisual = aIsVisual;
  }






  bool IsVisualMode() const { return mIsVisual; }

  enum class InteractionType : uint32_t {
    eClickInteraction,
    eKeyInteraction,
    eMouseMoveInteraction,
    eScrollInteraction
  };

  void RecordInteractionTime(InteractionType aType,
                             const mozilla::TimeStamp& aTimeStamp);

  void DisableInteractionTimeRecording()
  {
    mInteractionTimeEnabled = false;
  }






  void SetBidi(uint32_t aBidiOptions,
                           bool aForceRestyle = false);






  uint32_t GetBidi() const;




  void SetIsRenderingOnlySelection(bool aResult)
  {
    mIsRenderingOnlySelection = aResult;
  }

  bool IsRenderingOnlySelection() const { return mIsRenderingOnlySelection; }

  bool IsTopLevelWindowInactive();




  nsITheme* GetTheme();







  void ThemeChanged();







  void UIResolutionChanged();




  void UIResolutionChangedSync();




  void SysColorChanged();


  void SetPrintSettings(nsIPrintSettings *aPrintSettings);

  nsIPrintSettings* GetPrintSettings() { return mPrintSettings; }


  FramePropertyTable* PropertyTable() { return &mPropertyTable; }





  bool EnsureVisible();


  void CountReflows(const char * aName,
                                nsIFrame * aFrame);


  void RestyledElement() {
    ++mElementsRestyled;
  }
  void ConstructedFrame() {
    ++mFramesConstructed;
  }
  void ReflowedFrame() {
    ++mFramesReflowed;
  }

  uint64_t ElementsRestyledCount() {
    return mElementsRestyled;
  }
  uint64_t FramesConstructedCount() {
    return mFramesConstructed;
  }
  uint64_t FramesReflowedCount() {
    return mFramesReflowed;
  }





  void SetTelemetryScrollY(nscoord aScrollY)
  {
    nscoord delta = abs(aScrollY - mTelemetryScrollLastY);
    mTelemetryScrollLastY = aScrollY;

    mTelemetryScrollTotalY += delta;
    if (aScrollY > mTelemetryScrollMaxY) {
      mTelemetryScrollMaxY = aScrollY;
    }
  }
  nscoord TelemetryScrollMaxY() const
  {
    return mTelemetryScrollMaxY;
  }
  nscoord TelemetryScrollTotalY() const
  {
    return mTelemetryScrollTotalY;
  }

  static nscoord GetBorderWidthForKeyword(unsigned int aBorderWidthKeyword)
  {


    static const nscoord kBorderWidths[] = {
      CSSPixelsToAppUnits(1),
      CSSPixelsToAppUnits(3),
      CSSPixelsToAppUnits(5)
    };
    do { } while (0);

    return kBorderWidths[aBorderWidthKeyword];
  }

  gfxTextPerfMetrics *GetTextPerfMetrics() { return mTextPerf; }

  bool IsDynamic() { return (mType == eContext_PageLayout || mType == eContext_Galley); }
  bool IsScreen() { return (mMedium == nsGkAtoms::screen ||
                              mType == eContext_PageLayout ||
                              mType == eContext_PrintPreview); }
  bool IsPrintingOrPrintPreview() { return (mType == eContext_Print || mType == eContext_PrintPreview); }


  bool IsChrome() const { return mIsChrome; }
  bool IsChromeOriginImage() const { return mIsChromeOriginImage; }
  void UpdateIsChrome();


  bool HasAuthorSpecifiedRules(const nsIFrame *aFrame,
                               uint32_t ruleTypeMask) const;


  bool UseDocumentColors() const {
    do { } while (0);

    return mUseDocumentColors;
  }


  void SetPaintFlashing(bool aPaintFlashing) {
    mPaintFlashing = aPaintFlashing;
    mPaintFlashingInitialized = true;
  }



  bool GetPaintFlashing() const;

  bool SuppressingResizeReflow() const { return mSuppressResizeReflow; }

  gfxUserFontSet* GetUserFontSet(bool aFlushUserFontSet = true);




  void UserFontSetUpdated(gfxUserFontEntry* aUpdatedFont = nullptr);

  gfxMissingFontRecorder *MissingFontRecorder() { return mMissingFonts; }
  void NotifyMissingFonts();

  void FlushCounterStyles();
  void RebuildCounterStyles();




  void EnsureSafeToHandOutCSSRules();





  void NotifyInvalidation(uint64_t aTransactionId, const nsRect& aRect);

  void NotifyInvalidation(uint64_t aTransactionId, const nsIntRect& aRect);
  void NotifyDidPaintForSubtree(uint64_t aTransactionId = 0,
                                const mozilla::TimeStamp& aTimeStamp = mozilla::TimeStamp());
  void FireDOMPaintEvent(nsTArray<nsRect>* aList, uint64_t aTransactionId,
                         mozilla::TimeStamp aTimeStamp = mozilla::TimeStamp());



  static void NotifySubDocInvalidation(mozilla::layers::ContainerLayer* aContainer,
                                       const nsIntRegion& aRegion);
  void SetNotifySubDocInvalidationData(mozilla::layers::ContainerLayer* aContainer);
  static void ClearNotifySubDocInvalidationData(mozilla::layers::ContainerLayer* aContainer);
  bool IsDOMPaintEventPending();




  uint64_t GetRestyleGeneration() const;




  bool HasPendingRestyleOrReflow();





  void NotifyFontFaceSetOnRefresh();
  void ReflowStarted(bool aInterruptible);




  class InterruptPreventer;
  friend class InterruptPreventer;
  class InterruptPreventer {
  public:
    explicit InterruptPreventer(nsPresContext* aCtx) :
      mCtx(aCtx),
      mInterruptsEnabled(aCtx->mInterruptsEnabled),
      mHasPendingInterrupt(aCtx->mHasPendingInterrupt)
    {
      mCtx->mInterruptsEnabled = false;
      mCtx->mHasPendingInterrupt = false;
    }
    ~InterruptPreventer() {
      mCtx->mInterruptsEnabled = mInterruptsEnabled;
      mCtx->mHasPendingInterrupt = mHasPendingInterrupt;
    }

  private:
    nsPresContext* mCtx;
    bool mInterruptsEnabled;
    bool mHasPendingInterrupt;
  };
  bool CheckForInterrupt(nsIFrame* aFrame);




  bool HasPendingInterrupt() { return mHasPendingInterrupt; }





  void SetPendingInterruptFromTest() { mPendingInterruptFromTest = true; }







  nsIFrame* GetPrimaryFrameFor(nsIContent* aContent);

  void NotifyDestroyingFrame(nsIFrame* aFrame)
  {
    PropertyTable()->DeleteAllFor(aFrame);
  }

  virtual size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;
  virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const {
    return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
  }

  bool IsRootContentDocument() const;

  bool HadNonBlankPaint() const {
    return mHadNonBlankPaint;
  }

  void NotifyNonBlankPaint();

  bool IsGlyph() const {
    return mIsGlyph;
  }

  void SetIsGlyph(bool aValue) {
    mIsGlyph = aValue;
  }

  bool UsesRootEMUnits() const {
    return mUsesRootEMUnits;
  }

  void SetUsesRootEMUnits(bool aValue) {
    mUsesRootEMUnits = aValue;
  }

  bool UsesExChUnits() const {
    return mUsesExChUnits;
  }

  void SetUsesExChUnits(bool aValue) {
    mUsesExChUnits = aValue;
  }

  bool UsesViewportUnits() const {
    return mUsesViewportUnits;
  }

  void SetUsesViewportUnits(bool aValue) {
    mUsesViewportUnits = aValue;
  }




  bool ExistThrottledUpdates() const {
    return mExistThrottledUpdates;
  }

  void SetExistThrottledUpdates(bool aExistThrottledUpdates) {
    mExistThrottledUpdates = aExistThrottledUpdates;
  }

  bool IsDeviceSizePageSize();

  bool HasWarnedAboutPositionedTableParts() const {
    return mHasWarnedAboutPositionedTableParts;
  }

  void SetHasWarnedAboutPositionedTableParts() {
    mHasWarnedAboutPositionedTableParts = true;
  }

  bool HasWarnedAboutTooLargeDashedOrDottedRadius() const {
    return mHasWarnedAboutTooLargeDashedOrDottedRadius;
  }

  void SetHasWarnedAboutTooLargeDashedOrDottedRadius() {
    mHasWarnedAboutTooLargeDashedOrDottedRadius = true;
  }

protected:
  friend class nsRunnableMethod<nsPresContext>;
  void ThemeChangedInternal();
  void SysColorChangedInternal();


  void UIResolutionChangedInternal();



  void UIResolutionChangedInternalScale(double aScale);




  static bool
  UIResolutionChangedSubdocumentCallback(nsIDocument* aDocument, void* aData);

  void SetImgAnimations(nsIContent *aParent, uint16_t aMode);
  void SetSMILAnimations(nsIDocument *aDoc, uint16_t aNewMode,
                                     uint16_t aOldMode);
  void GetDocumentColorPreferences();

  void PreferenceChanged(const char* aPrefName);
  static void PrefChangedCallback(const char*, void*);

  void UpdateAfterPreferencesChanged();
  static void PrefChangedUpdateTimerCallback(nsITimer *aTimer, void *aClosure);

  void GetUserPreferences();





  const LangGroupFontPrefs* GetFontPrefsForLang(nsIAtom *aLanguage) const
  {
    nsIAtom* lang = aLanguage ? aLanguage : mLanguage.get();
    return StaticPresData::Get()->GetFontPrefsForLangHelper(lang, &mLangGroupFontPrefs);
  }

  void UpdateCharSet(const nsCString& aCharSet);

  static bool NotifyDidPaintSubdocumentCallback(nsIDocument* aDocument, void* aData);

public:
  void DoChangeCharSet(const nsCString& aCharSet);




  bool MayHavePaintEventListener();






  bool MayHavePaintEventListenerInSubDocument();
  void InvalidatePaintedLayers();

protected:

  void Destroy();

  void AppUnitsPerDevPixelChanged();

  void HandleRebuildCounterStyles() {
    mPostedFlushCounterStyles = false;
    FlushCounterStyles();
  }

  bool HavePendingInputEvent();


  bool HasCachedStyleData();



  already_AddRefed<nsITimer> CreateTimer(nsTimerCallbackFunc aCallback,
                                         const char* aName,
                                         uint32_t aDelay);





  nsPresContextType mType;


  nsIPresShell* mShell;
  nsCOMPtr<nsIDocument> mDocument;
  RefPtr<nsDeviceContext> mDeviceContext;




  RefPtr<mozilla::EventStateManager> mEventManager;
  RefPtr<nsRefreshDriver> mRefreshDriver;
  RefPtr<mozilla::EffectCompositor> mEffectCompositor;
  RefPtr<nsTransitionManager> mTransitionManager;
  RefPtr<nsAnimationManager> mAnimationManager;
  RefPtr<mozilla::RestyleManager> mRestyleManager;
  RefPtr<mozilla::CounterStyleManager> mCounterStyleManager;
  nsIAtom* mMedium;
  nsCOMPtr<nsIAtom> mMediaEmulated;



  nsILinkHandler* mLinkHandler;






  nsCOMPtr<nsIAtom> mLanguage;

public:





  bool mInflationDisabledForShrinkWrap;

protected:

  mozilla::WeakPtr<nsDocShell> mContainer;


  int32_t mBaseMinFontSize;
  float mSystemFontScale;
  float mTextZoom;
  float mEffectiveTextZoom;
  float mFullZoom;
  float mOverrideDPPX;
  gfxSize mLastFontInflationScreenSize;

  int32_t mCurAppUnitsPerDevPixel;
  int32_t mAutoQualityMinFontSizePixelsPref;

  nsCOMPtr<nsITheme> mTheme;
  nsCOMPtr<nsILanguageAtomService> mLangService;
  nsCOMPtr<nsIPrintSettings> mPrintSettings;
  nsCOMPtr<nsITimer> mPrefChangedTimer;

  FramePropertyTable mPropertyTable;

  struct TransactionInvalidations {
    uint64_t mTransactionId;
    nsTArray<nsRect> mInvalidations;
  };
  AutoTArray<TransactionInvalidations, 4> mTransactions;


  nsAutoPtr<gfxTextPerfMetrics> mTextPerf;

  nsAutoPtr<gfxMissingFontRecorder> mMissingFonts;

  nsRect mVisibleArea;
  nsSize mPageSize;
  float mPageScale;
  float mPPScale;

  nscolor mDefaultColor;
  nscolor mBackgroundColor;

  nscolor mLinkColor;
  nscolor mActiveLinkColor;
  nscolor mVisitedLinkColor;

  nscolor mFocusBackgroundColor;
  nscolor mFocusTextColor;

  nscolor mBodyTextColor;

  ScrollbarStyles mViewportStyleScrollbar;
  uint8_t mFocusRingWidth;

  bool mExistThrottledUpdates;

  uint16_t mImageAnimationMode;
  uint16_t mImageAnimationModePref;






  LangGroupFontPrefs mLangGroupFontPrefs;

  nscoord mBorderWidthTable[3];

  uint32_t mInterruptChecksToSkip;



  uint64_t mElementsRestyled;
  uint64_t mFramesConstructed;
  uint64_t mFramesReflowed;

  mozilla::TimeStamp mReflowStartTime;



  mozilla::TimeStamp mFirstNonBlankPaintTime;
  mozilla::TimeStamp mFirstClickTime;
  mozilla::TimeStamp mFirstKeyTime;
  mozilla::TimeStamp mFirstMouseMoveTime;
  mozilla::TimeStamp mFirstScrollTime;
  bool mInteractionTimeEnabled;


  mozilla::TimeStamp mLastStyleUpdateForAllAnimations;

  nscoord mTelemetryScrollLastY;
  nscoord mTelemetryScrollMaxY;
  nscoord mTelemetryScrollTotalY;

  unsigned mHasPendingInterrupt : 1;
  unsigned mPendingInterruptFromTest : 1;
  unsigned mInterruptsEnabled : 1;
  unsigned mUseDocumentFonts : 1;
  unsigned mUseDocumentColors : 1;
  unsigned mUnderlineLinks : 1;
  unsigned mSendAfterPaintToContent : 1;
  unsigned mUseFocusColors : 1;
  unsigned mFocusRingOnAnything : 1;
  unsigned mFocusRingStyle : 1;
  unsigned mDrawImageBackground : 1;
  unsigned mDrawColorBackground : 1;
  unsigned mNeverAnimate : 1;
  unsigned mIsRenderingOnlySelection : 1;
  unsigned mPaginated : 1;
  unsigned mCanPaginatedScroll : 1;
  unsigned mDoScaledTwips : 1;
  unsigned mIsRootPaginatedDocument : 1;
  unsigned mPrefBidiDirection : 1;
  unsigned mPrefScrollbarSide : 2;
  unsigned mPendingSysColorChanged : 1;
  unsigned mPendingThemeChanged : 1;
  unsigned mPendingUIResolutionChanged : 1;
  unsigned mPendingMediaFeatureValuesChanged : 1;
  unsigned mPrefChangePendingNeedsReflow : 1;
  unsigned mIsEmulatingMedia : 1;


  unsigned mIsGlyph : 1;


  unsigned mUsesRootEMUnits : 1;

  unsigned mUsesExChUnits : 1;

  unsigned mUsesViewportUnits : 1;


  unsigned mPendingViewportChange : 1;


  unsigned mCounterStylesDirty : 1;

  unsigned mPostedFlushCounterStyles: 1;



  unsigned mSuppressResizeReflow : 1;

  unsigned mIsVisual : 1;

  unsigned mFireAfterPaintEvents : 1;

  unsigned mIsChrome : 1;
  unsigned mIsChromeOriginImage : 1;



  mutable unsigned mPaintFlashing : 1;
  mutable unsigned mPaintFlashingInitialized : 1;

  unsigned mHasWarnedAboutPositionedTableParts : 1;

  unsigned mHasWarnedAboutTooLargeDashedOrDottedRadius : 1;


  unsigned mQuirkSheetAdded : 1;


  unsigned mNeedsPrefUpdate : 1;


  unsigned mHadNonBlankPaint : 1;
protected:

  virtual ~nsPresContext();

  nscolor MakeColorPref(const nsString& aColor);

  void LastRelease();
};

class nsRootPresContext final : public nsPresContext {
public:
  nsRootPresContext(nsIDocument* aDocument, nsPresContextType aType);
  virtual ~nsRootPresContext();
  virtual void Detach() override;





  void EnsureEventualDidPaintEvent(uint64_t aTransactionId);





  void CancelDidPaintTimers(uint64_t aTransactionId);




  void CancelAllDidPaintTimers();







  void RegisterPluginForGeometryUpdates(nsIContent* aPlugin);





  void UnregisterPluginForGeometryUpdates(nsIContent* aPlugin);

  bool NeedToComputePluginGeometryUpdates()
  {
    return mRegisteredPlugins.Count() > 0;
  }
  void ComputePluginGeometryUpdates(nsIFrame* aFrame,
                                    nsDisplayListBuilder* aBuilder,
                                    nsDisplayList* aList);






  void ApplyPluginGeometryUpdates();





  void CollectPluginGeometryUpdates(mozilla::layers::LayerManager* aLayerManager);

  virtual bool IsRoot() override { return true; }






  void IncrementDOMGeneration() { mDOMGeneration++; }




  uint32_t GetDOMGeneration() { return mDOMGeneration; }






  void AddWillPaintObserver(nsIRunnable* aRunnable);




  void FlushWillPaintObservers();

  virtual size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const override;

protected:



  void InitApplyPluginGeometryTimer();



  void CancelApplyPluginGeometryTimer();

  class RunWillPaintObservers : public mozilla::Runnable {
  public:
    explicit RunWillPaintObservers(nsRootPresContext* aPresContext)
      : Runnable("nsPresContextType::RunWillPaintObservers")
      , mPresContext(aPresContext) {}
    void Revoke() { mPresContext = nullptr; }
    virtual nsresult Run() override
    {
      if (mPresContext) {
        mPresContext->FlushWillPaintObservers();
      }
      return NS_OK;
    }

    nsRootPresContext* mPresContext;
  };

  friend class nsPresContext;

  struct NotifyDidPaintTimer {
    uint64_t mTransactionId;
    nsCOMPtr<nsITimer> mTimer;
  };
  AutoTArray<NotifyDidPaintTimer, 4> mNotifyDidPaintTimers;

  nsCOMPtr<nsITimer> mApplyPluginGeometryTimer;
  nsTHashtable<nsRefPtrHashKey<nsIContent> > mRegisteredPlugins;
  nsTArray<nsCOMPtr<nsIRunnable> > mWillPaintObservers;
  nsRevocableEventPtr<RunWillPaintObservers> mWillPaintFallbackEvent;
  uint32_t mDOMGeneration;
};


class gfxContext;
class nsPresContext;
class nsRegion;

namespace mozilla {
namespace gfx {
class DrawTarget;
class Path;
}
}

namespace mozilla {







class DisplayItemClip {
  typedef mozilla::gfx::Color Color;
  typedef mozilla::gfx::DrawTarget DrawTarget;
  typedef mozilla::gfx::Path Path;

public:
  struct RoundedRect {
    nsRect mRect;

    nscoord mRadii[8];

    RoundedRect operator+(const nsPoint& aOffset) const {
      RoundedRect r = *this;
      r.mRect += aOffset;
      return r;
    }
    bool operator==(const RoundedRect& aOther) const {
      if (!mRect.IsEqualInterior(aOther.mRect)) {
        return false;
      }

      int32_t corner54 = mozilla::eCornerTopLeftX; for (mozilla::HalfCorner corner; corner54 <= mozilla::eCornerBottomLeftY && (corner = mozilla::HalfCorner(corner54), true); ++corner54) {
        if (mRadii[corner] != aOther.mRadii[corner]) {
          return false;
        }
      }
      return true;
    }
    bool operator!=(const RoundedRect& aOther) const {
      return !(*this == aOther);
    }
  };


  DisplayItemClip() : mHaveClipRect(false) {}

  void SetTo(const nsRect& aRect);
  void SetTo(const nsRect& aRect, const nscoord* aRadii);
  void SetTo(const nsRect& aRect, const nsRect& aRoundedRect, const nscoord* aRadii);
  void IntersectWith(const DisplayItemClip& aOther);




  void ApplyTo(gfxContext* aContext, nsPresContext* aPresContext,
               uint32_t aBegin = 0, uint32_t aEnd = (4294967295U));

  void ApplyRectTo(gfxContext* aContext, int32_t A2D) const;



  void ApplyRoundedRectClipsTo(gfxContext* aContext, int32_t A2DPRInt32,
                               uint32_t aBegin, uint32_t aEnd) const;


  void FillIntersectionOfRoundedRectClips(gfxContext* aContext,
                                          const Color& aColor,
                                          int32_t aAppUnitsPerDevPixel,
                                          uint32_t aBegin,
                                          uint32_t aEnd) const;

  already_AddRefed<Path> MakeRoundedRectPath(DrawTarget& aDrawTarget,
                                                  int32_t A2D,
                                                  const RoundedRect &aRoundRect) const;






  bool MayIntersect(const nsRect& aRect) const;




  nsRect ApproximateIntersectInward(const nsRect& aRect) const;
  bool ComputeRegionInClips(DisplayItemClip* aOldClip,
                            const nsPoint& aShift,
                            nsRegion* aCombined) const;





  bool IsRectClippedByRoundedCorner(const nsRect& aRect) const;



  bool IsRectAffectedByClip(const nsRect& aRect) const;
  bool IsRectAffectedByClip(const nsIntRect& aRect, float aXScale, float aYScale, int32_t A2D) const;


  nsRect NonRoundedIntersection() const;



  nsRect ApplyNonRoundedIntersection(const nsRect& aRect) const;


  void RemoveRoundedCorners();



  void AddOffsetAndComputeDifference(uint32_t aStart, const nsPoint& aPoint, const nsRect& aBounds,
                                     const DisplayItemClip& aOther, uint32_t aOtherStart, const nsRect& aOtherBounds,
                                     nsRegion* aDifference);

  bool operator==(const DisplayItemClip& aOther) const {
    return mHaveClipRect == aOther.mHaveClipRect &&
           (!mHaveClipRect || mClipRect.IsEqualInterior(aOther.mClipRect)) &&
           mRoundedClipRects == aOther.mRoundedClipRects;
  }
  bool operator!=(const DisplayItemClip& aOther) const {
    return !(*this == aOther);
  }

  bool HasClip() const { return mHaveClipRect; }
  const nsRect& GetClipRect() const
  {
    do { } while(0);
    return mClipRect;
  }

  void MoveBy(nsPoint aPoint);

  nsCString ToString() const;





  uint32_t GetCommonRoundedRectCount(const DisplayItemClip& aOther,
                                     uint32_t aMax) const;
  uint32_t GetRoundedRectCount() const { return mRoundedClipRects.Length(); }
  void AppendRoundedRects(nsTArray<RoundedRect>* aArray, uint32_t aCount) const;

  static const DisplayItemClip& NoClip();

  static void Shutdown();

private:
  nsRect mClipRect;
  nsTArray<RoundedRect> mRoundedClipRects;


  bool mHaveClipRect;
};

}



class nsScrollbarFrame;
class nsIFrame;

class nsIScrollbarMediator : public nsQueryFrame
{
public:
  static const nsQueryFrame::FrameIID kFrameIID = nsQueryFrame::nsIScrollbarMediator_id; typedef nsIScrollbarMediator Has_NS_DECL_QUERYFRAME_TARGET;
  enum ScrollSnapMode { DISABLE_SNAP, ENABLE_SNAP };






  virtual void ScrollByPage(nsScrollbarFrame* aScrollbar, int32_t aDirection,
                            ScrollSnapMode aSnap = DISABLE_SNAP) = 0;
  virtual void ScrollByWhole(nsScrollbarFrame* aScrollbar, int32_t aDirection,
                            ScrollSnapMode aSnap = DISABLE_SNAP) = 0;
  virtual void ScrollByLine(nsScrollbarFrame* aScrollbar, int32_t aDirection,
                            ScrollSnapMode aSnap = DISABLE_SNAP) = 0;






  virtual void RepeatButtonScroll(nsScrollbarFrame* aScrollbar) = 0;







  virtual void ThumbMoved(nsScrollbarFrame* aScrollbar,
                          nscoord aOldPos,
                          nscoord aNewPos) = 0;




  virtual void ScrollbarReleased(nsScrollbarFrame* aScrollbar) = 0;
  virtual void VisibilityChanged(bool aVisible) = 0;





  virtual nsIFrame* GetScrollbarBox(bool aVertical) = 0;




  virtual void ScrollbarActivityStarted() const = 0;
  virtual void ScrollbarActivityStopped() const = 0;

  virtual bool IsScrollbarOnRight() const = 0;





  virtual bool ShouldSuppressScrollbarRepaints() const = 0;
};






namespace mozilla {
namespace gfx {




const int LOG_CRITICAL = 1;
const int LOG_WARNING = 2;
const int LOG_DEBUG = 3;
const int LOG_DEBUG_PRLOG = 4;
const int LOG_EVERYTHING = 5;




const int LOG_DEFAULT = LOG_CRITICAL;


}
}


extern mozilla::LogModule* GetGFX2DLog();


namespace mozilla {
namespace gfx {


inline mozilla::LogLevel PRLogLevelForLevel(int aLevel) {
  switch (aLevel) {
  case LOG_CRITICAL:
    return LogLevel::Error;
  case LOG_WARNING:
    return LogLevel::Warning;
  case LOG_DEBUG:
    return LogLevel::Debug;
  case LOG_DEBUG_PRLOG:
    return LogLevel::Debug;
  case LOG_EVERYTHING:
    return LogLevel::Error;
  }
  return LogLevel::Debug;
}


class LoggingPrefs
{
public:





  static int32_t sGfxLogLevel;
};
enum class LogReason : int {
  MustBeMoreThanThis = -1,


  D3D11InvalidCallDeviceRemoved = 0,
  D3D11InvalidCall,
  D3DLockTimeout,
  D3D10FinalizeFrame,
  D3D11FinalizeFrame,
  D3D10SyncLock,
  D3D11SyncLock,
  D2D1NoWriteMap,
  JobStatusError,
  FilterInputError,
  FilterInputData,
  FilterInputRect,
  FilterInputSet,
  FilterInputFormat,
  FilterNodeD2D1Target,
  FilterNodeD2D1Backend,
  SourceSurfaceIncompatible,
  GlyphAllocFailedCairo,
  GlyphAllocFailedCG,
  InvalidRect,
  CannotDraw3D,
  IncompatibleBasicTexturedEffect,
  InvalidFont,
  PAllocTextureBackendMismatch,
  GetFontFileDataFailed,
  MessageChannelCloseFailure,
  MessageChannelInvalidHandle,
  TextureAliveAfterShutdown,
  InvalidContext,
  InvalidCommandList,
  AsyncTransactionTimeout,
  TextureCreation,
  InvalidCacheSurface,
  AlphaWithBasicClient,
  UnbalancedClipStack,
  ProcessingError,
  InvalidDrawTarget,
  NativeFontResourceNotFound,

  MustBeLessThanThis = 101,
};

struct BasicLogger
{



  static bool ShouldOutputMessage(int aLevel) {
    if (LoggingPrefs::sGfxLogLevel >= aLevel) {




      if (mozilla::detail::log_test(GetGFX2DLog(), PRLogLevelForLevel(aLevel))) {
        return true;
      } else

      if ((LoggingPrefs::sGfxLogLevel >= LOG_DEBUG_PRLOG) ||
                 (aLevel < LOG_DEBUG)) {
        return true;
      }

    }
    return false;
  }


  static void CrashAction(LogReason aReason) {}

  static void OutputMessage(const std::string &aString,
                            int aLevel,
                            bool aNoNewline) {
    if (LoggingPrefs::sGfxLogLevel >= aLevel) {




      if (mozilla::detail::log_test(GetGFX2DLog(), PRLogLevelForLevel(aLevel))) {
        do { if (mozilla::detail::log_test(GetGFX2DLog(), PRLogLevelForLevel(aLevel))) { mozilla::detail::log_print(GetGFX2DLog(), PRLogLevelForLevel(aLevel), "%s%s", aString.c_str(), aNoNewline ? "" : "\n"); } } while (0);
      } else

      if ((LoggingPrefs::sGfxLogLevel >= LOG_DEBUG_PRLOG) ||
                 (aLevel < LOG_DEBUG)) {
        printf("%s%s", aString.c_str(), aNoNewline ? "" : "\n");
      }

    }
  }
};

struct CriticalLogger {
  static void OutputMessage(const std::string &aString, int aLevel, bool aNoNewline);
  static void CrashAction(LogReason aReason);
};





typedef mozilla::Tuple<int32_t,std::string,double> LoggingRecordEntry;



typedef std::vector<LoggingRecordEntry> LoggingRecord;
class LogForwarder {
public:
  virtual ~LogForwarder() {}
  virtual void Log(const std::string &aString) = 0;
  virtual void CrashAction(LogReason aReason) = 0;
  virtual bool UpdateStringsVector(const std::string& aString) = 0;


  virtual LoggingRecord LoggingRecordCopy() = 0;
};

class NoLog
{
public:
  NoLog() {}
  ~NoLog() {}


               NoLog(const NoLog&) {}

  template<typename T>
  NoLog &operator <<(const T &aLogText) { return *this; }
};

enum class LogOptions : int {
  NoNewline = 0x01,
  AutoPrefix = 0x02,
  AssertOnCall = 0x04,
  CrashAction = 0x08,
};

template<typename T>
struct Hexa {
  explicit Hexa(T aVal) : mVal(aVal) {}
  T mVal;
};
template<typename T>
Hexa<T> hexa(T val) { return Hexa<T>(val); }

template<int L, typename Logger = BasicLogger>
class Log
{
public:


  static int DefaultOptions(bool aWithAssert = true) {
    return (int(LogOptions::AutoPrefix) |
            (aWithAssert ? int(LogOptions::AssertOnCall) : 0));
  }





  explicit Log(int aOptions = Log::DefaultOptions(L == LOG_CRITICAL),
               LogReason aReason = LogReason::MustBeMoreThanThis)
  : mOptions(0)
  , mLogIt(false)
  {
    Init(aOptions, BasicLogger::ShouldOutputMessage(L), aReason);
  }

  ~Log() {
    Flush();
  }

  void Flush() {
    if ((__builtin_expect(!!(!LogIt()), 1))) return;

    std::string str = mMessage.str();
    if (!str.empty()) {
      WriteLog(str);
    }
    mMessage.str("");
  }

  Log &operator <<(char aChar) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << aChar;
    }
    return *this;
  }
  Log &operator <<(const std::string &aLogText) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << aLogText;
    }
    return *this;
  }
  Log &operator <<(const char aStr[]) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << static_cast<const char*>(aStr);
    }
    return *this;
  }
  Log &operator <<(bool aBool) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << (aBool ? "true" : "false");
    }
    return *this;
  }
  Log &operator <<(int aInt) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << aInt;
    }
    return *this;
  }
  Log &operator <<(unsigned int aInt) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << aInt;
    }
    return *this;
  }
  Log &operator <<(long aLong) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << aLong;
    }
    return *this;
  }
  Log &operator <<(unsigned long aLong) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << aLong;
    }
    return *this;
  }
  Log &operator <<(long long aLong) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << aLong;
    }
    return *this;
  }
  Log &operator <<(unsigned long long aLong) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << aLong;
    }
    return *this;
  }
  Log &operator <<(Float aFloat) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << aFloat;
    }
    return *this;
  }
  Log &operator <<(double aDouble) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << aDouble;
    }
    return *this;
  }
  template <typename T, typename Sub, typename Coord>
  Log &operator <<(const BasePoint<T, Sub, Coord>& aPoint) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << "Point" << aPoint;
    }
    return *this;
  }
  template <typename T, typename Sub>
  Log &operator <<(const BaseSize<T, Sub>& aSize) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << "Size(" << aSize.width << "," << aSize.height << ")";
    }
    return *this;
  }
  template <typename T, typename Sub, typename Point, typename SizeT, typename Margin>
  Log &operator <<(const BaseRect<T, Sub, Point, SizeT, Margin>& aRect) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << "Rect" << aRect;
    }
    return *this;
  }
  Log &operator<<(const Matrix& aMatrix) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << "Matrix(" << aMatrix._11 << " " << aMatrix._12 << " ; " << aMatrix._21 << " " << aMatrix._22 << " ; " << aMatrix._31 << " " << aMatrix._32 << ")";
    }
    return *this;
  }
  template<typename T>
  Log &operator<<(Hexa<T> aHex) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      mMessage << std::showbase << std::hex
               << aHex.mVal
               << std::noshowbase << std::dec;
    }
    return *this;
  }

  Log& operator<<(SurfaceFormat aFormat) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      switch(aFormat) {
        case SurfaceFormat::B8G8R8A8:
          mMessage << "SurfaceFormat::B8G8R8A8";
          break;
        case SurfaceFormat::B8G8R8X8:
          mMessage << "SurfaceFormat::B8G8R8X8";
          break;
        case SurfaceFormat::R8G8B8A8:
          mMessage << "SurfaceFormat::R8G8B8A8";
          break;
        case SurfaceFormat::R8G8B8X8:
          mMessage << "SurfaceFormat::R8G8B8X8";
          break;
        case SurfaceFormat::R5G6B5_UINT16:
          mMessage << "SurfaceFormat::R5G6B5_UINT16";
          break;
        case SurfaceFormat::A8:
          mMessage << "SurfaceFormat::A8";
          break;
        case SurfaceFormat::YUV:
          mMessage << "SurfaceFormat::YUV";
          break;
        case SurfaceFormat::UNKNOWN:
          mMessage << "SurfaceFormat::UNKNOWN";
          break;
        default:
          mMessage << "Invalid SurfaceFormat (" << (int)aFormat << ")";
          break;
      }
    }
    return *this;
  }

  Log& operator<<(SurfaceType aType) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      switch(aType) {
        case SurfaceType::DATA:
          mMessage << "SurfaceType::DATA";
          break;
        case SurfaceType::D2D1_BITMAP:
          mMessage << "SurfaceType::D2D1_BITMAP";
          break;
        case SurfaceType::D2D1_DRAWTARGET:
          mMessage << "SurfaceType::D2D1_DRAWTARGET";
          break;
        case SurfaceType::CAIRO:
          mMessage << "SurfaceType::CAIRO";
          break;
        case SurfaceType::CAIRO_IMAGE:
          mMessage << "SurfaceType::CAIRO_IMAGE";
          break;
        case SurfaceType::COREGRAPHICS_IMAGE:
          mMessage << "SurfaceType::COREGRAPHICS_IMAGE";
          break;
        case SurfaceType::COREGRAPHICS_CGCONTEXT:
          mMessage << "SurfaceType::COREGRAPHICS_CGCONTEXT";
          break;
        case SurfaceType::SKIA:
          mMessage << "SurfaceType::SKIA";
          break;
        case SurfaceType::DUAL_DT:
          mMessage << "SurfaceType::DUAL_DT";
          break;
        case SurfaceType::D2D1_1_IMAGE:
          mMessage << "SurfaceType::D2D1_1_IMAGE";
          break;
        case SurfaceType::RECORDING:
          mMessage << "SurfaceType::RECORDING";
          break;
        case SurfaceType::TILED:
          mMessage << "SurfaceType::TILED";
          break;
        case SurfaceType::DATA_SHARED:
          mMessage << "SurfaceType::DATA_SHARED";
          break;
        default:
          mMessage << "Invalid SurfaceType (" << (int)aType << ")";
          break;
      }
    }
    return *this;
  }

  inline bool LogIt() const { return mLogIt; }
  inline bool NoNewline() const { return mOptions & int(LogOptions::NoNewline); }
  inline bool AutoPrefix() const { return mOptions & int(LogOptions::AutoPrefix); }
  inline bool ValidReason() const { return (int)mReason > (int)LogReason::MustBeMoreThanThis && (int)mReason < (int)LogReason::MustBeLessThanThis; }



               Log(const Log& log) { Init(log.mOptions, false, log.mReason); }

private:

  void Init(int aOptions, bool aLogIt, LogReason aReason) {
    mOptions = aOptions;
    mReason = aReason;
    mLogIt = aLogIt;
    if (mLogIt) {
      if (AutoPrefix()) {
        if (mOptions & int(LogOptions::AssertOnCall)) {
          mMessage << "[GFX" << L;
        } else {
          mMessage << "[GFX" << L << "-";
        }
      }
      if ((mOptions & int(LogOptions::CrashAction)) && ValidReason()) {
        mMessage << " " << (int)mReason;
      }
      if (AutoPrefix()) {
        mMessage << "]: ";
      }
    }
  }

  void WriteLog(const std::string &aString) {
    if ((__builtin_expect(!!(LogIt()), 0))) {
      Logger::OutputMessage(aString, L, NoNewline());
      if ((mOptions & int(LogOptions::CrashAction)) && ValidReason()) {
        Logger::CrashAction(mReason);
      }
    }
  }

  std::stringstream mMessage;
  int mOptions;
  LogReason mReason;
  bool mLogIt;
};

typedef Log<LOG_DEBUG> DebugLog;
typedef Log<LOG_WARNING> WarningLog;
typedef Log<LOG_CRITICAL, CriticalLogger> CriticalLog;
inline bool MOZ2D_error_if_impl(bool aCondition, const char* aExpr,
                                const char* aFile, int32_t aLine)
{
  if ((__builtin_expect(!!(aCondition), 0))) {
    mozilla::gfx::CriticalLog() << aExpr << " at " << aFile << ":" << aLine;
  }
  return aCondition;
}
const int INDENT_PER_LEVEL = 2;

class TreeLog
{
public:
  explicit TreeLog(const std::string& aPrefix = "")
        : mLog(int(LogOptions::NoNewline)),
          mPrefix(aPrefix),
          mDepth(0),
          mStartOfLine(true),
          mConditionedOnPref(false),
          mPrefFunction(nullptr) {}

  template <typename T>
  TreeLog& operator<<(const T& aObject) {
    if (mConditionedOnPref && !mPrefFunction()) {
      return *this;
    }
    if (mStartOfLine) {
      mLog << '[' << mPrefix << "] " << std::string(mDepth * INDENT_PER_LEVEL, ' ');
      mStartOfLine = false;
    }
    mLog << aObject;
    if (EndsInNewline(aObject)) {


      mLog.Flush();
      mStartOfLine = true;
    }
    return *this;
  }

  void IncreaseIndent() { ++mDepth; }
  void DecreaseIndent() {
    do { } while (0);
    --mDepth;
  }

  void ConditionOnPrefFunction(bool(*aPrefFunction)()) {
    mConditionedOnPref = true;
    mPrefFunction = aPrefFunction;
  }
private:
  Log<LOG_DEBUG> mLog;
  std::string mPrefix;
  uint32_t mDepth;
  bool mStartOfLine;
  bool mConditionedOnPref;
  bool (*mPrefFunction)();

  template <typename T>
  static bool EndsInNewline(const T& aObject) {
    return false;
  }

  static bool EndsInNewline(const std::string& aString) {
    return !aString.empty() && aString[aString.length() - 1] == '\n';
  }

  static bool EndsInNewline(char aChar) {
    return aChar == '\n';
  }

  static bool EndsInNewline(const char* aString) {
    return EndsInNewline(std::string(aString));
  }
};

class TreeAutoIndent
{
public:
  explicit TreeAutoIndent(TreeLog& aTreeLog) : mTreeLog(aTreeLog) {
    mTreeLog.IncreaseIndent();
  }

  TreeAutoIndent(const TreeAutoIndent& aTreeAutoIndent) :
      TreeAutoIndent(aTreeAutoIndent.mTreeLog) {
    mTreeLog.IncreaseIndent();
  }

  TreeAutoIndent& operator=(const TreeAutoIndent& aTreeAutoIndent) = delete;

  ~TreeAutoIndent() {
    mTreeLog.DecreaseIndent();
  }
private:
  TreeLog& mTreeLog;
};

}
}





namespace IPC {
template <typename T> struct ParamTraits;
}

namespace mozilla {
namespace layers {





struct ScrollUpdateInfo {
  uint32_t mScrollGeneration;
  CSSPoint mScrollOffset;
};







struct FrameMetrics {
  friend struct IPC::ParamTraits<mozilla::layers::FrameMetrics>;
public:

  typedef uint64_t ViewID;
  static const ViewID NULL_SCROLL_ID;
  static const ViewID START_SCROLL_ID = 2;


  enum ScrollOffsetUpdateType : uint8_t {
    eNone,
    eMainThread,
    ePending,


    eUserAction,



    eRestore,




    eSentinel
  };

  FrameMetrics()
    : mScrollId(NULL_SCROLL_ID)
    , mPresShellResolution(1)
    , mCompositionBounds(0, 0, 0, 0)
    , mDisplayPort(0, 0, 0, 0)
    , mCriticalDisplayPort(0, 0, 0, 0)
    , mScrollableRect(0, 0, 0, 0)
    , mCumulativeResolution()
    , mDevPixelsPerCSSPixel(1)
    , mScrollOffset(0, 0)
    , mZoom()
    , mScrollGeneration(0)
    , mSmoothScrollOffset(0, 0)
    , mRootCompositionSize(0, 0)
    , mDisplayPortMargins(0, 0, 0, 0)
    , mPresShellId(-1)
    , mViewport(0, 0, 0, 0)
    , mExtraResolution()
    , mPaintRequestTime()
    , mScrollUpdateType(eNone)
    , mIsRootContent(false)
    , mDoSmoothScroll(false)
    , mUseDisplayPortMargins(false)
    , mIsScrollInfoLayer(false)
  {
  }



  bool operator==(const FrameMetrics& aOther) const
  {

    return mScrollId == aOther.mScrollId &&
           mPresShellResolution == aOther.mPresShellResolution &&
           mCompositionBounds.IsEqualEdges(aOther.mCompositionBounds) &&
           mDisplayPort.IsEqualEdges(aOther.mDisplayPort) &&
           mCriticalDisplayPort.IsEqualEdges(aOther.mCriticalDisplayPort) &&
           mScrollableRect.IsEqualEdges(aOther.mScrollableRect) &&
           mCumulativeResolution == aOther.mCumulativeResolution &&
           mDevPixelsPerCSSPixel == aOther.mDevPixelsPerCSSPixel &&
           mScrollOffset == aOther.mScrollOffset &&

           mScrollGeneration == aOther.mScrollGeneration &&
           mSmoothScrollOffset == aOther.mSmoothScrollOffset &&
           mRootCompositionSize == aOther.mRootCompositionSize &&
           mDisplayPortMargins == aOther.mDisplayPortMargins &&
           mPresShellId == aOther.mPresShellId &&
           mViewport.IsEqualEdges(aOther.mViewport) &&
           mExtraResolution == aOther.mExtraResolution &&
           mPaintRequestTime == aOther.mPaintRequestTime &&
           mScrollUpdateType == aOther.mScrollUpdateType &&
           mIsRootContent == aOther.mIsRootContent &&
           mDoSmoothScroll == aOther.mDoSmoothScroll &&
           mUseDisplayPortMargins == aOther.mUseDisplayPortMargins &&
           mIsScrollInfoLayer == aOther.mIsScrollInfoLayer;
  }

  bool operator!=(const FrameMetrics& aOther) const
  {
    return !operator==(aOther);
  }

  bool IsScrollable() const
  {
    return mScrollId != NULL_SCROLL_ID;
  }

  CSSToScreenScale2D DisplayportPixelsPerCSSPixel() const
  {







    return mZoom * ParentLayerToLayerScale(1.0f) / mExtraResolution;
  }

  CSSToLayerScale2D LayersPixelsPerCSSPixel() const
  {
    return mDevPixelsPerCSSPixel * mCumulativeResolution;
  }


  LayerToParentLayerScale GetAsyncZoom() const
  {


    return (mZoom / LayersPixelsPerCSSPixel()).ToScaleFactor();
  }







  CSSRect GetExpandedScrollableRect() const
  {
    CSSRect scrollableRect = mScrollableRect;
    CSSSize compSize = CalculateCompositedSizeInCssPixels();
    if (scrollableRect.width < compSize.width) {
      scrollableRect.x = std::max(0.f,
                                  scrollableRect.x - (compSize.width - scrollableRect.width));
      scrollableRect.width = compSize.width;
    }

    if (scrollableRect.height < compSize.height) {
      scrollableRect.y = std::max(0.f,
                                  scrollableRect.y - (compSize.height - scrollableRect.height));
      scrollableRect.height = compSize.height;
    }

    return scrollableRect;
  }

  CSSSize CalculateCompositedSizeInCssPixels() const
  {
    if (GetZoom() == CSSToParentLayerScale2D(0, 0)) {
      return CSSSize();
    }
    return mCompositionBounds.Size() / GetZoom();
  }

  CSSRect CalculateCompositedRectInCssPixels() const
  {
    if (GetZoom() == CSSToParentLayerScale2D(0, 0)) {
      return CSSRect();
    }
    return mCompositionBounds / GetZoom();
  }

  CSSSize CalculateBoundedCompositedSizeInCssPixels() const
  {
    CSSSize size = CalculateCompositedSizeInCssPixels();
    size.width = std::min(size.width, mRootCompositionSize.width);
    size.height = std::min(size.height, mRootCompositionSize.height);
    return size;
  }

  CSSRect CalculateScrollRange() const
  {
    CSSSize scrollPortSize = CalculateCompositedSizeInCssPixels();
    CSSRect scrollRange = mScrollableRect;
    scrollRange.width = std::max(scrollRange.width - scrollPortSize.width, 0.0f);
    scrollRange.height = std::max(scrollRange.height - scrollPortSize.height, 0.0f);
    return scrollRange;
  }

  void ScrollBy(const CSSPoint& aPoint)
  {
    mScrollOffset += aPoint;
  }

  void ZoomBy(float aScale)
  {
    ZoomBy(gfxSize(aScale, aScale));
  }

  void ZoomBy(const gfxSize& aScale)
  {
    mZoom.xScale *= aScale.width;
    mZoom.yScale *= aScale.height;
  }

  void CopyScrollInfoFrom(const FrameMetrics& aOther)
  {
    mScrollOffset = aOther.mScrollOffset;
    mScrollGeneration = aOther.mScrollGeneration;
  }

  void CopySmoothScrollInfoFrom(const FrameMetrics& aOther)
  {
    mSmoothScrollOffset = aOther.mSmoothScrollOffset;
    mScrollGeneration = aOther.mScrollGeneration;
    mDoSmoothScroll = aOther.mDoSmoothScroll;
  }

  void UpdatePendingScrollInfo(const ScrollUpdateInfo& aInfo)
  {
    mScrollOffset = aInfo.mScrollOffset;
    mScrollGeneration = aInfo.mScrollGeneration;
    mScrollUpdateType = ePending;
  }

  void SetRepaintDrivenByUserAction(bool aUserAction)
  {
    mScrollUpdateType = aUserAction ? eUserAction : eNone;
  }

public:
  void SetPresShellResolution(float aPresShellResolution)
  {
    mPresShellResolution = aPresShellResolution;
  }

  float GetPresShellResolution() const
  {
    return mPresShellResolution;
  }

  void SetCompositionBounds(const ParentLayerRect& aCompositionBounds)
  {
    mCompositionBounds = aCompositionBounds;
  }

  const ParentLayerRect& GetCompositionBounds() const
  {
    return mCompositionBounds;
  }

  void SetDisplayPort(const CSSRect& aDisplayPort)
  {
    mDisplayPort = aDisplayPort;
  }

  const CSSRect& GetDisplayPort() const
  {
    return mDisplayPort;
  }

  void SetCriticalDisplayPort(const CSSRect& aCriticalDisplayPort)
  {
    mCriticalDisplayPort = aCriticalDisplayPort;
  }

  const CSSRect& GetCriticalDisplayPort() const
  {
    return mCriticalDisplayPort;
  }

  void SetCumulativeResolution(const LayoutDeviceToLayerScale2D& aCumulativeResolution)
  {
    mCumulativeResolution = aCumulativeResolution;
  }

  const LayoutDeviceToLayerScale2D& GetCumulativeResolution() const
  {
    return mCumulativeResolution;
  }

  void SetDevPixelsPerCSSPixel(const CSSToLayoutDeviceScale& aDevPixelsPerCSSPixel)
  {
    mDevPixelsPerCSSPixel = aDevPixelsPerCSSPixel;
  }

  const CSSToLayoutDeviceScale& GetDevPixelsPerCSSPixel() const
  {
    return mDevPixelsPerCSSPixel;
  }

  void SetIsRootContent(bool aIsRootContent)
  {
    mIsRootContent = aIsRootContent;
  }

  bool IsRootContent() const
  {
    return mIsRootContent;
  }

  void SetScrollOffset(const CSSPoint& aScrollOffset)
  {
    mScrollOffset = aScrollOffset;
  }

  const CSSPoint& GetScrollOffset() const
  {
    return mScrollOffset;
  }

  void SetSmoothScrollOffset(const CSSPoint& aSmoothScrollDestination)
  {
    mSmoothScrollOffset = aSmoothScrollDestination;
  }

  const CSSPoint& GetSmoothScrollOffset() const
  {
    return mSmoothScrollOffset;
  }

  void SetZoom(const CSSToParentLayerScale2D& aZoom)
  {
    mZoom = aZoom;
  }

  const CSSToParentLayerScale2D& GetZoom() const
  {
    return mZoom;
  }

  void SetScrollOffsetUpdated(uint32_t aScrollGeneration)
  {
    mScrollUpdateType = eMainThread;
    mScrollGeneration = aScrollGeneration;
  }

  void SetScrollOffsetRestored(uint32_t aScrollGeneration)
  {
    mScrollUpdateType = eRestore;
    mScrollGeneration = aScrollGeneration;
  }

  void SetSmoothScrollOffsetUpdated(int32_t aScrollGeneration)
  {
    mDoSmoothScroll = true;
    mScrollGeneration = aScrollGeneration;
  }

  ScrollOffsetUpdateType GetScrollUpdateType() const
  {
    return mScrollUpdateType;
  }

  bool GetScrollOffsetUpdated() const
  {
    return mScrollUpdateType != eNone;
  }

  bool GetDoSmoothScroll() const
  {
    return mDoSmoothScroll;
  }

  uint32_t GetScrollGeneration() const
  {
    return mScrollGeneration;
  }

  ViewID GetScrollId() const
  {
    return mScrollId;
  }

  void SetScrollId(ViewID scrollId)
  {
    mScrollId = scrollId;
  }

  void SetRootCompositionSize(const CSSSize& aRootCompositionSize)
  {
    mRootCompositionSize = aRootCompositionSize;
  }

  const CSSSize& GetRootCompositionSize() const
  {
    return mRootCompositionSize;
  }

  void SetDisplayPortMargins(const ScreenMargin& aDisplayPortMargins)
  {
    mDisplayPortMargins = aDisplayPortMargins;
  }

  const ScreenMargin& GetDisplayPortMargins() const
  {
    return mDisplayPortMargins;
  }

  void SetUseDisplayPortMargins(bool aValue)
  {
    mUseDisplayPortMargins = aValue;
  }

  bool GetUseDisplayPortMargins() const
  {
    return mUseDisplayPortMargins;
  }

  uint32_t GetPresShellId() const
  {
    return mPresShellId;
  }

  void SetPresShellId(uint32_t aPresShellId)
  {
    mPresShellId = aPresShellId;
  }

  void SetViewport(const CSSRect& aViewport)
  {
    mViewport = aViewport;
  }

  const CSSRect& GetViewport() const
  {
    return mViewport;
  }

  void SetExtraResolution(const ScreenToLayerScale2D& aExtraResolution)
  {
    mExtraResolution = aExtraResolution;
  }

  const ScreenToLayerScale2D& GetExtraResolution() const
  {
    return mExtraResolution;
  }

  const CSSRect& GetScrollableRect() const
  {
    return mScrollableRect;
  }

  void SetScrollableRect(const CSSRect& aScrollableRect)
  {
    mScrollableRect = aScrollableRect;
  }

  void SetPaintRequestTime(const TimeStamp& aTime) {
    mPaintRequestTime = aTime;
  }
  const TimeStamp& GetPaintRequestTime() const {
    return mPaintRequestTime;
  }

  void SetIsScrollInfoLayer(bool aIsScrollInfoLayer) {
    mIsScrollInfoLayer = aIsScrollInfoLayer;
  }
  bool IsScrollInfoLayer() const {
    return mIsScrollInfoLayer;
  }

private:

  ViewID mScrollId;
  float mPresShellResolution;
  ParentLayerRect mCompositionBounds;
  CSSRect mDisplayPort;







  CSSRect mCriticalDisplayPort;
  CSSRect mScrollableRect;
  LayoutDeviceToLayerScale2D mCumulativeResolution;
  CSSToLayoutDeviceScale mDevPixelsPerCSSPixel;
  CSSPoint mScrollOffset;





  CSSToParentLayerScale2D mZoom;


  uint32_t mScrollGeneration;



  CSSPoint mSmoothScrollOffset;


  CSSSize mRootCompositionSize;



  ScreenMargin mDisplayPortMargins;

  uint32_t mPresShellId;
  CSSRect mViewport;



  ScreenToLayerScale2D mExtraResolution;


  TimeStamp mPaintRequestTime;



  ScrollOffsetUpdateType mScrollUpdateType;


  bool mIsRootContent:1;



  bool mDoSmoothScroll:1;



  bool mUseDisplayPortMargins:1;


  bool mIsScrollInfoLayer:1;
  void SetDoSmoothScroll(bool aValue) {
    mDoSmoothScroll = aValue;
  }
};

struct ScrollSnapInfo {
  ScrollSnapInfo()
    : mScrollSnapTypeX(0)
    , mScrollSnapTypeY(0)
  {}

  bool operator==(const ScrollSnapInfo& aOther) const
  {
    return mScrollSnapTypeX == aOther.mScrollSnapTypeX &&
           mScrollSnapTypeY == aOther.mScrollSnapTypeY &&
           mScrollSnapIntervalX == aOther.mScrollSnapIntervalX &&
           mScrollSnapIntervalY == aOther.mScrollSnapIntervalY &&
           mScrollSnapDestination == aOther.mScrollSnapDestination &&
           mScrollSnapCoordinates == aOther.mScrollSnapCoordinates;
  }



  uint8_t mScrollSnapTypeX;
  uint8_t mScrollSnapTypeY;


  Maybe<nscoord> mScrollSnapIntervalX;
  Maybe<nscoord> mScrollSnapIntervalY;



  nsPoint mScrollSnapDestination;



  nsTArray<nsPoint> mScrollSnapCoordinates;
};





struct LayerClip {
  friend struct IPC::ParamTraits<mozilla::layers::LayerClip>;

public:
  LayerClip()
    : mClipRect()
    , mMaskLayerIndex()
  {}

  explicit LayerClip(const ParentLayerIntRect& aClipRect)
    : mClipRect(aClipRect)
    , mMaskLayerIndex()
  {}

  bool operator==(const LayerClip& aOther) const
  {
    return mClipRect == aOther.mClipRect &&
           mMaskLayerIndex == aOther.mMaskLayerIndex;
  }

  void SetClipRect(const ParentLayerIntRect& aClipRect) {
    mClipRect = aClipRect;
  }
  const ParentLayerIntRect& GetClipRect() const {
    return mClipRect;
  }

  void SetMaskLayerIndex(const Maybe<size_t>& aIndex) {
    mMaskLayerIndex = aIndex;
  }
  const Maybe<size_t>& GetMaskLayerIndex() const {
    return mMaskLayerIndex;
  }

private:
  ParentLayerIntRect mClipRect;



  Maybe<size_t> mMaskLayerIndex;
};

typedef Maybe<LayerClip> MaybeLayerClip;
struct ScrollMetadata {
  friend struct IPC::ParamTraits<mozilla::layers::ScrollMetadata>;

  typedef FrameMetrics::ViewID ViewID;
public:
  static StaticAutoPtr<const ScrollMetadata> sNullMetadata;

  ScrollMetadata()
    : mMetrics()
    , mSnapInfo()
    , mScrollParentId(FrameMetrics::NULL_SCROLL_ID)
    , mBackgroundColor()
    , mContentDescription()
    , mLineScrollAmount(0, 0)
    , mPageScrollAmount(0, 0)
    , mScrollClip()
    , mHasScrollgrab(false)
    , mAllowVerticalScrollWithWheel(false)
    , mIsLayersIdRoot(false)
    , mUsesContainerScrolling(false)
    , mForceDisableApz(false)
  {}

  bool operator==(const ScrollMetadata& aOther) const
  {
    return mMetrics == aOther.mMetrics &&
           mSnapInfo == aOther.mSnapInfo &&
           mScrollParentId == aOther.mScrollParentId &&
           mBackgroundColor == aOther.mBackgroundColor &&

           mLineScrollAmount == aOther.mLineScrollAmount &&
           mPageScrollAmount == aOther.mPageScrollAmount &&
           mScrollClip == aOther.mScrollClip &&
           mHasScrollgrab == aOther.mHasScrollgrab &&
           mAllowVerticalScrollWithWheel == aOther.mAllowVerticalScrollWithWheel &&
           mIsLayersIdRoot == aOther.mIsLayersIdRoot &&
           mUsesContainerScrolling == aOther.mUsesContainerScrolling &&
           mForceDisableApz == aOther.mForceDisableApz;
  }

  bool operator!=(const ScrollMetadata& aOther) const
  {
    return !operator==(aOther);
  }

  bool IsDefault() const
  {
    ScrollMetadata def;

    def.mMetrics.SetPresShellId(mMetrics.GetPresShellId());
    return (def == *this);
  }

  FrameMetrics& GetMetrics() { return mMetrics; }
  const FrameMetrics& GetMetrics() const { return mMetrics; }

  void SetSnapInfo(ScrollSnapInfo&& aSnapInfo) {
    mSnapInfo = Move(aSnapInfo);
  }
  const ScrollSnapInfo& GetSnapInfo() const { return mSnapInfo; }

  ViewID GetScrollParentId() const {
    return mScrollParentId;
  }

  void SetScrollParentId(ViewID aParentId) {
    mScrollParentId = aParentId;
  }
  const gfx::Color& GetBackgroundColor() const {
    return mBackgroundColor;
  }
  void SetBackgroundColor(const gfx::Color& aBackgroundColor) {
    mBackgroundColor = aBackgroundColor;
  }
  const nsCString& GetContentDescription() const {
    return mContentDescription;
  }
  void SetContentDescription(const nsCString& aContentDescription) {
    mContentDescription = aContentDescription;
  }
  const LayoutDeviceIntSize& GetLineScrollAmount() const {
    return mLineScrollAmount;
  }
  void SetLineScrollAmount(const LayoutDeviceIntSize& size) {
    mLineScrollAmount = size;
  }
  const LayoutDeviceIntSize& GetPageScrollAmount() const {
    return mPageScrollAmount;
  }
  void SetPageScrollAmount(const LayoutDeviceIntSize& size) {
    mPageScrollAmount = size;
  }

  void SetScrollClip(const Maybe<LayerClip>& aScrollClip) {
    mScrollClip = aScrollClip;
  }
  const Maybe<LayerClip>& GetScrollClip() const {
    return mScrollClip;
  }
  bool HasScrollClip() const {
    return mScrollClip.isSome();
  }
  const LayerClip& ScrollClip() const {
    return mScrollClip.ref();
  }
  LayerClip& ScrollClip() {
    return mScrollClip.ref();
  }

  bool HasMaskLayer() const {
    return HasScrollClip() && ScrollClip().GetMaskLayerIndex();
  }
  Maybe<ParentLayerIntRect> GetClipRect() const {
    return mScrollClip.isSome() ? Some(mScrollClip->GetClipRect()) : Nothing();
  }

  void SetHasScrollgrab(bool aHasScrollgrab) {
    mHasScrollgrab = aHasScrollgrab;
  }
  bool GetHasScrollgrab() const {
    return mHasScrollgrab;
  }
  bool AllowVerticalScrollWithWheel() const {
    return mAllowVerticalScrollWithWheel;
  }
  void SetAllowVerticalScrollWithWheel(bool aValue) {
    mAllowVerticalScrollWithWheel = aValue;
  }
  void SetIsLayersIdRoot(bool aValue) {
    mIsLayersIdRoot = aValue;
  }
  bool IsLayersIdRoot() const {
    return mIsLayersIdRoot;
  }


  void SetUsesContainerScrolling(bool aValue);
  bool UsesContainerScrolling() const {
    return mUsesContainerScrolling;
  }
  void SetForceDisableApz(bool aForceDisable) {
    mForceDisableApz = aForceDisable;
  }
  bool IsApzForceDisabled() const {
    return mForceDisableApz;
  }

private:
  FrameMetrics mMetrics;


  ScrollSnapInfo mSnapInfo;


  ViewID mScrollParentId;


  gfx::Color mBackgroundColor;




  nsCString mContentDescription;


  LayoutDeviceIntSize mLineScrollAmount;


  LayoutDeviceIntSize mPageScrollAmount;







  Maybe<LayerClip> mScrollClip;


  bool mHasScrollgrab:1;


  bool mAllowVerticalScrollWithWheel:1;



  bool mIsLayersIdRoot:1;



  bool mUsesContainerScrolling:1;



  bool mForceDisableApz:1;
};
struct ScrollableLayerGuid {
  uint64_t mLayersId;
  uint32_t mPresShellId;
  FrameMetrics::ViewID mScrollId;

  ScrollableLayerGuid()
    : mLayersId(0)
    , mPresShellId(0)
    , mScrollId(0)
  {
  }

  ScrollableLayerGuid(uint64_t aLayersId, uint32_t aPresShellId,
                      FrameMetrics::ViewID aScrollId)
    : mLayersId(aLayersId)
    , mPresShellId(aPresShellId)
    , mScrollId(aScrollId)
  {
  }

  ScrollableLayerGuid(uint64_t aLayersId, const FrameMetrics& aMetrics)
    : mLayersId(aLayersId)
    , mPresShellId(aMetrics.GetPresShellId())
    , mScrollId(aMetrics.GetScrollId())
  {
  }

  ScrollableLayerGuid(const ScrollableLayerGuid& other)
    : mLayersId(other.mLayersId)
    , mPresShellId(other.mPresShellId)
    , mScrollId(other.mScrollId)
  {
  }

  ~ScrollableLayerGuid()
  {
  }

  bool operator==(const ScrollableLayerGuid& other) const
  {
    return mLayersId == other.mLayersId
        && mPresShellId == other.mPresShellId
        && mScrollId == other.mScrollId;
  }

  bool operator!=(const ScrollableLayerGuid& other) const
  {
    return !(*this == other);
  }

  bool operator<(const ScrollableLayerGuid& other) const
  {
    if (mLayersId < other.mLayersId) {
      return true;
    }
    if (mLayersId == other.mLayersId) {
      if (mPresShellId < other.mPresShellId) {
        return true;
      }
      if (mPresShellId == other.mPresShellId) {
        return mScrollId < other.mScrollId;
      }
    }
    return false;
  }

  uint32_t Hash() const
  {
    return HashGeneric(mLayersId, mPresShellId, mScrollId);
  }
};

template <int LogLevel>
gfx::Log<LogLevel>& operator<<(gfx::Log<LogLevel>& log, const ScrollableLayerGuid& aGuid) {
  return log << '(' << aGuid.mLayersId << ',' << aGuid.mPresShellId << ',' << aGuid.mScrollId << ')';
}

struct ZoomConstraints {
  bool mAllowZoom;
  bool mAllowDoubleTapZoom;
  CSSToParentLayerScale mMinZoom;
  CSSToParentLayerScale mMaxZoom;

  ZoomConstraints()
    : mAllowZoom(true)
    , mAllowDoubleTapZoom(true)
  {
                                   ;
  }

  ZoomConstraints(bool aAllowZoom,
                  bool aAllowDoubleTapZoom,
                  const CSSToParentLayerScale& aMinZoom,
                  const CSSToParentLayerScale& aMaxZoom)
    : mAllowZoom(aAllowZoom)
    , mAllowDoubleTapZoom(aAllowDoubleTapZoom)
    , mMinZoom(aMinZoom)
    , mMaxZoom(aMaxZoom)
  {
                                   ;
  }

  ZoomConstraints(const ZoomConstraints& other)
    : mAllowZoom(other.mAllowZoom)
    , mAllowDoubleTapZoom(other.mAllowDoubleTapZoom)
    , mMinZoom(other.mMinZoom)
    , mMaxZoom(other.mMaxZoom)
  {
                                   ;
  }

  ~ZoomConstraints()
  {
                                   ;
  }

  bool operator==(const ZoomConstraints& other) const
  {
    return mAllowZoom == other.mAllowZoom
        && mAllowDoubleTapZoom == other.mAllowDoubleTapZoom
        && mMinZoom == other.mMinZoom
        && mMaxZoom == other.mMaxZoom;
  }

  bool operator!=(const ZoomConstraints& other) const
  {
    return !(*this == other);
  }
};

typedef Maybe<ZoomConstraints> MaybeZoomConstraints;

}
}




class nsBoxLayoutState;
class nsIScrollPositionListener;
class nsIFrame;
class nsPresContext;
class nsIContent;
class nsRenderingContext;
class nsIAtom;
class nsDisplayListBuilder;

namespace mozilla {
struct ContainerLayerParameters;
namespace layers {
class Layer;
}
}






class nsIScrollableFrame : public nsIScrollbarMediator {
public:
  typedef mozilla::CSSIntPoint CSSIntPoint;
  typedef mozilla::ContainerLayerParameters ContainerLayerParameters;
  typedef mozilla::layers::FrameMetrics FrameMetrics;
  typedef mozilla::layers::ScrollSnapInfo ScrollSnapInfo;

  static const nsQueryFrame::FrameIID kFrameIID = nsQueryFrame::nsIScrollableFrame_id; typedef nsIScrollableFrame Has_NS_DECL_QUERYFRAME_TARGET;





  virtual nsIFrame* GetScrolledFrame() const = 0;






  virtual mozilla::ScrollbarStyles GetScrollbarStyles() const = 0;

  enum { HORIZONTAL = 0x01, VERTICAL = 0x02 };





  virtual uint32_t GetScrollbarVisibility() const = 0;





  uint32_t GetPerceivedScrollingDirections() const;






  virtual nsMargin GetActualScrollbarSizes() const = 0;





  virtual nsMargin GetDesiredScrollbarSizes(nsBoxLayoutState* aState) = 0;





  virtual nsMargin GetDesiredScrollbarSizes(nsPresContext* aPresContext,
                                            nsRenderingContext* aRC) = 0;



  virtual nscoord
  GetNondisappearingScrollbarWidth(nsPresContext* aPresContext,
                                   nsRenderingContext* aRC,
                                   mozilla::WritingMode aWM) = 0;
  virtual nsRect GetScrolledRect() const = 0;





  virtual nsRect GetScrollPortRect() const = 0;





  virtual nsPoint GetScrollPosition() const = 0;



  virtual nsPoint GetLogicalScrollPosition() const = 0;
  virtual nsRect GetScrollRange() const = 0;




  virtual nsSize GetScrollPositionClampingScrollPortSize() const = 0;




  virtual nsSize GetLineScrollAmount() const = 0;




  virtual nsSize GetPageScrollAmount() const = 0;
  enum ScrollMode { INSTANT, SMOOTH, SMOOTH_MSD, NORMAL };
  enum ScrollMomentum { NOT_MOMENTUM, SYNTHESIZED_MOMENTUM_EVENT };
  virtual void ScrollTo(nsPoint aScrollPosition, ScrollMode aMode,
                        const nsRect* aRange = nullptr,
                        nsIScrollbarMediator::ScrollSnapMode aSnap
                          = nsIScrollbarMediator::DISABLE_SNAP) = 0;
  virtual void ScrollToCSSPixels(const CSSIntPoint& aScrollPosition,
                                 nsIScrollableFrame::ScrollMode aMode
                                   = nsIScrollableFrame::INSTANT) = 0;
  virtual void ScrollToCSSPixelsApproximate(const mozilla::CSSPoint& aScrollPosition,
                                            nsIAtom *aOrigin = nullptr) = 0;





  virtual CSSIntPoint GetScrollPositionCSSPixels() = 0;



  enum ScrollUnit { DEVICE_PIXELS, LINES, PAGES, WHOLE };
  virtual void ScrollBy(nsIntPoint aDelta, ScrollUnit aUnit, ScrollMode aMode,
                        nsIntPoint* aOverflow = nullptr,
                        nsIAtom* aOrigin = nullptr,
                        ScrollMomentum aMomentum = NOT_MOMENTUM,
                        nsIScrollbarMediator::ScrollSnapMode aSnap
                          = nsIScrollbarMediator::DISABLE_SNAP) = 0;







  virtual void ScrollSnap() = 0;
  virtual void ScrollToRestoredPosition() = 0;





  virtual void AddScrollPositionListener(nsIScrollPositionListener* aListener) = 0;



  virtual void RemoveScrollPositionListener(nsIScrollPositionListener* aListener) = 0;





  virtual void CurPosAttributeChanged(nsIContent* aChild) = 0;





  virtual nsresult PostScrolledAreaEventForCurrentArea() = 0;






  virtual bool IsScrollingActive(nsDisplayListBuilder* aBuilder) = 0;




  virtual bool IsProcessingAsyncScroll() = 0;




  virtual void ResetScrollPositionForLayerPixelAlignment() = 0;



  virtual bool DidHistoryRestore() const = 0;





  virtual void ClearDidHistoryRestore() = 0;




  virtual bool IsRectNearlyVisible(const nsRect& aRect) = 0;




  virtual nsRect ExpandRectToNearlyVisible(const nsRect& aRect) const = 0;





  virtual nsIAtom* LastScrollOrigin() = 0;
  virtual void AllowScrollOriginDowngrade() = 0;
  virtual nsIAtom* LastSmoothScrollOrigin() = 0;




  virtual uint32_t CurrentScrollGeneration() = 0;




  virtual nsPoint LastScrollDestination() = 0;





  virtual void ResetScrollInfoIfGeneration(uint32_t aGeneration) = 0;




  virtual bool WantAsyncScroll() const = 0;




  virtual mozilla::Maybe<mozilla::layers::ScrollMetadata> ComputeScrollMetadata(
    mozilla::layers::Layer* aLayer,
    nsIFrame* aContainerReferenceFrame,
    const ContainerLayerParameters& aParameters,
    const mozilla::DisplayItemClip* aClip) const = 0;




  virtual bool IsIgnoringViewportClipping() const = 0;




  virtual void MarkScrollbarsDirtyForReflow() const = 0;

  virtual void SetTransformingByAPZ(bool aTransforming) = 0;
  virtual bool IsTransformingByAPZ() const = 0;







  virtual void SetScrollableByAPZ(bool aScrollable) = 0;




  virtual void SetZoomableByAPZ(bool aZoomable) = 0;




  virtual bool UsesContainerScrolling() const = 0;
  virtual bool DecideScrollableLayer(nsDisplayListBuilder* aBuilder,
                                     nsRect* aDirtyRect,
                                     bool aAllowCreateDisplayPort) = 0;






  virtual void NotifyApproximateFrameVisibilityUpdate(bool aIgnoreDisplayPort) = 0;






  virtual bool GetDisplayPortAtLastApproximateFrameVisibilityUpdate(nsRect* aDisplayPort) = 0;






  virtual void TriggerDisplayPortExpiration() = 0;




  virtual ScrollSnapInfo GetScrollSnapInfo() const = 0;







  virtual bool DragScroll(mozilla::WidgetEvent* aEvent) = 0;

  virtual void AsyncScrollbarDragRejected() = 0;






  virtual bool IsRootScrollFrameOfDocument() const = 0;
};

class nsSMILValue;
class nsIContent;
class nsAString;

namespace mozilla {
namespace dom {
class SVGAnimationElement;
}
}
class nsISMILAttr
{
public:
  virtual nsresult ValueFromString(const nsAString& aStr,
                                   const mozilla::dom::SVGAnimationElement* aSrcElement,
                                   nsSMILValue& aValue,
                                   bool& aPreventCachingOfSandwich) const = 0;







  virtual nsSMILValue GetBaseValue() const = 0;







  virtual void ClearAnimValue() = 0;







  virtual nsresult SetAnimValue(const nsSMILValue& aValue) = 0;
  virtual const nsIContent* GetTargetNode() const { return nullptr; }




  virtual ~nsISMILAttr() {}
};
class nsIDOMClientRect : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetLeft(float *aLeft) = 0;


  virtual nsresult GetTop(float *aTop) = 0;


  virtual nsresult GetRight(float *aRight) = 0;


  virtual nsresult GetBottom(float *aBottom) = 0;


  virtual nsresult GetWidth(float *aWidth) = 0;


  virtual nsresult GetHeight(float *aHeight) = 0;

};

  template<typename T> struct nsIDOMClientRect::COMTypeInfo<nsIDOMClientRect, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMClientRect::COMTypeInfo<nsIDOMClientRect, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xb2f824c4, 0xd9d3, 0x499b, { 0x8d, 0x3b, 0x45, 0xc8, 0x24, 0x54, 0x97, 0xc6 }};
class nsIDOMClientRectList : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetLength(uint32_t *aLength) = 0;


  virtual nsresult Item(uint32_t index, nsIDOMClientRect * *_retval) = 0;

};

  template<typename T> struct nsIDOMClientRectList::COMTypeInfo<nsIDOMClientRectList, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIDOMClientRectList::COMTypeInfo<nsIDOMClientRectList, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xf474c567, 0xcbcb, 0x458f, { 0xab, 0xad, 0xae, 0x42, 0x36, 0x3d, 0xa2, 0x87 }};
struct nsRect;

namespace mozilla {
namespace dom {

class DOMRectReadOnly : public nsISupports
                      , public nsWrapperCache
{
protected:
  virtual ~DOMRectReadOnly() {}

public:
  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; virtual void DeleteCycleCollectable(void); typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:
  class cycleCollection : public nsXPCOMCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = false) : nsXPCOMCycleCollectionParticipant(aSkip) {} private: public: virtual nsresult TraverseNative(void *p, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "DOMRectReadOnly"; }; virtual void DeleteCycleCollectable(void *p) override { DowncastCCParticipant<DOMRectReadOnly>(p)->DeleteCycleCollectable(); } static DOMRectReadOnly* Downcast(nsISupports* s) { return static_cast<DOMRectReadOnly*>(static_cast<DOMRectReadOnly*>(s)); } static nsISupports* Upcast(DOMRectReadOnly *p) { return static_cast<nsISupports*>(static_cast<DOMRectReadOnly*>(p)); } template<typename T> friend nsISupports* ToSupports(T* p, cycleCollection* dummy); virtual void Unlink(void *p) override; virtual void Trace(void *p, const TraceCallbacks &cb, void *closure) override; static constexpr nsXPCOMCycleCollectionParticipant* GetParticipant() { return &DOMRectReadOnly::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;

  explicit DOMRectReadOnly(nsISupports* aParent)
    : mParent(aParent)
  {
  }

  nsISupports* GetParentObject() const
  {
    do { } while (0);
    return mParent;
  }
  virtual JSObject* WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;

  virtual double X() const = 0;
  virtual double Y() const = 0;
  virtual double Width() const = 0;
  virtual double Height() const = 0;

  double Left() const
  {
    double x = X(), w = Width();
    return std::min(x, x + w);
  }
  double Top() const
  {
    double y = Y(), h = Height();
    return std::min(y, y + h);
  }
  double Right() const
  {
    double x = X(), w = Width();
    return std::max(x, x + w);
  }
  double Bottom() const
  {
    double y = Y(), h = Height();
    return std::max(y, y + h);
  }

protected:
  nsCOMPtr<nsISupports> mParent;
};

class DOMRect final : public DOMRectReadOnly
                    , public nsIDOMClientRect
{
public:
  explicit DOMRect(nsISupports* aParent, double aX = 0, double aY = 0,
                   double aWidth = 0, double aHeight = 0)
    : DOMRectReadOnly(aParent)
    , mX(aX)
    , mY(aY)
    , mWidth(aWidth)
    , mHeight(aHeight)
  {
  }

  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override;
  virtual nsresult GetLeft(float *aLeft) override; virtual nsresult GetTop(float *aTop) override; virtual nsresult GetRight(float *aRight) override; virtual nsresult GetBottom(float *aBottom) override; virtual nsresult GetWidth(float *aWidth) override; virtual nsresult GetHeight(float *aHeight) override;

  static already_AddRefed<DOMRect>
  Constructor(const GlobalObject& aGlobal, ErrorResult& aRV);
  static already_AddRefed<DOMRect>
  Constructor(const GlobalObject& aGlobal, double aX, double aY,
              double aWidth, double aHeight, ErrorResult& aRV);

  virtual JSObject* WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;

  void SetRect(float aX, float aY, float aWidth, float aHeight) {
    mX = aX; mY = aY; mWidth = aWidth; mHeight = aHeight;
  }
  void SetLayoutRect(const nsRect& aLayoutRect);

  virtual double X() const override
  {
    return mX;
  }
  virtual double Y() const override
  {
    return mY;
  }
  virtual double Width() const override
  {
    return mWidth;
  }
  virtual double Height() const override
  {
    return mHeight;
  }

  void SetX(double aX)
  {
    mX = aX;
  }
  void SetY(double aY)
  {
    mY = aY;
  }
  void SetWidth(double aWidth)
  {
    mWidth = aWidth;
  }
  void SetHeight(double aHeight)
  {
    mHeight = aHeight;
  }

protected:
  double mX, mY, mWidth, mHeight;

private:
  ~DOMRect() {};
};

class DOMRectList final : public nsIDOMClientRectList,
                          public nsWrapperCache
{
  ~DOMRectList() {}

public:
  explicit DOMRectList(nsISupports *aParent) : mParent(aParent)
  {
  }

  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; virtual void DeleteCycleCollectable(void); typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:
  class cycleCollection : public nsXPCOMCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = false) : nsXPCOMCycleCollectionParticipant(aSkip) {} private: public: virtual nsresult TraverseNative(void *p, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "DOMRectList"; }; virtual void DeleteCycleCollectable(void *p) override { DowncastCCParticipant<DOMRectList>(p)->DeleteCycleCollectable(); } static DOMRectList* Downcast(nsISupports* s) { return static_cast<DOMRectList*>(static_cast<DOMRectList*>(s)); } static nsISupports* Upcast(DOMRectList *p) { return static_cast<nsISupports*>(static_cast<DOMRectList*>(p)); } template<typename T> friend nsISupports* ToSupports(T* p, cycleCollection* dummy); virtual void Unlink(void *p) override; virtual void Trace(void *p, const TraceCallbacks &cb, void *closure) override; static constexpr nsXPCOMCycleCollectionParticipant* GetParticipant() { return &DOMRectList::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;

  virtual nsresult GetLength(uint32_t *aLength) override; virtual nsresult Item(uint32_t index, nsIDOMClientRect * *_retval) override;

  virtual JSObject* WrapObject(JSContext *cx, JS::Handle<JSObject*> aGivenProto) override;

  nsISupports* GetParentObject()
  {
    return mParent;
  }

  void Append(DOMRect* aElement) { mArray.AppendElement(aElement); }

  static DOMRectList* FromSupports(nsISupports* aSupports)
  {
    return static_cast<DOMRectList*>(aSupports);
  }

  uint32_t Length()
  {
    return mArray.Length();
  }
  DOMRect* Item(uint32_t aIndex)
  {
    return mArray.SafeElementAt(aIndex);
  }
  DOMRect* IndexedGetter(uint32_t aIndex, bool& aFound)
  {
    aFound = aIndex < mArray.Length();
    if (!aFound) {
      return nullptr;
    }
    return mArray[aIndex];
  }

protected:
  nsTArray<RefPtr<DOMRect> > mArray;
  nsCOMPtr<nsISupports> mParent;
};

}
}



namespace mozilla {
namespace dom {


typedef const char* const DOMTokenListSupportedToken;






typedef DOMTokenListSupportedToken* DOMTokenListSupportedTokenArray;

}
}

namespace mozilla {
namespace dom {

class Element;
struct ElementAtoms;
struct NativePropertyHooks;
class ProtoAndIfaceCache;
struct ScrollIntoViewOptionsAtoms;

}
}

namespace mozilla {
namespace dom {

enum class ScrollLogicalPosition : uint8_t {
  Start,
  End,
  EndGuard_
};

namespace ScrollLogicalPositionValues {
extern const EnumEntry strings[3];
}

bool
ToJSValue(JSContext* aCx, ScrollLogicalPosition aArgument, JS::MutableHandle<JS::Value> aValue);


struct ScrollIntoViewOptions : public ScrollOptions
{
                        ScrollLogicalPosition mBlock;

  ScrollIntoViewOptions();

  explicit inline ScrollIntoViewOptions(const FastDictionaryInitializer& )
    : ScrollOptions(FastDictionaryInitializer())
  {

  }

  explicit inline ScrollIntoViewOptions(const ScrollIntoViewOptions& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  ScrollIntoViewOptions&
  operator=(const ScrollIntoViewOptions& aOther);

private:
  static bool
  InitIds(JSContext* cx, ScrollIntoViewOptionsAtoms* atomsCache);
};

namespace binding_detail {
struct FastScrollIntoViewOptions : public ScrollIntoViewOptions
{
  inline FastScrollIntoViewOptions()
    : ScrollIntoViewOptions(FastDictionaryInitializer())
  {

  }
};
}


namespace ElementBinding {

  typedef mozilla::dom::Element NativeType;

  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::Element* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetProtoObjectHandle(JSContext* aCx);

  JSObject*
  GetProtoObject(JSContext* aCx);

  JS::Handle<JSObject*>
  GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true);

  JSObject*
  GetConstructorObject(JSContext* aCx);

}



}
}








namespace mozilla {
namespace dom {

class DOMRect;
struct DOMRectAtoms;
struct DOMRectInitAtoms;
class DOMRectReadOnly;
struct DOMRectReadOnlyAtoms;
struct NativePropertyHooks;
class ProtoAndIfaceCache;

}
}

namespace mozilla {
namespace dom {

struct DOMRectInit : public DictionaryBase
{
                        double mHeight;
                        double mWidth;
                        double mX;
                        double mY;

  DOMRectInit();

  explicit inline DOMRectInit(const FastDictionaryInitializer& )
  {

  }

  explicit inline DOMRectInit(const DOMRectInit& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  DOMRectInit&
  operator=(const DOMRectInit& aOther);

private:
  static bool
  InitIds(JSContext* cx, DOMRectInitAtoms* atomsCache);
};

namespace binding_detail {
struct FastDOMRectInit : public DOMRectInit
{
  inline FastDOMRectInit()
    : DOMRectInit(FastDictionaryInitializer())
  {

  }
};
}


namespace DOMRectBinding {

  typedef mozilla::dom::DOMRect NativeType;

  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::DOMRect* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetProtoObjectHandle(JSContext* aCx);

  JS::Handle<JSObject*>
  GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true);

  JSObject*
  GetConstructorObject(JSContext* aCx);

}



namespace DOMRectReadOnlyBinding {

  typedef mozilla::dom::DOMRectReadOnly NativeType;

  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::DOMRectReadOnly* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetProtoObjectHandle(JSContext* aCx);

  JSObject*
  GetProtoObject(JSContext* aCx);

  JS::Handle<JSObject*>
  GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true);

  JSObject*
  GetConstructorObject(JSContext* aCx);

}



}
}










namespace mozilla {
namespace dom {

class DOMIntersectionObserver;
struct DOMIntersectionObserverAtoms;
class DOMIntersectionObserverEntry;
struct DOMIntersectionObserverEntryAtoms;
struct DOMRectInit;
class DoubleOrDoubleSequence;
class Element;
class IntersectionCallback;
struct IntersectionObserverEntryInitAtoms;
struct IntersectionObserverInitAtoms;
struct NativePropertyHooks;
class OwningDoubleOrDoubleSequence;
class ProtoAndIfaceCache;

}
}

namespace mozilla {
namespace dom {

class DoubleOrDoubleSequence
{
  friend class DoubleOrDoubleSequenceArgument;
  enum Type
  {
    eUninitialized,
    eDouble,
    eDoubleSequence
  };

  union Value
  {
    UnionMember<double > mDouble;
    UnionMember<binding_detail::AutoSequence<double> > mDoubleSequence;

  };

  Type mType;
  Value mValue;

  DoubleOrDoubleSequence(const DoubleOrDoubleSequence&) = delete;
  DoubleOrDoubleSequence& operator=(const DoubleOrDoubleSequence&) = delete;
public:
  explicit inline DoubleOrDoubleSequence()
    : mType(eUninitialized)
  {
  }

  inline ~DoubleOrDoubleSequence()
  {
    Uninit();
  }

  inline double&
  RawSetAsDouble()
  {
    if (mType == eDouble) {
      return mValue.mDouble.Value();
    }
    do { } while (0);
    mType = eDouble;
    return mValue.mDouble.SetValue();
  }

  inline double&
  SetAsDouble()
  {
    if (mType == eDouble) {
      return mValue.mDouble.Value();
    }
    Uninit();
    mType = eDouble;
    return mValue.mDouble.SetValue();
  }

  inline bool
  IsDouble() const
  {
    return mType == eDouble;
  }

  inline double&
  GetAsDouble()
  {
    do { } while (0);
    return mValue.mDouble.Value();
  }

  inline double
  GetAsDouble() const
  {
    do { } while (0);
    return mValue.mDouble.Value();
  }

  inline binding_detail::AutoSequence<double>&
  RawSetAsDoubleSequence()
  {
    if (mType == eDoubleSequence) {
      return mValue.mDoubleSequence.Value();
    }
    do { } while (0);
    mType = eDoubleSequence;
    return mValue.mDoubleSequence.SetValue();
  }

  inline binding_detail::AutoSequence<double>&
  SetAsDoubleSequence()
  {
    if (mType == eDoubleSequence) {
      return mValue.mDoubleSequence.Value();
    }
    Uninit();
    mType = eDoubleSequence;
    return mValue.mDoubleSequence.SetValue();
  }

  inline bool
  IsDoubleSequence() const
  {
    return mType == eDoubleSequence;
  }

  inline binding_detail::AutoSequence<double>&
  GetAsDoubleSequence()
  {
    do { } while (0);
    return mValue.mDoubleSequence.Value();
  }

  inline const Sequence<double>&
  GetAsDoubleSequence() const
  {
    do { } while (0);
    return mValue.mDoubleSequence.Value();
  }

  inline void
  Uninit()
  {
    switch (mType) {
      case eUninitialized: {
        break;
      }
      case eDouble: {
        DestroyDouble();
        break;
      }
      case eDoubleSequence: {
        DestroyDoubleSequence();
        break;
      }
    }
  }

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

private:
  inline void
  DestroyDouble()
  {
    do { } while (0);
    mValue.mDouble.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyDoubleSequence()
  {
    do { } while (0);
    mValue.mDoubleSequence.Destroy();
    mType = eUninitialized;
  }
};


class OwningDoubleOrDoubleSequence : public AllOwningUnionBase
{
  friend void ImplCycleCollectionUnlink(OwningDoubleOrDoubleSequence& aUnion);
  enum Type
  {
    eUninitialized,
    eDouble,
    eDoubleSequence
  };

  union Value
  {
    UnionMember<double > mDouble;
    UnionMember<Sequence<double> > mDoubleSequence;

  };

  Type mType;
  Value mValue;

public:
  explicit inline OwningDoubleOrDoubleSequence()
    : mType(eUninitialized)
  {
  }

  explicit inline OwningDoubleOrDoubleSequence(const OwningDoubleOrDoubleSequence& aOther)
    : mType(eUninitialized)
  {
    *this = aOther;
  }

  inline ~OwningDoubleOrDoubleSequence()
  {
    Uninit();
  }

  double&
  RawSetAsDouble();

  double&
  SetAsDouble();

  bool
  TrySetToDouble(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsDouble() const
  {
    return mType == eDouble;
  }

  inline double&
  GetAsDouble()
  {
    do { } while (0);
    return mValue.mDouble.Value();
  }

  inline double const &
  GetAsDouble() const
  {
    do { } while (0);
    return mValue.mDouble.Value();
  }

  Sequence<double>&
  RawSetAsDoubleSequence();

  Sequence<double>&
  SetAsDoubleSequence();

  bool
  TrySetToDoubleSequence(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsDoubleSequence() const
  {
    return mType == eDoubleSequence;
  }

  inline Sequence<double>&
  GetAsDoubleSequence()
  {
    do { } while (0);
    return mValue.mDoubleSequence.Value();
  }

  inline Sequence<double> const &
  GetAsDoubleSequence() const
  {
    do { } while (0);
    return mValue.mDoubleSequence.Value();
  }

  void
  Uninit();

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceUnion(JSTracer* trc);

  OwningDoubleOrDoubleSequence&
  operator=(const OwningDoubleOrDoubleSequence& aOther);

private:
  void
  DestroyDouble();

  void
  DestroyDoubleSequence();
};


struct IntersectionObserverEntryInit : public DictionaryBase
{
                        DOMRectInit mBoundingClientRect;
                        DOMRectInit mIntersectionRect;
                        DOMRectInit mRootBounds;
                        OwningNonNull<mozilla::dom::Element> mTarget;
                        double mTime;

  IntersectionObserverEntryInit();

  explicit inline IntersectionObserverEntryInit(const FastDictionaryInitializer& )
    : mBoundingClientRect(FastDictionaryInitializer()),
      mIntersectionRect(FastDictionaryInitializer()),
      mRootBounds(FastDictionaryInitializer())
  {

  }

  explicit inline IntersectionObserverEntryInit(const IntersectionObserverEntryInit& aOther)
    : mBoundingClientRect(FastDictionaryInitializer()),
      mIntersectionRect(FastDictionaryInitializer()),
      mRootBounds(FastDictionaryInitializer())
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  IntersectionObserverEntryInit&
  operator=(const IntersectionObserverEntryInit& aOther);

private:
  static bool
  InitIds(JSContext* cx, IntersectionObserverEntryInitAtoms* atomsCache);
};

namespace binding_detail {
struct FastIntersectionObserverEntryInit : public IntersectionObserverEntryInit
{
  inline FastIntersectionObserverEntryInit()
    : IntersectionObserverEntryInit(FastDictionaryInitializer())
  {

  }
};
}


struct IntersectionObserverInit : public DictionaryBase
{
                        RefPtr<mozilla::dom::Element> mRoot;
                        nsString mRootMargin;
                        OwningDoubleOrDoubleSequence mThreshold;

  IntersectionObserverInit();

  explicit inline IntersectionObserverInit(const FastDictionaryInitializer& )
  {

  }

  explicit inline IntersectionObserverInit(const IntersectionObserverInit& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  IntersectionObserverInit&
  operator=(const IntersectionObserverInit& aOther);

private:
  static bool
  InitIds(JSContext* cx, IntersectionObserverInitAtoms* atomsCache);
};

namespace binding_detail {
struct FastIntersectionObserverInit : public IntersectionObserverInit
{
  inline FastIntersectionObserverInit()
    : IntersectionObserverInit(FastDictionaryInitializer())
  {

  }
};
}


class IntersectionCallback : public CallbackFunction
{
public:
  explicit inline IntersectionCallback(JSContext* aCx, JS::Handle<JSObject*> aCallback, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aIncumbentGlobal)
  {
    do { } while (0);
  }

  explicit inline IntersectionCallback(JS::Handle<JSObject*> aCallback, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, FastCallbackConstructor())
  {
    do { } while (0);
  }

  explicit inline IntersectionCallback(JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aAsyncStack, aIncumbentGlobal)
  {
    do { } while (0);
  }

  explicit inline IntersectionCallback(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline void
  Call(const T& thisVal, const Sequence<OwningNonNull<DOMIntersectionObserverEntry>>& entries, DOMIntersectionObserver& observer, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JSCompartment* aCompartment = nullptr)
  {
    do { } while (0);
    if (!aExecutionReason) {
      aExecutionReason = "IntersectionCallback";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aCompartment);
    if (!s.GetContext()) {
      do { } while (0);
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetContext(), thisValJS, entries, observer, aRv);
  }

  inline void
  Call(const Sequence<OwningNonNull<DOMIntersectionObserverEntry>>& entries, DOMIntersectionObserver& observer, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JSCompartment* aCompartment = nullptr)
  {
    do { } while (0);
    if (!aExecutionReason) {
      aExecutionReason = "IntersectionCallback";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aCompartment);
    if (!s.GetContext()) {
      do { } while (0);
      return;
    }
    return Call(s.GetContext(), JS::UndefinedHandleValue, entries, observer, aRv);
  }

  template <typename T>
  inline void
  Call(const T& thisVal, const Sequence<OwningNonNull<DOMIntersectionObserverEntry>>& entries, DOMIntersectionObserver& observer, const char* aExecutionReason = nullptr)
  {
    IgnoredErrorResult rv;
    return Call(thisVal, entries, observer, rv, aExecutionReason);
  }

  inline void
  Call(const Sequence<OwningNonNull<DOMIntersectionObserverEntry>>& entries, DOMIntersectionObserver& observer, const char* aExecutionReason = nullptr)
  {
    IgnoredErrorResult rv;
    return Call(entries, observer, rv, aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const IntersectionCallback& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  void Call(JSContext* cx, JS::Handle<JS::Value> aThisVal, const Sequence<OwningNonNull<DOMIntersectionObserverEntry>>& entries, DOMIntersectionObserver& observer, ErrorResult& aRv);
};


namespace binding_detail {
class FastIntersectionCallback : public IntersectionCallback
{
public:
  explicit inline FastIntersectionCallback(JS::Handle<JSObject*> aCallback)
    : IntersectionCallback(aCallback, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    IntersectionCallback::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    IntersectionCallback::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
}


namespace IntersectionObserverBinding {

  typedef mozilla::dom::DOMIntersectionObserver NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::DOMIntersectionObserver* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetProtoObjectHandle(JSContext* aCx);

  JS::Handle<JSObject*>
  GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true);

  JSObject*
  GetConstructorObject(JSContext* aCx);

}



namespace IntersectionObserverEntryBinding {

  typedef mozilla::dom::DOMIntersectionObserverEntry NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::DOMIntersectionObserverEntry* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetProtoObjectHandle(JSContext* aCx);

  JS::Handle<JSObject*>
  GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true);

  JSObject*
  GetConstructorObject(JSContext* aCx);

}



}
}
namespace mozilla {
struct StyleComplexColor
{
  nscolor mColor;
  uint8_t mForegroundRatio;




  bool mIsAuto;

  static StyleComplexColor FromColor(nscolor aColor) {
    return {aColor, 0, false};
  }
  static StyleComplexColor CurrentColor() {
    return {((nscolor) (((0) << 24) | ((0)<<16) | ((0)<<8) | (0))), 255, false};
  }
  static StyleComplexColor Auto() {
    return {((nscolor) (((0) << 24) | ((0)<<16) | ((0)<<8) | (0))), 255, true};
  }

  bool IsNumericColor() const { return mForegroundRatio == 0; }
  bool IsCurrentColor() const { return mForegroundRatio == 255; }

  bool operator==(const StyleComplexColor& aOther) const {
    return mForegroundRatio == aOther.mForegroundRatio &&
           (IsCurrentColor() || mColor == aOther.mColor) &&
           mIsAuto == aOther.mIsAuto;
  }
  bool operator!=(const StyleComplexColor& aOther) const {
    return !(*this == aOther);
  }
};

}





enum nsCSSKeyword : int16_t {
  eCSSKeyword_UNKNOWN = -1,

eCSSKeyword__moz_activehyperlinktext,
eCSSKeyword__moz_all,
eCSSKeyword__moz_alt_content,
eCSSKeyword__moz_anchor_decoration,
eCSSKeyword__moz_available,
eCSSKeyword__moz_box,
eCSSKeyword__moz_button,
eCSSKeyword__moz_buttondefault,
eCSSKeyword__moz_buttonhoverface,
eCSSKeyword__moz_buttonhovertext,
eCSSKeyword__moz_cellhighlight,
eCSSKeyword__moz_cellhighlighttext,
eCSSKeyword__moz_center,
eCSSKeyword__moz_combobox,
eCSSKeyword__moz_comboboxtext,
eCSSKeyword__moz_block_height,
eCSSKeyword__moz_deck,
eCSSKeyword__moz_default_background_color,
eCSSKeyword__moz_default_color,
eCSSKeyword__moz_desktop,
eCSSKeyword__moz_dialog,
eCSSKeyword__moz_dialogtext,
eCSSKeyword__moz_document,
eCSSKeyword__moz_dragtargetzone,
eCSSKeyword__moz_element,
eCSSKeyword__moz_eventreerow,
eCSSKeyword__moz_field,
eCSSKeyword__moz_fieldtext,
eCSSKeyword__moz_fit_content,
eCSSKeyword__moz_fixed,
eCSSKeyword__moz_grabbing,
eCSSKeyword__moz_grab,
eCSSKeyword__moz_grid_group,
eCSSKeyword__moz_grid_line,
eCSSKeyword__moz_grid,
eCSSKeyword__moz_groupbox,
eCSSKeyword__moz_gtk_info_bar,
eCSSKeyword__moz_gtk_info_bar_text,
eCSSKeyword__moz_hidden_unscrollable,
eCSSKeyword__moz_hyperlinktext,
eCSSKeyword__moz_html_cellhighlight,
eCSSKeyword__moz_html_cellhighlighttext,
eCSSKeyword__moz_image_rect,
eCSSKeyword__moz_info,
eCSSKeyword__moz_inline_box,
eCSSKeyword__moz_inline_grid,
eCSSKeyword__moz_inline_stack,
eCSSKeyword__moz_left,
eCSSKeyword__moz_list,
eCSSKeyword__moz_mac_buttonactivetext,
eCSSKeyword__moz_mac_chrome_active,
eCSSKeyword__moz_mac_chrome_inactive,
eCSSKeyword__moz_mac_defaultbuttontext,
eCSSKeyword__moz_mac_focusring,
eCSSKeyword__moz_mac_fullscreen_button,
eCSSKeyword__moz_mac_menuselect,
eCSSKeyword__moz_mac_menushadow,
eCSSKeyword__moz_mac_menutextdisable,
eCSSKeyword__moz_mac_menutextselect,
eCSSKeyword__moz_mac_disabledtoolbartext,
eCSSKeyword__moz_mac_secondaryhighlight,
eCSSKeyword__moz_max_content,
eCSSKeyword__moz_menuhover,
eCSSKeyword__moz_menuhovertext,
eCSSKeyword__moz_menubartext,
eCSSKeyword__moz_menubarhovertext,
eCSSKeyword__moz_middle_with_baseline,
eCSSKeyword__moz_min_content,
eCSSKeyword__moz_nativehyperlinktext,
eCSSKeyword__moz_none,
eCSSKeyword__moz_oddtreerow,
eCSSKeyword__moz_popup,
eCSSKeyword__moz_pre_space,
eCSSKeyword__moz_pull_down_menu,
eCSSKeyword__moz_right,
eCSSKeyword__moz_scrollbars_horizontal,
eCSSKeyword__moz_scrollbars_none,
eCSSKeyword__moz_scrollbars_vertical,
eCSSKeyword__moz_stack,
eCSSKeyword__moz_text,
eCSSKeyword__moz_use_system_font,
eCSSKeyword__moz_visitedhyperlinktext,
eCSSKeyword__moz_window,
eCSSKeyword__moz_workspace,
eCSSKeyword__moz_zoom_in,
eCSSKeyword__moz_zoom_out,
eCSSKeyword__webkit_box,
eCSSKeyword__webkit_flex,
eCSSKeyword__webkit_inline_box,
eCSSKeyword__webkit_inline_flex,
eCSSKeyword_absolute,
eCSSKeyword_active,
eCSSKeyword_activeborder,
eCSSKeyword_activecaption,
eCSSKeyword_add,
eCSSKeyword_additive,
eCSSKeyword_alias,
eCSSKeyword_all,
eCSSKeyword_all_petite_caps,
eCSSKeyword_all_scroll,
eCSSKeyword_all_small_caps,
eCSSKeyword_alpha,
eCSSKeyword_alternate,
eCSSKeyword_alternate_reverse,
eCSSKeyword_always,
eCSSKeyword_annotation,
eCSSKeyword_appworkspace,
eCSSKeyword_auto,
eCSSKeyword_auto_fill,
eCSSKeyword_auto_fit,
eCSSKeyword_auto_flow,
eCSSKeyword_avoid,
eCSSKeyword_background,
eCSSKeyword_backwards,
eCSSKeyword_balance,
eCSSKeyword_baseline,
eCSSKeyword_bidi_override,
eCSSKeyword_blink,
eCSSKeyword_block,
eCSSKeyword_block_axis,
eCSSKeyword_blur,
eCSSKeyword_bold,
eCSSKeyword_bold_fraktur,
eCSSKeyword_bold_italic,
eCSSKeyword_bold_sans_serif,
eCSSKeyword_bold_script,
eCSSKeyword_bolder,
eCSSKeyword_border_box,
eCSSKeyword_both,
eCSSKeyword_bottom,
eCSSKeyword_bottom_outside,
eCSSKeyword_break_all,
eCSSKeyword_break_word,
eCSSKeyword_brightness,
eCSSKeyword_browser,
eCSSKeyword_bullets,
eCSSKeyword_button,
eCSSKeyword_buttonface,
eCSSKeyword_buttonhighlight,
eCSSKeyword_buttonshadow,
eCSSKeyword_buttontext,
eCSSKeyword_capitalize,
eCSSKeyword_caption,
eCSSKeyword_captiontext,
eCSSKeyword_cell,
eCSSKeyword_center,
eCSSKeyword_ch,
eCSSKeyword_character_variant,
eCSSKeyword_circle,
eCSSKeyword_cjk_decimal,
eCSSKeyword_clip,
eCSSKeyword_clone,
eCSSKeyword_close_quote,
eCSSKeyword_closest_corner,
eCSSKeyword_closest_side,
eCSSKeyword_cm,
eCSSKeyword_col_resize,
eCSSKeyword_collapse,
eCSSKeyword_color,
eCSSKeyword_color_burn,
eCSSKeyword_color_dodge,
eCSSKeyword_common_ligatures,
eCSSKeyword_column,
eCSSKeyword_column_reverse,
eCSSKeyword_condensed,
eCSSKeyword_contain,
eCSSKeyword_content_box,
eCSSKeyword_contents,
eCSSKeyword_context_fill,
eCSSKeyword_context_fill_opacity,
eCSSKeyword_context_menu,
eCSSKeyword_context_stroke,
eCSSKeyword_context_stroke_opacity,
eCSSKeyword_context_value,
eCSSKeyword_continuous,
eCSSKeyword_contrast,
eCSSKeyword_copy,
eCSSKeyword_contextual,
eCSSKeyword_cover,
eCSSKeyword_crop,
eCSSKeyword_cross,
eCSSKeyword_crosshair,
eCSSKeyword_currentcolor,
eCSSKeyword_cursive,
eCSSKeyword_cyclic,
eCSSKeyword_darken,
eCSSKeyword_dashed,
eCSSKeyword_dense,
eCSSKeyword_decimal,
eCSSKeyword_default,
eCSSKeyword_deg,
eCSSKeyword_diagonal_fractions,
eCSSKeyword_dialog,
eCSSKeyword_difference,
eCSSKeyword_digits,
eCSSKeyword_disabled,
eCSSKeyword_disc,
eCSSKeyword_disclosure_closed,
eCSSKeyword_disclosure_open,
eCSSKeyword_discretionary_ligatures,
eCSSKeyword_distribute,
eCSSKeyword_dot,
eCSSKeyword_dotted,
eCSSKeyword_double,
eCSSKeyword_double_circle,
eCSSKeyword_double_struck,
eCSSKeyword_drag,
eCSSKeyword_drop_shadow,
eCSSKeyword_e_resize,
eCSSKeyword_ease,
eCSSKeyword_ease_in,
eCSSKeyword_ease_in_out,
eCSSKeyword_ease_out,
eCSSKeyword_economy,
eCSSKeyword_element,
eCSSKeyword_elements,
eCSSKeyword_ellipse,
eCSSKeyword_ellipsis,
eCSSKeyword_em,
eCSSKeyword_embed,
eCSSKeyword_enabled,
eCSSKeyword_end,
eCSSKeyword_ethiopic_numeric,
eCSSKeyword_ex,
eCSSKeyword_exact,
eCSSKeyword_exclude,
eCSSKeyword_exclusion,
eCSSKeyword_expanded,
eCSSKeyword_extends,
eCSSKeyword_extra_condensed,
eCSSKeyword_extra_expanded,
eCSSKeyword_ew_resize,
eCSSKeyword_fallback,
eCSSKeyword_fantasy,
eCSSKeyword_farthest_side,
eCSSKeyword_farthest_corner,
eCSSKeyword_fill,
eCSSKeyword_filled,
eCSSKeyword_fill_box,
eCSSKeyword_first,
eCSSKeyword_fit_content,
eCSSKeyword_fixed,
eCSSKeyword_flat,
eCSSKeyword_flex,
eCSSKeyword_flex_end,
eCSSKeyword_flex_start,
eCSSKeyword_flip,
eCSSKeyword_flow_root,
eCSSKeyword_forwards,
eCSSKeyword_fraktur,
eCSSKeyword_frames,
eCSSKeyword_from_image,
eCSSKeyword_full_width,
eCSSKeyword_fullscreen,
eCSSKeyword_grab,
eCSSKeyword_grabbing,
eCSSKeyword_grad,
eCSSKeyword_grayscale,
eCSSKeyword_graytext,
eCSSKeyword_grid,
eCSSKeyword_groove,
eCSSKeyword_hard_light,
eCSSKeyword_hebrew,
eCSSKeyword_help,
eCSSKeyword_hidden,
eCSSKeyword_hide,
eCSSKeyword_highlight,
eCSSKeyword_highlighttext,
eCSSKeyword_historical_forms,
eCSSKeyword_historical_ligatures,
eCSSKeyword_horizontal,
eCSSKeyword_horizontal_tb,
eCSSKeyword_hue,
eCSSKeyword_hue_rotate,
eCSSKeyword_hz,
eCSSKeyword_icon,
eCSSKeyword_ignore,
eCSSKeyword_in,
eCSSKeyword_interlace,
eCSSKeyword_inactive,
eCSSKeyword_inactiveborder,
eCSSKeyword_inactivecaption,
eCSSKeyword_inactivecaptiontext,
eCSSKeyword_infinite,
eCSSKeyword_infobackground,
eCSSKeyword_infotext,
eCSSKeyword_inherit,
eCSSKeyword_initial,
eCSSKeyword_inline,
eCSSKeyword_inline_axis,
eCSSKeyword_inline_block,
eCSSKeyword_inline_end,
eCSSKeyword_inline_flex,
eCSSKeyword_inline_grid,
eCSSKeyword_inline_start,
eCSSKeyword_inline_table,
eCSSKeyword_inset,
eCSSKeyword_inside,
eCSSKeyword_inter_character,
eCSSKeyword_inter_word,
eCSSKeyword_interpolatematrix,
eCSSKeyword_accumulatematrix,
eCSSKeyword_intersect,
eCSSKeyword_isolate,
eCSSKeyword_isolate_override,
eCSSKeyword_invert,
eCSSKeyword_italic,
eCSSKeyword_japanese_formal,
eCSSKeyword_japanese_informal,
eCSSKeyword_jis78,
eCSSKeyword_jis83,
eCSSKeyword_jis90,
eCSSKeyword_jis04,
eCSSKeyword_justify,
eCSSKeyword_keep_all,
eCSSKeyword_khz,
eCSSKeyword_korean_hangul_formal,
eCSSKeyword_korean_hanja_formal,
eCSSKeyword_korean_hanja_informal,
eCSSKeyword_landscape,
eCSSKeyword_large,
eCSSKeyword_larger,
eCSSKeyword_last,
eCSSKeyword_last_baseline,
eCSSKeyword_layout,
eCSSKeyword_left,
eCSSKeyword_legacy,
eCSSKeyword_lighten,
eCSSKeyword_lighter,
eCSSKeyword_line_through,
eCSSKeyword_linear,
eCSSKeyword_lining_nums,
eCSSKeyword_list_item,
eCSSKeyword_local,
eCSSKeyword_logical,
eCSSKeyword_looped,
eCSSKeyword_lowercase,
eCSSKeyword_lr,
eCSSKeyword_lr_tb,
eCSSKeyword_ltr,
eCSSKeyword_luminance,
eCSSKeyword_luminosity,
eCSSKeyword_mandatory,
eCSSKeyword_manipulation,
eCSSKeyword_manual,
eCSSKeyword_margin_box,
eCSSKeyword_markers,
eCSSKeyword_match_parent,
eCSSKeyword_match_source,
eCSSKeyword_matrix,
eCSSKeyword_matrix3d,
eCSSKeyword_max_content,
eCSSKeyword_medium,
eCSSKeyword_menu,
eCSSKeyword_menutext,
eCSSKeyword_message_box,
eCSSKeyword_middle,
eCSSKeyword_min_content,
eCSSKeyword_minmax,
eCSSKeyword_mix,
eCSSKeyword_mixed,
eCSSKeyword_mm,
eCSSKeyword_monospace,
eCSSKeyword_move,
eCSSKeyword_ms,
eCSSKeyword_multiply,
eCSSKeyword_n_resize,
eCSSKeyword_narrower,
eCSSKeyword_ne_resize,
eCSSKeyword_nesw_resize,
eCSSKeyword_no_clip,
eCSSKeyword_no_close_quote,
eCSSKeyword_no_common_ligatures,
eCSSKeyword_no_contextual,
eCSSKeyword_no_discretionary_ligatures,
eCSSKeyword_no_drag,
eCSSKeyword_no_drop,
eCSSKeyword_no_historical_ligatures,
eCSSKeyword_no_open_quote,
eCSSKeyword_no_repeat,
eCSSKeyword_none,
eCSSKeyword_normal,
eCSSKeyword_not_allowed,
eCSSKeyword_nowrap,
eCSSKeyword_numeric,
eCSSKeyword_ns_resize,
eCSSKeyword_nw_resize,
eCSSKeyword_nwse_resize,
eCSSKeyword_oblique,
eCSSKeyword_oldstyle_nums,
eCSSKeyword_opacity,
eCSSKeyword_open,
eCSSKeyword_open_quote,
eCSSKeyword_optional,
eCSSKeyword_ordinal,
eCSSKeyword_ornaments,
eCSSKeyword_outset,
eCSSKeyword_outside,
eCSSKeyword_over,
eCSSKeyword_overlay,
eCSSKeyword_overline,
eCSSKeyword_paint,
eCSSKeyword_padding_box,
eCSSKeyword_painted,
eCSSKeyword_pan_x,
eCSSKeyword_pan_y,
eCSSKeyword_paused,
eCSSKeyword_pc,
eCSSKeyword_perspective,
eCSSKeyword_petite_caps,
eCSSKeyword_physical,
eCSSKeyword_plaintext,
eCSSKeyword_pointer,
eCSSKeyword_polygon,
eCSSKeyword_portrait,
eCSSKeyword_pre,
eCSSKeyword_pre_wrap,
eCSSKeyword_pre_line,
eCSSKeyword_preserve_3d,
eCSSKeyword_progress,
eCSSKeyword_progressive,
eCSSKeyword_proportional_nums,
eCSSKeyword_proportional_width,
eCSSKeyword_proximity,
eCSSKeyword_pt,
eCSSKeyword_px,
eCSSKeyword_rad,
eCSSKeyword_read_only,
eCSSKeyword_read_write,
eCSSKeyword_relative,
eCSSKeyword_repeat,
eCSSKeyword_repeat_x,
eCSSKeyword_repeat_y,
eCSSKeyword_reverse,
eCSSKeyword_ridge,
eCSSKeyword_right,
eCSSKeyword_rl,
eCSSKeyword_rl_tb,
eCSSKeyword_rotate,
eCSSKeyword_rotate3d,
eCSSKeyword_rotatex,
eCSSKeyword_rotatey,
eCSSKeyword_rotatez,
eCSSKeyword_round,
eCSSKeyword_row,
eCSSKeyword_row_resize,
eCSSKeyword_row_reverse,
eCSSKeyword_rtl,
eCSSKeyword_ruby,
eCSSKeyword_ruby_base,
eCSSKeyword_ruby_base_container,
eCSSKeyword_ruby_text,
eCSSKeyword_ruby_text_container,
eCSSKeyword_running,
eCSSKeyword_s,
eCSSKeyword_s_resize,
eCSSKeyword_safe,
eCSSKeyword_saturate,
eCSSKeyword_saturation,
eCSSKeyword_scale,
eCSSKeyword_scale_down,
eCSSKeyword_scale3d,
eCSSKeyword_scalex,
eCSSKeyword_scaley,
eCSSKeyword_scalez,
eCSSKeyword_screen,
eCSSKeyword_script,
eCSSKeyword_scroll,
eCSSKeyword_scrollbar,
eCSSKeyword_scrollbar_small,
eCSSKeyword_scrollbar_horizontal,
eCSSKeyword_scrollbar_vertical,
eCSSKeyword_se_resize,
eCSSKeyword_select_after,
eCSSKeyword_select_all,
eCSSKeyword_select_before,
eCSSKeyword_select_menu,
eCSSKeyword_select_same,
eCSSKeyword_self_end,
eCSSKeyword_self_start,
eCSSKeyword_semi_condensed,
eCSSKeyword_semi_expanded,
eCSSKeyword_separate,
eCSSKeyword_sepia,
eCSSKeyword_serif,
eCSSKeyword_sesame,
eCSSKeyword_show,
eCSSKeyword_sideways,
eCSSKeyword_sideways_lr,
eCSSKeyword_sideways_right,
eCSSKeyword_sideways_rl,
eCSSKeyword_simp_chinese_formal,
eCSSKeyword_simp_chinese_informal,
eCSSKeyword_simplified,
eCSSKeyword_skew,
eCSSKeyword_skewx,
eCSSKeyword_skewy,
eCSSKeyword_slashed_zero,
eCSSKeyword_slice,
eCSSKeyword_small,
eCSSKeyword_small_caps,
eCSSKeyword_small_caption,
eCSSKeyword_smaller,
eCSSKeyword_smooth,
eCSSKeyword_soft,
eCSSKeyword_soft_light,
eCSSKeyword_solid,
eCSSKeyword_space_around,
eCSSKeyword_space_between,
eCSSKeyword_space_evenly,
eCSSKeyword_span,
eCSSKeyword_spell_out,
eCSSKeyword_square,
eCSSKeyword_stacked_fractions,
eCSSKeyword_start,
eCSSKeyword_static,
eCSSKeyword_standalone,
eCSSKeyword_status_bar,
eCSSKeyword_step_end,
eCSSKeyword_step_start,
eCSSKeyword_sticky,
eCSSKeyword_stretch,
eCSSKeyword_stretch_to_fit,
eCSSKeyword_stretched,
eCSSKeyword_strict,
eCSSKeyword_stroke,
eCSSKeyword_stroke_box,
eCSSKeyword_style,
eCSSKeyword_styleset,
eCSSKeyword_stylistic,
eCSSKeyword_sub,
eCSSKeyword_subgrid,
eCSSKeyword_subtract,
eCSSKeyword_super,
eCSSKeyword_sw_resize,
eCSSKeyword_swash,
eCSSKeyword_swap,
eCSSKeyword_table,
eCSSKeyword_table_caption,
eCSSKeyword_table_cell,
eCSSKeyword_table_column,
eCSSKeyword_table_column_group,
eCSSKeyword_table_footer_group,
eCSSKeyword_table_header_group,
eCSSKeyword_table_row,
eCSSKeyword_table_row_group,
eCSSKeyword_tabular_nums,
eCSSKeyword_tailed,
eCSSKeyword_tb,
eCSSKeyword_tb_rl,
eCSSKeyword_text,
eCSSKeyword_text_bottom,
eCSSKeyword_text_top,
eCSSKeyword_thick,
eCSSKeyword_thin,
eCSSKeyword_threeddarkshadow,
eCSSKeyword_threedface,
eCSSKeyword_threedhighlight,
eCSSKeyword_threedlightshadow,
eCSSKeyword_threedshadow,
eCSSKeyword_titling_caps,
eCSSKeyword_toggle,
eCSSKeyword_top,
eCSSKeyword_top_outside,
eCSSKeyword_trad_chinese_formal,
eCSSKeyword_trad_chinese_informal,
eCSSKeyword_traditional,
eCSSKeyword_translate,
eCSSKeyword_translate3d,
eCSSKeyword_translatex,
eCSSKeyword_translatey,
eCSSKeyword_translatez,
eCSSKeyword_transparent,
eCSSKeyword_triangle,
eCSSKeyword_tri_state,
eCSSKeyword_ultra_condensed,
eCSSKeyword_ultra_expanded,
eCSSKeyword_under,
eCSSKeyword_underline,
eCSSKeyword_unicase,
eCSSKeyword_unsafe,
eCSSKeyword_unset,
eCSSKeyword_uppercase,
eCSSKeyword_upright,
eCSSKeyword_vertical,
eCSSKeyword_vertical_lr,
eCSSKeyword_vertical_rl,
eCSSKeyword_vertical_text,
eCSSKeyword_view_box,
eCSSKeyword_visible,
eCSSKeyword_visiblefill,
eCSSKeyword_visiblepainted,
eCSSKeyword_visiblestroke,
eCSSKeyword_w_resize,
eCSSKeyword_wait,
eCSSKeyword_wavy,
eCSSKeyword_weight,
eCSSKeyword_wider,
eCSSKeyword_window,
eCSSKeyword_windowframe,
eCSSKeyword_windowtext,
eCSSKeyword_words,
eCSSKeyword_wrap,
eCSSKeyword_wrap_reverse,
eCSSKeyword_write_only,
eCSSKeyword_x_large,
eCSSKeyword_x_small,
eCSSKeyword_xx_large,
eCSSKeyword_xx_small,
eCSSKeyword_zoom_in,
eCSSKeyword_zoom_out,


eCSSKeyword_radio,
eCSSKeyword_checkbox,
eCSSKeyword_button_bevel,
eCSSKeyword_toolbox,
eCSSKeyword_toolbar,
eCSSKeyword_toolbarbutton,
eCSSKeyword_toolbargripper,
eCSSKeyword_dualbutton,
eCSSKeyword_toolbarbutton_dropdown,
eCSSKeyword_button_arrow_up,
eCSSKeyword_button_arrow_down,
eCSSKeyword_button_arrow_next,
eCSSKeyword_button_arrow_previous,
eCSSKeyword_separator,
eCSSKeyword_splitter,
eCSSKeyword_statusbar,
eCSSKeyword_statusbarpanel,
eCSSKeyword_resizerpanel,
eCSSKeyword_resizer,
eCSSKeyword_listbox,
eCSSKeyword_listitem,
eCSSKeyword_numbers,
eCSSKeyword_number_input,
eCSSKeyword_treeview,
eCSSKeyword_treeitem,
eCSSKeyword_treetwisty,
eCSSKeyword_treetwistyopen,
eCSSKeyword_treeline,
eCSSKeyword_treeheader,
eCSSKeyword_treeheadercell,
eCSSKeyword_treeheadersortarrow,
eCSSKeyword_progressbar,
eCSSKeyword_progressbar_vertical,
eCSSKeyword_progresschunk,
eCSSKeyword_progresschunk_vertical,
eCSSKeyword_tab,
eCSSKeyword_tabpanels,
eCSSKeyword_tabpanel,
eCSSKeyword_tab_scroll_arrow_back,
eCSSKeyword_tab_scroll_arrow_forward,
eCSSKeyword_tooltip,
eCSSKeyword_spinner,
eCSSKeyword_spinner_upbutton,
eCSSKeyword_spinner_downbutton,
eCSSKeyword_spinner_textfield,
eCSSKeyword_scrollbarbutton_up,
eCSSKeyword_scrollbarbutton_down,
eCSSKeyword_scrollbarbutton_left,
eCSSKeyword_scrollbarbutton_right,
eCSSKeyword_scrollbartrack_horizontal,
eCSSKeyword_scrollbartrack_vertical,
eCSSKeyword_scrollbarthumb_horizontal,
eCSSKeyword_scrollbarthumb_vertical,
eCSSKeyword_sheet,
eCSSKeyword_textfield,
eCSSKeyword_textfield_multiline,
eCSSKeyword_caret,
eCSSKeyword_searchfield,
eCSSKeyword_menubar,
eCSSKeyword_menupopup,
eCSSKeyword_menuitem,
eCSSKeyword_checkmenuitem,
eCSSKeyword_radiomenuitem,
eCSSKeyword_menucheckbox,
eCSSKeyword_menuradio,
eCSSKeyword_menuseparator,
eCSSKeyword_menuarrow,
eCSSKeyword_menuimage,
eCSSKeyword_menuitemtext,
eCSSKeyword_menulist,
eCSSKeyword_menulist_button,
eCSSKeyword_menulist_text,
eCSSKeyword_menulist_textfield,
eCSSKeyword_meterbar,
eCSSKeyword_meterchunk,
eCSSKeyword_minimal_ui,
eCSSKeyword_range,
eCSSKeyword_range_thumb,
eCSSKeyword_sans_serif,
eCSSKeyword_sans_serif_bold_italic,
eCSSKeyword_sans_serif_italic,
eCSSKeyword_scale_horizontal,
eCSSKeyword_scale_vertical,
eCSSKeyword_scalethumb_horizontal,
eCSSKeyword_scalethumb_vertical,
eCSSKeyword_scalethumbstart,
eCSSKeyword_scalethumbend,
eCSSKeyword_scalethumbtick,
eCSSKeyword_groupbox,
eCSSKeyword_checkbox_container,
eCSSKeyword_radio_container,
eCSSKeyword_checkbox_label,
eCSSKeyword_radio_label,
eCSSKeyword_button_focus,
eCSSKeyword__moz_win_media_toolbox,
eCSSKeyword__moz_win_communications_toolbox,
eCSSKeyword__moz_win_browsertabbar_toolbox,
eCSSKeyword__moz_win_mediatext,
eCSSKeyword__moz_win_communicationstext,
eCSSKeyword__moz_win_glass,
eCSSKeyword__moz_win_borderless_glass,
eCSSKeyword__moz_window_titlebar,
eCSSKeyword__moz_window_titlebar_maximized,
eCSSKeyword__moz_window_frame_left,
eCSSKeyword__moz_window_frame_right,
eCSSKeyword__moz_window_frame_bottom,
eCSSKeyword__moz_window_button_close,
eCSSKeyword__moz_window_button_minimize,
eCSSKeyword__moz_window_button_maximize,
eCSSKeyword__moz_window_button_restore,
eCSSKeyword__moz_window_button_box,
eCSSKeyword__moz_window_button_box_maximized,
eCSSKeyword__moz_mac_help_button,
eCSSKeyword__moz_win_exclude_glass,
eCSSKeyword__moz_mac_vibrancy_light,
eCSSKeyword__moz_mac_vibrancy_dark,
eCSSKeyword__moz_mac_disclosure_button_closed,
eCSSKeyword__moz_mac_disclosure_button_open,
eCSSKeyword__moz_mac_source_list,
eCSSKeyword__moz_mac_source_list_selection,
eCSSKeyword__moz_mac_active_source_list_selection,
eCSSKeyword_alphabetic,
eCSSKeyword_bevel,
eCSSKeyword_butt,
eCSSKeyword_central,
eCSSKeyword_crispedges,
eCSSKeyword_evenodd,
eCSSKeyword_geometricprecision,
eCSSKeyword_hanging,
eCSSKeyword_ideographic,
eCSSKeyword_linearrgb,
eCSSKeyword_mathematical,

eCSSKeyword_miter,
eCSSKeyword_no_change,
eCSSKeyword_non_scaling_stroke,
eCSSKeyword_nonzero,
eCSSKeyword_optimizelegibility,
eCSSKeyword_optimizequality,
eCSSKeyword_optimizespeed,
eCSSKeyword_reset_size,


eCSSKeyword_srgb,
eCSSKeyword_symbolic,
eCSSKeyword_symbols,
eCSSKeyword_text_after_edge,
eCSSKeyword_text_before_edge,
eCSSKeyword_use_script,
eCSSKeyword__moz_crisp_edges,
eCSSKeyword_space,
 eCSSKeyword_COUNT
};



class nsCSSKeywords {
public:
  static void AddRefTable(void);
  static void ReleaseTable(void);


  static nsCSSKeyword LookupKeyword(const nsACString& aKeyword);
  static nsCSSKeyword LookupKeyword(const nsAString& aKeyword);


  static const nsAFlatCString& GetStringValue(nsCSSKeyword aKeyword);
};
enum nsCSSPropertyID {
  eCSSProperty_UNKNOWN = -1,






eCSSProperty_align_content,
eCSSProperty_align_items,
eCSSProperty_align_self,
eCSSProperty_animation_delay,
eCSSProperty_animation_direction,
eCSSProperty_animation_duration,
eCSSProperty_animation_fill_mode,
eCSSProperty_animation_iteration_count,
eCSSProperty_animation_name,
eCSSProperty_animation_play_state,
eCSSProperty_animation_timing_function,
eCSSProperty__moz_appearance,
eCSSProperty_appearance,
eCSSProperty_backface_visibility,
eCSSProperty_background_attachment,
eCSSProperty_background_blend_mode,
eCSSProperty_background_clip,
eCSSProperty_background_color,
eCSSProperty_background_image,
eCSSProperty_background_origin,
eCSSProperty_background_position_x,
eCSSProperty_background_position_y,
eCSSProperty_background_repeat,
eCSSProperty_background_size,
eCSSProperty__moz_binding,
eCSSProperty_block_size,
eCSSProperty_border_block_end_color,
eCSSProperty_border_block_end_style,
eCSSProperty_border_block_end_width,
eCSSProperty_border_block_start_color,
eCSSProperty_border_block_start_style,
eCSSProperty_border_block_start_width,
eCSSProperty_border_bottom_color,
eCSSProperty__moz_border_bottom_colors,
eCSSProperty_border_bottom_left_radius,
eCSSProperty_border_bottom_right_radius,
eCSSProperty_border_bottom_style,
eCSSProperty_border_bottom_width,
eCSSProperty_border_collapse,
eCSSProperty_border_image_outset,
eCSSProperty_border_image_repeat,
eCSSProperty_border_image_slice,
eCSSProperty_border_image_source,
eCSSProperty_border_image_width,
eCSSProperty_border_inline_end_color,
eCSSProperty_border_inline_end_style,
eCSSProperty_border_inline_end_width,
eCSSProperty_border_inline_start_color,
eCSSProperty_border_inline_start_style,
eCSSProperty_border_inline_start_width,
eCSSProperty_border_left_color,
eCSSProperty__moz_border_left_colors,
eCSSProperty_border_left_style,
eCSSProperty_border_left_width,
eCSSProperty_border_right_color,
eCSSProperty__moz_border_right_colors,
eCSSProperty_border_right_style,
eCSSProperty_border_right_width,
eCSSProperty_border_spacing,
eCSSProperty_border_top_color,
eCSSProperty__moz_border_top_colors,
eCSSProperty_border_top_left_radius,
eCSSProperty_border_top_right_radius,
eCSSProperty_border_top_style,
eCSSProperty_border_top_width,
eCSSProperty_bottom,
eCSSProperty__moz_box_align,
eCSSProperty_box_decoration_break,
eCSSProperty__moz_box_direction,
eCSSProperty__moz_box_flex,
eCSSProperty__moz_box_ordinal_group,
eCSSProperty__moz_box_orient,
eCSSProperty__moz_box_pack,
eCSSProperty_box_shadow,
eCSSProperty_box_sizing,
eCSSProperty_caption_side,
eCSSProperty_caret_color,
eCSSProperty_clear,
eCSSProperty_clip,
eCSSProperty_clip_path,
eCSSProperty_clip_rule,
eCSSProperty_color,
eCSSProperty_color_adjust,
eCSSProperty_color_interpolation,
eCSSProperty_color_interpolation_filters,
eCSSProperty_column_count,
eCSSProperty_column_fill,
eCSSProperty_column_gap,
eCSSProperty_column_rule_color,
eCSSProperty_column_rule_style,
eCSSProperty_column_rule_width,
eCSSProperty_column_span,
eCSSProperty_column_width,
eCSSProperty_contain,
eCSSProperty_content,
eCSSProperty__moz_control_character_visibility,
eCSSProperty_counter_increment,
eCSSProperty_counter_reset,
eCSSProperty_cursor,
eCSSProperty_direction,
eCSSProperty_display,
eCSSProperty_dominant_baseline,
eCSSProperty_empty_cells,
eCSSProperty_fill,
eCSSProperty_fill_opacity,
eCSSProperty_fill_rule,
eCSSProperty_filter,
eCSSProperty_flex_basis,
eCSSProperty_flex_direction,
eCSSProperty_flex_grow,
eCSSProperty_flex_shrink,
eCSSProperty_flex_wrap,
eCSSProperty_float_,
eCSSProperty__moz_float_edge,
eCSSProperty_flood_color,
eCSSProperty_flood_opacity,
eCSSProperty_font_family,
eCSSProperty_font_feature_settings,
eCSSProperty_font_kerning,
eCSSProperty_font_language_override,
eCSSProperty_font_size,
eCSSProperty_font_size_adjust,
eCSSProperty_font_stretch,
eCSSProperty_font_style,
eCSSProperty_font_synthesis,
eCSSProperty_font_variant_alternates,
eCSSProperty_font_variant_caps,
eCSSProperty_font_variant_east_asian,
eCSSProperty_font_variant_ligatures,
eCSSProperty_font_variant_numeric,
eCSSProperty_font_variant_position,
eCSSProperty_font_variation_settings,
eCSSProperty_font_weight,
eCSSProperty__moz_force_broken_image_icon,
eCSSProperty_grid_auto_columns,
eCSSProperty_grid_auto_flow,
eCSSProperty_grid_auto_rows,
eCSSProperty_grid_column_end,
eCSSProperty_grid_column_gap,
eCSSProperty_grid_column_start,
eCSSProperty_grid_row_end,
eCSSProperty_grid_row_gap,
eCSSProperty_grid_row_start,
eCSSProperty_grid_template_areas,
eCSSProperty_grid_template_columns,
eCSSProperty_grid_template_rows,
eCSSProperty_height,
eCSSProperty_hyphens,
eCSSProperty_initial_letter,
eCSSProperty_image_orientation,
eCSSProperty__moz_image_region,
eCSSProperty_image_rendering,
eCSSProperty_ime_mode,
eCSSProperty_inline_size,
eCSSProperty_isolation,
eCSSProperty_justify_content,
eCSSProperty_justify_items,
eCSSProperty_justify_self,
eCSSProperty__x_lang,
eCSSProperty_left,
eCSSProperty_letter_spacing,
eCSSProperty_lighting_color,
eCSSProperty_line_height,
eCSSProperty_list_style_image,
eCSSProperty_list_style_position,
eCSSProperty_list_style_type,
eCSSProperty_margin_block_end,
eCSSProperty_margin_block_start,
eCSSProperty_margin_bottom,
eCSSProperty_margin_inline_end,
eCSSProperty_margin_inline_start,
eCSSProperty_margin_left,
eCSSProperty_margin_right,
eCSSProperty_margin_top,
eCSSProperty_marker_end,
eCSSProperty_marker_mid,
eCSSProperty_marker_start,
eCSSProperty_mask_clip,
eCSSProperty_mask_composite,
eCSSProperty_mask_image,
eCSSProperty_mask_mode,
eCSSProperty_mask_origin,
eCSSProperty_mask_position_x,
eCSSProperty_mask_position_y,
eCSSProperty_mask_repeat,
eCSSProperty_mask_size,
eCSSProperty_mask_type,
eCSSProperty__moz_math_display,
eCSSProperty__moz_math_variant,
eCSSProperty_max_block_size,
eCSSProperty_max_height,
eCSSProperty_max_inline_size,
eCSSProperty_max_width,
eCSSProperty_min_block_size,
eCSSProperty__moz_min_font_size_ratio,
eCSSProperty_min_height,
eCSSProperty_min_inline_size,
eCSSProperty_min_width,
eCSSProperty_mix_blend_mode,
eCSSProperty_object_fit,
eCSSProperty_object_position,
eCSSProperty_offset_block_end,
eCSSProperty_offset_block_start,
eCSSProperty_offset_inline_end,
eCSSProperty_offset_inline_start,
eCSSProperty_opacity,
eCSSProperty_order,
eCSSProperty__moz_orient,
eCSSProperty__moz_osx_font_smoothing,
eCSSProperty_outline_color,
eCSSProperty_outline_offset,
eCSSProperty__moz_outline_radius_bottomleft,
eCSSProperty__moz_outline_radius_bottomright,
eCSSProperty__moz_outline_radius_topleft,
eCSSProperty__moz_outline_radius_topright,
eCSSProperty_outline_style,
eCSSProperty_outline_width,
eCSSProperty_overflow_clip_box,
eCSSProperty_overflow_x,
eCSSProperty_overflow_y,
eCSSProperty_padding_block_end,
eCSSProperty_padding_block_start,
eCSSProperty_padding_bottom,
eCSSProperty_padding_inline_end,
eCSSProperty_padding_inline_start,
eCSSProperty_padding_left,
eCSSProperty_padding_right,
eCSSProperty_padding_top,
eCSSProperty_page_break_after,
eCSSProperty_page_break_before,
eCSSProperty_page_break_inside,
eCSSProperty_paint_order,
eCSSProperty_perspective,
eCSSProperty_perspective_origin,
eCSSProperty_pointer_events,
eCSSProperty_position,
eCSSProperty_quotes,
eCSSProperty_resize,
eCSSProperty_right,
eCSSProperty_ruby_align,
eCSSProperty_ruby_position,
eCSSProperty__moz_script_level,
eCSSProperty__moz_script_min_size,
eCSSProperty__moz_script_size_multiplier,
eCSSProperty_scroll_behavior,
eCSSProperty_scroll_snap_coordinate,
eCSSProperty_scroll_snap_destination,
eCSSProperty_scroll_snap_points_x,
eCSSProperty_scroll_snap_points_y,
eCSSProperty_scroll_snap_type_x,
eCSSProperty_scroll_snap_type_y,
eCSSProperty_shape_outside,
eCSSProperty_shape_rendering,
eCSSProperty__x_span,
eCSSProperty__moz_stack_sizing,
eCSSProperty_stop_color,
eCSSProperty_stop_opacity,
eCSSProperty_stroke,
eCSSProperty_stroke_dasharray,
eCSSProperty_stroke_dashoffset,
eCSSProperty_stroke_linecap,
eCSSProperty_stroke_linejoin,
eCSSProperty_stroke_miterlimit,
eCSSProperty_stroke_opacity,
eCSSProperty_stroke_width,
eCSSProperty__x_system_font,
eCSSProperty__moz_tab_size,
eCSSProperty_table_layout,
eCSSProperty_text_align,
eCSSProperty_text_align_last,
eCSSProperty_text_anchor,
eCSSProperty_text_combine_upright,
eCSSProperty_text_decoration_color,
eCSSProperty_text_decoration_line,
eCSSProperty_text_decoration_style,
eCSSProperty_text_emphasis_color,
eCSSProperty_text_emphasis_position,
eCSSProperty_text_emphasis_style,
eCSSProperty__webkit_text_fill_color,
eCSSProperty_text_indent,
eCSSProperty_text_justify,
eCSSProperty_text_orientation,
eCSSProperty_text_overflow,
eCSSProperty_text_rendering,
eCSSProperty_text_shadow,
eCSSProperty__moz_text_size_adjust,
eCSSProperty__webkit_text_stroke_color,
eCSSProperty__webkit_text_stroke_width,
eCSSProperty_text_transform,
eCSSProperty__x_text_zoom,
eCSSProperty_top,
eCSSProperty__moz_top_layer,
eCSSProperty_touch_action,
eCSSProperty_transform,
eCSSProperty_transform_box,
eCSSProperty_transform_origin,
eCSSProperty_transform_style,
eCSSProperty_transition_delay,
eCSSProperty_transition_duration,
eCSSProperty_transition_property,
eCSSProperty_transition_timing_function,
eCSSProperty_unicode_bidi,
eCSSProperty__moz_user_focus,
eCSSProperty__moz_user_input,
eCSSProperty__moz_user_modify,
eCSSProperty__moz_user_select,
eCSSProperty_vector_effect,
eCSSProperty_vertical_align,
eCSSProperty_visibility,
eCSSProperty_white_space,
eCSSProperty_width,
eCSSProperty_will_change,
eCSSProperty__moz_window_dragging,
eCSSProperty__moz_window_shadow,
eCSSProperty_word_break,
eCSSProperty_word_spacing,
eCSSProperty_overflow_wrap,
eCSSProperty_writing_mode,
eCSSProperty_z_index,



  eCSSProperty_COUNT_no_shorthands,

  eCSSProperty_COUNT_DUMMY = eCSSProperty_COUNT_no_shorthands - 1,




eCSSProperty_all,





eCSSProperty_animation,
eCSSProperty_background,
eCSSProperty_background_position,
eCSSProperty_border,





eCSSProperty_border_block_end,
eCSSProperty_border_block_start,
eCSSProperty_border_bottom,
eCSSProperty_border_color,






eCSSProperty_border_image,
eCSSProperty_border_inline_end,
eCSSProperty_border_inline_start,
eCSSProperty_border_left,
eCSSProperty_border_radius,





eCSSProperty_border_right,
eCSSProperty_border_style,





eCSSProperty_border_top,
eCSSProperty_border_width,
eCSSProperty_column_rule,
eCSSProperty_columns,
eCSSProperty_flex,
eCSSProperty_flex_flow,
eCSSProperty_font,
eCSSProperty_font_variant,
eCSSProperty_grid,





eCSSProperty_grid_area,
eCSSProperty_grid_column,
eCSSProperty_grid_gap,





eCSSProperty_grid_row,
eCSSProperty_grid_template,
eCSSProperty_list_style,
eCSSProperty_margin,
eCSSProperty_marker,
eCSSProperty_mask,
eCSSProperty_mask_position,
eCSSProperty_outline,
eCSSProperty__moz_outline_radius,
eCSSProperty_overflow,
eCSSProperty_padding,
eCSSProperty_place_content,





eCSSProperty_place_items,





eCSSProperty_place_self,
eCSSProperty_scroll_snap_type,
eCSSProperty_text_decoration,
eCSSProperty_text_emphasis,
eCSSProperty__webkit_text_stroke,
eCSSProperty__moz_transform,
eCSSProperty_transition,


  eCSSProperty_COUNT,

  eCSSProperty_COUNT_DUMMY2 = eCSSProperty_COUNT - 1,




eCSSPropertyAlias_WordWrap,



eCSSPropertyAlias_MozTransformOrigin,



eCSSPropertyAlias_MozPerspectiveOrigin,



eCSSPropertyAlias_MozPerspective,



eCSSPropertyAlias_MozTransformStyle,



eCSSPropertyAlias_MozBackfaceVisibility,



eCSSPropertyAlias_MozBorderImage,



eCSSPropertyAlias_MozTransition,



eCSSPropertyAlias_MozTransitionDelay,



eCSSPropertyAlias_MozTransitionDuration,



eCSSPropertyAlias_MozTransitionProperty,



eCSSPropertyAlias_MozTransitionTimingFunction,



eCSSPropertyAlias_MozAnimation,



eCSSPropertyAlias_MozAnimationDelay,



eCSSPropertyAlias_MozAnimationDirection,



eCSSPropertyAlias_MozAnimationDuration,



eCSSPropertyAlias_MozAnimationFillMode,



eCSSPropertyAlias_MozAnimationIterationCount,



eCSSPropertyAlias_MozAnimationName,



eCSSPropertyAlias_MozAnimationPlayState,



eCSSPropertyAlias_MozAnimationTimingFunction,



eCSSPropertyAlias_MozBoxSizing,



eCSSPropertyAlias_MozFontFeatureSettings,



eCSSPropertyAlias_MozFontLanguageOverride,



eCSSPropertyAlias_MozPaddingEnd,



eCSSPropertyAlias_MozPaddingStart,



eCSSPropertyAlias_MozMarginEnd,



eCSSPropertyAlias_MozMarginStart,



eCSSPropertyAlias_MozBorderEnd,



eCSSPropertyAlias_MozBorderEndColor,



eCSSPropertyAlias_MozBorderEndStyle,



eCSSPropertyAlias_MozBorderEndWidth,



eCSSPropertyAlias_MozBorderStart,



eCSSPropertyAlias_MozBorderStartColor,



eCSSPropertyAlias_MozBorderStartStyle,



eCSSPropertyAlias_MozBorderStartWidth,



eCSSPropertyAlias_MozHyphens,



eCSSPropertyAlias_MozColumnCount,



eCSSPropertyAlias_MozColumnFill,



eCSSPropertyAlias_MozColumnGap,



eCSSPropertyAlias_MozColumnRule,



eCSSPropertyAlias_MozColumnRuleColor,



eCSSPropertyAlias_MozColumnRuleStyle,



eCSSPropertyAlias_MozColumnRuleWidth,



eCSSPropertyAlias_MozColumnWidth,



eCSSPropertyAlias_MozColumns,







eCSSPropertyAlias_WebkitAnimation,



eCSSPropertyAlias_WebkitAnimationDelay,



eCSSPropertyAlias_WebkitAnimationDirection,



eCSSPropertyAlias_WebkitAnimationDuration,



eCSSPropertyAlias_WebkitAnimationFillMode,



eCSSPropertyAlias_WebkitAnimationIterationCount,



eCSSPropertyAlias_WebkitAnimationName,



eCSSPropertyAlias_WebkitAnimationPlayState,



eCSSPropertyAlias_WebkitAnimationTimingFunction,




eCSSPropertyAlias_WebkitAppearance,




eCSSPropertyAlias_WebkitFilter,



eCSSPropertyAlias_WebkitTextSizeAdjust,




eCSSPropertyAlias_WebkitTransform,



eCSSPropertyAlias_WebkitTransformOrigin,



eCSSPropertyAlias_WebkitTransformStyle,



eCSSPropertyAlias_WebkitBackfaceVisibility,



eCSSPropertyAlias_WebkitPerspective,



eCSSPropertyAlias_WebkitPerspectiveOrigin,




eCSSPropertyAlias_WebkitTransition,



eCSSPropertyAlias_WebkitTransitionDelay,



eCSSPropertyAlias_WebkitTransitionDuration,



eCSSPropertyAlias_WebkitTransitionProperty,



eCSSPropertyAlias_WebkitTransitionTimingFunction,




eCSSPropertyAlias_WebkitBorderRadius,



eCSSPropertyAlias_WebkitBorderTopLeftRadius,



eCSSPropertyAlias_WebkitBorderTopRightRadius,



eCSSPropertyAlias_WebkitBorderBottomLeftRadius,



eCSSPropertyAlias_WebkitBorderBottomRightRadius,




eCSSPropertyAlias_WebkitBackgroundClip,



eCSSPropertyAlias_WebkitBackgroundOrigin,



eCSSPropertyAlias_WebkitBackgroundSize,




eCSSPropertyAlias_WebkitBorderImage,




eCSSPropertyAlias_WebkitBoxShadow,



eCSSPropertyAlias_WebkitBoxSizing,
eCSSPropertyAlias_WebkitBoxFlex,



eCSSPropertyAlias_WebkitBoxOrdinalGroup,



eCSSPropertyAlias_WebkitBoxOrient,



eCSSPropertyAlias_WebkitBoxDirection,



eCSSPropertyAlias_WebkitBoxAlign,



eCSSPropertyAlias_WebkitBoxPack,






eCSSPropertyAlias_WebkitFlexDirection,



eCSSPropertyAlias_WebkitFlexWrap,



eCSSPropertyAlias_WebkitFlexFlow,



eCSSPropertyAlias_WebkitOrder,



eCSSPropertyAlias_WebkitFlex,



eCSSPropertyAlias_WebkitFlexGrow,



eCSSPropertyAlias_WebkitFlexShrink,



eCSSPropertyAlias_WebkitFlexBasis,



eCSSPropertyAlias_WebkitJustifyContent,



eCSSPropertyAlias_WebkitAlignItems,



eCSSPropertyAlias_WebkitAlignSelf,



eCSSPropertyAlias_WebkitAlignContent,




eCSSPropertyAlias_WebkitUserSelect,





eCSSPropertyAlias_WebkitMask,



eCSSPropertyAlias_WebkitMaskClip,



eCSSPropertyAlias_WebkitMaskComposite,



eCSSPropertyAlias_WebkitMaskImage,



eCSSPropertyAlias_WebkitMaskOrigin,



eCSSPropertyAlias_WebkitMaskPosition,



eCSSPropertyAlias_WebkitMaskPositionX,



eCSSPropertyAlias_WebkitMaskPositionY,



eCSSPropertyAlias_WebkitMaskRepeat,



eCSSPropertyAlias_WebkitMaskSize,


  eCSSProperty_COUNT_with_aliases,

  eCSSProperty_COUNT_DUMMY3 = eCSSProperty_COUNT_with_aliases - 1,






  eCSSPropertyExtra_no_properties,
  eCSSPropertyExtra_all_properties,


  eCSSPropertyExtra_x_none_value,
  eCSSPropertyExtra_x_auto_value,


  eCSSPropertyExtra_variable,


  eCSSProperty_DOM
};

namespace mozilla {

template<>
inline PLDHashNumber
Hash<nsCSSPropertyID>(const nsCSSPropertyID& aValue)
{
  return uint32_t(aValue);
}

}



enum nsCSSFontDesc {
  eCSSFontDesc_UNKNOWN = -1,







eCSSFontDesc_Family,
eCSSFontDesc_Style,
eCSSFontDesc_Weight,
eCSSFontDesc_Stretch,
eCSSFontDesc_Src,
eCSSFontDesc_UnicodeRange,
eCSSFontDesc_FontFeatureSettings,
eCSSFontDesc_FontLanguageOverride,
eCSSFontDesc_Display,

  eCSSFontDesc_COUNT
};



enum nsCSSCounterDesc {
  eCSSCounterDesc_UNKNOWN = -1,







eCSSCounterDesc_System,
eCSSCounterDesc_Symbols,
eCSSCounterDesc_AdditiveSymbols,
eCSSCounterDesc_Negative,
eCSSCounterDesc_Prefix,
eCSSCounterDesc_Suffix,
eCSSCounterDesc_Range,
eCSSCounterDesc_Pad,
eCSSCounterDesc_Fallback,
eCSSCounterDesc_SpeakAs,

  eCSSCounterDesc_COUNT
};

enum nsCSSPropertyLogicalGroup {
  eCSSPropertyLogicalGroup_UNKNOWN = -1,







eCSSPropertyLogicalGroup_BorderColor,
eCSSPropertyLogicalGroup_BorderStyle,
eCSSPropertyLogicalGroup_BorderWidth,
eCSSPropertyLogicalGroup_Margin,
eCSSPropertyLogicalGroup_MaxSize,
eCSSPropertyLogicalGroup_Offset,
eCSSPropertyLogicalGroup_Padding,
eCSSPropertyLogicalGroup_MinSize,
eCSSPropertyLogicalGroup_Size,



  eCSSPropertyLogicalGroup_COUNT
};
enum nsStyleStructID {
nsStyleStructID_None = -1,
nsStyleStructID_Inherited_Start = 0,

nsStyleStructID_DUMMY1 = nsStyleStructID_Inherited_Start - 1,





eStyleStruct_Font,



eStyleStruct_Color,


eStyleStruct_List,




eStyleStruct_Text,





eStyleStruct_Visibility,


eStyleStruct_UserInterface,


eStyleStruct_TableBorder,




eStyleStruct_SVG,





eStyleStruct_Variables,



nsStyleStructID_Reset_Start,

nsStyleStructID_DUMMY2 = nsStyleStructID_Reset_Start - 1,





eStyleStruct_Background,





eStyleStruct_Position,




eStyleStruct_TextReset,





eStyleStruct_Display,




eStyleStruct_Content,




eStyleStruct_UIReset,


eStyleStruct_Table,


eStyleStruct_Margin,




eStyleStruct_Padding,




eStyleStruct_Border,





eStyleStruct_Outline,





eStyleStruct_XUL,


eStyleStruct_SVGReset,





eStyleStruct_Column,





eStyleStruct_Effects,




nsStyleStructID_Length,

nsStyleStructID_Inherited_Count =
  nsStyleStructID_Reset_Start - nsStyleStructID_Inherited_Start,
nsStyleStructID_Reset_Count =
  nsStyleStructID_Length - nsStyleStructID_Reset_Start,

};




typedef decltype(nsStyleStructID(0) + nsStyleStructID(0)) nsStyleStructID_size_t;








struct PRFileDesc;
struct PRLibrary;

class nsISimpleEnumerator;
class nsIFile : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    NORMAL_FILE_TYPE = 0U,
    DIRECTORY_TYPE = 1U
  };


  virtual nsresult Append(const nsAString & node) = 0;


  virtual nsresult AppendNative(const nsACString & node) = 0;


  virtual nsresult Normalize(void) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult Create(uint32_t type, uint32_t permissions) = 0;


  virtual nsresult GetLeafName(nsAString & aLeafName) = 0;
  virtual nsresult SetLeafName(const nsAString & aLeafName) = 0;


  virtual nsresult GetNativeLeafName(nsACString & aNativeLeafName) = 0;
  virtual nsresult SetNativeLeafName(const nsACString & aNativeLeafName) = 0;


  virtual nsresult CopyTo(nsIFile *newParentDir, const nsAString & newName) = 0;


  virtual nsresult CopyToNative(nsIFile *newParentDir, const nsACString & newName) = 0;


  virtual nsresult CopyToFollowingLinks(nsIFile *newParentDir, const nsAString & newName) = 0;


  virtual nsresult CopyToFollowingLinksNative(nsIFile *newParentDir, const nsACString & newName) = 0;


  virtual nsresult MoveTo(nsIFile *newParentDir, const nsAString & newName) = 0;


  virtual nsresult MoveToNative(nsIFile *newParentDir, const nsACString & newName) = 0;


  virtual nsresult RenameTo(nsIFile *newParentDir, const nsAString & newName) = 0;


  virtual nsresult RenameToNative(nsIFile *newParentDir, const nsACString & newName) = 0;


  virtual nsresult Remove(bool recursive) = 0;


  virtual nsresult GetPermissions(uint32_t *aPermissions) = 0;
  virtual nsresult SetPermissions(uint32_t aPermissions) = 0;


  virtual nsresult GetPermissionsOfLink(uint32_t *aPermissionsOfLink) = 0;
  virtual nsresult SetPermissionsOfLink(uint32_t aPermissionsOfLink) = 0;


  virtual nsresult GetLastModifiedTime(PRTime *aLastModifiedTime) = 0;
  virtual nsresult SetLastModifiedTime(PRTime aLastModifiedTime) = 0;


  virtual nsresult GetLastModifiedTimeOfLink(PRTime *aLastModifiedTimeOfLink) = 0;
  virtual nsresult SetLastModifiedTimeOfLink(PRTime aLastModifiedTimeOfLink) = 0;


  virtual nsresult GetFileSize(int64_t *aFileSize) = 0;
  virtual nsresult SetFileSize(int64_t aFileSize) = 0;


  virtual nsresult GetFileSizeOfLink(int64_t *aFileSizeOfLink) = 0;


  virtual nsresult GetTarget(nsAString & aTarget) = 0;


  virtual nsresult GetNativeTarget(nsACString & aNativeTarget) = 0;


  virtual nsresult GetPath(nsAString & aPath) = 0;


  virtual nsresult GetNativePath(nsACString & aNativePath) = 0;


  virtual nsresult Exists(bool *_retval) = 0;


  virtual nsresult IsWritable(bool *_retval) = 0;


  virtual nsresult IsReadable(bool *_retval) = 0;


  virtual nsresult IsExecutable(bool *_retval) = 0;


  virtual nsresult IsHidden(bool *_retval) = 0;


  virtual nsresult IsDirectory(bool *_retval) = 0;


  virtual nsresult IsFile(bool *_retval) = 0;


  virtual nsresult IsSymlink(bool *_retval) = 0;


  virtual nsresult IsSpecial(bool *_retval) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult CreateUnique(uint32_t type, uint32_t permissions) = 0;


  virtual nsresult Clone(nsIFile * *_retval) = 0;


  virtual nsresult Equals(nsIFile *inFile, bool *_retval) = 0;


  virtual nsresult Contains(nsIFile *inFile, bool *_retval) = 0;


  virtual nsresult GetParent(nsIFile * *aParent) = 0;


  virtual nsresult GetDirectoryEntries(nsISimpleEnumerator * *aDirectoryEntries) = 0;


  virtual nsresult InitWithPath(const nsAString & filePath) = 0;


  virtual nsresult InitWithNativePath(const nsACString & filePath) = 0;


  virtual nsresult InitWithFile(nsIFile *aFile) = 0;


  virtual nsresult GetFollowLinks(bool *aFollowLinks) = 0;
  virtual nsresult SetFollowLinks(bool aFollowLinks) = 0;

  enum {
    OS_READAHEAD = 1073741824U,
    DELETE_ON_CLOSE = 2147483648U
  };


  __attribute__ ((warn_unused_result)) virtual nsresult OpenNSPRFileDesc(int32_t flags, int32_t mode, PRFileDesc **_retval) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult OpenANSIFileDesc(const char * mode, FILE **_retval) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult Load(PRLibrary **_retval) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetDiskSpaceAvailable(int64_t *aDiskSpaceAvailable) = 0;


  virtual nsresult AppendRelativePath(const nsAString & relativeFilePath) = 0;


  virtual nsresult AppendRelativeNativePath(const nsACString & relativeFilePath) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetPersistentDescriptor(nsACString & aPersistentDescriptor) = 0;
  __attribute__ ((warn_unused_result)) virtual nsresult SetPersistentDescriptor(const nsACString & aPersistentDescriptor) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult Reveal(void) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult Launch(void) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetRelativeDescriptor(nsIFile *fromFile, nsACString & _retval) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult SetRelativeDescriptor(nsIFile *fromFile, const nsACString & relativeDesc) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult GetRelativePath(nsIFile *fromFile, nsACString & _retval) = 0;


  __attribute__ ((warn_unused_result)) virtual nsresult SetRelativePath(nsIFile *fromFile, const nsACString & relativeDesc) = 0;

};

  template<typename T> struct nsIFile::COMTypeInfo<nsIFile, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIFile::COMTypeInfo<nsIFile, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x2fa6884a, 0xae65, 0x412a, { 0x9d, 0x4c, 0xce, 0x6e, 0x34, 0x54, 0x4b, 0xa1 }};
class nsIProperties : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult Get(const char * prop, const nsIID & iid, void **result) = 0;


  virtual nsresult Set(const char * prop, nsISupports *value) = 0;


  virtual nsresult Has(const char * prop, bool *_retval) = 0;


  virtual nsresult Undefine(const char * prop) = 0;


  virtual nsresult GetKeys(uint32_t *count, char * **keys) = 0;

};

  template<typename T> struct nsIProperties::COMTypeInfo<nsIProperties, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIProperties::COMTypeInfo<nsIProperties, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x78650582, 0x4e93, 0x4b60, { 0x8e, 0x85, 0x26, 0xeb, 0xd3, 0xeb, 0x14, 0xca }};




inline nsresult
NS_GetSpecialDirectory(const char* aSpecialDirName, nsIFile** aResult)
{
  nsresult rv;
  nsCOMPtr<nsIProperties> serv(do_GetService("@mozilla.org/file/directory_service;1",
                                             &rv));
  if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {
    return rv;
  }

  return serv->Get(aSpecialDirName, (nsIFile::COMTypeInfo<nsIFile, void>::kIID),
                   reinterpret_cast<void**>(aResult));
}
namespace mozilla {

struct StaticXREAppData;




class XREAppData
{
public:
  XREAppData() { }
  ~XREAppData() { }
  XREAppData(const XREAppData& aOther)
  {
    *this = aOther;
  }

  explicit XREAppData(const StaticXREAppData& aOther)
  {
    *this = aOther;
  }

  XREAppData& operator=(const StaticXREAppData& aOther);
  XREAppData& operator=(const XREAppData& aOther);
  XREAppData& operator=(XREAppData&& aOther) = default;

  struct NSFreePolicy
  {
    void operator()(const void* ptr) {
      free(const_cast<void*>(ptr));
    }
  };



  class CharPtr
  {
  public:
    explicit CharPtr() = default;
    explicit CharPtr(const char* v)
    {
      *this = v;
    }
    CharPtr(CharPtr&&) = default;
    ~CharPtr() = default;

    CharPtr& operator=(const char* v)
    {
      if (v) {
        mValue.reset(NS_strdup(v));
      } else {
        mValue = nullptr;
      }
      return *this;
    }
    CharPtr& operator=(const CharPtr& v)
    {
      *this = (const char*) v;
      return *this;
    }

    operator const char*() const {
      return mValue.get();
    }

  private:
    UniquePtr<const char, NSFreePolicy> mValue;
  };





  nsCOMPtr<nsIFile> directory;






  CharPtr vendor;






  CharPtr name;






  CharPtr remotingName;






  CharPtr version;




  CharPtr buildID;
  CharPtr ID;





  CharPtr copyright;




  uint32_t flags = 0;





  nsCOMPtr<nsIFile> xreDirectory;




  CharPtr minVersion;
  CharPtr maxVersion;




  CharPtr crashReporterURL;
  CharPtr profile;




  CharPtr UAName;
};
struct StaticXREAppData
{
  const char* vendor;
  const char* name;
  const char* remotingName;
  const char* version;
  const char* buildID;
  const char* ID;
  const char* copyright;
  uint32_t flags;
  const char* minVersion;
  const char* maxVersion;
  const char* crashReporterURL;
  const char* profile;
  const char* UAName;
};

}






struct XREChildData
{
};
struct XREShellData
{






};
namespace mozilla {
struct BootstrapConfig;
}
int XRE_main (int argc, char* argv[], const mozilla::BootstrapConfig& aConfig);
nsresult XRE_GetFileFromPath (const char* aPath, nsIFile** aResult);
nsresult XRE_GetBinaryPath (const char* aArgv0, nsIFile** aResult);





const mozilla::Module* XRE_GetStaticModule ();
nsresult XRE_LockProfileDirectory (nsIFile* aDirectory, nsISupports** aLockObject);
nsresult XRE_InitEmbedding2 (nsIFile* aLibXULDirectory, nsIFile* aAppDirectory, nsIDirectoryServiceProvider* aAppDirProvider);
nsresult XRE_AddStaticComponent (const mozilla::Module* aComponent);
enum NSLocationType
{
  NS_APP_LOCATION,
  NS_EXTENSION_LOCATION,
  NS_SKIN_LOCATION,
  NS_BOOTSTRAPPED_LOCATION
};

nsresult XRE_AddManifestLocation (NSLocationType aType, nsIFile* aLocation);
nsresult XRE_AddJarManifestLocation (NSLocationType aType, nsIFile* aLocation);
void XRE_NotifyProfile ();





void XRE_TermEmbedding ();
nsresult XRE_ParseAppData (nsIFile* aINIFile, mozilla::XREAppData& aAppData);



enum GeckoProcessType
{
  GeckoProcessType_Default = 0,

  GeckoProcessType_Plugin,
  GeckoProcessType_Content,

  GeckoProcessType_IPDLUnitTest,

  GeckoProcessType_GMPlugin,

  GeckoProcessType_GPU,

  GeckoProcessType_End,
  GeckoProcessType_Invalid = GeckoProcessType_End
};

static const char* const kGeckoProcessTypeString[] = {
  "default",
  "plugin",
  "tab",
  "ipdlunittest",
  "geckomediaplugin",
  "gpu"
};

static_assert(sizeof(mozilla::detail::ArrayLengthHelper(kGeckoProcessTypeString)) ==
              GeckoProcessType_End,
              "Array length mismatch");

const char* XRE_ChildProcessTypeToString (GeckoProcessType aProcessType);







void XRE_SetProcessType (const char* aProcessTypeString);




bool XRE_TakeMinidumpForChild (uint32_t aChildPid, nsIFile** aDump, uint32_t* aSequence);




bool XRE_SetRemoteExceptionHandler (const char* aPipe);



namespace mozilla {
namespace gmp {
class GMPLoader;
}
}

nsresult XRE_InitChildProcess (int aArgc, char* aArgv[], const XREChildData* aChildData);




GeckoProcessType XRE_GetProcessType ();


bool XRE_IsParentProcess ();


bool XRE_IsContentProcess ();


bool XRE_IsGPUProcess ();


typedef void (*MainFunction)(void* aData);

nsresult XRE_InitParentProcess (int aArgc, char* aArgv[], MainFunction aMainFunction, void* aMainFunctionExtraData);





int XRE_RunIPDLTest (int aArgc, char* aArgv[]);



nsresult XRE_RunAppShell ();


nsresult XRE_InitCommandLine (int aArgc, char* aArgv[]);


nsresult XRE_DeinitCommandLine ();


class MessageLoop;

void XRE_ShutdownChildProcess ();


MessageLoop* XRE_GetIOMessageLoop ();


bool XRE_SendTestShellCommand (JSContext* aCx, JSString* aCommand, void* aCallback);



bool XRE_ShutdownTestShell ();


void XRE_InstallX11ErrorHandler ();


void XRE_TelemetryAccumulate (int aID, uint32_t aSample);


void XRE_StartupTimelineRecord (int aEvent, mozilla::TimeStamp aWhen);


void XRE_InitOmnijar (nsIFile* aGreOmni, nsIFile* aAppOmni);


void XRE_StopLateWriteChecks (void);


void XRE_EnableSameExecutableForContentProc ();


int XRE_XPCShellMain (int argc, char** argv, char** envp, const XREShellData* aShellData);
static_assert(((7<<9) &
               (1<<12)) == 0,
              "didn't leave enough room for the parse property constants");
enum nsStyleAnimType {


  eStyleAnimType_Custom,


  eStyleAnimType_Coord,



  eStyleAnimType_Sides_Top,
  eStyleAnimType_Sides_Right,
  eStyleAnimType_Sides_Bottom,
  eStyleAnimType_Sides_Left,



  eStyleAnimType_Corner_TopLeft,
  eStyleAnimType_Corner_TopRight,
  eStyleAnimType_Corner_BottomRight,
  eStyleAnimType_Corner_BottomLeft,


  eStyleAnimType_nscoord,


  eStyleAnimType_float,


  eStyleAnimType_Color,


  eStyleAnimType_ComplexColor,


  eStyleAnimType_PaintServer,


  eStyleAnimType_Shadow,


  eStyleAnimType_Discrete,


  eStyleAnimType_None
};

class nsCSSProps {
public:
  typedef mozilla::CSSEnabledState EnabledState;

  struct KTableEntry
  {



    constexpr KTableEntry(nsCSSKeyword aKeyword, int16_t aValue)
      : mKeyword(aKeyword)
      , mValue(aValue)
    {
    }

    template<typename T,
             typename = typename std::enable_if<std::is_enum<T>::value>::type>
    constexpr KTableEntry(nsCSSKeyword aKeyword, T aValue)
      : mKeyword(aKeyword)
      , mValue(static_cast<int16_t>(aValue))
    {
      static_assert(mozilla::EnumTypeFitsWithin<T, int16_t>::value,
                    "aValue must be an enum that fits within mValue");
    }

    nsCSSKeyword mKeyword;
    int16_t mValue;
  };

  static void AddRefTable(void);
  static void ReleaseTable(void);




  static nsCSSPropertyID LookupProperty(const nsAString& aProperty,
                                      EnabledState aEnabled);
  static nsCSSPropertyID LookupProperty(const nsACString& aProperty,
                                      EnabledState aEnabled);


  static nsCSSPropertyID LookupPropertyByIDLName(
      const nsAString& aPropertyIDLName,
      EnabledState aEnabled);
  static nsCSSPropertyID LookupPropertyByIDLName(
      const nsACString& aPropertyIDLName,
      EnabledState aEnabled);



  static bool IsCustomPropertyName(const nsAString& aProperty);
  static bool IsCustomPropertyName(const nsACString& aProperty);

  static inline bool IsShorthand(nsCSSPropertyID aProperty) {
    do { } while (0);

    return (aProperty >= eCSSProperty_COUNT_no_shorthands);
  }


  static bool IsInherited(nsCSSPropertyID aProperty);


  static nsCSSFontDesc LookupFontDesc(const nsAString& aProperty);
  static nsCSSFontDesc LookupFontDesc(const nsACString& aProperty);


  static nsCSSCounterDesc LookupCounterDesc(const nsAString& aProperty);
  static nsCSSCounterDesc LookupCounterDesc(const nsACString& aProperty);


  static bool IsPredefinedCounterStyle(const nsAString& aStyle);
  static bool IsPredefinedCounterStyle(const nsACString& aStyle);


  static const nsAFlatCString& GetStringValue(nsCSSPropertyID aProperty);
  static const nsAFlatCString& GetStringValue(nsCSSFontDesc aFontDesc);
  static const nsAFlatCString& GetStringValue(nsCSSCounterDesc aCounterDesc);




  static const nsAFlatCString& LookupPropertyValue(nsCSSPropertyID aProperty, int32_t aValue);



  static bool GetColorName(int32_t aPropID, nsCString &aStr);




  static int32_t FindIndexOfKeyword(nsCSSKeyword aKeyword,
                                    const KTableEntry aTable[]);



  static bool FindKeyword(nsCSSKeyword aKeyword, const KTableEntry aTable[],
                          int32_t& aValue);


  static nsCSSKeyword ValueToKeywordEnum(int32_t aValue,
                                         const KTableEntry aTable[]);
  template<typename T,
           typename = typename std::enable_if<std::is_enum<T>::value>::type>
  static nsCSSKeyword ValueToKeywordEnum(T aValue,
                                         const KTableEntry aTable[])
  {
    static_assert(mozilla::EnumTypeFitsWithin<T, int16_t>::value,
                  "aValue must be an enum that fits within KTableEntry::mValue");
    return ValueToKeywordEnum(static_cast<int16_t>(aValue), aTable);
  }

  static const nsAFlatCString& ValueToKeyword(int32_t aValue,
                                              const KTableEntry aTable[]);
  template<typename T,
           typename = typename std::enable_if<std::is_enum<T>::value>::type>
  static const nsAFlatCString& ValueToKeyword(T aValue,
                                              const KTableEntry aTable[])
  {
    static_assert(mozilla::EnumTypeFitsWithin<T, int16_t>::value,
                  "aValue must be an enum that fits within KTableEntry::mValue");
    return ValueToKeyword(static_cast<int16_t>(aValue), aTable);
  }

  static const nsStyleStructID kSIDTable[eCSSProperty_COUNT_no_shorthands];
  static const KTableEntry* const kKeywordTableTable[eCSSProperty_COUNT_no_shorthands];
  static const nsStyleAnimType kAnimTypeTable[eCSSProperty_COUNT_no_shorthands];
  static const ptrdiff_t
    kStyleStructOffsetTable[eCSSProperty_COUNT_no_shorthands];

private:
  static const uint32_t kFlagsTable[eCSSProperty_COUNT];

public:
  static inline bool PropHasFlags(nsCSSPropertyID aProperty, uint32_t aFlags)
  {
    do { } while (0);

    do { } while (0);



    return (nsCSSProps::kFlagsTable[aProperty] & aFlags) == aFlags;
  }

  static inline uint32_t PropertyParseType(nsCSSPropertyID aProperty)
  {
    do { } while (0);

    return nsCSSProps::kFlagsTable[aProperty] &
           (7<<9);
  }

  static inline uint32_t ValueRestrictions(nsCSSPropertyID aProperty)
  {
    do { } while (0);

    return nsCSSProps::kFlagsTable[aProperty] &
           (3<<13);
  }

private:

  static const uint32_t kParserVariantTable[eCSSProperty_COUNT_no_shorthands];

public:
  static inline uint32_t ParserVariant(nsCSSPropertyID aProperty) {
    do { } while (0);

    return nsCSSProps::kParserVariantTable[aProperty];
  }

private:


  static const nsCSSPropertyID *const
    kSubpropertyTable[eCSSProperty_COUNT - eCSSProperty_COUNT_no_shorthands];

public:
  static inline
  const nsCSSPropertyID * SubpropertyEntryFor(nsCSSPropertyID aProperty) {
    do { } while (0);


    return nsCSSProps::kSubpropertyTable[aProperty -
                                         eCSSProperty_COUNT_no_shorthands];
  }




  static const nsCSSPropertyID * ShorthandsContaining(nsCSSPropertyID aProperty) {
    do { } while (0);
    do { } while (0);

    return gShorthandsContainingTable[aProperty];
  }
private:





  static nsCSSPropertyID *gShorthandsContainingTable[eCSSProperty_COUNT_no_shorthands];
  static nsCSSPropertyID* gShorthandsContainingPool;
  static bool BuildShorthandsContainingTable();

private:
  static const size_t gPropertyCountInStruct[nsStyleStructID_Length];
  static const size_t gPropertyIndexInStruct[eCSSProperty_COUNT_no_shorthands];
public:




  static size_t PropertyCountInStruct(nsStyleStructID aSID) {
    do { } while (0);

    return gPropertyCountInStruct[aSID];
  }




  static size_t PropertyIndexInStruct(nsCSSPropertyID aProperty) {
    do { } while (0);

    return gPropertyIndexInStruct[aProperty];
  }

private:


  static const nsCSSPropertyID* const
    kLogicalGroupTable[eCSSPropertyLogicalGroup_COUNT];

public:
  static const nsCSSPropertyID* LogicalGroup(nsCSSPropertyID aProperty);

private:
  static bool gPropertyEnabled[eCSSProperty_COUNT_with_aliases];

private:

  static const char* const kIDLNameTable[eCSSProperty_COUNT];

public:
  static const char* PropertyIDLName(nsCSSPropertyID aProperty)
  {
    do { } while (0);

    return kIDLNameTable[aProperty];
  }

private:
  static const int32_t kIDLNameSortPositionTable[eCSSProperty_COUNT];

public:




  static int32_t PropertyIDLNameSortPosition(nsCSSPropertyID aProperty)
  {
    do { } while (0);

    return kIDLNameSortPositionTable[aProperty];
  }

  static bool IsEnabled(nsCSSPropertyID aProperty) {
    do { } while (0);




    do { } while (0);


    return gPropertyEnabled[aProperty];
  }




  static const mozilla::UseCounter gPropertyUseCounter[eCSSProperty_COUNT_no_shorthands];

public:

  static mozilla::UseCounter UseCounterFor(nsCSSPropertyID aProperty) {
    do { } while (0);

    return gPropertyUseCounter[aProperty];
  }

  static bool IsEnabled(nsCSSPropertyID aProperty, EnabledState aEnabled)
  {
    if (IsEnabled(aProperty)) {
      return true;
    }
    if (aEnabled == EnabledState::eIgnoreEnabledState) {
      return true;
    }
    if ((aEnabled & EnabledState::eInUASheets) &&
        PropHasFlags(aProperty, (1<<22)))
    {
      return true;
    }
    if ((aEnabled & EnabledState::eInChrome) &&
        PropHasFlags(aProperty, (1<<23)))
    {
      return true;
    }
    return false;
  }

public:
  static const KTableEntry kAnimationDirectionKTable[];
  static const KTableEntry kAnimationFillModeKTable[];
  static const KTableEntry kAnimationIterationCountKTable[];
  static const KTableEntry kAnimationPlayStateKTable[];
  static const KTableEntry kAnimationTimingFunctionKTable[];
  static const KTableEntry kAppearanceKTable[];
  static const KTableEntry kMozAppearanceKTable[];
  static const KTableEntry kAzimuthKTable[];
  static const KTableEntry kBackfaceVisibilityKTable[];
  static const KTableEntry kTransformStyleKTable[];
  static const KTableEntry kImageLayerAttachmentKTable[];
  static const KTableEntry kBackgroundOriginKTable[];
  static const KTableEntry kMaskOriginKTable[];
  static const KTableEntry kImageLayerPositionKTable[];
  static const KTableEntry kImageLayerRepeatKTable[];
  static const KTableEntry kImageLayerRepeatPartKTable[];
  static const KTableEntry kImageLayerSizeKTable[];
  static const KTableEntry kImageLayerCompositeKTable[];
  static const KTableEntry kImageLayerModeKTable[];


  static KTableEntry kBackgroundClipKTable[];
  static const KTableEntry kMaskClipKTable[];
  static const KTableEntry kBlendModeKTable[];
  static const KTableEntry kBorderCollapseKTable[];
  static const KTableEntry kBorderImageRepeatKTable[];
  static const KTableEntry kBorderImageSliceKTable[];
  static const KTableEntry kBorderStyleKTable[];
  static const KTableEntry kBorderWidthKTable[];
  static const KTableEntry kBoxAlignKTable[];
  static const KTableEntry kBoxDecorationBreakKTable[];
  static const KTableEntry kBoxDirectionKTable[];
  static const KTableEntry kBoxOrientKTable[];
  static const KTableEntry kBoxPackKTable[];
  static const KTableEntry kClipPathGeometryBoxKTable[];
  static const KTableEntry kCounterRangeKTable[];
  static const KTableEntry kCounterSpeakAsKTable[];
  static const KTableEntry kCounterSymbolsSystemKTable[];
  static const KTableEntry kCounterSystemKTable[];
  static const KTableEntry kDominantBaselineKTable[];
  static const KTableEntry kShapeRadiusKTable[];
  static const KTableEntry kFillRuleKTable[];
  static const KTableEntry kFilterFunctionKTable[];
  static const KTableEntry kImageRenderingKTable[];
  static const KTableEntry kShapeOutsideShapeBoxKTable[];
  static const KTableEntry kShapeRenderingKTable[];
  static const KTableEntry kStrokeLinecapKTable[];
  static const KTableEntry kStrokeLinejoinKTable[];
  static const KTableEntry kStrokeContextValueKTable[];
  static const KTableEntry kVectorEffectKTable[];
  static const KTableEntry kTextAnchorKTable[];
  static const KTableEntry kTextRenderingKTable[];
  static const KTableEntry kColorAdjustKTable[];
  static const KTableEntry kColorInterpolationKTable[];
  static const KTableEntry kColumnFillKTable[];
  static const KTableEntry kColumnSpanKTable[];
  static const KTableEntry kBoxPropSourceKTable[];
  static const KTableEntry kBoxShadowTypeKTable[];
  static const KTableEntry kBoxSizingKTable[];
  static const KTableEntry kCaptionSideKTable[];


  static KTableEntry kClearKTable[];
  static const KTableEntry kColorKTable[];
  static const KTableEntry kContentKTable[];
  static const KTableEntry kControlCharacterVisibilityKTable[];
  static const KTableEntry kCursorKTable[];
  static const KTableEntry kDirectionKTable[];


  static KTableEntry kDisplayKTable[];
  static const KTableEntry kElevationKTable[];
  static const KTableEntry kEmptyCellsKTable[];

  static const KTableEntry kAlignAllKeywords[];
  static const KTableEntry kAlignOverflowPosition[];
  static const KTableEntry kAlignSelfPosition[];
  static const KTableEntry kAlignLegacy[];
  static const KTableEntry kAlignLegacyPosition[];
  static const KTableEntry kAlignAutoNormalStretchBaseline[];
  static const KTableEntry kAlignNormalStretchBaseline[];
  static const KTableEntry kAlignNormalBaseline[];
  static const KTableEntry kAlignContentDistribution[];
  static const KTableEntry kAlignContentPosition[];

  static const KTableEntry kAutoCompletionAlignJustifySelf[];
  static const KTableEntry kAutoCompletionAlignItems[];
  static const KTableEntry kAutoCompletionAlignJustifyContent[];

  static const KTableEntry kFlexDirectionKTable[];
  static const KTableEntry kFlexWrapKTable[];


  static KTableEntry kFloatKTable[];
  static const KTableEntry kFloatEdgeKTable[];
  static const KTableEntry kFontDisplayKTable[];
  static const KTableEntry kFontKTable[];
  static const KTableEntry kFontKerningKTable[];
  static const KTableEntry kFontSizeKTable[];
  static const KTableEntry kFontSmoothingKTable[];
  static const KTableEntry kFontStretchKTable[];
  static const KTableEntry kFontStyleKTable[];
  static const KTableEntry kFontSynthesisKTable[];
  static const KTableEntry kFontVariantKTable[];
  static const KTableEntry kFontVariantAlternatesKTable[];
  static const KTableEntry kFontVariantAlternatesFuncsKTable[];
  static const KTableEntry kFontVariantCapsKTable[];
  static const KTableEntry kFontVariantEastAsianKTable[];
  static const KTableEntry kFontVariantLigaturesKTable[];
  static const KTableEntry kFontVariantNumericKTable[];
  static const KTableEntry kFontVariantPositionKTable[];
  static const KTableEntry kFontWeightKTable[];
  static const KTableEntry kGridAutoFlowKTable[];
  static const KTableEntry kGridTrackBreadthKTable[];
  static const KTableEntry kHyphensKTable[];
  static const KTableEntry kImageOrientationKTable[];
  static const KTableEntry kImageOrientationFlipKTable[];
  static const KTableEntry kIsolationKTable[];
  static const KTableEntry kIMEModeKTable[];
  static const KTableEntry kLineHeightKTable[];
  static const KTableEntry kListStylePositionKTable[];
  static const KTableEntry kListStyleKTable[];
  static const KTableEntry kMaskTypeKTable[];
  static const KTableEntry kMathVariantKTable[];
  static const KTableEntry kMathDisplayKTable[];
  static const KTableEntry kContainKTable[];
  static const KTableEntry kContextOpacityKTable[];
  static const KTableEntry kContextPatternKTable[];
  static const KTableEntry kObjectFitKTable[];
  static const KTableEntry kOrientKTable[];
  static const KTableEntry kOutlineStyleKTable[];
  static const KTableEntry kOverflowKTable[];
  static const KTableEntry kOverflowSubKTable[];
  static const KTableEntry kOverflowClipBoxKTable[];
  static const KTableEntry kOverflowWrapKTable[];
  static const KTableEntry kPageBreakKTable[];
  static const KTableEntry kPageBreakInsideKTable[];
  static const KTableEntry kPageMarksKTable[];
  static const KTableEntry kPageSizeKTable[];
  static const KTableEntry kPitchKTable[];
  static const KTableEntry kPointerEventsKTable[];
  static const KTableEntry kPositionKTable[];
  static const KTableEntry kRadialGradientShapeKTable[];
  static const KTableEntry kRadialGradientSizeKTable[];
  static const KTableEntry kRadialGradientLegacySizeKTable[];
  static const KTableEntry kResizeKTable[];
  static const KTableEntry kRubyAlignKTable[];
  static const KTableEntry kRubyPositionKTable[];
  static const KTableEntry kScrollBehaviorKTable[];
  static const KTableEntry kScrollSnapTypeKTable[];
  static const KTableEntry kSpeakKTable[];
  static const KTableEntry kSpeakHeaderKTable[];
  static const KTableEntry kSpeakNumeralKTable[];
  static const KTableEntry kSpeakPunctuationKTable[];
  static const KTableEntry kSpeechRateKTable[];
  static const KTableEntry kStackSizingKTable[];
  static const KTableEntry kTableLayoutKTable[];


  static KTableEntry kTextAlignKTable[];
  static KTableEntry kTextAlignLastKTable[];
  static const KTableEntry kTextCombineUprightKTable[];
  static const KTableEntry kTextDecorationLineKTable[];
  static const KTableEntry kTextDecorationStyleKTable[];
  static const KTableEntry kTextEmphasisPositionKTable[];
  static const KTableEntry kTextEmphasisStyleFillKTable[];
  static const KTableEntry kTextEmphasisStyleShapeKTable[];
  static const KTableEntry kTextJustifyKTable[];
  static const KTableEntry kTextOrientationKTable[];
  static const KTableEntry kTextOverflowKTable[];
  static const KTableEntry kTextSizeAdjustKTable[];
  static const KTableEntry kTextTransformKTable[];
  static const KTableEntry kTouchActionKTable[];
  static const KTableEntry kTopLayerKTable[];
  static const KTableEntry kTransformBoxKTable[];
  static const KTableEntry kTransitionTimingFunctionKTable[];
  static const KTableEntry kUnicodeBidiKTable[];
  static const KTableEntry kUserFocusKTable[];
  static const KTableEntry kUserInputKTable[];
  static const KTableEntry kUserModifyKTable[];
  static const KTableEntry kUserSelectKTable[];
  static const KTableEntry kVerticalAlignKTable[];
  static const KTableEntry kVisibilityKTable[];
  static const KTableEntry kVolumeKTable[];
  static const KTableEntry kWhitespaceKTable[];
  static const KTableEntry kWidthKTable[];
  static const KTableEntry kWindowDraggingKTable[];
  static const KTableEntry kWindowShadowKTable[];
  static const KTableEntry kWordBreakKTable[];
  static const KTableEntry kWritingModeKTable[];
};


class nsIEventTarget;
class nsIRunnable;

namespace mozilla {
class AbstractThread;
namespace dom {
class TabGroup;
}
class Dispatcher
{
public:
  public: virtual MozExternalRefCountType AddRef(void) = 0; virtual MozExternalRefCountType Release(void) = 0; public:


  virtual nsresult Dispatch(const char* aName,
                            TaskCategory aCategory,
                            already_AddRefed<nsIRunnable>&& aRunnable) = 0;



  virtual nsIEventTarget* EventTargetFor(TaskCategory aCategory) const = 0;



  AbstractThread* AbstractMainThreadFor(TaskCategory aCategory);



  virtual dom::TabGroup* AsTabGroup() { return nullptr; }

  static nsresult UnlabeledDispatch(const char* aName,
                                    TaskCategory aCategory,
                                    already_AddRefed<nsIRunnable>&& aRunnable);

protected:


  virtual AbstractThread* AbstractMainThreadForImpl(TaskCategory aCategory) = 0;
};

class ValidatingDispatcher : public Dispatcher
{
public:
  ValidatingDispatcher();

  class AutoProcessEvent final {
  public:
    AutoProcessEvent();
    ~AutoProcessEvent();

  private:
    ValidatingDispatcher* mPrevRunningDispatcher;
  };


  bool AccessAllowed() const
  {
    return !sRunningDispatcher || mAccessValid;
  }


  void ValidateAccess() const
  {
    do { } while (0);
  }

  class Runnable;
  friend class Runnable;

  bool* GetValidAccessPtr() { return &mAccessValid; }

  nsresult Dispatch(const char* aName,
                    TaskCategory aCategory,
                    already_AddRefed<nsIRunnable>&& aRunnable) override;

  nsIEventTarget* EventTargetFor(TaskCategory aCategory) const override;

protected:


  AbstractThread* AbstractMainThreadForImpl(TaskCategory aCategory) override;


  virtual already_AddRefed<nsIEventTarget>
  CreateEventTargetFor(TaskCategory aCategory);



  static ValidatingDispatcher* FromEventTarget(nsIEventTarget* aEventTarget);

  nsresult LabeledDispatch(const char* aName,
                           TaskCategory aCategory,
                           already_AddRefed<nsIRunnable>&& aRunnable);

  void CreateEventTargets(bool aNeedValidation);



  void Shutdown(bool aXPCOMShutdown);

  enum ValidationType {
    StartValidation,
    EndValidation,
  };
  void SetValidatingAccess(ValidationType aType);

  static ValidatingDispatcher* sRunningDispatcher;
  bool mAccessValid;

  nsCOMPtr<nsIEventTarget> mEventTargets[size_t(TaskCategory::Count)];
  RefPtr<AbstractThread> mAbstractThreads[size_t(TaskCategory::Count)];
};

}






namespace mozilla {

class SystemGroup
{
 public:

  static nsresult Dispatch(const char* aName,
                           TaskCategory aCategory,
                           already_AddRefed<nsIRunnable>&& aRunnable);


  static nsIEventTarget* EventTargetFor(TaskCategory aCategory);



  static AbstractThread* AbstractMainThreadFor(TaskCategory aCategory);

  static void InitStatic();
  static void Shutdown();
};

}







namespace detail {

template<typename T>
class ProxyReleaseEvent : public mozilla::Runnable
{
public:
  explicit ProxyReleaseEvent(already_AddRefed<T> aDoomed)
  : Runnable("ProxyReleaseEvent"), mDoomed(aDoomed.take()) {}

  virtual nsresult Run() override
  {
    do { if (mDoomed) { (mDoomed)->Release(); (mDoomed) = 0; } } while (0);
    return NS_OK;
  }

private:
  T* mDoomed;
};

template<typename T>
void
ProxyRelease(nsIEventTarget* aTarget, already_AddRefed<T> aDoomed, bool aAlwaysProxy)
{

  RefPtr<T> doomed = aDoomed;
  nsresult rv;

  if (!doomed || !aTarget) {
    return;
  }

  if (!aAlwaysProxy) {
    bool onCurrentThread = false;
    rv = aTarget->IsOnCurrentThread(&onCurrentThread);
    if (((bool)(__builtin_expect(!!(!NS_FAILED_impl(rv)), 1))) && onCurrentThread) {
      return;
    }
  }

  nsCOMPtr<nsIRunnable> ev = new ProxyReleaseEvent<T>(doomed.forget());

  rv = aTarget->Dispatch(ev, nsIEventTarget::DISPATCH_NORMAL);
  if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {
    do { } while(0);


  }
}

template<bool nsISupportsBased>
struct ProxyReleaseChooser
{
  template<typename T>
  static void ProxyRelease(nsIEventTarget* aTarget,
                           already_AddRefed<T> aDoomed,
                           bool aAlwaysProxy)
  {
    ::detail::ProxyRelease(aTarget, mozilla::Move(aDoomed), aAlwaysProxy);
  }
};

template<>
struct ProxyReleaseChooser<true>
{


  template<typename T>
  static void ProxyRelease(nsIEventTarget* aTarget,
                           already_AddRefed<T> aDoomed,
                           bool aAlwaysProxy)
  {
    ProxyReleaseISupports(aTarget, ToSupports(aDoomed.take()), aAlwaysProxy);
  }

  static void ProxyReleaseISupports(nsIEventTarget* aTarget,
                                    nsISupports* aDoomed,
                                    bool aAlwaysProxy);
};

}
template<class T>
inline __attribute__ ((visibility ("hidden"))) void
NS_ProxyRelease(nsIEventTarget* aTarget, already_AddRefed<T> aDoomed,
                bool aAlwaysProxy = false)
{
  ::detail::ProxyReleaseChooser<mozilla::IsBaseOf<nsISupports, T>::value>
    ::ProxyRelease(aTarget, mozilla::Move(aDoomed), aAlwaysProxy);
}
template<class T>
inline __attribute__ ((visibility ("hidden"))) void
NS_ReleaseOnMainThread(already_AddRefed<T> aDoomed,
                       bool aAlwaysProxy = false)
{



  nsCOMPtr<nsIThread> mainThread;
  if (!NS_IsMainThread() || aAlwaysProxy) {
    nsresult rv = NS_GetMainThread(getter_AddRefs(mainThread));

    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {
      do { } while (0);
      mozilla::Unused << aDoomed.take();
      return;
    }
  }

  NS_ProxyRelease(mainThread, mozilla::Move(aDoomed), aAlwaysProxy);
}





template<class T>
inline __attribute__ ((visibility ("hidden"))) void
NS_ReleaseOnMainThreadSystemGroup(already_AddRefed<T> aDoomed,
                                  bool aAlwaysProxy = false)
{



  nsCOMPtr<nsIEventTarget> systemGroupEventTarget;
  if (!NS_IsMainThread() || aAlwaysProxy) {
    systemGroupEventTarget = mozilla::SystemGroup::EventTargetFor(mozilla::TaskCategory::Other);

    if (!systemGroupEventTarget) {
      do { } while (0);
      mozilla::Unused << aDoomed.take();
      return;
    }
  }

  NS_ProxyRelease(systemGroupEventTarget, mozilla::Move(aDoomed), aAlwaysProxy);
}
template<class T>
class nsMainThreadPtrHolder final
{
public:





  explicit nsMainThreadPtrHolder(T* aPtr, bool aStrict = true)
    : mRawPtr(nullptr)
    , mStrict(aStrict)
  {


    do { } while (0);
    ns_if_addref(mRawPtr = aPtr);
  }
  explicit nsMainThreadPtrHolder(already_AddRefed<T> aPtr, bool aString = true)
    : mRawPtr(aPtr.take())
    , mStrict(aString)
  {


  }

private:

  ~nsMainThreadPtrHolder()
  {
    if (NS_IsMainThread()) {
      do { if (mRawPtr) { (mRawPtr)->Release(); (mRawPtr) = 0; } } while (0);
    } else if (mRawPtr) {
      NS_ReleaseOnMainThread(dont_AddRef(mRawPtr));
    }
  }

public:
  T* get()
  {

    if (mStrict && (__builtin_expect(!!(!NS_IsMainThread()), 0))) {
      do { } while(0);
      do { AnnotateMozCrashReason("MOZ_CRASH(" ")"); do { *((volatile int*) __null) = 269; ::abort(); } while (0); } while (0);
    }
    return mRawPtr;
  }

  bool operator==(const nsMainThreadPtrHolder<T>& aOther) const
  {
    return mRawPtr == aOther.mRawPtr;
  }
  bool operator!() const
  {
    return !mRawPtr;
  }

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsMainThreadPtrHolder<T> >::value, "Reference-counted class " "nsMainThreadPtrHolder<T>" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); nsrefcnt count = ++mRefCnt; ; return (nsrefcnt) count; } MozExternalRefCountType Release(void) { do { } while (0); nsrefcnt count = --mRefCnt; ; if (count == 0) { delete (this); return 0; } return count; } typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:

private:

  T* mRawPtr;


  bool mStrict;



  T& operator=(nsMainThreadPtrHolder& aOther);
  nsMainThreadPtrHolder(const nsMainThreadPtrHolder& aOther);
};

template<class T>
class nsMainThreadPtrHandle
{
  RefPtr<nsMainThreadPtrHolder<T>> mPtr;

public:
  nsMainThreadPtrHandle() : mPtr(nullptr) {}
               nsMainThreadPtrHandle(decltype(nullptr)) : mPtr(nullptr) {}
  explicit nsMainThreadPtrHandle(nsMainThreadPtrHolder<T>* aHolder)
    : mPtr(aHolder)
  {
  }
  explicit nsMainThreadPtrHandle(
      already_AddRefed<nsMainThreadPtrHolder<T>> aHolder)
    : mPtr(aHolder)
  {
  }
  nsMainThreadPtrHandle(const nsMainThreadPtrHandle& aOther)
    : mPtr(aOther.mPtr)
  {
  }
  nsMainThreadPtrHandle& operator=(const nsMainThreadPtrHandle& aOther)
  {
    mPtr = aOther.mPtr;
    return *this;
  }
  nsMainThreadPtrHandle& operator=(nsMainThreadPtrHolder<T>* aHolder)
  {
    mPtr = aHolder;
    return *this;
  }




  T* get()
  {
    if (mPtr) {
      return mPtr.get()->get();
    }
    return nullptr;
  }
  const T* get() const
  {
    if (mPtr) {
      return mPtr.get()->get();
    }
    return nullptr;
  }

  operator T*() { return get(); }
  T* operator->() { return get(); }


  bool operator==(const nsMainThreadPtrHandle<T>& aOther) const
  {
    if (!mPtr || !aOther.mPtr) {
      return mPtr == aOther.mPtr;
    }
    return *mPtr == *aOther.mPtr;
  }
  bool operator!=(const nsMainThreadPtrHandle<T>& aOther) const
  {
    return !operator==(aOther);
  }
  bool operator==(decltype(nullptr)) const { return mPtr == nullptr; }
  bool operator!=(decltype(nullptr)) const { return mPtr != nullptr; }
  bool operator!() const {
    return !mPtr || !*mPtr;
  }
};

namespace mozilla {

template<typename T>
using PtrHolder = nsMainThreadPtrHolder<T>;

template<typename T>
using PtrHandle = nsMainThreadPtrHandle<T>;

}
class imgRequestProxy;
class nsIAtom;
class nsIContent;
class nsIDocument;
class nsIPrincipal;
class nsIURI;
class nsPresContext;
template <class T>
class nsPtrHashKey;

namespace mozilla {
class CSSStyleSheet;
}
namespace mozilla {
namespace css {

struct URLExtraData
{
  URLExtraData(already_AddRefed<nsIURI> aBaseURI,
               already_AddRefed<nsIURI> aReferrer,
               already_AddRefed<nsIPrincipal> aPrincipal)
    : mBaseURI(Move(aBaseURI))
    , mReferrer(Move(aReferrer))
    , mPrincipal(Move(aPrincipal))
  {
    do { } while (0);
  }

  URLExtraData(nsIURI* aBaseURI, nsIURI* aReferrer, nsIPrincipal* aPrincipal)
    : URLExtraData(do_AddRef(aBaseURI),
                   do_AddRef(aReferrer),
                   do_AddRef(aPrincipal)) {}

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<URLExtraData>::value, "Reference-counted class " "URLExtraData" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); nsrefcnt count = ++mRefCnt; ; return (nsrefcnt) count; } MozExternalRefCountType Release(void) { do { } while (0); nsrefcnt count = --mRefCnt; ; if (count == 0) { delete (this); return 0; } return count; } typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:

  nsIURI* BaseURI() const { return mBaseURI; }
  nsIURI* GetReferrer() const { return mReferrer; }
  nsIPrincipal* GetPrincipal() const { return mPrincipal; }

private:
  ~URLExtraData();

  RefPtr<nsIURI> mBaseURI;
  RefPtr<nsIURI> mReferrer;
  RefPtr<nsIPrincipal> mPrincipal;
};

struct URLValueData
{
protected:
  URLValueData(nsStringBuffer* aString,
               already_AddRefed<URLExtraData> aExtraData);

  URLValueData(already_AddRefed<PtrHolder<nsIURI>> aURI,
               nsStringBuffer* aString,
               already_AddRefed<URLExtraData> aExtraData);

public:




  bool Equals(const URLValueData& aOther) const;
  bool DefinitelyEqualURIs(const URLValueData& aOther) const;



  bool DefinitelyEqualURIsAndPrincipal(const URLValueData& aOther) const;

  nsIURI* GetURI() const;

  bool IsLocalRef() const { return mIsLocalRef; }

  bool HasRef() const;

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<URLValueData>::value, "Reference-counted class " "URLValueData" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); nsrefcnt count = ++mRefCnt; ; return (nsrefcnt) count; } MozExternalRefCountType Release(void) { do { } while (0); nsrefcnt count = --mRefCnt; ; if (count == 0) { delete (this); return 0; } return count; } typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:



  already_AddRefed<nsIURI> ResolveLocalRef(nsIURI* aURI) const;
  already_AddRefed<nsIURI> ResolveLocalRef(nsIContent* aContent) const;



  void GetSourceString(nsString& aRef) const;

  bool EqualsExceptRef(nsIURI* aURI) const;

private:


  mutable PtrHandle<nsIURI> mURI;
public:
  RefPtr<nsStringBuffer> mString;
  RefPtr<URLExtraData> mExtraData;
private:
  mutable bool mURIResolved;

  bool mIsLocalRef;

protected:
  virtual ~URLValueData() = default;

  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

private:
  URLValueData(const URLValueData& aOther) = delete;
  URLValueData& operator=(const URLValueData& aOther) = delete;
};

struct URLValue final : public URLValueData
{

  URLValue(nsStringBuffer* aString, nsIURI* aBaseURI, nsIURI* aReferrer,
           nsIPrincipal* aOriginPrincipal);
  URLValue(nsIURI* aURI, nsStringBuffer* aString, nsIURI* aBaseURI,
           nsIURI* aReferrer, nsIPrincipal* aOriginPrincipal);


  URLValue(nsStringBuffer* aString,
           already_AddRefed<URLExtraData> aExtraData)
    : URLValueData(aString, Move(aExtraData)) {}

  URLValue(const URLValue&) = delete;
  URLValue& operator=(const URLValue&) = delete;

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;
};

struct ImageValue final : public URLValueData
{






  ImageValue(nsIURI* aURI, nsStringBuffer* aString,
             already_AddRefed<URLExtraData> aExtraData,
             nsIDocument* aDocument);



  ImageValue(nsStringBuffer* aString,
             already_AddRefed<URLExtraData> aExtraData);

  ImageValue(const ImageValue&) = delete;
  ImageValue& operator=(const ImageValue&) = delete;

  void Initialize(nsIDocument* aDocument);



protected:
  ~ImageValue();

public:


  nsRefPtrHashtable<nsPtrHashKey<nsIDocument>, imgRequestProxy> mRequests;

private:



};

struct GridNamedArea {
  nsString mName;
  uint32_t mColumnStart;
  uint32_t mColumnEnd;
  uint32_t mRowStart;
  uint32_t mRowEnd;
};

struct GridTemplateAreasValue final {

  nsTArray<GridNamedArea> mNamedAreas;



  nsTArray<nsString> mTemplates;



  uint32_t mNColumns;



  uint32_t NRows() const {
    return mTemplates.Length();
  }

  GridTemplateAreasValue()
    : mNColumns(0)

  {
  }

  bool operator==(const GridTemplateAreasValue& aOther) const
  {
    return mTemplates == aOther.mTemplates;
  }

  bool operator!=(const GridTemplateAreasValue& aOther) const
  {
    return !(*this == aOther);
  }

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<GridTemplateAreasValue>::value, "Reference-counted class " "GridTemplateAreasValue" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); ++mRefCnt; ; return mRefCnt; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); --mRefCnt; ; if (mRefCnt == 0) { mRefCnt = 1; delete(this); return 0; } return mRefCnt; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

private:


  ~GridTemplateAreasValue()
  {
  }

  GridTemplateAreasValue(const GridTemplateAreasValue& aOther) = delete;
  GridTemplateAreasValue&
  operator=(const GridTemplateAreasValue& aOther) = delete;
};

class FontFamilyListRefCnt final : public FontFamilyList {
public:
    FontFamilyListRefCnt()
        : FontFamilyList()
    {}

    explicit FontFamilyListRefCnt(FontFamilyType aGenericType)
        : FontFamilyList(aGenericType)
    {}

    FontFamilyListRefCnt(const nsAString& aFamilyName,
                         QuotedName aQuoted)
        : FontFamilyList(aFamilyName, aQuoted)
    {}

    FontFamilyListRefCnt(const FontFamilyListRefCnt& aOther)
        : FontFamilyList(aOther)
    {}

    public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<FontFamilyListRefCnt>::value, "Reference-counted class " "FontFamilyListRefCnt" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); ++mRefCnt; ; return mRefCnt; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); --mRefCnt; ; if (mRefCnt == 0) { mRefCnt = 1; delete(this); return 0; } return mRefCnt; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:;

private:
    ~FontFamilyListRefCnt() {}
};

struct RGBAColorData
{



  float mR;
  float mG;
  float mB;
  float mA;

  RGBAColorData() = default;
               RGBAColorData(nscolor aColor)
    : mR(((uint8_t) ((aColor) & 0xff)) * (1.0f / 255.0f))
    , mG(((uint8_t) (((aColor) >> 8) & 0xff)) * (1.0f / 255.0f))
    , mB(((uint8_t) (((aColor) >> 16) & 0xff)) * (1.0f / 255.0f))
    , mA(((uint8_t) (((aColor) >> 24) & 0xff)) * (1.0f / 255.0f))
  {}
  RGBAColorData(float aR, float aG, float aB, float aA)
    : mR(aR), mG(aG), mB(aB), mA(aA) {}

  bool operator==(const RGBAColorData& aOther) const
  {
    return mR == aOther.mR && mG == aOther.mG &&
           mB == aOther.mB && mA == aOther.mA;
  }
  bool operator!=(const RGBAColorData& aOther) const
  {
    return !(*this == aOther);
  }

  nscolor ToColor() const
  {
    return ((nscolor) (((ClampColor(mA * 255.0f)) << 24) | ((ClampColor(mB * 255.0f))<<16) | ((ClampColor(mG * 255.0f))<<8) | (ClampColor(mR * 255.0f))));



  }

  RGBAColorData WithAlpha(float aAlpha) const
  {
    RGBAColorData result = *this;
    result.mA = aAlpha;
    return result;
  }
};

struct ComplexColorData
{
  RGBAColorData mColor;
  float mForegroundRatio;

  ComplexColorData() = default;
  ComplexColorData(const RGBAColorData& aColor, float aForegroundRatio)
    : mColor(aColor), mForegroundRatio(aForegroundRatio) {}
  ComplexColorData(nscolor aColor, float aForegroundRatio)
    : mColor(aColor), mForegroundRatio(aForegroundRatio) {}
  explicit ComplexColorData(const StyleComplexColor& aColor)
    : mColor(aColor.mColor)
    , mForegroundRatio(aColor.mForegroundRatio * (1.0f / 255.0f)) {}

  bool operator==(const ComplexColorData& aOther) const
  {
    return mForegroundRatio == aOther.mForegroundRatio &&
           (IsCurrentColor() || mColor == aOther.mColor);
  }
  bool operator!=(const ComplexColorData& aOther) const
  {
    return !(*this == aOther);
  }

  bool IsCurrentColor() const { return mForegroundRatio >= 1.0f; }
  bool IsNumericColor() const { return mForegroundRatio <= 0.0f; }

  StyleComplexColor ToComplexColor() const
  {
    return {mColor.ToColor(), ClampColor(mForegroundRatio * 255.0f)};
  }
};

struct ComplexColorValue final : public ComplexColorData
{

  template<typename... Args>
  explicit ComplexColorValue(Args&&... aArgs)
    : ComplexColorData(Forward<Args>(aArgs)...) {}
  ComplexColorValue(const ComplexColorValue&) = delete;

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<ComplexColorValue>::value, "Reference-counted class " "ComplexColorValue" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); ++mRefCnt; ; return mRefCnt; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); --mRefCnt; ; if (mRefCnt == 0) { mRefCnt = 1; delete(this); return 0; } return mRefCnt; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:

  size_t SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const;

private:
  ~ComplexColorValue() {}
};

}
}

enum nsCSSUnit {
  eCSSUnit_Null = 0,
  eCSSUnit_Auto = 1,
  eCSSUnit_Inherit = 2,
  eCSSUnit_Initial = 3,
  eCSSUnit_Unset = 4,
  eCSSUnit_None = 5,
  eCSSUnit_Normal = 6,
  eCSSUnit_System_Font = 7,
  eCSSUnit_All = 8,
  eCSSUnit_Dummy = 9,

  eCSSUnit_DummyInherit = 10,


  eCSSUnit_String = 11,
  eCSSUnit_Ident = 12,
  eCSSUnit_Attr = 14,
  eCSSUnit_Local_Font = 15,
  eCSSUnit_Font_Format = 16,
  eCSSUnit_Element = 17,

  eCSSUnit_Array = 20,
  eCSSUnit_Counter = 21,
  eCSSUnit_Counters = 22,
  eCSSUnit_Cubic_Bezier = 23,
  eCSSUnit_Steps = 24,
  eCSSUnit_Symbols = 25,
  eCSSUnit_Function = 26,
  eCSSUnit_Calc = 30,


  eCSSUnit_Calc_Plus = 31,
  eCSSUnit_Calc_Minus = 32,
  eCSSUnit_Calc_Times_L = 33,
  eCSSUnit_Calc_Times_R = 34,
  eCSSUnit_Calc_Divided = 35,

  eCSSUnit_URL = 40,
  eCSSUnit_Image = 41,
  eCSSUnit_Gradient = 42,
  eCSSUnit_TokenStream = 43,
  eCSSUnit_GridTemplateAreas = 44,


  eCSSUnit_Pair = 50,
  eCSSUnit_Triplet = 51,
  eCSSUnit_Rect = 52,
  eCSSUnit_List = 53,
  eCSSUnit_ListDep = 54,

  eCSSUnit_SharedList = 55,

  eCSSUnit_PairList = 56,
  eCSSUnit_PairListDep = 57,


  eCSSUnit_FontFamilyList = 58,


  eCSSUnit_AtomIdent = 60,

  eCSSUnit_Integer = 70,
  eCSSUnit_Enumerated = 71,

  eCSSUnit_EnumColor = 80,
  eCSSUnit_RGBColor = 81,
  eCSSUnit_RGBAColor = 82,
  eCSSUnit_HexColor = 83,
  eCSSUnit_ShortHexColor = 84,
  eCSSUnit_HexColorAlpha = 85,
  eCSSUnit_ShortHexColorAlpha = 86,
  eCSSUnit_PercentageRGBColor = 87,



  eCSSUnit_PercentageRGBAColor = 88,



  eCSSUnit_HSLColor = 89,
  eCSSUnit_HSLAColor = 90,
  eCSSUnit_ComplexColor = 91,

  eCSSUnit_Percent = 100,
  eCSSUnit_Number = 101,


  eCSSUnit_PhysicalMillimeter = 200,



  eCSSUnit_ViewportWidth = 700,
  eCSSUnit_ViewportHeight = 701,
  eCSSUnit_ViewportMin = 702,
  eCSSUnit_ViewportMax = 703,


  eCSSUnit_EM = 800,
  eCSSUnit_XHeight = 801,
  eCSSUnit_Char = 802,
  eCSSUnit_RootEM = 803,


  eCSSUnit_Point = 900,
  eCSSUnit_Inch = 901,
  eCSSUnit_Millimeter = 902,
  eCSSUnit_Centimeter = 903,
  eCSSUnit_Pica = 904,
  eCSSUnit_Quarter = 905,
  eCSSUnit_Pixel = 906,


  eCSSUnit_Degree = 1000,
  eCSSUnit_Grad = 1001,
  eCSSUnit_Radian = 1002,
  eCSSUnit_Turn = 1003,


  eCSSUnit_Hertz = 2000,
  eCSSUnit_Kilohertz = 2001,


  eCSSUnit_Seconds = 3000,
  eCSSUnit_Milliseconds = 3001,


  eCSSUnit_FlexFraction = 4000
};

struct nsCSSValueGradient;
struct nsCSSValuePair;
struct nsCSSValuePair_heap;
struct nsCSSValueTokenStream;
struct nsCSSRect;
struct nsCSSRect_heap;
struct nsCSSValueList;
struct nsCSSValueList_heap;
struct nsCSSValueSharedList;
struct nsCSSValuePairList;
struct nsCSSValuePairList_heap;
struct nsCSSValueTriplet;
struct nsCSSValueTriplet_heap;
class nsCSSValueFloatColor;

class nsCSSValue {
public:
  struct Array;
  friend struct Array;

  friend struct mozilla::css::URLValueData;

  friend struct mozilla::css::ImageValue;


  explicit nsCSSValue(nsCSSUnit aUnit = eCSSUnit_Null)
    : mUnit(aUnit)
  {
    do { } while (0);
  }

  nsCSSValue(int32_t aValue, nsCSSUnit aUnit);
  nsCSSValue(float aValue, nsCSSUnit aUnit);
  nsCSSValue(const nsString& aValue, nsCSSUnit aUnit);
  nsCSSValue(Array* aArray, nsCSSUnit aUnit);
  explicit nsCSSValue(mozilla::css::URLValue* aValue);
  explicit nsCSSValue(mozilla::css::ImageValue* aValue);
  explicit nsCSSValue(nsCSSValueGradient* aValue);
  explicit nsCSSValue(nsCSSValueTokenStream* aValue);
  explicit nsCSSValue(mozilla::css::GridTemplateAreasValue* aValue);
  explicit nsCSSValue(mozilla::css::FontFamilyListRefCnt* aValue);
  nsCSSValue(const nsCSSValue& aCopy);
  nsCSSValue(nsCSSValue&& aOther)
    : mUnit(aOther.mUnit)
    , mValue(aOther.mValue)
  {
    aOther.mUnit = eCSSUnit_Null;
  }
  ~nsCSSValue() { Reset(); }

  nsCSSValue& operator=(const nsCSSValue& aCopy);
  nsCSSValue& operator=(nsCSSValue&& aCopy);
  bool operator==(const nsCSSValue& aOther) const;

  bool operator!=(const nsCSSValue& aOther) const
  {
    return !(*this == aOther);
  }


  enum Serialization { eNormalized, eAuthorSpecified };





  void AppendToString(nsCSSPropertyID aProperty, nsAString& aResult,
                      Serialization aValueSerialization) const;

  nsCSSUnit GetUnit() const { return mUnit; }
  bool IsLengthUnit() const
    { return eCSSUnit_PhysicalMillimeter <= mUnit && mUnit <= eCSSUnit_Pixel; }
  bool IsLengthPercentCalcUnit() const
    { return IsLengthUnit() || mUnit == eCSSUnit_Percent || IsCalcUnit(); }





  bool IsFixedLengthUnit() const
    { return mUnit == eCSSUnit_PhysicalMillimeter; }
  bool IsRelativeLengthUnit() const
    { return eCSSUnit_EM <= mUnit && mUnit <= eCSSUnit_RootEM; }



  static bool IsPixelLengthUnit(nsCSSUnit aUnit)
    { return eCSSUnit_Point <= aUnit && aUnit <= eCSSUnit_Pixel; }
  bool IsPixelLengthUnit() const
    { return IsPixelLengthUnit(mUnit); }
  static bool IsPercentLengthUnit(nsCSSUnit aUnit)
    { return aUnit == eCSSUnit_Percent; }
  bool IsPercentLengthUnit()
    { return IsPercentLengthUnit(mUnit); }
  static bool IsFloatUnit(nsCSSUnit aUnit)
    { return eCSSUnit_Number <= aUnit; }
  bool IsAngularUnit() const
    { return eCSSUnit_Degree <= mUnit && mUnit <= eCSSUnit_Turn; }
  bool IsFrequencyUnit() const
    { return eCSSUnit_Hertz <= mUnit && mUnit <= eCSSUnit_Kilohertz; }
  bool IsTimeUnit() const
    { return eCSSUnit_Seconds <= mUnit && mUnit <= eCSSUnit_Milliseconds; }
  bool IsCalcUnit() const
    { return eCSSUnit_Calc <= mUnit && mUnit <= eCSSUnit_Calc_Divided; }

  bool UnitHasStringValue() const
    { return eCSSUnit_String <= mUnit && mUnit <= eCSSUnit_Element; }
  bool UnitHasArrayValue() const
    { return eCSSUnit_Array <= mUnit && mUnit <= eCSSUnit_Calc_Divided; }
  bool IsIntegerColorUnit() const { return IsIntegerColorUnit(mUnit); }
  bool IsFloatColorUnit() const { return IsFloatColorUnit(mUnit); }
  bool IsNumericColorUnit() const { return IsNumericColorUnit(mUnit); }
  static bool IsIntegerColorUnit(nsCSSUnit aUnit)
  { return eCSSUnit_RGBColor <= aUnit && aUnit <= eCSSUnit_ShortHexColorAlpha; }
  static bool IsFloatColorUnit(nsCSSUnit aUnit)
  { return eCSSUnit_PercentageRGBColor <= aUnit &&
           aUnit <= eCSSUnit_HSLAColor; }
  static bool IsNumericColorUnit(nsCSSUnit aUnit)
  { return IsIntegerColorUnit(aUnit) || IsFloatColorUnit(aUnit); }

  int32_t GetIntValue() const
  {
    do { } while (0);



    return mValue.mInt;
  }

  nsCSSKeyword GetKeywordValue() const
  {
    do { } while (0);
    return static_cast<nsCSSKeyword>(mValue.mInt);
  }

  float GetPercentValue() const
  {
    do { } while (0);
    return mValue.mFloat;
  }

  float GetFloatValue() const
  {
    do { } while (0);
    do { } while (0);
    return mValue.mFloat;
  }

  float GetAngleValue() const
  {
    do { } while (0);

    return mValue.mFloat;
  }


  double GetAngleValueInRadians() const;


  double GetAngleValueInDegrees() const;

  nsAString& GetStringValue(nsAString& aBuffer) const
  {
    do { } while (0);
    aBuffer.Truncate();
    uint32_t len = NS_strlen(GetBufferValue(mValue.mString));
    mValue.mString->ToString(len, aBuffer);
    return aBuffer;
  }

  const char16_t* GetStringBufferValue() const
  {
    do { } while (0);
    return GetBufferValue(mValue.mString);
  }

  nscolor GetColorValue() const;
  bool IsNonTransparentColor() const;
  mozilla::StyleComplexColor GetStyleComplexColorValue() const
  {
    do { } while (0);
    return mValue.mComplexColor->ToComplexColor();
  }

  Array* GetArrayValue() const
  {
    do { } while (0);
    return mValue.mArray;
  }

  nsIURI* GetURLValue() const
  {
    do { } while (0);

    return mUnit == eCSSUnit_URL ?
      mValue.mURL->GetURI() : mValue.mImage->GetURI();
  }

  nsCSSValueGradient* GetGradientValue() const
  {
    do { } while (0);
    return mValue.mGradient;
  }

  nsCSSValueTokenStream* GetTokenStreamValue() const
  {
    do { } while (0);
    return mValue.mTokenStream;
  }

  nsCSSValueSharedList* GetSharedListValue() const
  {
    do { } while (0);
    return mValue.mSharedList;
  }

  mozilla::FontFamilyList* GetFontFamilyListValue() const
  {
    do { } while (0);

    do { } while(0);

    return mValue.mFontFamilyList;
  }


  inline nsCSSValuePair& GetPairValue();
  inline const nsCSSValuePair& GetPairValue() const;

  inline nsCSSRect& GetRectValue();
  inline const nsCSSRect& GetRectValue() const;

  inline nsCSSValueList* GetListValue();
  inline const nsCSSValueList* GetListValue() const;

  inline nsCSSValuePairList* GetPairListValue();
  inline const nsCSSValuePairList* GetPairListValue() const;

  inline nsCSSValueTriplet& GetTripletValue();
  inline const nsCSSValueTriplet& GetTripletValue() const;


  mozilla::css::URLValue* GetURLStructValue() const
  {


    do { } while (0);
    return mValue.mURL;
  }

  mozilla::css::ImageValue* GetImageStructValue() const
  {
    do { } while (0);
    return mValue.mImage;
  }

  mozilla::css::GridTemplateAreasValue* GetGridTemplateAreas() const
  {
    do { } while (0);

    return mValue.mGridTemplateAreas;
  }

  const char16_t* GetOriginalURLValue() const
  {
    do { } while (0);

    return GetBufferValue(mUnit == eCSSUnit_URL ?
                            mValue.mURL->mString :
                            mValue.mImage->mString);
  }




  imgRequestProxy* GetImageValue(nsIDocument* aDocument) const;



  already_AddRefed<imgRequestProxy> GetPossiblyStaticImageValue(
      nsIDocument* aDocument, nsPresContext* aPresContext) const;

  nscoord GetFixedLength(nsPresContext* aPresContext) const;
  nscoord GetPixelLength() const;

  nsCSSValueFloatColor* GetFloatColorValue() const
  {
    do { } while (0);
    return mValue.mFloatColor;
  }

  nsIAtom* GetAtomValue() const {
    do { } while (0);
    return mValue.mAtom;
  }

  void Reset()
  {
    if (mUnit != eCSSUnit_Null)
      DoReset();
  }
private:
  void DoReset();

public:
  void SetIntValue(int32_t aValue, nsCSSUnit aUnit);
  template<typename T,
           typename = typename std::enable_if<std::is_enum<T>::value>::type>
  void SetEnumValue(T aValue)
  {
    static_assert(mozilla::EnumTypeFitsWithin<T, int32_t>::value,
                  "aValue must be an enum that fits within mValue.mInt");
    SetIntValue(static_cast<int32_t>(aValue), eCSSUnit_Enumerated);
  }
  void SetPercentValue(float aValue);
  void SetFloatValue(float aValue, nsCSSUnit aUnit);
  void SetStringValue(const nsString& aValue, nsCSSUnit aUnit);
  void SetColorValue(nscolor aValue);
  void SetIntegerColorValue(nscolor aValue, nsCSSUnit aUnit);

  void SetIntegerCoordValue(nscoord aCoord);
  void SetFloatColorValue(float aComponent1,
                          float aComponent2,
                          float aComponent3,
                          float aAlpha, nsCSSUnit aUnit);
  void SetRGBAColorValue(const mozilla::css::RGBAColorData& aValue);
  void SetComplexColorValue(
    already_AddRefed<mozilla::css::ComplexColorValue> aValue);
  void SetArrayValue(nsCSSValue::Array* aArray, nsCSSUnit aUnit);
  void SetURLValue(mozilla::css::URLValue* aURI);
  void SetImageValue(mozilla::css::ImageValue* aImage);
  void SetGradientValue(nsCSSValueGradient* aGradient);
  void SetTokenStreamValue(nsCSSValueTokenStream* aTokenStream);
  void SetGridTemplateAreas(mozilla::css::GridTemplateAreasValue* aValue);
  void SetFontFamilyListValue(mozilla::css::FontFamilyListRefCnt* aFontListValue);
  void SetPairValue(const nsCSSValuePair* aPair);
  void SetPairValue(const nsCSSValue& xValue, const nsCSSValue& yValue);
  void SetSharedListValue(nsCSSValueSharedList* aList);
  void SetDependentListValue(nsCSSValueList* aList);
  void SetDependentPairListValue(nsCSSValuePairList* aList);
  void SetTripletValue(const nsCSSValueTriplet* aTriplet);
  void SetTripletValue(const nsCSSValue& xValue, const nsCSSValue& yValue, const nsCSSValue& zValue);
  void SetAutoValue();
  void SetInheritValue();
  void SetInitialValue();
  void SetUnsetValue();
  void SetNoneValue();
  void SetAllValue();
  void SetNormalValue();
  void SetSystemFontValue();
  void SetDummyValue();
  void SetDummyInheritValue();


  void SetCalcValue(const nsStyleCoord::CalcValue* aCalc);

  nsStyleCoord::CalcValue GetCalcValue() const;



  nsCSSRect& SetRectValue();
  nsCSSValueList* SetListValue();
  nsCSSValuePairList* SetPairListValue();


  void AdoptListValue(mozilla::UniquePtr<nsCSSValueList> aValue);
  void AdoptPairListValue(mozilla::UniquePtr<nsCSSValuePairList> aValue);

  void StartImageLoad(nsIDocument* aDocument) const;


  Array* InitFunction(nsCSSKeyword aFunctionId, uint32_t aNumArgs);

  bool EqualsFunction(nsCSSKeyword aFunctionId) const;



  static already_AddRefed<nsStringBuffer>
    BufferFromString(const nsString& aValue);


  void AtomizeIdentValue();

  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

  static void
  AppendSidesShorthandToString(const nsCSSPropertyID aProperties[],
                               const nsCSSValue* aValues[],
                               nsAString& aString,
                               Serialization aSerialization);
  static void
  AppendBasicShapeRadiusToString(const nsCSSPropertyID aProperties[],
                                 const nsCSSValue* aValues[],
                                 nsAString& aResult,
                                 Serialization aValueSerialization);
  static void
  AppendAlignJustifyValueToString(int32_t aValue, nsAString& aResult);

private:
  static const char16_t* GetBufferValue(nsStringBuffer* aBuffer) {
    return static_cast<char16_t*>(aBuffer->Data());
  }

  void AppendPolygonToString(nsCSSPropertyID aProperty, nsAString& aResult,
                             Serialization aValueSerialization) const;
  void AppendPositionCoordinateToString(const nsCSSValue& aValue,
                                        nsCSSPropertyID aProperty,
                                        nsAString& aResult,
                                        Serialization aSerialization) const;
  void AppendCircleOrEllipseToString(
           nsCSSKeyword aFunctionId,
           nsCSSPropertyID aProperty, nsAString& aResult,
           Serialization aValueSerialization) const;
  void AppendBasicShapePositionToString(
           nsAString& aResult,
           Serialization aValueSerialization) const;
  void AppendInsetToString(nsCSSPropertyID aProperty, nsAString& aResult,
                           Serialization aValueSerialization) const;
protected:
  nsCSSUnit mUnit;
  union {
    int32_t mInt;
    float mFloat;


    nsStringBuffer* mString;
    nscolor mColor;
    nsIAtom* mAtom;
    Array* mArray;
    mozilla::css::URLValue* mURL;
    mozilla::css::ImageValue* mImage;
    mozilla::css::GridTemplateAreasValue* mGridTemplateAreas;
    nsCSSValueGradient* mGradient;
    nsCSSValueTokenStream* mTokenStream;
    nsCSSValuePair_heap* mPair;
    nsCSSRect_heap* mRect;
    nsCSSValueTriplet_heap* mTriplet;
    nsCSSValueList_heap* mList;
    nsCSSValueList* mListDependent;
    nsCSSValueSharedList* mSharedList;
    nsCSSValuePairList_heap* mPairList;
    nsCSSValuePairList* mPairListDependent;
    nsCSSValueFloatColor* mFloatColor;
    mozilla::css::FontFamilyListRefCnt* mFontFamilyList;
    mozilla::css::ComplexColorValue* mComplexColor;
  } mValue;
};

struct nsCSSValue::Array final {


  static Array* Create(size_t aItemCount) {
    return new (aItemCount) Array(aItemCount);
  }

  nsCSSValue& operator[](size_t aIndex) {
    do { } while (0);
    return mArray[aIndex];
  }

  const nsCSSValue& operator[](size_t aIndex) const {
    do { } while (0);
    return mArray[aIndex];
  }

  nsCSSValue& Item(size_t aIndex) { return (*this)[aIndex]; }
  const nsCSSValue& Item(size_t aIndex) const { return (*this)[aIndex]; }

  size_t Count() const { return mCount; }


  nsCSSValue* ItemStorage() {
    return this->First();
  }

  bool operator==(const Array& aOther) const
  {
    if (mCount != aOther.mCount)
      return false;
    for (size_t i = 0; i < mCount; ++i)
      if ((*this)[i] != aOther[i])
        return false;
    return true;
  }

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<Array>::value, "Reference-counted class " "Array" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); nsrefcnt count = ++mRefCnt; ; return (nsrefcnt) count; } MozExternalRefCountType Release(void) { do { } while (0); nsrefcnt count = --mRefCnt; ; if (count == 0) { delete (this); return 0; } return count; } typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:;
private:

  const size_t mCount;



  nsCSSValue mArray[1];

  void* operator new(size_t aSelfSize, size_t aItemCount) throw() {
    do { } while (0);
    return ::operator new(aSelfSize + sizeof(nsCSSValue) * (aItemCount - 1));
  }

  void operator delete(void* aPtr) { ::operator delete(aPtr); }

  nsCSSValue* First() { return mArray; }

  const nsCSSValue* First() const { return mArray; }





  explicit Array(size_t aItemCount)
    : mRefCnt(0)
    , mCount(aItemCount)
  {
    for (nsCSSValue *val = First() + 1, *val_end = First() + mCount; val != val_end; ++val) {
      new (val) nsCSSValue();
    }
  }

  ~Array()
  {
    for (nsCSSValue *val = First() + 1, *val_end = First() + mCount; val != val_end; ++val) {
      val->~nsCSSValue();
    }
  }

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;



private:
  Array(const Array& aOther) = delete;
  Array& operator=(const Array& aOther) = delete;
};


struct nsCSSValueList {
  nsCSSValueList() : mNext(nullptr) { ; }
  ~nsCSSValueList();

  nsCSSValueList* Clone() const;
  void CloneInto(nsCSSValueList* aList) const;
  void AppendToString(nsCSSPropertyID aProperty, nsAString& aResult,
                      nsCSSValue::Serialization aValueSerialization) const;

  static bool Equal(const nsCSSValueList* aList1,
                    const nsCSSValueList* aList2);

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

  nsCSSValue mValue;
  nsCSSValueList* mNext;

private:
  nsCSSValueList(const nsCSSValueList& aCopy)
    : mValue(aCopy.mValue), mNext(nullptr)
  {
                                  ;
  }




  bool operator==(nsCSSValueList const& aOther) const = delete;
  bool operator!=(const nsCSSValueList& aOther) const = delete;
};




struct nsCSSValueList_heap final : public nsCSSValueList {
  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsCSSValueList_heap>::value, "Reference-counted class " "nsCSSValueList_heap" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); ++mRefCnt; ; return mRefCnt; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); --mRefCnt; ; if (mRefCnt == 0) { mRefCnt = 1; delete(this); return 0; } return mRefCnt; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

private:

  ~nsCSSValueList_heap()
  {
  }
};





struct nsCSSValueSharedList final {
  nsCSSValueSharedList()
    : mHead(nullptr)
  {
  }


  explicit nsCSSValueSharedList(nsCSSValueList* aList)
    : mHead(aList)
  {
  }

private:

  ~nsCSSValueSharedList();

public:
  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsCSSValueSharedList>::value, "Reference-counted class " "nsCSSValueSharedList" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); nsrefcnt count = ++mRefCnt; ; return (nsrefcnt) count; } MozExternalRefCountType Release(void) { do { } while (0); nsrefcnt count = --mRefCnt; ; if (count == 0) { delete (this); return 0; } return count; } typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:

  void AppendToString(nsCSSPropertyID aProperty, nsAString& aResult,
                      nsCSSValue::Serialization aValueSerialization) const;

  bool operator==(nsCSSValueSharedList const& aOther) const;
  bool operator!=(const nsCSSValueSharedList& aOther) const
  { return !(*this == aOther); }

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

  nsCSSValueList* mHead;
};



inline nsCSSValueList*
nsCSSValue::GetListValue()
{
  if (mUnit == eCSSUnit_List)
    return mValue.mList;
  else {
    do { } while (0);
    return mValue.mListDependent;
  }
}

inline const nsCSSValueList*
nsCSSValue::GetListValue() const
{
  if (mUnit == eCSSUnit_List)
    return mValue.mList;
  else {
    do { } while (0);
    return mValue.mListDependent;
  }
}

struct nsCSSRect {
  nsCSSRect(void);
  nsCSSRect(const nsCSSRect& aCopy);
  ~nsCSSRect();

  void AppendToString(nsCSSPropertyID aProperty, nsAString& aResult,
                      nsCSSValue::Serialization aValueSerialization) const;

  bool operator==(const nsCSSRect& aOther) const {
    return mTop == aOther.mTop &&
           mRight == aOther.mRight &&
           mBottom == aOther.mBottom &&
           mLeft == aOther.mLeft;
  }

  bool operator!=(const nsCSSRect& aOther) const {
    return mTop != aOther.mTop ||
           mRight != aOther.mRight ||
           mBottom != aOther.mBottom ||
           mLeft != aOther.mLeft;
  }

  void SetAllSidesTo(const nsCSSValue& aValue);

  bool AllSidesEqualTo(const nsCSSValue& aValue) const {
    return mTop == aValue &&
           mRight == aValue &&
           mBottom == aValue &&
           mLeft == aValue;
  }

  void Reset() {
    mTop.Reset();
    mRight.Reset();
    mBottom.Reset();
    mLeft.Reset();
  }

  bool HasValue() const {
    return
      mTop.GetUnit() != eCSSUnit_Null ||
      mRight.GetUnit() != eCSSUnit_Null ||
      mBottom.GetUnit() != eCSSUnit_Null ||
      mLeft.GetUnit() != eCSSUnit_Null;
  }

  nsCSSValue mTop;
  nsCSSValue mRight;
  nsCSSValue mBottom;
  nsCSSValue mLeft;

  typedef nsCSSValue nsCSSRect::*side_type;
  static const side_type sides[4];
};




struct nsCSSRect_heap final : public nsCSSRect {
  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsCSSRect_heap>::value, "Reference-counted class " "nsCSSRect_heap" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); ++mRefCnt; ; return mRefCnt; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); --mRefCnt; ; if (mRefCnt == 0) { mRefCnt = 1; delete(this); return 0; } return mRefCnt; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

private:

  ~nsCSSRect_heap()
  {
  }
};



inline nsCSSRect&
nsCSSValue::GetRectValue()
{
  do { } while (0);
  return *mValue.mRect;
}

inline const nsCSSRect&
nsCSSValue::GetRectValue() const
{
  do { } while (0);
  return *mValue.mRect;
}

struct nsCSSValuePair {
  nsCSSValuePair()
  {
                                  ;
  }
  explicit nsCSSValuePair(nsCSSUnit aUnit)
    : mXValue(aUnit), mYValue(aUnit)
  {
                                  ;
  }
  nsCSSValuePair(const nsCSSValue& aXValue, const nsCSSValue& aYValue)
    : mXValue(aXValue), mYValue(aYValue)
  {
                                  ;
  }
  nsCSSValuePair(const nsCSSValuePair& aCopy)
    : mXValue(aCopy.mXValue), mYValue(aCopy.mYValue)
  {
                                  ;
  }
  ~nsCSSValuePair()
  {
                                  ;
  }

  nsCSSValuePair& operator=(const nsCSSValuePair& aOther) {
    mXValue = aOther.mXValue;
    mYValue = aOther.mYValue;
    return *this;
  }

  bool operator==(const nsCSSValuePair& aOther) const {
    return mXValue == aOther.mXValue &&
           mYValue == aOther.mYValue;
  }

  bool operator!=(const nsCSSValuePair& aOther) const {
    return mXValue != aOther.mXValue ||
           mYValue != aOther.mYValue;
  }

  bool BothValuesEqualTo(const nsCSSValue& aValue) const {
    return mXValue == aValue &&
           mYValue == aValue;
  }

  void SetBothValuesTo(const nsCSSValue& aValue) {
    mXValue = aValue;
    mYValue = aValue;
  }

  void Reset() {
    mXValue.Reset();
    mYValue.Reset();
  }

  bool HasValue() const {
    return mXValue.GetUnit() != eCSSUnit_Null ||
           mYValue.GetUnit() != eCSSUnit_Null;
  }

  void AppendToString(nsCSSPropertyID aProperty, nsAString& aResult,
                      nsCSSValue::Serialization aValueSerialization) const;

  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

  nsCSSValue mXValue;
  nsCSSValue mYValue;
};




struct nsCSSValuePair_heap final : public nsCSSValuePair {

  nsCSSValuePair_heap(const nsCSSValue& aXValue, const nsCSSValue& aYValue)
      : nsCSSValuePair(aXValue, aYValue)
  {}

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsCSSValuePair_heap>::value, "Reference-counted class " "nsCSSValuePair_heap" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); ++mRefCnt; ; return mRefCnt; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); --mRefCnt; ; if (mRefCnt == 0) { mRefCnt = 1; delete(this); return 0; } return mRefCnt; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

private:

  ~nsCSSValuePair_heap()
  {
  }
};

struct nsCSSValueTriplet {
    nsCSSValueTriplet()
    {
                                         ;
    }
    explicit nsCSSValueTriplet(nsCSSUnit aUnit)
        : mXValue(aUnit), mYValue(aUnit), mZValue(aUnit)
    {
                                         ;
    }
    nsCSSValueTriplet(const nsCSSValue& aXValue,
                      const nsCSSValue& aYValue,
                      const nsCSSValue& aZValue)
        : mXValue(aXValue), mYValue(aYValue), mZValue(aZValue)
    {
                                         ;
    }
    nsCSSValueTriplet(const nsCSSValueTriplet& aCopy)
        : mXValue(aCopy.mXValue), mYValue(aCopy.mYValue), mZValue(aCopy.mZValue)
    {
                                         ;
    }
    ~nsCSSValueTriplet()
    {
                                         ;
    }

    bool operator==(const nsCSSValueTriplet& aOther) const {
        return mXValue == aOther.mXValue &&
               mYValue == aOther.mYValue &&
               mZValue == aOther.mZValue;
    }

    bool operator!=(const nsCSSValueTriplet& aOther) const {
        return mXValue != aOther.mXValue ||
               mYValue != aOther.mYValue ||
               mZValue != aOther.mZValue;
    }

    bool AllValuesEqualTo(const nsCSSValue& aValue) const {
        return mXValue == aValue &&
               mYValue == aValue &&
               mZValue == aValue;
    }

    void SetAllValuesTo(const nsCSSValue& aValue) {
        mXValue = aValue;
        mYValue = aValue;
        mZValue = aValue;
    }

    void Reset() {
        mXValue.Reset();
        mYValue.Reset();
        mZValue.Reset();
    }

    bool HasValue() const {
        return mXValue.GetUnit() != eCSSUnit_Null ||
               mYValue.GetUnit() != eCSSUnit_Null ||
               mZValue.GetUnit() != eCSSUnit_Null;
    }

    void AppendToString(nsCSSPropertyID aProperty, nsAString& aResult,
                        nsCSSValue::Serialization aValueSerialization) const;

    nsCSSValue mXValue;
    nsCSSValue mYValue;
    nsCSSValue mZValue;
};




struct nsCSSValueTriplet_heap final : public nsCSSValueTriplet {

  nsCSSValueTriplet_heap(const nsCSSValue& aXValue, const nsCSSValue& aYValue, const nsCSSValue& aZValue)
    : nsCSSValueTriplet(aXValue, aYValue, aZValue)
  {}

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsCSSValueTriplet_heap>::value, "Reference-counted class " "nsCSSValueTriplet_heap" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); ++mRefCnt; ; return mRefCnt; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); --mRefCnt; ; if (mRefCnt == 0) { mRefCnt = 1; delete(this); return 0; } return mRefCnt; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

private:

  ~nsCSSValueTriplet_heap()
  {
  }
};



inline nsCSSValuePair&
nsCSSValue::GetPairValue()
{
  do { } while (0);
  return *mValue.mPair;
}

inline const nsCSSValuePair&
nsCSSValue::GetPairValue() const
{
  do { } while (0);
  return *mValue.mPair;
}

inline nsCSSValueTriplet&
nsCSSValue::GetTripletValue()
{
    do { } while (0);
    return *mValue.mTriplet;
}

inline const nsCSSValueTriplet&
nsCSSValue::GetTripletValue() const
{
    do { } while (0);
    return *mValue.mTriplet;
}


struct nsCSSValuePairList {
  nsCSSValuePairList() : mNext(nullptr) { ; }
  ~nsCSSValuePairList();

  nsCSSValuePairList* Clone() const;
  void AppendToString(nsCSSPropertyID aProperty, nsAString& aResult,
                      nsCSSValue::Serialization aValueSerialization) const;

  static bool Equal(const nsCSSValuePairList* aList1,
                    const nsCSSValuePairList* aList2);

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

  nsCSSValue mXValue;
  nsCSSValue mYValue;
  nsCSSValuePairList* mNext;

private:
  nsCSSValuePairList(const nsCSSValuePairList& aCopy)
    : mXValue(aCopy.mXValue), mYValue(aCopy.mYValue), mNext(nullptr)
  {
                                      ;
  }




  bool operator==(const nsCSSValuePairList& aOther) const = delete;
  bool operator!=(const nsCSSValuePairList& aOther) const = delete;
};




struct nsCSSValuePairList_heap final : public nsCSSValuePairList {
  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsCSSValuePairList_heap>::value, "Reference-counted class " "nsCSSValuePairList_heap" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); ++mRefCnt; ; return mRefCnt; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); --mRefCnt; ; if (mRefCnt == 0) { mRefCnt = 1; delete(this); return 0; } return mRefCnt; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

private:

  ~nsCSSValuePairList_heap()
  {
  }
};



inline nsCSSValuePairList*
nsCSSValue::GetPairListValue()
{
  if (mUnit == eCSSUnit_PairList)
    return mValue.mPairList;
  else {
    do { } while (0);
    return mValue.mPairListDependent;
  }
}

inline const nsCSSValuePairList*
nsCSSValue::GetPairListValue() const
{
  if (mUnit == eCSSUnit_PairList)
    return mValue.mPairList;
  else {
    do { } while (0);
    return mValue.mPairListDependent;
  }
}

struct nsCSSValueGradientStop {
public:
  nsCSSValueGradientStop();


  nsCSSValueGradientStop(const nsCSSValueGradientStop& aOther);
  ~nsCSSValueGradientStop();

  nsCSSValue mLocation;
  nsCSSValue mColor;


  bool mIsInterpolationHint;

  bool operator==(const nsCSSValueGradientStop& aOther) const
  {
    return (mLocation == aOther.mLocation &&
            mIsInterpolationHint == aOther.mIsInterpolationHint &&
            (mIsInterpolationHint || mColor == aOther.mColor));
  }

  bool operator!=(const nsCSSValueGradientStop& aOther) const
  {
    return !(*this == aOther);
  }

  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;
};

struct nsCSSValueGradient final {
  nsCSSValueGradient(bool aIsRadial, bool aIsRepeating);


  bool mIsRadial;
  bool mIsRepeating;
  bool mIsLegacySyntax;
  bool mIsExplicitSize;

  nsCSSValuePair mBgPos;
  nsCSSValue mAngle;


private:
  nsCSSValue mRadialValues[2];
public:
  nsCSSValue& GetRadialShape()
  {
    do { } while (0);
    return mRadialValues[0];
  }
  const nsCSSValue& GetRadialShape() const
  {
    do { } while (0);
    return mRadialValues[0];
  }
  nsCSSValue& GetRadialSize()
  {
    do { } while (0);
    return mRadialValues[1];
  }
  const nsCSSValue& GetRadialSize() const
  {
    do { } while (0);
    return mRadialValues[1];
  }
  nsCSSValue& GetRadiusX()
  {
    do { } while (0);
    return mRadialValues[0];
  }
  const nsCSSValue& GetRadiusX() const
  {
    do { } while (0);
    return mRadialValues[0];
  }
  nsCSSValue& GetRadiusY()
  {
    do { } while (0);
    return mRadialValues[1];
  }
  const nsCSSValue& GetRadiusY() const
  {
    do { } while (0);
    return mRadialValues[1];
  }

  InfallibleTArray<nsCSSValueGradientStop> mStops;

  bool operator==(const nsCSSValueGradient& aOther) const
  {
    if (mIsRadial != aOther.mIsRadial ||
        mIsRepeating != aOther.mIsRepeating ||
        mIsLegacySyntax != aOther.mIsLegacySyntax ||
        mIsExplicitSize != aOther.mIsExplicitSize ||
        mBgPos != aOther.mBgPos ||
        mAngle != aOther.mAngle ||
        mRadialValues[0] != aOther.mRadialValues[0] ||
        mRadialValues[1] != aOther.mRadialValues[1])
      return false;

    if (mStops.Length() != aOther.mStops.Length())
      return false;

    for (uint32_t i = 0; i < mStops.Length(); i++) {
      if (mStops[i] != aOther.mStops[i])
        return false;
    }

    return true;
  }

  bool operator!=(const nsCSSValueGradient& aOther) const
  {
    return !(*this == aOther);
  }

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsCSSValueGradient>::value, "Reference-counted class " "nsCSSValueGradient" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); ++mRefCnt; ; return mRefCnt; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); --mRefCnt; ; if (mRefCnt == 0) { mRefCnt = 1; delete(this); return 0; } return mRefCnt; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

private:

  ~nsCSSValueGradient()
  {
  }

  nsCSSValueGradient(const nsCSSValueGradient& aOther) = delete;
  nsCSSValueGradient& operator=(const nsCSSValueGradient& aOther) = delete;
};
struct nsCSSValueTokenStream final {
  nsCSSValueTokenStream();

private:

  ~nsCSSValueTokenStream();

public:
  bool operator==(const nsCSSValueTokenStream& aOther) const
  {
    bool eq;
    return mPropertyID == aOther.mPropertyID &&
           mShorthandPropertyID == aOther.mShorthandPropertyID &&
           mTokenStream.Equals(aOther.mTokenStream) &&
           mLevel == aOther.mLevel &&
           (mBaseURI == aOther.mBaseURI ||
            (mBaseURI && aOther.mBaseURI &&
             ((bool)(__builtin_expect(!!(!NS_FAILED_impl(mBaseURI->Equals(aOther.mBaseURI, &eq))), 1))) &&
             eq)) &&
           (mSheetURI == aOther.mSheetURI ||
            (mSheetURI && aOther.mSheetURI &&
             ((bool)(__builtin_expect(!!(!NS_FAILED_impl(mSheetURI->Equals(aOther.mSheetURI, &eq))), 1))) &&
             eq)) &&
           (mSheetPrincipal == aOther.mSheetPrincipal ||
            (mSheetPrincipal && aOther.mSheetPrincipal &&
             ((bool)(__builtin_expect(!!(!NS_FAILED_impl(mSheetPrincipal->Equals(aOther.mSheetPrincipal, &eq))), 1))) &&

             eq));
  }

  bool operator!=(const nsCSSValueTokenStream& aOther) const
  {
    return !(*this == aOther);
  }

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsCSSValueTokenStream>::value, "Reference-counted class " "nsCSSValueTokenStream" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); ++mRefCnt; ; return mRefCnt; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); --mRefCnt; ; if (mRefCnt == 0) { mRefCnt = 1; delete(this); return 0; } return mRefCnt; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;





  nsCSSPropertyID mPropertyID;




  nsCSSPropertyID mShorthandPropertyID;





  nsString mTokenStream;

  nsCOMPtr<nsIURI> mBaseURI;
  nsCOMPtr<nsIURI> mSheetURI;
  nsCOMPtr<nsIPrincipal> mSheetPrincipal;


  uint32_t mLineNumber;
  uint32_t mLineOffset;
  mozilla::SheetType mLevel;

private:
  nsCSSValueTokenStream(const nsCSSValueTokenStream& aOther) = delete;
  nsCSSValueTokenStream& operator=(const nsCSSValueTokenStream& aOther) = delete;
};

class nsCSSValueFloatColor final {
public:
  nsCSSValueFloatColor(float aComponent1, float aComponent2, float aComponent3,
                       float aAlpha)
    : mComponent1(aComponent1)
    , mComponent2(aComponent2)
    , mComponent3(aComponent3)
    , mAlpha(aAlpha)
  {}

private:

  ~nsCSSValueFloatColor()
  {}

public:
  bool operator==(nsCSSValueFloatColor& aOther) const;

  nscolor GetColorValue(nsCSSUnit aUnit) const;
  float Comp1() const { return mComponent1; }
  float Comp2() const { return mComponent2; }
  float Comp3() const { return mComponent3; }
  float Alpha() const { return mAlpha; }
  bool IsNonTransparentColor() const;

  void AppendToString(nsCSSUnit aUnit, nsAString& aResult) const;

  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsCSSValueFloatColor>::value, "Reference-counted class " "nsCSSValueFloatColor" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); ++mRefCnt; ; return mRefCnt; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); --mRefCnt; ; if (mRefCnt == 0) { mRefCnt = 1; delete(this); return 0; } return mRefCnt; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:

private:
  float mComponent1;
  float mComponent2;
  float mComponent3;
  float mAlpha;

  nsCSSValueFloatColor(const nsCSSValueFloatColor& aOther) = delete;
  nsCSSValueFloatColor& operator=(const nsCSSValueFloatColor& aOther)
                                                                   = delete;
};

struct nsCSSCornerSizes {
  nsCSSCornerSizes(void);
  nsCSSCornerSizes(const nsCSSCornerSizes& aCopy);
  ~nsCSSCornerSizes();


  nsCSSValue const & GetCorner(uint32_t aCorner) const {
    return this->*corners[aCorner];
  }
  nsCSSValue & GetCorner(uint32_t aCorner) {
    return this->*corners[aCorner];
  }

  bool operator==(const nsCSSCornerSizes& aOther) const {
    int32_t corner1905 = mozilla::eCornerTopLeft; for (mozilla::Corner corner; corner1905 <= mozilla::eCornerBottomLeft && (corner = mozilla::Corner(corner1905), true); ++corner1905) {
      if (this->GetCorner(corner) != aOther.GetCorner(corner))
        return false;
    }
    return true;
  }

  bool operator!=(const nsCSSCornerSizes& aOther) const {
    int32_t corner1913 = mozilla::eCornerTopLeft; for (mozilla::Corner corner; corner1913 <= mozilla::eCornerBottomLeft && (corner = mozilla::Corner(corner1913), true); ++corner1913) {
      if (this->GetCorner(corner) != aOther.GetCorner(corner))
        return true;
    }
    return false;
  }

  bool HasValue() const {
    int32_t corner1921 = mozilla::eCornerTopLeft; for (mozilla::Corner corner; corner1921 <= mozilla::eCornerBottomLeft && (corner = mozilla::Corner(corner1921), true); ++corner1921) {
      if (this->GetCorner(corner).GetUnit() != eCSSUnit_Null)
        return true;
    }
    return false;
  }

  void Reset();

  nsCSSValue mTopLeft;
  nsCSSValue mTopRight;
  nsCSSValue mBottomRight;
  nsCSSValue mBottomLeft;

protected:
  typedef nsCSSValue nsCSSCornerSizes::*corner_type;
  static const corner_type corners[4];
};


using mozilla::dom::DOMRect;
using mozilla::dom::Element;

namespace mozilla {
namespace dom {

class DOMIntersectionObserver;

class DOMIntersectionObserverEntry final : public nsISupports,
                                           public nsWrapperCache
{
  ~DOMIntersectionObserverEntry() {}

public:
  DOMIntersectionObserverEntry(nsISupports* aOwner,
                               DOMHighResTimeStamp aTime,
                               RefPtr<DOMRect> aRootBounds,
                               RefPtr<DOMRect> aBoundingClientRect,
                               RefPtr<DOMRect> aIntersectionRect,
                               bool aIsIntersecting,
                               Element* aTarget,
                               double aIntersectionRatio)
  : mOwner(aOwner),
    mTime(aTime),
    mRootBounds(aRootBounds),
    mBoundingClientRect(aBoundingClientRect),
    mIntersectionRect(aIntersectionRect),
    mIsIntersecting(aIsIntersecting),
    mTarget(aTarget),
    mIntersectionRatio(aIntersectionRatio)
  {
  }
  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; virtual void DeleteCycleCollectable(void); typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:
  class cycleCollection : public nsXPCOMCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = false) : nsXPCOMCycleCollectionParticipant(aSkip) {} private: public: virtual nsresult TraverseNative(void *p, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "DOMIntersectionObserverEntry"; }; virtual void DeleteCycleCollectable(void *p) override { DowncastCCParticipant<DOMIntersectionObserverEntry>(p)->DeleteCycleCollectable(); } static DOMIntersectionObserverEntry* Downcast(nsISupports* s) { return static_cast<DOMIntersectionObserverEntry*>(static_cast<DOMIntersectionObserverEntry*>(s)); } static nsISupports* Upcast(DOMIntersectionObserverEntry *p) { return static_cast<nsISupports*>(static_cast<DOMIntersectionObserverEntry*>(p)); } template<typename T> friend nsISupports* ToSupports(T* p, cycleCollection* dummy); virtual void Unlink(void *p) override; virtual void Trace(void *p, const TraceCallbacks &cb, void *closure) override; static constexpr nsXPCOMCycleCollectionParticipant* GetParticipant() { return &DOMIntersectionObserverEntry::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;

  nsISupports* GetParentObject() const
  {
    return mOwner;
  }

  virtual JSObject* WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override
  {
    return mozilla::dom::IntersectionObserverEntryBinding::Wrap(aCx, this, aGivenProto);
  }

  DOMHighResTimeStamp Time()
  {
    return mTime;
  }

  DOMRect* GetRootBounds()
  {
    return mRootBounds;
  }

  DOMRect* BoundingClientRect()
  {
    return mBoundingClientRect;
  }

  DOMRect* IntersectionRect()
  {
    return mIntersectionRect;
  }

  bool IsIntersecting()
  {
    return mIsIntersecting;
  }

  double IntersectionRatio()
  {
    return mIntersectionRatio;
  }

  Element* Target()
  {
    return mTarget;
  }

protected:
  nsCOMPtr<nsISupports> mOwner;
  DOMHighResTimeStamp mTime;
  RefPtr<DOMRect> mRootBounds;
  RefPtr<DOMRect> mBoundingClientRect;
  RefPtr<DOMRect> mIntersectionRect;
  bool mIsIntersecting;
  RefPtr<Element> mTarget;
  double mIntersectionRatio;
};





class DOMIntersectionObserver final : public nsISupports,
                                      public nsWrapperCache
{
  virtual ~DOMIntersectionObserver() {
    Disconnect();
  }

public:
  DOMIntersectionObserver(already_AddRefed<nsPIDOMWindowInner>&& aOwner,
                          mozilla::dom::IntersectionCallback& aCb)
  : mOwner(aOwner), mDocument(mOwner->GetExtantDoc()), mCallback(&aCb), mConnected(false)
  {
  }
  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; virtual void DeleteCycleCollectable(void); typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:
  class cycleCollection : public nsXPCOMCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = false) : nsXPCOMCycleCollectionParticipant(aSkip) {} private: public: virtual nsresult TraverseNative(void *p, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "DOMIntersectionObserver"; }; virtual void DeleteCycleCollectable(void *p) override { DowncastCCParticipant<DOMIntersectionObserver>(p)->DeleteCycleCollectable(); } static DOMIntersectionObserver* Downcast(nsISupports* s) { return static_cast<DOMIntersectionObserver*>(static_cast<DOMIntersectionObserver*>(s)); } static nsISupports* Upcast(DOMIntersectionObserver *p) { return static_cast<nsISupports*>(static_cast<DOMIntersectionObserver*>(p)); } template<typename T> friend nsISupports* ToSupports(T* p, cycleCollection* dummy); virtual void Unlink(void *p) override; virtual void Trace(void *p, const TraceCallbacks &cb, void *closure) override; static constexpr nsXPCOMCycleCollectionParticipant* GetParticipant() { return &DOMIntersectionObserver::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;
  template<typename T, typename U> struct COMTypeInfo;

  static already_AddRefed<DOMIntersectionObserver>
  Constructor(const mozilla::dom::GlobalObject& aGlobal,
              mozilla::dom::IntersectionCallback& aCb,
              mozilla::ErrorResult& aRv);
  static already_AddRefed<DOMIntersectionObserver>
  Constructor(const mozilla::dom::GlobalObject& aGlobal,
              mozilla::dom::IntersectionCallback& aCb,
              const mozilla::dom::IntersectionObserverInit& aOptions,
              mozilla::ErrorResult& aRv);

  virtual JSObject* WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override
  {
    return mozilla::dom::IntersectionObserverBinding::Wrap(aCx, this, aGivenProto);
  }

  nsISupports* GetParentObject() const
  {
    return mOwner;
  }

  Element* GetRoot() const {
    return mRoot;
  }

  void GetRootMargin(mozilla::dom::DOMString& aRetVal);
  void GetThresholds(nsTArray<double>& aRetVal);
  void Observe(Element& aTarget);
  void Unobserve(Element& aTarget);

  void UnlinkTarget(Element& aTarget);
  void Disconnect();

  void TakeRecords(nsTArray<RefPtr<DOMIntersectionObserverEntry>>& aRetVal);

  mozilla::dom::IntersectionCallback* IntersectionCallback() { return mCallback; }

  bool SetRootMargin(const nsAString& aString);

  void Update(nsIDocument* aDocument, DOMHighResTimeStamp time);
  void Notify();

protected:
  void Connect();
  void QueueIntersectionObserverEntry(Element* aTarget,
                                      DOMHighResTimeStamp time,
                                      const Maybe<nsRect>& aRootRect,
                                      const nsRect& aTargetRect,
                                      const Maybe<nsRect>& aIntersectionRect,
                                      double aIntersectionRatio);

  nsCOMPtr<nsPIDOMWindowInner> mOwner;
  RefPtr<nsIDocument> mDocument;
  RefPtr<mozilla::dom::IntersectionCallback> mCallback;
  RefPtr<Element> mRoot;
  nsCSSRect mRootMargin;
  nsTArray<double> mThresholds;
  nsTHashtable<nsPtrHashKey<Element>> mObservationTargets;
  nsTArray<RefPtr<DOMIntersectionObserverEntry>> mQueuedEntries;
  bool mConnected;
};

template<typename T> struct DOMIntersectionObserver::COMTypeInfo<DOMIntersectionObserver, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID DOMIntersectionObserver::COMTypeInfo<DOMIntersectionObserver, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0x8570a575, 0xe303, 0x4d18, { 0xb6, 0xb1, 0x4d, 0x2b, 0x49, 0xd8, 0xef, 0x94 } };

}
}

class mozAutoDocUpdate;
class nsIFrame;
class nsIDOMMozNamedAttrMap;
class nsIMozBrowserFrame;
class nsIURI;
class nsIScrollableFrame;
class nsAttrValueOrString;
class nsContentList;
class nsDOMTokenList;
struct nsRect;
class nsFocusManager;
class nsGlobalWindow;
class nsICSSDeclaration;
class nsISMILAttr;
class nsDocument;
class nsDOMStringMap;

namespace mozilla {
class DeclarationBlock;
namespace dom {
  struct AnimationFilter;
  struct ScrollIntoViewOptions;
  struct ScrollToOptions;
  class DOMIntersectionObserver;
  class ElementOrCSSPseudoElement;
  class UnrestrictedDoubleOrKeyframeAnimationOptions;
  enum class CallerType : uint32_t;
}
}


already_AddRefed<nsContentList>
NS_GetContentList(nsINode* aRootNode,
                  int32_t aMatchNameSpaceId,
                  const nsAString& aTagname);




enum {

  ELEMENT_HAS_PENDING_RESTYLE = NODE_SHARED_RESTYLE_BIT_1,




  ELEMENT_IS_POTENTIAL_RESTYLE_ROOT = NODE_SHARED_RESTYLE_BIT_2,





  ELEMENT_HAS_PENDING_ANIMATION_ONLY_RESTYLE = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (NODE_TYPE_SPECIFIC_BITS_OFFSET + (0)))),




  ELEMENT_IS_POTENTIAL_ANIMATION_ONLY_RESTYLE_ROOT = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (NODE_TYPE_SPECIFIC_BITS_OFFSET + (1)))),



  ELEMENT_IS_CONDITIONAL_RESTYLE_ANCESTOR = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (NODE_TYPE_SPECIFIC_BITS_OFFSET + (2)))),


  ELEMENT_PENDING_RESTYLE_FLAGS =
    ELEMENT_HAS_PENDING_RESTYLE |
    ELEMENT_HAS_PENDING_ANIMATION_ONLY_RESTYLE,


  ELEMENT_POTENTIAL_RESTYLE_ROOT_FLAGS =
    ELEMENT_IS_POTENTIAL_RESTYLE_ROOT |
    ELEMENT_IS_POTENTIAL_ANIMATION_ONLY_RESTYLE_ROOT,


  ELEMENT_ALL_RESTYLE_FLAGS = ELEMENT_PENDING_RESTYLE_FLAGS |
                              ELEMENT_POTENTIAL_RESTYLE_ROOT_FLAGS |
                              ELEMENT_IS_CONDITIONAL_RESTYLE_ANCESTOR,


  ELEMENT_HAS_SCROLLGRAB = (nsWrapperCache::FlagsType(1U) << (WRAPPER_CACHE_FLAGS_BITS_USED + (NODE_TYPE_SPECIFIC_BITS_OFFSET + (3)))),


  ELEMENT_TYPE_SPECIFIC_BITS_OFFSET = NODE_TYPE_SPECIFIC_BITS_OFFSET + 4
};




static_assert(WRAPPER_CACHE_FLAGS_BITS_USED + (ELEMENT_TYPE_SPECIFIC_BITS_OFFSET) <= sizeof(nsWrapperCache::FlagsType) * 8, "Not enough space for our bits");

namespace mozilla {
enum class CSSPseudoElementType : uint8_t;
class EventChainPostVisitor;
class EventChainPreVisitor;
class EventChainVisitor;
class EventListenerManager;
class EventStateManager;

namespace dom {

class Animation;
class CustomElementRegistry;
class Link;
class DOMRect;
class DOMRectList;
class DestinationInsertionPointList;
class Grid;






class Element : public FragmentOrElement
{
public:

  explicit Element(already_AddRefed<mozilla::dom::NodeInfo>& aNodeInfo) :
    FragmentOrElement(aNodeInfo),
    mState((mozilla::EventStates(mozilla::EventStates::InternalType(1) << 29)))
  {
    do { } while (0);

    SetIsElement();
  }

  ~Element()
  {

    do { } while(0);

  }



  template<typename T, typename U> struct COMTypeInfo;

  virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override;





  EventStates State() const
  {


    return mState;
  }
  void UpdateState(bool aNotify);




  void UpdateLinkState(EventStates aState);

  virtual int32_t TabIndexDefault()
  {
    return -1;
  }




  int32_t TabIndex();




  void SetTabIndex(int32_t aTabIndex, mozilla::ErrorResult& aError);




  virtual void Focus(mozilla::ErrorResult& aError);




  virtual void Blur(mozilla::ErrorResult& aError);





  EventStates StyleState() const
  {
    if (!HasLockedStyleStates()) {
      return mState;
    }
    return StyleStateFromLocks();
  }





  struct StyleStateLocks {

    EventStates mLocks;

    EventStates mValues;
  };




  StyleStateLocks LockedStyleStates() const;





  void LockStyleStates(EventStates aStates, bool aEnabled);




  void UnlockStyleStates(EventStates aStates);




  void ClearStyleStateLocks();




  DeclarationBlock* GetInlineStyleDeclaration() const;




  const nsMappedAttributes* GetMappedAttributes() const;

  void ClearMappedServoStyle() {
    mAttrsAndChildren.ClearMappedServoStyle();
  }





  virtual nsresult SetInlineStyleDeclaration(DeclarationBlock* aDeclaration,
                                             const nsAString* aSerialized,
                                             bool aNotify);





  virtual DeclarationBlock* GetSMILOverrideStyleDeclaration();






  virtual nsresult SetSMILOverrideStyleDeclaration(
    DeclarationBlock* aDeclaration, bool aNotify);





  virtual UniquePtr<nsISMILAttr> GetAnimatedAttr(int32_t aNamespaceID,
                                                 nsIAtom* aName)
  {
    return nullptr;
  }
  virtual nsICSSDeclaration* GetSMILOverrideStyle();




  virtual bool IsLabelable() const;




  virtual bool IsInteractiveHTMLContent(bool aIgnoreTabindex) const;
  virtual nsIMozBrowserFrame* GetAsMozBrowserFrame() { return nullptr; }
  virtual bool IsAttributeMapped(const nsIAtom* aAttribute) const;







  virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute,
                                              int32_t aModType) const;

  inline Directionality GetDirectionality() const {
    if (HasFlag(NODE_HAS_DIRECTION_RTL)) {
      return eDir_RTL;
    }

    if (HasFlag(NODE_HAS_DIRECTION_LTR)) {
      return eDir_LTR;
    }

    return eDir_NotSet;
  }

  inline void SetDirectionality(Directionality aDir, bool aNotify) {
    UnsetFlags(NODE_ALL_DIRECTION_FLAGS);
    if (!aNotify) {
      RemoveStatesSilently(((mozilla::EventStates(mozilla::EventStates::InternalType(1) << 44)) | (mozilla::EventStates(mozilla::EventStates::InternalType(1) << 45))));
    }

    switch (aDir) {
      case (eDir_RTL):
        SetFlags(NODE_HAS_DIRECTION_RTL);
        if (!aNotify) {
          AddStatesSilently((mozilla::EventStates(mozilla::EventStates::InternalType(1) << 45)));
        }
        break;

      case(eDir_LTR):
        SetFlags(NODE_HAS_DIRECTION_LTR);
        if (!aNotify) {
          AddStatesSilently((mozilla::EventStates(mozilla::EventStates::InternalType(1) << 44)));
        }
        break;

      default:
        break;
    }






    if (aNotify) {
      UpdateState(true);
    }
  }

  bool GetBindingURL(nsIDocument* aDocument, css::URLValue **aResult);





  inline bool HasDirAuto() const {
    return (!HasFixedDir() &&
            (HasValidDir() || IsHTMLElement(nsGkAtoms::bdi)));
  }

  Directionality GetComputedDirectionality() const;

  inline Element* GetFlattenedTreeParentElement() const;
  inline Element* GetFlattenedTreeParentElementForStyle() const;

  bool HasDirtyDescendantsForServo() const
  {
    do { } while (0);
    return HasFlag(NODE_HAS_DIRTY_DESCENDANTS_FOR_SERVO);
  }

  void SetHasDirtyDescendantsForServo() {
    do { } while (0);
    SetFlags(NODE_HAS_DIRTY_DESCENDANTS_FOR_SERVO);
  }

  void UnsetHasDirtyDescendantsForServo() {
    do { } while (0);
    UnsetFlags(NODE_HAS_DIRTY_DESCENDANTS_FOR_SERVO);
  }

  inline void NoteDirtyDescendantsForServo();





  bool HasServoData() const {

    return !!mServoData.Get();



  }

  void ClearServoData();







  inline CustomElementData* GetCustomElementData() const
  {
    nsDOMSlots *slots = GetExistingDOMSlots();
    if (slots) {
      return slots->mCustomElementData;
    }
    return nullptr;
  }







  void SetCustomElementData(CustomElementData* aData);

protected:






  virtual EventStates IntrinsicState() const;







  void AddStatesSilently(EventStates aStates)
  {
    mState |= aStates;
  }







  void RemoveStatesSilently(EventStates aStates)
  {
    mState &= ~aStates;
  }

private:


  friend class mozilla::EventStateManager;
  friend class ::nsGlobalWindow;
  friend class ::nsFocusManager;


  friend class CustomElementRegistry;


  friend class Link;

  void NotifyStateChange(EventStates aStates);

  void NotifyStyleStateChange(EventStates aStates);


  EventStates StyleStateFromLocks() const;

protected:




  virtual void AddStates(EventStates aStates)
  {
    do { } while(0);

    AddStatesSilently(aStates);
    NotifyStateChange(aStates);
  }
  virtual void RemoveStates(EventStates aStates)
  {
    do { } while(0);

    RemoveStatesSilently(aStates);
    NotifyStateChange(aStates);
  }
public:

  void AddManuallyManagedStates(EventStates aStates)
  {
    do { } while (0);

    AddStates(aStates);
  }
  void RemoveManuallyManagedStates(EventStates aStates)
  {
    do { } while (0);

    RemoveStates(aStates);
  }

  virtual void UpdateEditableState(bool aNotify) override;

  virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
                              nsIContent* aBindingParent,
                              bool aCompileEventHandlers) override;
  virtual void UnbindFromTree(bool aDeep = true,
                              bool aNullParent = true) override;
  already_AddRefed<mozilla::dom::NodeInfo>
  GetExistingAttrNameFromQName(const nsAString& aStr) const;

  nsresult SetAttr(int32_t aNameSpaceID, nsIAtom* aName,
                   const nsAString& aValue, bool aNotify)
  {
    return SetAttr(aNameSpaceID, aName, nullptr, aValue, aNotify);
  }
  bool MaybeCheckSameAttrVal(int32_t aNamespaceID, nsIAtom* aName,
                             nsIAtom* aPrefix,
                             const nsAttrValueOrString& aValue,
                             bool aNotify, nsAttrValue& aOldValue,
                             uint8_t* aModType, bool* aHasListeners);

  bool OnlyNotifySameValueSet(int32_t aNamespaceID, nsIAtom* aName,
                              nsIAtom* aPrefix,
                              const nsAttrValueOrString& aValue,
                              bool aNotify, nsAttrValue& aOldValue,
                              uint8_t* aModType, bool* aHasListeners);

  virtual nsresult SetAttr(int32_t aNameSpaceID, nsIAtom* aName, nsIAtom* aPrefix,
                           const nsAString& aValue, bool aNotify) override;


  nsresult SetParsedAttr(int32_t aNameSpaceID, nsIAtom* aName, nsIAtom* aPrefix,
                         nsAttrValue& aParsedValue, bool aNotify);


  bool GetAttr(int32_t aNameSpaceID, nsIAtom* aName,
               nsAString& aResult) const;
  inline bool HasAttr(int32_t aNameSpaceID, nsIAtom* aName) const;

  inline bool AttrValueIs(int32_t aNameSpaceID, nsIAtom* aName,
                          const nsAString& aValue,
                          nsCaseTreatment aCaseSensitive) const;
  inline bool AttrValueIs(int32_t aNameSpaceID, nsIAtom* aName,
                          nsIAtom* aValue,
                          nsCaseTreatment aCaseSensitive) const;
  virtual int32_t FindAttrValueIn(int32_t aNameSpaceID,
                                  nsIAtom* aName,
                                  AttrValuesArray* aValues,
                                  nsCaseTreatment aCaseSensitive) const override;
  virtual nsresult UnsetAttr(int32_t aNameSpaceID, nsIAtom* aAttribute,
                             bool aNotify) override;
  virtual const nsAttrName* GetAttrNameAt(uint32_t aIndex) const override;
  virtual BorrowedAttrInfo GetAttrInfoAt(uint32_t aIndex) const override;
  virtual uint32_t GetAttrCount() const override;
  virtual bool IsNodeOfType(uint32_t aFlags) const override;






  const nsAttrValue* GetClasses() const {
    if (MayHaveClass()) {
      return DoGetClasses();
    }
    return nullptr;
  }
  void Describe(nsAString& aOutDescription) const override;




  struct MappedAttributeEntry {
    nsIAtom** attribute;
  };







  template<size_t N>
  static bool
  FindAttributeDependence(const nsIAtom* aAttribute,
                          const MappedAttributeEntry* const (&aMaps)[N])
  {
    return FindAttributeDependence(aAttribute, aMaps, N);
  }

  static nsIAtom*** HTMLSVGPropertiesToTraverseAndUnlink();

private:
  void DescribeAttribute(uint32_t index, nsAString& aOutDescription) const;

  static bool
  FindAttributeDependence(const nsIAtom* aAttribute,
                          const MappedAttributeEntry* const aMaps[],
                          uint32_t aMapCount);

protected:
  inline bool GetAttr(int32_t aNameSpaceID, nsIAtom* aName,
                      DOMString& aResult) const
  {
    do { } while(0);
    do { } while(0);

    do { } while (0);

    const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
    if (val) {
      val->ToString(aResult);
      return true;
    }

    return false;
  }

public:
  bool HasAttrs() const { return mAttrsAndChildren.HasAttrs(); }

  inline bool GetAttr(const nsAString& aName, DOMString& aResult) const
  {
    do { } while (0);

    const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName);
    if (val) {
      val->ToString(aResult);
      return true;
    }

    return false;
  }

  void GetTagName(nsAString& aTagName) const
  {
    aTagName = NodeName();
  }
  void GetId(nsAString& aId) const
  {
    GetAttr(kNameSpaceID_None, nsGkAtoms::id, aId);
  }
  void GetId(DOMString& aId) const
  {
    GetAttr(kNameSpaceID_None, nsGkAtoms::id, aId);
  }
  void SetId(const nsAString& aId)
  {
    SetAttr(kNameSpaceID_None, nsGkAtoms::id, aId, true);
  }
  void GetClassName(nsAString& aClassName)
  {
    GetAttr(kNameSpaceID_None, nsGkAtoms::_class, aClassName);
  }
  void GetClassName(DOMString& aClassName)
  {
    GetAttr(kNameSpaceID_None, nsGkAtoms::_class, aClassName);
  }
  void SetClassName(const nsAString& aClassName)
  {
    SetAttr(kNameSpaceID_None, nsGkAtoms::_class, aClassName, true);
  }

  nsDOMTokenList* ClassList();
  nsDOMAttributeMap* Attributes()
  {
    nsDOMSlots* slots = DOMSlots();
    if (!slots->mAttributeMap) {
      slots->mAttributeMap = new nsDOMAttributeMap(this);
    }

    return slots->mAttributeMap;
  }

  void GetAttributeNames(nsTArray<nsString>& aResult);

  void GetAttribute(const nsAString& aName, nsString& aReturn)
  {
    DOMString str;
    GetAttribute(aName, str);
    str.ToString(aReturn);
  }

  void GetAttribute(const nsAString& aName, DOMString& aReturn);
  void GetAttributeNS(const nsAString& aNamespaceURI,
                      const nsAString& aLocalName,
                      nsAString& aReturn);
  void SetAttribute(const nsAString& aName, const nsAString& aValue,
                    ErrorResult& aError);
  void SetAttributeNS(const nsAString& aNamespaceURI,
                      const nsAString& aLocalName,
                      const nsAString& aValue,
                      ErrorResult& aError);
  void RemoveAttribute(const nsAString& aName,
                       ErrorResult& aError);
  void RemoveAttributeNS(const nsAString& aNamespaceURI,
                         const nsAString& aLocalName,
                         ErrorResult& aError);
  bool HasAttribute(const nsAString& aName) const
  {
    return InternalGetAttrNameFromQName(aName) != nullptr;
  }
  bool HasAttributeNS(const nsAString& aNamespaceURI,
                      const nsAString& aLocalName) const;
  bool HasAttributes() const
  {
    return HasAttrs();
  }
  Element* Closest(const nsAString& aSelector,
                   ErrorResult& aResult);
  bool Matches(const nsAString& aSelector,
               ErrorResult& aError);
  already_AddRefed<nsIHTMLCollection>
    GetElementsByTagName(const nsAString& aQualifiedName);
  already_AddRefed<nsIHTMLCollection>
    GetElementsByTagNameNS(const nsAString& aNamespaceURI,
                           const nsAString& aLocalName,
                           ErrorResult& aError);
  already_AddRefed<nsIHTMLCollection>
    GetElementsByClassName(const nsAString& aClassNames);

  CSSPseudoElementType GetPseudoElementType() const {
    if (!HasProperties()) {
      return CSSPseudoElementType::NotPseudo;
    }
    nsresult rv = NS_OK;
    auto raw = GetProperty(nsGkAtoms::pseudoProperty, &rv);
    if (rv == NS_PROPTABLE_PROP_NOT_THERE) {
      return CSSPseudoElementType::NotPseudo;
    }
    return CSSPseudoElementType(reinterpret_cast<uintptr_t>(raw));
  }

  void SetPseudoElementType(CSSPseudoElementType aPseudo) {
    static_assert(sizeof(CSSPseudoElementType) <= sizeof(uintptr_t),
                  "Need to be able to store this in a void*");
    do { } while (0);
    SetProperty(nsGkAtoms::pseudoProperty, reinterpret_cast<void*>(aPseudo));
  }

private:





  nsINode* InsertAdjacent(const nsAString& aWhere,
                          nsINode* aNode,
                          ErrorResult& aError);

public:
  Element* InsertAdjacentElement(const nsAString& aWhere,
                                 Element& aElement,
                                 ErrorResult& aError);

  void InsertAdjacentText(const nsAString& aWhere,
                          const nsAString& aData,
                          ErrorResult& aError);

  void SetPointerCapture(int32_t aPointerId, ErrorResult& aError)
  {
    bool activeState = false;
    if (!nsIPresShell::GetPointerInfo(aPointerId, activeState)) {
      aError.Throw(NS_ERROR_DOM_INVALID_POINTER_ERR);
      return;
    }
    if (!IsInUncomposedDoc()) {
      aError.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
      return;
    }
    if (!activeState) {
      return;
    }
    nsIPresShell::SetPointerCapturingContent(aPointerId, this);
  }
  void ReleasePointerCapture(int32_t aPointerId, ErrorResult& aError)
  {
    bool activeState = false;
    if (!nsIPresShell::GetPointerInfo(aPointerId, activeState)) {
      aError.Throw(NS_ERROR_DOM_INVALID_POINTER_ERR);
      return;
    }
    if (HasPointerCapture(aPointerId)) {
      nsIPresShell::ReleasePointerCapturingContent(aPointerId);
    }
  }
  bool HasPointerCapture(long aPointerId)
  {
    nsIPresShell::PointerCaptureInfo* pointerCaptureInfo =
      nsIPresShell::GetPointerCaptureInfo(aPointerId);
    if (pointerCaptureInfo && pointerCaptureInfo->mPendingContent == this) {
      return true;
    }
    return false;
  }
  void SetCapture(bool aRetargetToElement)
  {



    if (!nsIPresShell::GetCapturingContent()) {
      nsIPresShell::SetCapturingContent(this, 4 |
        (aRetargetToElement ? 2 : 0));
    }
  }

  void SetCaptureAlways(bool aRetargetToElement)
  {
    nsIPresShell::SetCapturingContent(this,
        4 | 1 |
        (aRetargetToElement ? 2 : 0));
  }

  void ReleaseCapture()
  {
    if (nsIPresShell::GetCapturingContent() == this) {
      nsIPresShell::SetCapturingContent(nullptr, 0);
    }
  }

  void RequestFullscreen(CallerType aCallerType, ErrorResult& aError);
  void RequestPointerLock(CallerType aCallerType);
  Attr* GetAttributeNode(const nsAString& aName);
  already_AddRefed<Attr> SetAttributeNode(Attr& aNewAttr,
                                          ErrorResult& aError);
  already_AddRefed<Attr> RemoveAttributeNode(Attr& aOldAttr,
                                             ErrorResult& aError);
  Attr* GetAttributeNodeNS(const nsAString& aNamespaceURI,
                           const nsAString& aLocalName);
  already_AddRefed<Attr> SetAttributeNodeNS(Attr& aNewAttr,
                                            ErrorResult& aError);

  already_AddRefed<DOMRectList> GetClientRects();
  already_AddRefed<DOMRect> GetBoundingClientRect();

  already_AddRefed<ShadowRoot> CreateShadowRoot(ErrorResult& aError);
  already_AddRefed<DestinationInsertionPointList> GetDestinationInsertionPoints();

  ShadowRoot *FastGetShadowRoot() const
  {
    nsDOMSlots* slots = GetExistingDOMSlots();
    return slots ? slots->mShadowRoot.get() : nullptr;
  }

  void ScrollIntoView();
  void ScrollIntoView(bool aTop);
  void ScrollIntoView(const ScrollIntoViewOptions &aOptions);
  void Scroll(double aXScroll, double aYScroll);
  void Scroll(const ScrollToOptions& aOptions);
  void ScrollTo(double aXScroll, double aYScroll);
  void ScrollTo(const ScrollToOptions& aOptions);
  void ScrollBy(double aXScrollDif, double aYScrollDif);
  void ScrollBy(const ScrollToOptions& aOptions);




  bool ScrollByNoFlush(int32_t aDx, int32_t aDy);
  int32_t ScrollTop();
  void SetScrollTop(int32_t aScrollTop);
  int32_t ScrollLeft();
  void SetScrollLeft(int32_t aScrollLeft);
  int32_t ScrollWidth();
  int32_t ScrollHeight();
  void MozScrollSnap();
  int32_t ClientTop()
  {
    return nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().y);
  }
  int32_t ClientLeft()
  {
    return nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().x);
  }
  int32_t ClientWidth()
  {
    return nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().width);
  }
  int32_t ClientHeight()
  {
    return nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().height);
  }
  int32_t ScrollTopMin()
  {
    nsIScrollableFrame* sf = GetScrollFrame();
    return sf ?
           nsPresContext::AppUnitsToIntCSSPixels(sf->GetScrollRange().y) : 0;
  }
  int32_t ScrollTopMax()
  {
    nsIScrollableFrame* sf = GetScrollFrame();
    return sf ?
           nsPresContext::AppUnitsToIntCSSPixels(sf->GetScrollRange().YMost()) :
           0;
  }
  int32_t ScrollLeftMin()
  {
    nsIScrollableFrame* sf = GetScrollFrame();
    return sf ?
           nsPresContext::AppUnitsToIntCSSPixels(sf->GetScrollRange().x) : 0;
  }
  int32_t ScrollLeftMax()
  {
    nsIScrollableFrame* sf = GetScrollFrame();
    return sf ?
           nsPresContext::AppUnitsToIntCSSPixels(sf->GetScrollRange().XMost()) :
           0;
  }

  void GetGridFragments(nsTArray<RefPtr<Grid>>& aResult);

  already_AddRefed<Animation>
  Animate(JSContext* aContext,
          JS::Handle<JSObject*> aKeyframes,
          const UnrestrictedDoubleOrKeyframeAnimationOptions& aOptions,
          ErrorResult& aError);



  static already_AddRefed<Animation>
  Animate(const Nullable<ElementOrCSSPseudoElement>& aTarget,
          JSContext* aContext,
          JS::Handle<JSObject*> aKeyframes,
          const UnrestrictedDoubleOrKeyframeAnimationOptions& aOptions,
          ErrorResult& aError);




  void GetAnimations(const AnimationFilter& filter,
                     nsTArray<RefPtr<Animation>>& aAnimations);
  static void GetAnimationsUnsorted(Element* aElement,
                                    CSSPseudoElementType aPseudoType,
                                    nsTArray<RefPtr<Animation>>& aAnimations);

  virtual nsresult GetInnerHTML(nsAString& aInnerHTML);
  virtual void SetInnerHTML(const nsAString& aInnerHTML, ErrorResult& aError);
  void GetOuterHTML(nsAString& aOuterHTML);
  void SetOuterHTML(const nsAString& aOuterHTML, ErrorResult& aError);
  void InsertAdjacentHTML(const nsAString& aPosition, const nsAString& aText,
                          ErrorResult& aError);
  nsresult SetEventHandler(nsIAtom* aEventName,
                           const nsAString& aValue,
                           bool aDefer = true);




  nsresult LeaveLink(nsPresContext* aPresContext);

  static bool ShouldBlur(nsIContent *aContent);
  static nsresult DispatchClickEvent(nsPresContext* aPresContext,
                                     WidgetInputEvent* aSourceEvent,
                                     nsIContent* aTarget,
                                     bool aFullDispatch,
                                     const EventFlags* aFlags,
                                     nsEventStatus* aStatus);
  using nsIContent::DispatchEvent;
  static nsresult DispatchEvent(nsPresContext* aPresContext,
                                WidgetEvent* aEvent,
                                nsIContent* aTarget,
                                bool aFullDispatch,
                                nsEventStatus* aStatus);
  nsIFrame* GetPrimaryFrame(FlushType aType);

  nsIFrame* GetPrimaryFrame() const { return nsIContent::GetPrimaryFrame(); }

  const nsAttrValue* GetParsedAttr(nsIAtom* aAttr) const
  {
    return mAttrsAndChildren.GetAttr(aAttr);
  }

  const nsAttrValue* GetParsedAttr(nsIAtom* aAttr, int32_t aNameSpaceID) const
  {
    return mAttrsAndChildren.GetAttr(aAttr, aNameSpaceID);
  }






  nsDOMAttributeMap *GetAttributeMap()
  {
    nsDOMSlots *slots = GetExistingDOMSlots();

    return slots ? slots->mAttributeMap.get() : nullptr;
  }

  virtual void RecompileScriptEventListeners()
  {
  }
  virtual BorrowedAttrInfo GetAttrInfo(int32_t aNamespaceID, nsIAtom* aName) const;
  virtual void NodeInfoChanged(nsIDocument* aOldDoc) {}






  static void ParseCORSValue(const nsAString& aValue, nsAttrValue& aResult);




  static CORSMode StringToCORSMode(const nsAString& aValue);





  static CORSMode AttrValueToCORSMode(const nsAttrValue* aValue);

  virtual JSObject* WrapObject(JSContext *aCx, JS::Handle<JSObject*> aGivenProto) final override;

  nsINode* GetScopeChainParent() const override;




  nsIEditor* GetEditorInternal();
  bool GetBoolAttr(nsIAtom* aAttr) const
  {
    return HasAttr(kNameSpaceID_None, aAttr);
  }
  nsresult SetBoolAttr(nsIAtom* aAttr, bool aValue);
  void GetEnumAttr(nsIAtom* aAttr,
                   const char* aDefault,
                   nsAString& aResult) const;
  void GetEnumAttr(nsIAtom* aAttr,
                   const char* aDefaultMissing,
                   const char* aDefaultInvalid,
                   nsAString& aResult) const;




  void UnsetAttr(nsIAtom* aAttr, ErrorResult& aError)
  {
    aError = UnsetAttr(kNameSpaceID_None, aAttr, true);
  }




  void SetAttr(nsIAtom* aAttr, const nsAString& aValue, ErrorResult& aError)
  {
    aError = SetAttr(kNameSpaceID_None, aAttr, aValue, true);
  }






  void SetOrRemoveNullableStringAttr(nsIAtom* aName, const nsAString& aValue,
                                     ErrorResult& aError);
  float FontSizeInflation();

  net::ReferrerPolicy GetReferrerPolicyAsEnum();






  already_AddRefed<nsDOMStringMap> Dataset();


  void ClearDataset();

  void RegisterIntersectionObserver(DOMIntersectionObserver* aObserver);
  void UnregisterIntersectionObserver(DOMIntersectionObserver* aObserver);
  bool UpdateIntersectionObservation(DOMIntersectionObserver* aObserver, int32_t threshold);

protected:




  static const bool kFireMutationEvent = true;
  static const bool kDontFireMutationEvent = false;
  static const bool kNotifyDocumentObservers = true;
  static const bool kDontNotifyDocumentObservers = false;
  static const bool kCallAfterSetAttr = true;
  static const bool kDontCallAfterSetAttr = false;
  nsresult SetAttrAndNotify(int32_t aNamespaceID,
                            nsIAtom* aName,
                            nsIAtom* aPrefix,
                            const nsAttrValue& aOldValue,
                            nsAttrValue& aParsedValue,
                            uint8_t aModType,
                            bool aFireMutation,
                            bool aNotify,
                            bool aCallAfterSetAttr,
                            nsIDocument* aComposedDocument,
                            const mozAutoDocUpdate& aGuard);
  void Scroll(const CSSIntPoint& aScroll, const ScrollOptions& aOptions);
  virtual bool ParseAttribute(int32_t aNamespaceID,
                                nsIAtom* aAttribute,
                                const nsAString& aValue,
                                nsAttrValue& aResult);
  virtual bool SetMappedAttribute(nsIDocument* aDocument,
                                    nsIAtom* aName,
                                    nsAttrValue& aValue,
                                    nsresult* aRetval);
  virtual nsresult BeforeSetAttr(int32_t aNamespaceID, nsIAtom* aName,
                                 const nsAttrValueOrString* aValue,
                                 bool aNotify)
  {
    return NS_OK;
  }
  virtual nsresult AfterSetAttr(int32_t aNamespaceID, nsIAtom* aName,
                                const nsAttrValue* aValue, bool aNotify)
  {
    return NS_OK;
  }





  virtual EventListenerManager*
    GetEventListenerManagerForAttr(nsIAtom* aAttrName, bool* aDefer);






  const nsAttrName*
  InternalGetAttrNameFromQName(const nsAString& aStr,
                               nsAutoString* aNameToUse = nullptr) const;

  nsIFrame* GetStyledFrame();

  virtual Element* GetNameSpaceElement() override
  {
    return this;
  }

  Attr* GetAttributeNodeNSInternal(const nsAString& aNamespaceURI,
                                   const nsAString& aLocalName);

  inline void RegisterActivityObserver();
  inline void UnregisterActivityObserver();




  void AddToIdTable(nsIAtom* aId);
  void RemoveFromIdTable();
  bool CheckHandleEventForLinksPrecondition(EventChainVisitor& aVisitor,
                                            nsIURI** aURI) const;




  nsresult GetEventTargetParentForLinks(EventChainPreVisitor& aVisitor);




  nsresult PostHandleEventForLinks(EventChainPostVisitor& aVisitor);
  virtual void GetLinkTarget(nsAString& aTarget);

  nsDOMTokenList* GetTokenList(nsIAtom* aAtom,
                               const DOMTokenListSupportedTokenArray aSupportedTokens = nullptr);

  nsDataHashtable<nsRefPtrHashKey<DOMIntersectionObserver>, int32_t>*
    RegisteredIntersectionObservers();

private:




  const nsAttrValue* DoGetClasses() const;





  nsRect GetClientAreaRect();

  nsIScrollableFrame* GetScrollFrame(nsIFrame **aStyledFrame = nullptr,
                                     bool aFlushLayout = true);


  EventStates mState;


  mozilla::ServoCell<ServoNodeData*> mServoData;

};

class RemoveFromBindingManagerRunnable : public mozilla::Runnable
{
public:
  RemoveFromBindingManagerRunnable(nsBindingManager* aManager,
                                   nsIContent* aContent,
                                   nsIDocument* aDoc);

  virtual nsresult Run() override;
private:
  virtual ~RemoveFromBindingManagerRunnable();
  RefPtr<nsBindingManager> mManager;
  RefPtr<nsIContent> mContent;
  nsCOMPtr<nsIDocument> mDoc;
};

class DestinationInsertionPointList : public nsINodeList
{
public:
  explicit DestinationInsertionPointList(Element* aElement);

  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; virtual void DeleteCycleCollectable(void); typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:
  class cycleCollection : public nsXPCOMCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = false) : nsXPCOMCycleCollectionParticipant(aSkip) {} private: public: virtual nsresult TraverseNative(void *p, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "DestinationInsertionPointList"; }; virtual void DeleteCycleCollectable(void *p) override { DowncastCCParticipant<DestinationInsertionPointList>(p)->DeleteCycleCollectable(); } static DestinationInsertionPointList* Downcast(nsISupports* s) { return static_cast<DestinationInsertionPointList*>(static_cast<DestinationInsertionPointList*>(s)); } static nsISupports* Upcast(DestinationInsertionPointList *p) { return static_cast<nsISupports*>(static_cast<DestinationInsertionPointList*>(p)); } template<typename T> friend nsISupports* ToSupports(T* p, cycleCollection* dummy); virtual void Unlink(void *p) override; virtual void Trace(void *p, const TraceCallbacks &cb, void *closure) override; static constexpr nsXPCOMCycleCollectionParticipant* GetParticipant() { return &DestinationInsertionPointList::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;


  virtual nsresult Item(uint32_t index, nsIDOMNode * *_retval) override; virtual nsresult GetLength(uint32_t *aLength) override;


  virtual nsIContent* Item(uint32_t aIndex) override;
  virtual int32_t IndexOf(nsIContent* aContent) override;
  virtual nsINode* GetParentObject() override { return mParent; }
  virtual uint32_t Length() const;
  virtual JSObject* WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
protected:
  virtual ~DestinationInsertionPointList();

  RefPtr<Element> mParent;
  nsCOMArray<nsIContent> mDestinationPoints;
};

template<typename T> struct Element::COMTypeInfo<Element, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID Element::COMTypeInfo<Element, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0xc67ed254, 0xfd3b, 0x4b10, { 0x96, 0xa2, 0xc5, 0x8b, 0x7b, 0x64, 0x97, 0xd1 } };

inline bool
Element::HasAttr(int32_t aNameSpaceID, nsIAtom* aName) const
{
  do { } while(0);
  do { } while(0);


  return mAttrsAndChildren.IndexOfAttr(aName, aNameSpaceID) >= 0;
}

inline bool
Element::AttrValueIs(int32_t aNameSpaceID,
                     nsIAtom* aName,
                     const nsAString& aValue,
                     nsCaseTreatment aCaseSensitive) const
{
  do { } while(0);
  do { } while(0);

  const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
  return val && val->Equals(aValue, aCaseSensitive);
}

inline bool
Element::AttrValueIs(int32_t aNameSpaceID,
                     nsIAtom* aName,
                     nsIAtom* aValue,
                     nsCaseTreatment aCaseSensitive) const
{
  do { } while(0);
  do { } while(0);
  do { } while(0);

  const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
  return val && val->Equals(aValue, aCaseSensitive);
}

}
}

inline mozilla::dom::Element* nsINode::AsElement()
{
  do { } while (0);
  return static_cast<mozilla::dom::Element*>(this);
}

inline const mozilla::dom::Element* nsINode::AsElement() const
{
  do { } while (0);
  return static_cast<const mozilla::dom::Element*>(this);
}

inline void nsINode::UnsetRestyleFlagsIfGecko()
{
  if (IsElement() && !AsElement()->IsStyledByServo()) {
    UnsetFlags(ELEMENT_ALL_RESTYLE_FLAGS);
  }
}
namespace mozilla {

namespace dom {
class Element;
}

struct OwningAnimationTarget
{
  OwningAnimationTarget(dom::Element* aElement, CSSPseudoElementType aType)
    : mElement(aElement), mPseudoType(aType) { }

  explicit OwningAnimationTarget(dom::Element* aElement)
    : mElement(aElement) { }

  bool operator==(const OwningAnimationTarget& aOther) const
  {
     return mElement == aOther.mElement &&
            mPseudoType == aOther.mPseudoType;
  }



  RefPtr<dom::Element> mElement;
  CSSPseudoElementType mPseudoType = CSSPseudoElementType::NotPseudo;
};

struct NonOwningAnimationTarget
{
  NonOwningAnimationTarget() = default;

  NonOwningAnimationTarget(dom::Element* aElement, CSSPseudoElementType aType)
    : mElement(aElement), mPseudoType(aType) { }

  explicit NonOwningAnimationTarget(const OwningAnimationTarget& aOther)
    : mElement(aOther.mElement), mPseudoType(aOther.mPseudoType) { }

  bool operator==(const NonOwningAnimationTarget& aOther) const
  {
    return mElement == aOther.mElement &&
           mPseudoType == aOther.mPseudoType;
  }



  dom::Element* mElement = nullptr;
  CSSPseudoElementType mPseudoType = CSSPseudoElementType::NotPseudo;
};



inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            Maybe<OwningAnimationTarget>& aTarget,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  if (aTarget) {
    ImplCycleCollectionTraverse(aCallback, aTarget->mElement, aName, aFlags);
  }
}

inline void
ImplCycleCollectionUnlink(Maybe<OwningAnimationTarget>& aTarget)
{
  if (aTarget) {
    ImplCycleCollectionUnlink(aTarget->mElement);
  }
}

}



namespace mozilla {


class PseudoElementHashEntry : public PLDHashEntryHdr
{
public:
  typedef NonOwningAnimationTarget KeyType;
  typedef const NonOwningAnimationTarget* KeyTypePointer;

  explicit PseudoElementHashEntry(KeyTypePointer aKey)
    : mElement(aKey->mElement)
    , mPseudoType(aKey->mPseudoType) { }
  explicit PseudoElementHashEntry(const PseudoElementHashEntry& aCopy)=default;

  ~PseudoElementHashEntry() = default;

  KeyType GetKey() const { return { mElement, mPseudoType }; }
  bool KeyEquals(KeyTypePointer aKey) const
  {
    return mElement == aKey->mElement &&
           mPseudoType == aKey->mPseudoType;
  }

  static KeyTypePointer KeyToPointer(KeyType& aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {
    if (!aKey)
      return 0;




    return mozilla::HashGeneric(aKey->mElement,
                                static_cast<uint8_t>(aKey->mPseudoType));
  }
  enum { ALLOW_MEMMOVE = true };

  RefPtr<dom::Element> mElement;
  CSSPseudoElementType mPseudoType;
};

}




struct RuleProcessorData;
struct ElementRuleProcessorData;
struct PseudoElementRuleProcessorData;
struct AnonBoxRuleProcessorData;

struct XULTreeRuleProcessorData;

struct StateRuleProcessorData;
struct PseudoElementStateRuleProcessorData;
struct AttributeRuleProcessorData;
class nsPresContext;
class nsIStyleRuleProcessor : public nsISupports {
public:
  template<typename T, typename U> struct COMTypeInfo;



  typedef bool (* EnumFunc)(nsIStyleRuleProcessor*, void*);







  virtual void RulesMatching(ElementRuleProcessorData* aData) = 0;





  virtual void RulesMatching(PseudoElementRuleProcessorData* aData) = 0;




  virtual void RulesMatching(AnonBoxRuleProcessorData* aData) = 0;






  virtual void RulesMatching(XULTreeRuleProcessorData* aData) = 0;







  virtual bool
    HasDocumentStateDependentStyle(StateRuleProcessorData* aData) = 0;
  virtual nsRestyleHint
    HasStateDependentStyle(StateRuleProcessorData* aData) = 0;
  virtual nsRestyleHint
    HasStateDependentStyle(PseudoElementStateRuleProcessorData* aData) = 0;
  virtual nsRestyleHint HasAttributeDependentStyle(
      AttributeRuleProcessorData* aData,
      mozilla::RestyleHintData& aRestyleHintDataResult) = 0;






  virtual bool MediumFeaturesChanged(nsPresContext* aPresContext) = 0;





  virtual size_t SizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const = 0;
  virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const = 0;
};

template<typename T> struct nsIStyleRuleProcessor::COMTypeInfo<nsIStyleRuleProcessor, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIStyleRuleProcessor::COMTypeInfo<nsIStyleRuleProcessor, T>::kIID __attribute__ ((visibility ("hidden"))) = { 0xc1d6001e, 0x4fcb, 0x4c40, {0xbc, 0xe1, 0x5e, 0xba, 0x80, 0xbf, 0xd8, 0xf3} };


class nsCSSPropertyIDSet;
class nsIAtom;
class nsIFrame;
class nsIStyleRule;
class nsPresContext;
class nsStyleContext;
struct RawServoAnimationValueMap;
typedef RawServoAnimationValueMap const* RawServoAnimationValueMapBorrowed;

namespace mozilla {

class EffectSet;
class RestyleTracker;
class StyleAnimationValue;
struct AnimationPerformanceWarning;
struct AnimationProperty;
struct NonOwningAnimationTarget;

namespace dom {
class Animation;
class Element;
}

class EffectCompositor
{
public:
  explicit EffectCompositor(nsPresContext* aPresContext)
    : mPresContext(aPresContext)
  {
    for (size_t i = 0; i < kCascadeLevelCount; i++) {
      CascadeLevel cascadeLevel = CascadeLevel(i);
      mRuleProcessors[cascadeLevel] =
        new AnimationStyleRuleProcessor(this, cascadeLevel);
    }
  }

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<EffectCompositor>::value, "Reference-counted class " "EffectCompositor" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); nsrefcnt count = mRefCnt.incr(static_cast<void*>(this), EffectCompositor::cycleCollection::GetParticipant()); ; return count; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); nsrefcnt count = mRefCnt.decr(static_cast<void*>(this), EffectCompositor::cycleCollection::GetParticipant()); ; return count; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsCycleCollectingAutoRefCnt mRefCnt; public:
  void DeleteCycleCollectable(void) { delete this; } class cycleCollection : public nsCycleCollectionParticipant { public: constexpr explicit cycleCollection (bool aSkip = false) : nsCycleCollectionParticipant(aSkip) {} private: public: virtual void Root(void *n) override; virtual void Unlink(void *n) override; virtual void Unroot(void *n) override; virtual nsresult TraverseNative(void *n, nsCycleCollectionTraversalCallback &cb) override; virtual const char* ClassName() override { return "EffectCompositor"; }; virtual void DeleteCycleCollectable(void *n) override { DowncastCCParticipant<EffectCompositor>(n)->DeleteCycleCollectable(); } static EffectCompositor* Downcast(void* s) { return DowncastCCParticipant<EffectCompositor>(s); } static void* Upcast(EffectCompositor *p) { return static_cast<void*>(p); } static constexpr nsCycleCollectionParticipant* GetParticipant() { return &EffectCompositor::_cycleCollectorGlobal; } }; static cycleCollection _cycleCollectorGlobal;

  void Disconnect() {
    mPresContext = nullptr;
  }


  enum class CascadeLevel : uint32_t {


    Animations = 0,

    Transitions = 1
  };


  static const size_t kCascadeLevelCount =
    static_cast<size_t>(CascadeLevel::Transitions) + 1;


  nsPresContext* PresContext() const { return mPresContext; }

  enum class RestyleType {



    Throttled,

    Standard,







    Layer
  };





  void RequestRestyle(dom::Element* aElement,
                      CSSPseudoElementType aPseudoType,
                      RestyleType aRestyleType,
                      CascadeLevel aCascadeLevel);





  void PostRestyleForAnimation(dom::Element* aElement,
                               CSSPseudoElementType aPseudoType,
                               CascadeLevel aCascadeLevel);




  void PostRestyleForThrottledAnimations();





  template<typename StyleType>
  void UpdateEffectProperties(StyleType&& aStyleType,
                              dom::Element* aElement,
                              CSSPseudoElementType aPseudoType);
  void MaybeUpdateAnimationRule(dom::Element* aElement,
                                CSSPseudoElementType aPseudoType,
                                CascadeLevel aCascadeLevel,
                                nsStyleContext *aStyleContext);
  nsIStyleRule* GetAnimationRule(dom::Element* aElement,
                                 CSSPseudoElementType aPseudoType,
                                 CascadeLevel aCascadeLevel,
                                 nsStyleContext* aStyleContext);






  bool GetServoAnimationRule(
    const dom::Element* aElement,
    CSSPseudoElementType aPseudoType,
    CascadeLevel aCascadeLevel,
    RawServoAnimationValueMapBorrowed aAnimationValues);

  bool HasPendingStyleUpdates() const;
  bool HasThrottledStyleUpdates() const;




  void AddStyleUpdatesTo(RestyleTracker& aTracker);

  nsIStyleRuleProcessor* RuleProcessor(CascadeLevel aCascadeLevel) const
  {
    return mRuleProcessors[aCascadeLevel];
  }

  static bool HasAnimationsForCompositor(const nsIFrame* aFrame,
                                         nsCSSPropertyID aProperty);

  static nsTArray<RefPtr<dom::Animation>>
  GetAnimationsForCompositor(const nsIFrame* aFrame,
                             nsCSSPropertyID aProperty);

  static void ClearIsRunningOnCompositor(const nsIFrame* aFrame,
                                         nsCSSPropertyID aProperty);
  static void
  MaybeUpdateCascadeResults(dom::Element* aElement,
                            CSSPseudoElementType aPseudoType,
                            nsStyleContext* aStyleContext);





  static void
  MaybeUpdateCascadeResults(dom::Element* aElement,
                            CSSPseudoElementType aPseudoType);







  static void
  UpdateCascadeResults(dom::Element* aElement,
                       CSSPseudoElementType aPseudoType,
                       nsStyleContext* aStyleContext);
  static Maybe<NonOwningAnimationTarget>
  GetAnimationElementAndPseudoForFrame(const nsIFrame* aFrame);



  static void SetPerformanceWarning(
    const nsIFrame* aFrame,
    nsCSSPropertyID aProperty,
    const AnimationPerformanceWarning& aWarning);





  bool PreTraverse();


  bool PreTraverse(dom::Element* aElement, nsIAtom* aPseudoTagOrNull);

private:
  ~EffectCompositor() = default;



  static void ComposeAnimationRule(dom::Element* aElement,
                                   CSSPseudoElementType aPseudoType,
                                   CascadeLevel aCascadeLevel);

  static dom::Element* GetElementToRestyle(dom::Element* aElement,
                                           CSSPseudoElementType
                                             aPseudoType);




  static void
  GetOverriddenProperties(nsStyleContext* aStyleContext,
                          EffectSet& aEffectSet,
                          nsCSSPropertyIDSet& aPropertiesOverridden);

  static void
  UpdateCascadeResults(EffectSet& aEffectSet,
                       dom::Element* aElement,
                       CSSPseudoElementType aPseudoType,
                       nsStyleContext* aStyleContext);

  static nsPresContext* GetPresContext(dom::Element* aElement);

  nsPresContext* mPresContext;






  EnumeratedArray<CascadeLevel, CascadeLevel(kCascadeLevelCount),
                  nsDataHashtable<PseudoElementHashEntry, bool>>
                    mElementsToRestyle;

  class AnimationStyleRuleProcessor final : public nsIStyleRuleProcessor
  {
  public:
    AnimationStyleRuleProcessor(EffectCompositor* aCompositor,
                                CascadeLevel aCascadeLevel)
      : mCompositor(aCompositor)
      , mCascadeLevel(aCascadeLevel)
    {
      do { } while (0);
    }

    public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:


    nsRestyleHint HasStateDependentStyle(
                        StateRuleProcessorData* aData) override;
    nsRestyleHint HasStateDependentStyle(
                        PseudoElementStateRuleProcessorData* aData) override;
    bool HasDocumentStateDependentStyle(StateRuleProcessorData* aData) override;
    nsRestyleHint HasAttributeDependentStyle(
                        AttributeRuleProcessorData* aData,
                        RestyleHintData& aRestyleHintDataResult) override;
    bool MediumFeaturesChanged(nsPresContext* aPresContext) override;
    void RulesMatching(ElementRuleProcessorData* aData) override;
    void RulesMatching(PseudoElementRuleProcessorData* aData) override;
    void RulesMatching(AnonBoxRuleProcessorData* aData) override;

    void RulesMatching(XULTreeRuleProcessorData* aData) override;

    size_t SizeOfExcludingThis(MallocSizeOf aMallocSizeOf)
      const override;
    size_t SizeOfIncludingThis(MallocSizeOf aMallocSizeOf)
      const override;

  private:
    ~AnimationStyleRuleProcessor() = default;

    EffectCompositor* mCompositor;
    CascadeLevel mCascadeLevel;
  };

  EnumeratedArray<CascadeLevel, CascadeLevel(kCascadeLevelCount),
                  OwningNonNull<AnimationStyleRuleProcessor>>
                    mRuleProcessors;
};

}
class nsSMILKeySpline
{
public:
  nsSMILKeySpline() { }







  nsSMILKeySpline(double aX1, double aY1,
                  double aX2, double aY2)
  {
    Init(aX1, aY1, aX2, aY2);
  }

  double X1() const { return mX1; }
  double Y1() const { return mY1; }
  double X2() const { return mX2; }
  double Y2() const { return mY2; }

  void Init(double aX1, double aY1,
            double aX2, double aY2);







  double GetSplineValue(double aX) const;

  void GetSplineDerivativeValues(double aX, double& aDX, double& aDY) const;

  bool operator==(const nsSMILKeySpline& aOther) const {
    return mX1 == aOther.mX1 &&
           mY1 == aOther.mY1 &&
           mX2 == aOther.mX2 &&
           mY2 == aOther.mY2;
  }
  bool operator!=(const nsSMILKeySpline& aOther) const {
    return !(*this == aOther);
  }
  int32_t Compare(const nsSMILKeySpline& aRhs) const {
    if (mX1 != aRhs.mX1) return mX1 < aRhs.mX1 ? -1 : 1;
    if (mY1 != aRhs.mY1) return mY1 < aRhs.mY1 ? -1 : 1;
    if (mX2 != aRhs.mX2) return mX2 < aRhs.mX2 ? -1 : 1;
    if (mY2 != aRhs.mY2) return mY2 < aRhs.mY2 ? -1 : 1;
    return 0;
  }

private:
  void
  CalcSampleValues();




  static double
  CalcBezier(double aT, double aA1, double aA2);




  static double
  GetSlope(double aT, double aA1, double aA2);

  double
  GetTForX(double aX) const;

  double
  NewtonRaphsonIterate(double aX, double aGuessT) const;

  double
  BinarySubdivide(double aX, double aA, double aB) const;

  static double
  A(double aA1, double aA2)
  {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  static double
  B(double aA1, double aA2)
  {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  static double
  C(double aA1)
  {
    return 3.0 * aA1;
  }

  double mX1;
  double mY1;
  double mX2;
  double mY2;

  enum { kSplineTableSize = 11 };
  double mSampleValues[kSplineTableSize];

  static const double kSampleStepSize;
};
namespace mozilla {
namespace css {
class ErrorReporter;
}
}







enum nsCSSTokenType {



  eCSSToken_Whitespace,

  eCSSToken_Comment,






  eCSSToken_Ident,
  eCSSToken_Function,
  eCSSToken_AtKeyword,
  eCSSToken_ID,
  eCSSToken_Hash,
  eCSSToken_Number,
  eCSSToken_Dimension,
  eCSSToken_Percentage,






  eCSSToken_String,
  eCSSToken_Bad_String,
  eCSSToken_URL,
  eCSSToken_Bad_URL,


  eCSSToken_Symbol,





  eCSSToken_Includes,
  eCSSToken_Dashmatch,
  eCSSToken_Beginsmatch,
  eCSSToken_Endsmatch,
  eCSSToken_Containsmatch,
  eCSSToken_URange,







  eCSSToken_HTMLComment,
};
enum nsCSSTokenSerializationType {
  eCSSTokenSerialization_Nothing,
  eCSSTokenSerialization_Whitespace,
  eCSSTokenSerialization_AtKeyword_or_Hash,
  eCSSTokenSerialization_Number,
  eCSSTokenSerialization_Dimension,
  eCSSTokenSerialization_Percentage,
  eCSSTokenSerialization_URange,
  eCSSTokenSerialization_URL_or_BadURL,
  eCSSTokenSerialization_Function,
  eCSSTokenSerialization_Ident,
  eCSSTokenSerialization_CDC,
  eCSSTokenSerialization_DashMatch,
  eCSSTokenSerialization_ContainsMatch,
  eCSSTokenSerialization_Symbol_Hash,
  eCSSTokenSerialization_Symbol_At,
  eCSSTokenSerialization_Symbol_Dot_or_Plus,
  eCSSTokenSerialization_Symbol_Minus,
  eCSSTokenSerialization_Symbol_OpenParen,
  eCSSTokenSerialization_Symbol_Question,
  eCSSTokenSerialization_Symbol_Assorted,
  eCSSTokenSerialization_Symbol_Equals,
  eCSSTokenSerialization_Symbol_Bar,
  eCSSTokenSerialization_Symbol_Slash,
  eCSSTokenSerialization_Symbol_Asterisk,
  eCSSTokenSerialization_Other
};




struct nsCSSToken {
  nsAutoString mIdent;
  float mNumber;
  int32_t mInteger;
  int32_t mInteger2;
  nsCSSTokenType mType;
  char16_t mSymbol;
  bool mIntegerValid;
  bool mHasSign;

  nsCSSToken()
    : mNumber(0), mInteger(0), mInteger2(0), mType(eCSSToken_Whitespace),
      mSymbol('\0'), mIntegerValid(false), mHasSign(false)
  {}

  bool IsSymbol(char16_t aSymbol) const {
    return mType == eCSSToken_Symbol && mSymbol == aSymbol;
  }

  void AppendToString(nsString& aBuffer) const;
};


class nsCSSScannerPosition {
  friend class nsCSSScanner;
public:
  nsCSSScannerPosition() : mInitialized(false) { }

  uint32_t LineNumber() {
    do { } while (0);
    return mLineNumber;
  }

  uint32_t LineOffset() {
    do { } while (0);
    return mLineOffset;
  }

private:
  uint32_t mOffset;
  uint32_t mLineNumber;
  uint32_t mLineOffset;
  uint32_t mTokenLineNumber;
  uint32_t mTokenLineOffset;
  uint32_t mTokenOffset;
  bool mInitialized;
};

enum nsCSSScannerExclude {

  eCSSScannerExclude_None,

  eCSSScannerExclude_Comments,

  eCSSScannerExclude_WhitespaceAndComments
};




class nsCSSScanner {
  public:




  nsCSSScanner(const nsAString& aBuffer, uint32_t aLineNumber);
  ~nsCSSScanner();

  void SetErrorReporter(mozilla::css::ErrorReporter* aReporter) {
    mReporter = aReporter;
  }


  void ClearSeenBadToken() { mSeenBadToken = false; }
  bool SeenBadToken() const { return mSeenBadToken; }


  void ClearSeenVariableReference() { mSeenVariableReference = false; }
  bool SeenVariableReference() const { return mSeenVariableReference; }



  uint32_t GetLineNumber() const { return mTokenLineNumber; }



  uint32_t GetColumnNumber() const
  { return mTokenOffset - mTokenLineOffset; }

  uint32_t GetTokenOffset() const
  { return mTokenOffset; }

  uint32_t GetTokenEndOffset() const
  { return mOffset; }



  nsDependentSubstring GetCurrentLine() const;




  bool Next(nsCSSToken& aTokenResult, nsCSSScannerExclude aSkip);






  void NextURL(nsCSSToken& aTokenResult);
  void Backup(uint32_t n);


  void StartRecording();


  void StopRecording();



  void StopRecording(nsString& aBuffer);


  uint32_t RecordingLength() const;






  void SavePosition(nsCSSScannerPosition& aState);


  void RestoreSavedPosition(const nsCSSScannerPosition& aState);

  enum EOFCharacters {
    eEOFCharacters_None = 0x0000,


    eEOFCharacters_DropBackslash = 0x0001,


    eEOFCharacters_ReplacementChar = 0x0002,


    eEOFCharacters_Asterisk = 0x0004,
    eEOFCharacters_Slash = 0x0008,


    eEOFCharacters_DoubleQuote = 0x0010,


    eEOFCharacters_SingleQuote = 0x0020,


    eEOFCharacters_CloseParen = 0x0040,
  };





  static void AppendImpliedEOFCharacters(EOFCharacters aEOFCharacters,
                                         nsAString& aString);

  EOFCharacters GetEOFCharacters() const {



    return mEOFCharacters;
  }





protected:
  int32_t Peek(uint32_t n = 0);
  void Advance(uint32_t n = 1);
  void AdvanceLine();

  void SkipWhitespace();
  void SkipComment();

  bool GatherEscape(nsString& aOutput, bool aInString);
  bool GatherText(uint8_t aClass, nsString& aIdent);

  bool ScanIdent(nsCSSToken& aResult);
  bool ScanAtKeyword(nsCSSToken& aResult);
  bool ScanHash(nsCSSToken& aResult);
  bool ScanNumber(nsCSSToken& aResult);
  bool ScanString(nsCSSToken& aResult);
  bool ScanURange(nsCSSToken& aResult);

  void SetEOFCharacters(uint32_t aEOFCharacters);
  void AddEOFCharacters(uint32_t aEOFCharacters);

  const char16_t *mBuffer;
  uint32_t mOffset;
  uint32_t mCount;

  uint32_t mLineNumber;
  uint32_t mLineOffset;

  uint32_t mTokenLineNumber;
  uint32_t mTokenLineOffset;
  uint32_t mTokenOffset;

  uint32_t mRecordStartOffset;
  EOFCharacters mEOFCharacters;

  mozilla::css::ErrorReporter *mReporter;

  bool mRecording;
  bool mSeenBadToken;
  bool mSeenVariableReference;
};



struct nsCSSGridTemplateAreaToken {
  nsAutoString mName;
  bool isTrash;
};


class nsCSSGridTemplateAreaScanner {
public:
  explicit nsCSSGridTemplateAreaScanner(const nsAString& aBuffer);



  bool Next(nsCSSGridTemplateAreaToken& aTokenResult);

private:
  const char16_t *mBuffer;
  uint32_t mOffset;
  uint32_t mCount;
};



namespace mozilla {

class CSSVariableResolver;

class CSSVariableValues
{
public:
  CSSVariableValues();
  CSSVariableValues(const CSSVariableValues& aOther);



  CSSVariableValues& operator=(const CSSVariableValues& aOther);

  bool operator==(const CSSVariableValues& aOther) const;
  bool operator!=(const CSSVariableValues& aOther) const
    { return !(*this == aOther); }
  bool Get(const nsAString& aName, nsString& aValue) const;
  bool Get(const nsAString& aName,
           nsString& aValue,
           nsCSSTokenSerializationType& aFirstToken,
           nsCSSTokenSerializationType& aLastToken) const;
  void GetVariableAt(size_t aIndex, nsAString& aName) const;




  size_t Count() const;
  void Put(const nsAString& aName,
           nsString aValue,
           nsCSSTokenSerializationType aFirstToken,
           nsCSSTokenSerializationType aLastToken);





  void AddVariablesToResolver(CSSVariableResolver* aResolver) const;

private:
  struct Variable
  {
    Variable()
      : mFirstToken(eCSSTokenSerialization_Nothing)
      , mLastToken(eCSSTokenSerialization_Nothing)
    {}

    Variable(const nsAString& aVariableName,
             nsString aValue,
             nsCSSTokenSerializationType aFirstToken,
             nsCSSTokenSerializationType aLastToken)
      : mVariableName(aVariableName)
      , mValue(aValue)
      , mFirstToken(aFirstToken)
      , mLastToken(aLastToken)
    {}

    nsString mVariableName;
    nsString mValue;
    nsCSSTokenSerializationType mFirstToken;
    nsCSSTokenSerializationType mLastToken;
  };




  void CopyVariablesFrom(const CSSVariableValues& aOther);





  nsDataHashtable<nsStringHashKey, size_t> mVariableIDs;




  nsTArray<Variable> mVariables;
};

}






class imgIContainer;

class imgINotificationObserver;

class nsIURI;

class nsIPrincipal;
class imgIRequest : public nsIRequest {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetImage(imgIContainer * *aImage) = 0;

  enum {
    STATUS_NONE = 0,
    STATUS_SIZE_AVAILABLE = 1,
    STATUS_LOAD_COMPLETE = 2,
    STATUS_ERROR = 4,
    STATUS_FRAME_COMPLETE = 8,
    STATUS_DECODE_COMPLETE = 16,
    STATUS_IS_ANIMATED = 32,
    STATUS_HAS_TRANSPARENCY = 64
  };


  virtual nsresult GetImageStatus(uint32_t *aImageStatus) = 0;


  virtual nsresult GetImageErrorCode(nsresult *aImageErrorCode) = 0;


  virtual nsresult GetURI(nsIURI * *aURI) = 0;


  virtual nsresult GetCurrentURI(nsIURI * *aCurrentURI) = 0;


  virtual nsresult GetNotificationObserver(imgINotificationObserver * *aNotificationObserver) = 0;


  virtual nsresult GetMimeType(char * *aMimeType) = 0;


  virtual nsresult Clone(imgINotificationObserver *aObserver, imgIRequest * *_retval) = 0;


  virtual nsresult GetImagePrincipal(nsIPrincipal * *aImagePrincipal) = 0;


  virtual nsresult GetMultipart(bool *aMultipart) = 0;

  enum {
    CORS_NONE = 1,
    CORS_ANONYMOUS = 2,
    CORS_USE_CREDENTIALS = 3
  };


  virtual nsresult GetCORSMode(int32_t *aCORSMode) = 0;


  virtual nsresult CancelAndForgetObserver(nsresult aStatus) = 0;


  virtual nsresult StartDecoding(uint32_t aFlags) = 0;


  virtual bool StartDecodingWithResult(uint32_t aFlags) = 0;


  virtual nsresult LockImage(void) = 0;


  virtual nsresult UnlockImage(void) = 0;


  virtual nsresult RequestDiscard(void) = 0;


  virtual nsresult GetStaticRequest(imgIRequest * *_retval) = 0;


  virtual nsresult IncrementAnimationConsumers(void) = 0;


  virtual nsresult DecrementAnimationConsumers(void) = 0;

};

  template<typename T> struct imgIRequest::COMTypeInfo<imgIRequest, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID imgIRequest::COMTypeInfo<imgIRequest, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xdb0a945c, 0x3883, 0x424a, { 0x98, 0xd0, 0x2e, 0xe0, 0x52, 0x3b, 0x02, 0x55 }};
class nsISecurityInfoProvider : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetSecurityInfo(nsISupports * *aSecurityInfo) = 0;


  virtual nsresult GetHasTransferredData(bool *aHasTransferredData) = 0;

};

  template<typename T> struct nsISecurityInfoProvider::COMTypeInfo<nsISecurityInfoProvider, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsISecurityInfoProvider::COMTypeInfo<nsISecurityInfoProvider, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xb8cc9126, 0x9319, 0x4415, { 0xaf, 0xd9, 0xb8, 0x22, 0x20, 0xd4, 0x53, 0xed }};


class nsISupportsPriority : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    PRIORITY_HIGHEST = -20,
    PRIORITY_HIGH = -10,
    PRIORITY_NORMAL = 0,
    PRIORITY_LOW = 10,
    PRIORITY_LOWEST = 20
  };


  virtual nsresult GetPriority(int32_t *aPriority) = 0;
  virtual nsresult SetPriority(int32_t aPriority) = 0;


  virtual nsresult AdjustPriority(int32_t delta) = 0;

};

  template<typename T> struct nsISupportsPriority::COMTypeInfo<nsISupportsPriority, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsISupportsPriority::COMTypeInfo<nsISupportsPriority, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xaa578b44, 0xabd5, 0x4c19, { 0x8b, 0x14, 0x36, 0xd4, 0xde, 0x6f, 0xdc, 0x36 }};
class nsIPrincipal;

namespace mozilla {
class TimeStamp;
}
class nsITimedChannel : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetTimingEnabled(bool *aTimingEnabled) = 0;
  virtual nsresult SetTimingEnabled(bool aTimingEnabled) = 0;


  virtual nsresult GetRedirectCount(uint16_t *aRedirectCount) = 0;
  virtual nsresult SetRedirectCount(uint16_t aRedirectCount) = 0;


  virtual nsresult GetChannelCreation(mozilla::TimeStamp *aChannelCreation) = 0;


  virtual nsresult GetAsyncOpen(mozilla::TimeStamp *aAsyncOpen) = 0;


  virtual nsresult GetDomainLookupStart(mozilla::TimeStamp *aDomainLookupStart) = 0;


  virtual nsresult GetDomainLookupEnd(mozilla::TimeStamp *aDomainLookupEnd) = 0;


  virtual nsresult GetConnectStart(mozilla::TimeStamp *aConnectStart) = 0;


  virtual nsresult GetConnectEnd(mozilla::TimeStamp *aConnectEnd) = 0;


  virtual nsresult GetRequestStart(mozilla::TimeStamp *aRequestStart) = 0;


  virtual nsresult GetResponseStart(mozilla::TimeStamp *aResponseStart) = 0;


  virtual nsresult GetResponseEnd(mozilla::TimeStamp *aResponseEnd) = 0;


  virtual nsresult GetRedirectStart(mozilla::TimeStamp *aRedirectStart) = 0;
  virtual nsresult SetRedirectStart(mozilla::TimeStamp aRedirectStart) = 0;


  virtual nsresult GetRedirectEnd(mozilla::TimeStamp *aRedirectEnd) = 0;
  virtual nsresult SetRedirectEnd(mozilla::TimeStamp aRedirectEnd) = 0;


  virtual nsresult GetInitiatorType(nsAString & aInitiatorType) = 0;
  virtual nsresult SetInitiatorType(const nsAString & aInitiatorType) = 0;


  virtual nsresult GetAllRedirectsSameOrigin(bool *aAllRedirectsSameOrigin) = 0;
  virtual nsresult SetAllRedirectsSameOrigin(bool aAllRedirectsSameOrigin) = 0;


  virtual nsresult GetAllRedirectsPassTimingAllowCheck(bool *aAllRedirectsPassTimingAllowCheck) = 0;
  virtual nsresult SetAllRedirectsPassTimingAllowCheck(bool aAllRedirectsPassTimingAllowCheck) = 0;


  virtual nsresult TimingAllowCheck(nsIPrincipal *origin, bool *_retval) = 0;

   inline bool TimingAllowCheck(nsIPrincipal* aOrigin) {
    bool allowed = false;
    return ((bool)(__builtin_expect(!!(!NS_FAILED_impl(TimingAllowCheck(aOrigin, &allowed))), 1))) && allowed;
  }

  virtual nsresult GetCacheReadStart(mozilla::TimeStamp *aCacheReadStart) = 0;


  virtual nsresult GetCacheReadEnd(mozilla::TimeStamp *aCacheReadEnd) = 0;


  virtual nsresult GetChannelCreationTime(PRTime *aChannelCreationTime) = 0;


  virtual nsresult GetAsyncOpenTime(PRTime *aAsyncOpenTime) = 0;


  virtual nsresult GetDomainLookupStartTime(PRTime *aDomainLookupStartTime) = 0;


  virtual nsresult GetDomainLookupEndTime(PRTime *aDomainLookupEndTime) = 0;


  virtual nsresult GetConnectStartTime(PRTime *aConnectStartTime) = 0;


  virtual nsresult GetConnectEndTime(PRTime *aConnectEndTime) = 0;


  virtual nsresult GetRequestStartTime(PRTime *aRequestStartTime) = 0;


  virtual nsresult GetResponseStartTime(PRTime *aResponseStartTime) = 0;


  virtual nsresult GetResponseEndTime(PRTime *aResponseEndTime) = 0;


  virtual nsresult GetCacheReadStartTime(PRTime *aCacheReadStartTime) = 0;


  virtual nsresult GetCacheReadEndTime(PRTime *aCacheReadEndTime) = 0;


  virtual nsresult GetRedirectStartTime(PRTime *aRedirectStartTime) = 0;


  virtual nsresult GetRedirectEndTime(PRTime *aRedirectEndTime) = 0;

};

  template<typename T> struct nsITimedChannel::COMTypeInfo<nsITimedChannel, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsITimedChannel::COMTypeInfo<nsITimedChannel, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xca63784d, 0x959c, 0x4c3a, { 0x9a, 0x59, 0x23, 0x4a, 0x2a, 0x52, 0x0d, 0xe0 }};






class nsIChannel;

class nsIAsyncVerifyRedirectCallback;
class nsIChannelEventSink : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;

  enum {
    REDIRECT_TEMPORARY = 1U,
    REDIRECT_PERMANENT = 2U,
    REDIRECT_INTERNAL = 4U,
    REDIRECT_STS_UPGRADE = 8U
  };


  virtual nsresult AsyncOnChannelRedirect(nsIChannel *oldChannel, nsIChannel *newChannel, uint32_t flags, nsIAsyncVerifyRedirectCallback *callback) = 0;

};

  template<typename T> struct nsIChannelEventSink::COMTypeInfo<nsIChannelEventSink, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIChannelEventSink::COMTypeInfo<nsIChannelEventSink, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x0197720d, 0x37ed, 0x4e75, { 0x89, 0x56, 0xd0, 0xd2, 0x96, 0xe4, 0xd8, 0xa6 }};
class nsIInterfaceRequestor : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult GetInterface(const nsIID & uuid, void **result) = 0;

};

  template<typename T> struct nsIInterfaceRequestor::COMTypeInfo<nsIInterfaceRequestor, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIInterfaceRequestor::COMTypeInfo<nsIInterfaceRequestor, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x033a1470, 0x8b2a, 0x11d3, { 0xaf, 0x88, 0x00, 0xa0, 0x24, 0xff, 0xc0, 0x8c }};

class nsIThreadRetargetableStreamListener : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult CheckListenerChain(void) = 0;

};

  template<typename T> struct nsIThreadRetargetableStreamListener::COMTypeInfo<nsIThreadRetargetableStreamListener, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIThreadRetargetableStreamListener::COMTypeInfo<nsIThreadRetargetableStreamListener, T>::kIID __attribute__ ((visibility ("hidden"))) = {0xfb2304b8, 0xf82f, 0x4433, { 0xaf, 0x68, 0xd8, 0x74, 0xa2, 0xeb, 0xbd, 0xc1 }};






class nsIAsyncVerifyRedirectCallback : public nsISupports {
 public:

  template<typename T, typename U> struct COMTypeInfo;


  virtual nsresult OnRedirectVerifyCallback(nsresult result) = 0;

};

  template<typename T> struct nsIAsyncVerifyRedirectCallback::COMTypeInfo<nsIAsyncVerifyRedirectCallback, T> { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; template<typename T> const nsIID nsIAsyncVerifyRedirectCallback::COMTypeInfo<nsIAsyncVerifyRedirectCallback, T>::kIID __attribute__ ((visibility ("hidden"))) = {0x8d171460, 0xa716, 0x41f1, { 0x92, 0xbe, 0x8c, 0x65, 0x9d, 0xb3, 0x9b, 0x45 }};
namespace mozilla {
class BlockingResourceBase
{
public:

  enum BlockingResourceType { eMutex, eReentrantMonitor, eCondVar };





  static const char* const kResourceTypeName[];
  BlockingResourceBase(const char* aName, BlockingResourceType aType) {}

  ~BlockingResourceBase() {}


};


}

namespace mozilla {

namespace detail {

class ConditionVariableImpl;

class MutexImpl
{
public:
  struct PlatformData;

  __attribute__((weak)) __attribute__((visibility("default"))) MutexImpl();
  __attribute__((weak)) __attribute__((visibility("default"))) ~MutexImpl();

  bool operator==(const MutexImpl& rhs) {
    return platformData_ == rhs.platformData_;
  }

protected:
  __attribute__((weak)) __attribute__((visibility("default"))) void lock();
  __attribute__((weak)) __attribute__((visibility("default"))) void unlock();

private:
  MutexImpl(const MutexImpl&) = delete;
  void operator=(const MutexImpl&) = delete;
  MutexImpl(MutexImpl&&) = delete;
  void operator=(MutexImpl&&) = delete;

  PlatformData* platformData();


  void* platformData_[sizeof(pthread_mutex_t) / sizeof(void*)];
  static_assert(sizeof(pthread_mutex_t) / sizeof(void*) != 0 &&
                sizeof(pthread_mutex_t) % sizeof(void*) == 0,
                "pthread_mutex_t must have pointer alignment");




  friend class mozilla::detail::ConditionVariableImpl;
};

}

}
namespace mozilla {






class OffTheBooksMutex : public detail::MutexImpl, BlockingResourceBase
{
public:






  explicit OffTheBooksMutex(const char* aName)
    : detail::MutexImpl()
    , BlockingResourceBase(aName, eMutex)



  {
  }

  ~OffTheBooksMutex()
  {



  }





  void Lock() { this->lock(); }




  void Unlock() { this->unlock(); }






  void AssertCurrentThreadOwns() const {}
  void AssertNotCurrentThreadOwns() const {}
private:
  OffTheBooksMutex();
  OffTheBooksMutex(const OffTheBooksMutex&);
  OffTheBooksMutex& operator=(const OffTheBooksMutex&);

  friend class CondVar;




};






class Mutex : public OffTheBooksMutex
{
public:
  explicit Mutex(const char* aName)
    : OffTheBooksMutex(aName)
  {
                         ;
  }

  ~Mutex()
  {
                         ;
  }

private:
  Mutex();
  Mutex(const Mutex&);
  Mutex& operator=(const Mutex&);
};
template<typename T>
class BaseAutoLock
{
public:
  explicit BaseAutoLock(T& aLock )
    : mLock(&aLock)
  {
    do { } while (0);
    do { } while(0);
    mLock->Lock();
  }

  ~BaseAutoLock(void)
  {
    mLock->Unlock();
  }

private:
  BaseAutoLock();
  BaseAutoLock(BaseAutoLock&);
  BaseAutoLock& operator=(BaseAutoLock&);
  static void* operator new(size_t) throw();

  T* mLock;

};

typedef BaseAutoLock<Mutex> MutexAutoLock;
typedef BaseAutoLock<OffTheBooksMutex> OffTheBooksMutexAutoLock;
template<typename T>
class BaseAutoUnlock
{
public:
  explicit BaseAutoUnlock(T& aLock )
    : mLock(&aLock)
  {
    do { } while (0);
    do { } while(0);
    mLock->Unlock();
  }

  ~BaseAutoUnlock()
  {
    mLock->Lock();
  }

private:
  BaseAutoUnlock();
  BaseAutoUnlock(BaseAutoUnlock&);
  BaseAutoUnlock& operator=(BaseAutoUnlock&);
  static void* operator new(size_t) throw();

  T* mLock;

};

typedef BaseAutoUnlock<Mutex> MutexAutoUnlock;
typedef BaseAutoUnlock<OffTheBooksMutex> OffTheBooksMutexAutoUnlock;

}

class nsIDocument;
class nsIURI;

namespace mozilla {
namespace image {

class ImageURL;
class ImageCacheKey final
{
public:
  ImageCacheKey(nsIURI* aURI, const OriginAttributes& aAttrs,
                nsIDocument* aDocument, nsresult& aRv);
  ImageCacheKey(ImageURL* aURI, const OriginAttributes& aAttrs,
                nsIDocument* aDocument);

  ImageCacheKey(const ImageCacheKey& aOther);
  ImageCacheKey(ImageCacheKey&& aOther);

  bool operator==(const ImageCacheKey& aOther) const;
  uint32_t Hash() const { return mHash; }


  const char* Spec() const;


  bool IsChrome() const { return mIsChrome; }



  void* ControlledDocument() const { return mControlledDocument; }

private:
  static uint32_t ComputeHash(ImageURL* aURI,
                              const Maybe<uint64_t>& aBlobSerial,
                              const OriginAttributes& aAttrs,
                              void* aControlledDocument);
  static void* GetControlledDocumentToken(nsIDocument* aDocument);

  RefPtr<ImageURL> mURI;
  Maybe<uint64_t> mBlobSerial;
  OriginAttributes mOriginAttributes;
  void* mControlledDocument;
  uint32_t mHash;
  bool mIsChrome;
};

}
}

class imgCacheValidator;
class imgLoader;
class imgRequestProxy;
class imgCacheEntry;
class nsIApplicationCache;
class nsIProperties;
class nsIRequest;
class nsITimedChannel;
class nsIURI;

namespace mozilla {
namespace image {
class Image;
class ImageURL;
class ProgressTracker;
}
}

struct NewPartResult;

class imgRequest final : public nsIStreamListener,
                         public nsIThreadRetargetableStreamListener,
                         public nsIChannelEventSink,
                         public nsIInterfaceRequestor,
                         public nsIAsyncVerifyRedirectCallback
{
  typedef mozilla::image::Image Image;
  typedef mozilla::image::ImageCacheKey ImageCacheKey;
  typedef mozilla::image::ImageURL ImageURL;
  typedef mozilla::image::ProgressTracker ProgressTracker;
  typedef mozilla::net::ReferrerPolicy ReferrerPolicy;

public:
  imgRequest(imgLoader* aLoader, const ImageCacheKey& aCacheKey);

  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:
  virtual nsresult OnDataAvailable(nsIRequest *aRequest, nsISupports *aContext, nsIInputStream *aInputStream, uint64_t aOffset, uint32_t aCount) override;
  virtual nsresult CheckListenerChain(void) override;
  virtual nsresult OnStartRequest(nsIRequest *aRequest, nsISupports *aContext) override; virtual nsresult OnStopRequest(nsIRequest *aRequest, nsISupports *aContext, nsresult aStatusCode) override;
  virtual nsresult AsyncOnChannelRedirect(nsIChannel *oldChannel, nsIChannel *newChannel, uint32_t flags, nsIAsyncVerifyRedirectCallback *callback) override;
  virtual nsresult GetInterface(const nsIID & uuid, void **result) override;
  virtual nsresult OnRedirectVerifyCallback(nsresult result) override;

  __attribute__ ((warn_unused_result)) nsresult Init(nsIURI* aURI,
                             nsIURI* aCurrentURI,
                             bool aHadInsecureRedirect,
                             nsIRequest* aRequest,
                             nsIChannel* aChannel,
                             imgCacheEntry* aCacheEntry,
                             nsISupports* aCX,
                             nsIPrincipal* aLoadingPrincipal,
                             int32_t aCORSMode,
                             ReferrerPolicy aReferrerPolicy);

  void ClearLoader();


  void AddProxy(imgRequestProxy* proxy);

  nsresult RemoveProxy(imgRequestProxy* proxy, nsresult aStatus);




  void CancelAndAbort(nsresult aStatus);


  void ContinueCancel(nsresult aStatus);


  void ContinueEvict();


  void StartDecoding();

  inline uint64_t InnerWindowID() const {
    return mInnerWindowId;
  }





  static void SetCacheValidation(imgCacheEntry* aEntry, nsIRequest* aRequest);





  bool CacheChanged(nsIRequest* aNewRequest);

  bool GetMultipart() const;



  bool HadInsecureRedirect() const;


  int32_t GetCORSMode() const { return mCORSMode; }


  ReferrerPolicy GetReferrerPolicy() const { return mReferrerPolicy; }



  already_AddRefed<nsIPrincipal> GetLoadingPrincipal() const
  {
    nsCOMPtr<nsIPrincipal> principal = mLoadingPrincipal;
    return principal.forget();
  }




  already_AddRefed<ProgressTracker> GetProgressTracker() const;


  already_AddRefed<Image> GetImage() const;


  inline nsIPrincipal* GetPrincipal() const { return mPrincipal.get(); }


  const ImageCacheKey& CacheKey() const { return mCacheKey; }


  void ResetCacheEntry();


  nsresult GetURI(ImageURL** aURI);
  nsresult GetCurrentURI(nsIURI** aURI);
  bool IsChrome() const;

  nsresult GetImageErrorCode(void);


  bool HasTransferredData() const;


  const char* GetMimeType() const { return mContentType.get(); }



  int32_t Priority() const;



  void AdjustPriority(imgRequestProxy* aProxy, int32_t aDelta);


  nsIRequest* GetRequest() const { return mRequest; }

  nsITimedChannel* GetTimedChannel() const { return mTimedChannel; }

  nsresult GetSecurityInfo(nsISupports** aSecurityInfoOut);

  imgCacheValidator* GetValidator() const { return mValidator; }
  void SetValidator(imgCacheValidator* aValidator) { mValidator = aValidator; }

  void* LoadId() const { return mLoadId; }
  void SetLoadId(void* aLoadId) { mLoadId = aLoadId; }




  void SetCacheEntry(imgCacheEntry* aEntry);


  bool HasCacheEntry() const;




  void SetIsInCache(bool aCacheable);

  void EvictFromCache();
  void RemoveFromCache();


  void SetProperties(const nsACString& aContentType,
                     const nsACString& aContentDisposition);

  nsIProperties* Properties() const { return mProperties; }

  bool HasConsumers() const;

private:
  friend class FinishPreparingForNewPartRunnable;

  virtual ~imgRequest();

  void FinishPreparingForNewPart(const NewPartResult& aResult);

  void Cancel(nsresult aStatus);


  void UpdateCacheEntrySize();


  bool IsDecodeRequested() const;


  imgLoader* mLoader;
  nsCOMPtr<nsIRequest> mRequest;



  RefPtr<ImageURL> mURI;

  nsCOMPtr<nsIURI> mCurrentURI;


  nsCOMPtr<nsIPrincipal> mLoadingPrincipal;

  nsCOMPtr<nsIPrincipal> mPrincipal;
  nsCOMPtr<nsIProperties> mProperties;
  nsCOMPtr<nsISupports> mSecurityInfo;
  nsCOMPtr<nsIChannel> mChannel;
  nsCOMPtr<nsIInterfaceRequestor> mPrevChannelSink;
  nsCOMPtr<nsIApplicationCache> mApplicationCache;

  nsCOMPtr<nsITimedChannel> mTimedChannel;

  nsCString mContentType;


  RefPtr<imgCacheEntry> mCacheEntry;


  ImageCacheKey mCacheKey;

  void* mLoadId;



  void* mFirstProxy;

  imgCacheValidator* mValidator;
  nsCOMPtr<nsIAsyncVerifyRedirectCallback> mRedirectCallback;
  nsCOMPtr<nsIChannel> mNewRedirectChannel;


  uint64_t mInnerWindowId;



  int32_t mCORSMode;


  ReferrerPolicy mReferrerPolicy;

  nsresult mImageErrorCode;

  mutable mozilla::Mutex mMutex;




  RefPtr<ProgressTracker> mProgressTracker;
  RefPtr<Image> mImage;
  bool mIsMultiPartChannel : 1;
  bool mGotData : 1;
  bool mIsInCache : 1;
  bool mDecodeRequested : 1;
  bool mNewPartPending : 1;
  bool mHadInsecureRedirect : 1;
};
namespace mozilla {
namespace image {
class IProgressObserver : public SupportsWeakPtr<IProgressObserver>
{
public:




  public: virtual MozExternalRefCountType AddRef(void) = 0; virtual MozExternalRefCountType Release(void) = 0; public:


  virtual void Notify(int32_t aType, const nsIntRect* aRect = nullptr) = 0;
  virtual void OnLoadComplete(bool aLastPart) = 0;


  virtual void BlockOnload() = 0;
  virtual void UnblockOnload() = 0;


  virtual void SetHasImage() = 0;
  virtual bool NotificationsDeferred() const = 0;
  virtual void SetNotificationsDeferred(bool aDeferNotifications) = 0;

protected:
  virtual ~IProgressObserver() { }
};

}
}
class imgINotificationObserver;
class imgStatusNotifyRunnable;
class ProxyBehaviour;

namespace mozilla {
namespace image {
class Image;
class ImageURL;
class ProgressTracker;
}
}

class imgRequestProxy : public imgIRequest,
                        public mozilla::image::IProgressObserver,
                        public nsISupportsPriority,
                        public nsISecurityInfoProvider,
                        public nsITimedChannel
{
protected:
  virtual ~imgRequestProxy();

public:
  typedef mozilla::image::Image Image;
  typedef mozilla::image::ImageURL ImageURL;
  typedef mozilla::image::ProgressTracker ProgressTracker;

  const char* typeName() const { return "imgRequestProxy"; } size_t typeSize() const { return sizeof(*this); }
  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) override; virtual MozExternalRefCountType AddRef(void) override; virtual MozExternalRefCountType Release(void) override; typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:
  virtual nsresult GetImage(imgIContainer * *aImage) override; virtual nsresult GetImageStatus(uint32_t *aImageStatus) override; virtual nsresult GetImageErrorCode(nsresult *aImageErrorCode) override; virtual nsresult GetURI(nsIURI * *aURI) override; virtual nsresult GetCurrentURI(nsIURI * *aCurrentURI) override; virtual nsresult GetNotificationObserver(imgINotificationObserver * *aNotificationObserver) override; virtual nsresult GetMimeType(char * *aMimeType) override; virtual nsresult Clone(imgINotificationObserver *aObserver, imgIRequest * *_retval) override; virtual nsresult GetImagePrincipal(nsIPrincipal * *aImagePrincipal) override; virtual nsresult GetMultipart(bool *aMultipart) override; virtual nsresult GetCORSMode(int32_t *aCORSMode) override; virtual nsresult CancelAndForgetObserver(nsresult aStatus) override; virtual nsresult StartDecoding(uint32_t aFlags) override; virtual bool StartDecodingWithResult(uint32_t aFlags) override; virtual nsresult LockImage(void) override; virtual nsresult UnlockImage(void) override; virtual nsresult RequestDiscard(void) override; virtual nsresult GetStaticRequest(imgIRequest * *_retval) override; virtual nsresult IncrementAnimationConsumers(void) override; virtual nsresult DecrementAnimationConsumers(void) override;
  virtual nsresult GetName(nsACString & aName) override; virtual nsresult IsPending(bool *_retval) override; virtual nsresult GetStatus(nsresult *aStatus) override; virtual nsresult Cancel(nsresult aStatus) override; virtual nsresult Suspend(void) override; virtual nsresult Resume(void) override; virtual nsresult GetLoadGroup(nsILoadGroup * *aLoadGroup) override; virtual nsresult SetLoadGroup(nsILoadGroup *aLoadGroup) override; virtual nsresult GetLoadFlags(nsLoadFlags *aLoadFlags) override; virtual nsresult SetLoadFlags(nsLoadFlags aLoadFlags) override;
  virtual nsresult GetPriority(int32_t *aPriority) override; virtual nsresult SetPriority(int32_t aPriority) override; virtual nsresult AdjustPriority(int32_t delta) override;
  virtual nsresult GetSecurityInfo(nsISupports * *aSecurityInfo) override; virtual nsresult GetHasTransferredData(bool *aHasTransferredData) override;


  imgRequestProxy();



  nsresult Init(imgRequest* aOwner,
                nsILoadGroup* aLoadGroup,
                ImageURL* aURI,
                imgINotificationObserver* aObserver);

  nsresult ChangeOwner(imgRequest* aNewOwner);




  void AddToLoadGroup();
  void RemoveFromLoadGroup(bool releaseLoadGroup);

  inline bool HasObserver() const {
    return mListener != nullptr;
  }





  void NotifyListener();




  void SyncNotifyListener();


  virtual void Notify(int32_t aType,
                      const mozilla::gfx::IntRect* aRect = nullptr) override;
  virtual void OnLoadComplete(bool aLastPart) override;


  virtual void BlockOnload() override;
  virtual void UnblockOnload() override;


  virtual void SetHasImage() override;



  virtual bool NotificationsDeferred() const override
  {
    return mDeferNotifications;
  }
  virtual void SetNotificationsDeferred(bool aDeferNotifications) override
  {
    mDeferNotifications = aDeferNotifications;
  }





  void ClearAnimationConsumers();

  virtual nsresult Clone(imgINotificationObserver* aObserver,
                         imgRequestProxy** aClone);
  nsresult GetStaticRequest(imgRequestProxy** aReturn);

  nsresult GetURI(ImageURL** aURI);

protected:
  friend class mozilla::image::ProgressTracker;
  friend class imgStatusNotifyRunnable;

  class imgCancelRunnable;
  friend class imgCancelRunnable;

  class imgCancelRunnable : public mozilla::Runnable
  {
    public:
      imgCancelRunnable(imgRequestProxy* owner, nsresult status)
        : Runnable("imgCancelRunnable"), mOwner(owner), mStatus(status)
      { }

      virtual nsresult Run() override {
        mOwner->DoCancel(mStatus);
        return NS_OK;
      }

    private:
      RefPtr<imgRequestProxy> mOwner;
      nsresult mStatus;
  };


  void DoCancel(nsresult status);


  void NullOutListener();

  void DoRemoveFromLoadGroup() {
    RemoveFromLoadGroup(true);
  }





  already_AddRefed<ProgressTracker> GetProgressTracker() const;

  nsITimedChannel* TimedChannel()
  {
    if (!GetOwner()) {
      return nullptr;
    }
    return GetOwner()->GetTimedChannel();
  }

  already_AddRefed<Image> GetImage() const;
  bool HasImage() const;
  imgRequest* GetOwner() const;

  nsresult PerformClone(imgINotificationObserver* aObserver,
                        imgRequestProxy* (aAllocFn)(imgRequestProxy*),
                        imgRequestProxy** aClone);

public:
  virtual nsresult GetTimingEnabled(bool *aTimingEnabled) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetTimingEnabled(aTimingEnabled); } virtual nsresult SetTimingEnabled(bool aTimingEnabled) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->SetTimingEnabled(aTimingEnabled); } virtual nsresult GetRedirectCount(uint16_t *aRedirectCount) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetRedirectCount(aRedirectCount); } virtual nsresult SetRedirectCount(uint16_t aRedirectCount) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->SetRedirectCount(aRedirectCount); } virtual nsresult GetChannelCreation(mozilla::TimeStamp *aChannelCreation) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetChannelCreation(aChannelCreation); } virtual nsresult GetAsyncOpen(mozilla::TimeStamp *aAsyncOpen) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetAsyncOpen(aAsyncOpen); } virtual nsresult GetDomainLookupStart(mozilla::TimeStamp *aDomainLookupStart) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetDomainLookupStart(aDomainLookupStart); } virtual nsresult GetDomainLookupEnd(mozilla::TimeStamp *aDomainLookupEnd) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetDomainLookupEnd(aDomainLookupEnd); } virtual nsresult GetConnectStart(mozilla::TimeStamp *aConnectStart) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetConnectStart(aConnectStart); } virtual nsresult GetConnectEnd(mozilla::TimeStamp *aConnectEnd) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetConnectEnd(aConnectEnd); } virtual nsresult GetRequestStart(mozilla::TimeStamp *aRequestStart) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetRequestStart(aRequestStart); } virtual nsresult GetResponseStart(mozilla::TimeStamp *aResponseStart) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetResponseStart(aResponseStart); } virtual nsresult GetResponseEnd(mozilla::TimeStamp *aResponseEnd) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetResponseEnd(aResponseEnd); } virtual nsresult GetRedirectStart(mozilla::TimeStamp *aRedirectStart) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetRedirectStart(aRedirectStart); } virtual nsresult SetRedirectStart(mozilla::TimeStamp aRedirectStart) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->SetRedirectStart(aRedirectStart); } virtual nsresult GetRedirectEnd(mozilla::TimeStamp *aRedirectEnd) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetRedirectEnd(aRedirectEnd); } virtual nsresult SetRedirectEnd(mozilla::TimeStamp aRedirectEnd) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->SetRedirectEnd(aRedirectEnd); } virtual nsresult GetInitiatorType(nsAString & aInitiatorType) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetInitiatorType(aInitiatorType); } virtual nsresult SetInitiatorType(const nsAString & aInitiatorType) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->SetInitiatorType(aInitiatorType); } virtual nsresult GetAllRedirectsSameOrigin(bool *aAllRedirectsSameOrigin) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetAllRedirectsSameOrigin(aAllRedirectsSameOrigin); } virtual nsresult SetAllRedirectsSameOrigin(bool aAllRedirectsSameOrigin) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->SetAllRedirectsSameOrigin(aAllRedirectsSameOrigin); } virtual nsresult GetAllRedirectsPassTimingAllowCheck(bool *aAllRedirectsPassTimingAllowCheck) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetAllRedirectsPassTimingAllowCheck(aAllRedirectsPassTimingAllowCheck); } virtual nsresult SetAllRedirectsPassTimingAllowCheck(bool aAllRedirectsPassTimingAllowCheck) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->SetAllRedirectsPassTimingAllowCheck(aAllRedirectsPassTimingAllowCheck); } virtual nsresult TimingAllowCheck(nsIPrincipal *origin, bool *_retval) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->TimingAllowCheck(origin, _retval); } virtual nsresult GetCacheReadStart(mozilla::TimeStamp *aCacheReadStart) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetCacheReadStart(aCacheReadStart); } virtual nsresult GetCacheReadEnd(mozilla::TimeStamp *aCacheReadEnd) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetCacheReadEnd(aCacheReadEnd); } virtual nsresult GetChannelCreationTime(PRTime *aChannelCreationTime) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetChannelCreationTime(aChannelCreationTime); } virtual nsresult GetAsyncOpenTime(PRTime *aAsyncOpenTime) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetAsyncOpenTime(aAsyncOpenTime); } virtual nsresult GetDomainLookupStartTime(PRTime *aDomainLookupStartTime) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetDomainLookupStartTime(aDomainLookupStartTime); } virtual nsresult GetDomainLookupEndTime(PRTime *aDomainLookupEndTime) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetDomainLookupEndTime(aDomainLookupEndTime); } virtual nsresult GetConnectStartTime(PRTime *aConnectStartTime) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetConnectStartTime(aConnectStartTime); } virtual nsresult GetConnectEndTime(PRTime *aConnectEndTime) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetConnectEndTime(aConnectEndTime); } virtual nsresult GetRequestStartTime(PRTime *aRequestStartTime) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetRequestStartTime(aRequestStartTime); } virtual nsresult GetResponseStartTime(PRTime *aResponseStartTime) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetResponseStartTime(aResponseStartTime); } virtual nsresult GetResponseEndTime(PRTime *aResponseEndTime) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetResponseEndTime(aResponseEndTime); } virtual nsresult GetCacheReadStartTime(PRTime *aCacheReadStartTime) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetCacheReadStartTime(aCacheReadStartTime); } virtual nsresult GetCacheReadEndTime(PRTime *aCacheReadEndTime) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetCacheReadEndTime(aCacheReadEndTime); } virtual nsresult GetRedirectStartTime(PRTime *aRedirectStartTime) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetRedirectStartTime(aRedirectStartTime); } virtual nsresult GetRedirectEndTime(PRTime *aRedirectEndTime) override { return !TimedChannel() ? NS_ERROR_NULL_POINTER : TimedChannel()->GetRedirectEndTime(aRedirectEndTime); }

protected:
  mozilla::UniquePtr<ProxyBehaviour> mBehaviour;

private:
  friend class imgCacheValidator;
  friend imgRequestProxy* NewStaticProxy(imgRequestProxy* aThis);


  RefPtr<ImageURL> mURI;




  imgINotificationObserver* mListener;



  nsCOMPtr<nsILoadGroup> mLoadGroup;

  nsLoadFlags mLoadFlags;
  uint32_t mLockCount;
  uint32_t mAnimationConsumers;
  bool mCanceled;
  bool mIsInLoadGroup;
  bool mListenerIsStrongRef;
  bool mDecodeRequested;



  bool mDeferNotifications;
};



class imgRequestProxyStatic : public imgRequestProxy
{

public:
  imgRequestProxyStatic(Image* aImage, nsIPrincipal* aPrincipal);

  virtual nsresult GetImagePrincipal(nsIPrincipal** aPrincipal) override;

  using imgRequestProxy::Clone;

  virtual nsresult Clone(imgINotificationObserver* aObserver,
                         imgRequestProxy** aClone) override;

protected:
  friend imgRequestProxy* NewStaticProxy(imgRequestProxy*);



  nsCOMPtr<nsIPrincipal> mPrincipal;
};
namespace mozilla {
namespace image {

enum class Angle : uint8_t {
  D0,
  D90,
  D180,
  D270
};

enum class Flip : uint8_t {
  Unflipped,
  Horizontal
};






struct Orientation
{
  explicit Orientation(Angle aRotation = Angle::D0,
                       Flip mFlip = Flip::Unflipped)
    : rotation(aRotation)
    , flip(mFlip)
  { }

  bool IsIdentity() const {
    return (rotation == Angle::D0) && (flip == Flip::Unflipped);
  }

  bool SwapsWidthAndHeight() const {
    return (rotation == Angle::D90) || (rotation == Angle::D270);
  }

  bool operator==(const Orientation& aOther) const {
    return (rotation == aOther.rotation) && (flip == aOther.flip);
  }

  bool operator!=(const Orientation& aOther) const {
    return !(*this == aOther);
  }

  Angle rotation;
  Flip flip;
};

}
}
class nsPresContext;

namespace mozilla {

class WritingMode;

typedef int32_t CounterValue;

class CounterStyleManager;
class AnonymousCounterStyle;

struct NegativeType;
struct PadType;

class CounterStyle
{
protected:
  explicit constexpr CounterStyle(int32_t aStyle)
    : mStyle(aStyle)
  {
  }

private:
  CounterStyle(const CounterStyle& aOther) = delete;
  void operator=(const CounterStyle& other) = delete;

public:
  int32_t GetStyle() const { return mStyle; }
  bool IsNone() const { return mStyle == 0; }
  bool IsCustomStyle() const { return mStyle == -1; }



  bool IsDependentStyle() const;

  virtual void GetStyleName(nsSubstring& aResult) = 0;
  virtual void GetPrefix(nsSubstring& aResult) = 0;
  virtual void GetSuffix(nsSubstring& aResult) = 0;
  void GetCounterText(CounterValue aOrdinal,
                      WritingMode aWritingMode,
                      nsSubstring& aResult,
                      bool& aIsRTL);
  virtual void GetSpokenCounterText(CounterValue aOrdinal,
                                    WritingMode aWritingMode,
                                    nsSubstring& aResult,
                                    bool& aIsBullet);



  virtual bool IsBullet() = 0;

  virtual void GetNegative(NegativeType& aResult) = 0;





  virtual bool IsOrdinalInRange(CounterValue aOrdinal) = 0;





  virtual bool IsOrdinalInAutoRange(CounterValue aOrdinal) = 0;
  virtual void GetPad(PadType& aResult) = 0;
  virtual CounterStyle* GetFallback() = 0;
  virtual uint8_t GetSpeakAs() = 0;
  virtual bool UseNegativeSign() = 0;

  virtual void CallFallbackStyle(CounterValue aOrdinal,
                                 WritingMode aWritingMode,
                                 nsSubstring& aResult,
                                 bool& aIsRTL);
  virtual bool GetInitialCounterText(CounterValue aOrdinal,
                                     WritingMode aWritingMode,
                                     nsSubstring& aResult,
                                     bool& aIsRTL) = 0;

  virtual AnonymousCounterStyle* AsAnonymous() { return nullptr; }

  public: virtual MozExternalRefCountType AddRef(void) = 0; virtual MozExternalRefCountType Release(void) = 0; public:

protected:
  int32_t mStyle;
};

class AnonymousCounterStyle final : public CounterStyle
{
public:
  explicit AnonymousCounterStyle(const nsSubstring& aContent);
  explicit AnonymousCounterStyle(const nsCSSValue::Array* aValue);

  virtual void GetStyleName(nsAString& aResult) override;
  virtual void GetPrefix(nsAString& aResult) override;
  virtual void GetSuffix(nsAString& aResult) override;
  virtual bool IsBullet() override;

  virtual void GetNegative(NegativeType& aResult) override;
  virtual bool IsOrdinalInRange(CounterValue aOrdinal) override;
  virtual bool IsOrdinalInAutoRange(CounterValue aOrdinal) override;
  virtual void GetPad(PadType& aResult) override;
  virtual CounterStyle* GetFallback() override;
  virtual uint8_t GetSpeakAs() override;
  virtual bool UseNegativeSign() override;

  virtual bool GetInitialCounterText(CounterValue aOrdinal,
                                     WritingMode aWritingMode,
                                     nsSubstring& aResult,
                                     bool& aIsRTL) override;

  virtual AnonymousCounterStyle* AsAnonymous() override { return this; }

  bool IsSingleString() const { return mSingleString; }
  uint8_t GetSystem() const { return mSystem; }
  const nsTArray<nsString>& GetSymbols() const { return mSymbols; }

  public: MozExternalRefCountType AddRef(void) override { static_assert(!mozilla::IsDestructible<AnonymousCounterStyle>::value, "Reference-counted class " "AnonymousCounterStyle" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); ++mRefCnt; ; return mRefCnt; } MozExternalRefCountType Release(void) override { do { } while (0); ((void)0); --mRefCnt; ; if (mRefCnt == 0) { mRefCnt = 1; delete(this); return 0; } return mRefCnt; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:

private:
  ~AnonymousCounterStyle() {}

  bool mSingleString;
  uint8_t mSystem;
  nsTArray<nsString> mSymbols;
};

class CounterStyleManager final
{
private:
  ~CounterStyleManager();
public:
  explicit CounterStyleManager(nsPresContext* aPresContext);

  static void InitializeBuiltinCounterStyles();

  void Disconnect();

  bool IsInitial() const
  {

    return mCacheTable.Count() == 2;
  }

  CounterStyle* BuildCounterStyle(const nsSubstring& aName);

  static CounterStyle* GetBuiltinStyle(int32_t aStyle);
  static CounterStyle* GetNoneStyle()
  {
    return GetBuiltinStyle(0);
  }
  static CounterStyle* GetDecimalStyle()
  {
    return GetBuiltinStyle(4);
  }





  bool NotifyRuleChanged();

  nsPresContext* PresContext() const { return mPresContext; }

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<CounterStyleManager>::value, "Reference-counted class " "CounterStyleManager" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); ((void)0); ++mRefCnt; ; return mRefCnt; } MozExternalRefCountType Release(void) { do { } while (0); ((void)0); --mRefCnt; ; if (mRefCnt == 0) { mRefCnt = 1; delete(this); return 0; } return mRefCnt; } typedef mozilla::FalseType HasThreadSafeRefCnt; protected: nsAutoRefCnt mRefCnt; public:

private:
  nsPresContext* mPresContext;
  nsRefPtrHashtable<nsStringHashKey, CounterStyle> mCacheTable;
};

}



class nsIFrame;
class nsIURI;
class nsStyleContext;
class nsTextFrame;
class imgIContainer;
struct nsStyleVisibility;
namespace mozilla {
namespace dom {
class ImageTracker;
}
}
static_assert(int(mozilla::SheetType::Count) - 1 <=
                (0xf0000000 >> 28),
              "NS_RULE_NODE_LEVEL_MASK cannot fit SheetType");

static_assert(0x000ffffff == (1 << nsStyleStructID_Length) - 1,
              "NS_STYLE_INHERIT_MASK is not correct");

static_assert((0x01000000 & 0x000ffffff) == 0,
  "NS_RULE_NODE_IS_ANIMATION_RULE must not overlap the style struct bits.");

namespace mozilla {

struct Position {
  using Coord = nsStyleCoord::CalcValue;

  Coord mXPosition, mYPosition;


  Position() {}



  void SetInitialPercentValues(float aPercentVal);



  void SetInitialZeroValues();



  bool DependsOnPositioningAreaSize() const {
    return mXPosition.mPercent != 0.0f || mYPosition.mPercent != 0.0f;
  }

  bool operator==(const Position& aOther) const {
    return mXPosition == aOther.mXPosition &&
      mYPosition == aOther.mYPosition;
  }
  bool operator!=(const Position& aOther) const {
    return !(*this == aOther);
  }
};

}


struct nsStyleFont
{
  nsStyleFont(const nsFont& aFont, const nsPresContext* aContext);
  nsStyleFont(const nsStyleFont& aStyleFont);
  explicit nsStyleFont(const nsPresContext* aContext);
  ~nsStyleFont() {
                               ;
  }
  void FinishStyle(nsPresContext* aPresContext) {}

  nsChangeHint CalcDifference(const nsStyleFont& aNewData) const;






  static nscoord ZoomText(const nsPresContext* aPresContext, nscoord aSize);





  static nscoord UnZoomText(nsPresContext* aPresContext, nscoord aSize);
  static already_AddRefed<nsIAtom> GetLanguage(const nsPresContext* aPresContext);

  void* operator new(size_t sz, nsStyleFont* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleFont, sz);
  }
  void Destroy(nsPresContext* aContext);

  void EnableZoom(nsPresContext* aContext, bool aEnable);

  nsFont mFont;
  nscoord mSize;





  uint8_t mGenericID;



  int8_t mScriptLevel;

  uint8_t mMathVariant;

  uint8_t mMathDisplay;


  uint8_t mMinFontSizeRatio;


  bool mExplicitLanguage;



  bool mAllowZoom;


  nscoord mScriptUnconstrainedSize;
  nscoord mScriptMinSize;
  float mScriptSizeMultiplier;
  nsCOMPtr<nsIAtom> mLanguage;
};

struct nsStyleGradientStop
{
  nsStyleCoord mLocation;
  nscolor mColor;
  bool mIsInterpolationHint;


  bool operator==(const nsStyleGradientStop&) const = delete;
  bool operator!=(const nsStyleGradientStop&) const = delete;
};

class nsStyleGradient final
{
public:
  nsStyleGradient();
  uint8_t mShape;
  uint8_t mSize;

  bool mRepeating;
  bool mLegacySyntax;

  nsStyleCoord mBgPosX;
  nsStyleCoord mBgPosY;
  nsStyleCoord mAngle;

  nsStyleCoord mRadiusX;
  nsStyleCoord mRadiusY;


  nsTArray<nsStyleGradientStop> mStops;

  bool operator==(const nsStyleGradient& aOther) const;
  bool operator!=(const nsStyleGradient& aOther) const {
    return !(*this == aOther);
  }

  bool IsOpaque();
  bool HasCalc();
  uint32_t Hash(PLDHashNumber aHash);

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsStyleGradient>::value, "Reference-counted class " "nsStyleGradient" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); nsrefcnt count = ++mRefCnt; ; return (nsrefcnt) count; } MozExternalRefCountType Release(void) { do { } while (0); nsrefcnt count = --mRefCnt; ; if (count == 0) { delete (this); return 0; } return count; } typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:

private:

  ~nsStyleGradient() {}

  nsStyleGradient(const nsStyleGradient& aOther) = delete;
  nsStyleGradient& operator=(const nsStyleGradient& aOther) = delete;
};
class nsStyleImageRequest
{
public:




  enum class Mode : uint8_t {







    Track = 0x1,





    Discard = 0x2,
  };




  nsStyleImageRequest(Mode aModeFlags,
                      imgRequestProxy* aRequestProxy,
                      mozilla::css::ImageValue* aImageValue,
                      mozilla::dom::ImageTracker* aImageTracker);



  nsStyleImageRequest(
      Mode aModeFlags,
      nsStringBuffer* aURLBuffer,
      already_AddRefed<mozilla::css::URLExtraData> aExtraData);

  bool Resolve(nsPresContext* aPresContext);
  bool IsResolved() const { return mResolved; }

  imgRequestProxy* get() {
    do { } while (0);
    do { } while (0);
    return mRequestProxy.get();
  }
  const imgRequestProxy* get() const {
    return const_cast<nsStyleImageRequest*>(this)->get();
  }



  bool DefinitelyEquals(const nsStyleImageRequest& aOther) const;

  mozilla::css::ImageValue* GetImageValue() const { return mImageValue; }

  already_AddRefed<nsIURI> GetImageURI() const;

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsStyleImageRequest>::value, "Reference-counted class " "nsStyleImageRequest" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); nsrefcnt count = ++mRefCnt; ; return (nsrefcnt) count; } MozExternalRefCountType Release(void) { do { } while (0); nsrefcnt count = --mRefCnt; ; if (count == 0) { delete (this); return 0; } return count; } typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:;

private:
  ~nsStyleImageRequest();
  nsStyleImageRequest& operator=(const nsStyleImageRequest& aOther) = delete;

  void MaybeTrackAndLock();

  RefPtr<imgRequestProxy> mRequestProxy;
  RefPtr<mozilla::css::ImageValue> mImageValue;
  RefPtr<mozilla::dom::ImageTracker> mImageTracker;


  RefPtr<mozilla::dom::DocGroup> mDocGroup;

  Mode mModeFlags;
  bool mResolved;
};

inline constexpr mozilla::CastableTypedEnumResult<nsStyleImageRequest::Mode> operator |(nsStyleImageRequest::Mode a, nsStyleImageRequest::Mode b) { typedef mozilla::CastableTypedEnumResult<nsStyleImageRequest::Mode> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<nsStyleImageRequest::Mode>::Type U; return Result(nsStyleImageRequest::Mode(U(a) | U(b))); } inline nsStyleImageRequest::Mode& operator |=(nsStyleImageRequest::Mode& a, nsStyleImageRequest::Mode b) { return a = a | b; } inline constexpr mozilla::CastableTypedEnumResult<nsStyleImageRequest::Mode> operator &(nsStyleImageRequest::Mode a, nsStyleImageRequest::Mode b) { typedef mozilla::CastableTypedEnumResult<nsStyleImageRequest::Mode> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<nsStyleImageRequest::Mode>::Type U; return Result(nsStyleImageRequest::Mode(U(a) & U(b))); } inline nsStyleImageRequest::Mode& operator &=(nsStyleImageRequest::Mode& a, nsStyleImageRequest::Mode b) { return a = a & b; } inline constexpr mozilla::CastableTypedEnumResult<nsStyleImageRequest::Mode> operator ^(nsStyleImageRequest::Mode a, nsStyleImageRequest::Mode b) { typedef mozilla::CastableTypedEnumResult<nsStyleImageRequest::Mode> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<nsStyleImageRequest::Mode>::Type U; return Result(nsStyleImageRequest::Mode(U(a) ^ U(b))); } inline nsStyleImageRequest::Mode& operator ^=(nsStyleImageRequest::Mode& a, nsStyleImageRequest::Mode b) { return a = a ^ b; } inline constexpr mozilla::CastableTypedEnumResult<nsStyleImageRequest::Mode> operator~(nsStyleImageRequest::Mode a) { typedef mozilla::CastableTypedEnumResult<nsStyleImageRequest::Mode> Result; typedef mozilla::detail::UnsignedIntegerTypeForEnum<nsStyleImageRequest::Mode>::Type U; return Result(nsStyleImageRequest::Mode(~(U(a)))); }

enum nsStyleImageType {
  eStyleImageType_Null,
  eStyleImageType_Image,
  eStyleImageType_Gradient,
  eStyleImageType_Element
};

struct CachedBorderImageData
{


  void SetCachedSVGViewportSize(const mozilla::Maybe<nsSize>& aSVGViewportSize);
  const mozilla::Maybe<nsSize>& GetCachedSVGViewportSize();
  void PurgeCachedImages();
  void SetSubImage(uint8_t aIndex, imgIContainer* aSubImage);
  imgIContainer* GetSubImage(uint8_t aIndex);

private:



  mozilla::Maybe<nsSize> mCachedSVGViewportSize;
  nsCOMArray<imgIContainer> mSubImages;
};
struct nsStyleImage
{
  nsStyleImage();
  ~nsStyleImage();
  nsStyleImage(const nsStyleImage& aOther);
  nsStyleImage& operator=(const nsStyleImage& aOther);

  void SetNull();
  void SetImageRequest(already_AddRefed<nsStyleImageRequest> aImage);
  void SetGradientData(nsStyleGradient* aGradient);
  void SetElementId(const char16_t* aElementId);
  void SetCropRect(mozilla::UniquePtr<nsStyleSides> aCropRect);

  void ResolveImage(nsPresContext* aContext) {
    do { } while (0);
    if (mType == eStyleImageType_Image && !mImage->IsResolved()) {
      mImage->Resolve(aContext);
    }
  }

  nsStyleImageType GetType() const {
    return mType;
  }
  nsStyleImageRequest* GetImageRequest() const {
    do { } while (0);
    do { } while (0);
    return mImage;
  }
  imgRequestProxy* GetImageData() const {
    return GetImageRequest()->get();
  }
  nsStyleGradient* GetGradientData() const {
    do { } while(0);
    return mGradient;
  }
  const char16_t* GetElementId() const {
    do { } while(0);
    return mElementId;
  }
  const mozilla::UniquePtr<nsStyleSides>& GetCropRect() const {
    do { } while(0);

    return mCropRect;
  }

  already_AddRefed<nsIURI> GetImageURI() const;
  bool ComputeActualCropRect(nsIntRect& aActualCropRect,
                               bool* aIsEntireImage = nullptr) const;







  bool StartDecoding() const;




  bool IsOpaque() const;





  bool IsComplete() const;





  bool IsLoaded() const;




  bool IsEmpty() const {







    return mType == eStyleImageType_Null;
  }

  bool operator==(const nsStyleImage& aOther) const;
  bool operator!=(const nsStyleImage& aOther) const {
    return !(*this == aOther);
  }

  bool ImageDataEquals(const nsStyleImage& aOther) const
  {
    return GetType() == eStyleImageType_Image &&
           aOther.GetType() == eStyleImageType_Image &&
           GetImageData() == aOther.GetImageData();
  }



  inline void SetSubImage(uint8_t aIndex, imgIContainer* aSubImage) const;
  inline imgIContainer* GetSubImage(uint8_t aIndex) const;
  void PurgeCacheForViewportChange(
    const mozilla::Maybe<nsSize>& aSVGViewportSize,
    const bool aHasIntrinsicRatio) const;

private:
  void DoCopy(const nsStyleImage& aOther);
  void EnsureCachedBIData() const;



  mozilla::UniquePtr<CachedBorderImageData> mCachedBIData;

  nsStyleImageType mType;
  union {
    nsStyleImageRequest* mImage;
    nsStyleGradient* mGradient;
    char16_t* mElementId;
  };


  mozilla::UniquePtr<nsStyleSides> mCropRect;
};

struct nsStyleColor
{
  explicit nsStyleColor(const nsPresContext* aContext);
  nsStyleColor(const nsStyleColor& aOther);
  ~nsStyleColor() {
                                ;
  }
  void FinishStyle(nsPresContext* aPresContext) {}

  nscolor CalcComplexColor(const mozilla::StyleComplexColor& aColor) const {
    return mozilla::LinearBlendColors(aColor.mColor, mColor,
                                      aColor.mForegroundRatio);
  }

  nsChangeHint CalcDifference(const nsStyleColor& aNewData) const;

  void* operator new(size_t sz, nsStyleColor* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleColor, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleColor();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleColor, this);
  }



  nscolor mColor;
};

struct nsStyleImageLayers {

  enum {
    shorthand = 0,
    color,
    image,
    repeat,
    positionX,
    positionY,
    clip,
    origin,
    size,
    attachment,
    maskMode,
    composite
  };

  enum class LayerType : uint8_t {
    Background = 0,
    Mask
  };

  explicit nsStyleImageLayers(LayerType aType);
  nsStyleImageLayers(const nsStyleImageLayers &aSource);
  ~nsStyleImageLayers() {
                                      ;
  }

  static bool IsInitialPositionForLayerType(mozilla::Position aPosition, LayerType aType);

  struct Size;
  friend struct Size;
  struct Size {
    struct Dimension : public nsStyleCoord::CalcValue {
      nscoord ResolveLengthPercentage(nscoord aAvailable) const {
        double d = double(mPercent) * double(aAvailable) + double(mLength);
        if (d < 0.0) {
          return 0;
        }
        return NSToCoordRoundWithClamp(float(d));
      }
    };
    Dimension mWidth, mHeight;

    bool IsInitialValue() const {
      return mWidthType == eAuto && mHeightType == eAuto;
    }

    nscoord ResolveWidthLengthPercentage(const nsSize& aBgPositioningArea) const {
      do { } while (0);

      return mWidth.ResolveLengthPercentage(aBgPositioningArea.width);
    }

    nscoord ResolveHeightLengthPercentage(const nsSize& aBgPositioningArea) const {
      do { } while (0);

      return mHeight.ResolveLengthPercentage(aBgPositioningArea.height);
    }





    enum DimensionType {



      eContain, eCover,

      eAuto,
      eLengthPercentage,
      eDimensionType_COUNT
    };
    uint8_t mWidthType, mHeightType;




    bool DependsOnPositioningAreaSize(const nsStyleImage& aImage) const;


    Size() {}


    void SetInitialValues();

    bool operator==(const Size& aOther) const;
    bool operator!=(const Size& aOther) const {
      return !(*this == aOther);
    }
  };

  struct Repeat;
  friend struct Repeat;
  struct Repeat {
    uint8_t mXRepeat, mYRepeat;


    Repeat() {}

    bool IsInitialValue() const {
      return mXRepeat == 0x03 &&
             mYRepeat == 0x03;
    }

    bool DependsOnPositioningAreaSize() const {
      return mXRepeat == 0x04 ||
             mYRepeat == 0x04;
    }


    void SetInitialValues() {
      mXRepeat = 0x03;
      mYRepeat = 0x03;
    }

    bool operator==(const Repeat& aOther) const {
      return mXRepeat == aOther.mXRepeat &&
             mYRepeat == aOther.mYRepeat;
    }
    bool operator!=(const Repeat& aOther) const {
      return !(*this == aOther);
    }
  };

  struct Layer;
  friend struct Layer;
  struct Layer {
    typedef mozilla::StyleGeometryBox StyleGeometryBox;

    nsStyleImage mImage;
    RefPtr<mozilla::css::URLValueData> mSourceURI;







    mozilla::Position mPosition;
    Size mSize;
    StyleGeometryBox mClip;

      StyleGeometryBox mOrigin;
    uint8_t mAttachment;





    uint8_t mBlendMode;





    uint8_t mComposite;





    uint8_t mMaskMode;





    Repeat mRepeat;



    Layer();
    ~Layer();


    void Initialize(LayerType aType);

    void ResolveImage(nsPresContext* aContext) {
      if (mImage.GetType() == eStyleImageType_Image) {
        mImage.ResolveImage(aContext);
      }
    }






    bool RenderingMightDependOnPositioningAreaSizeChange() const;


    nsChangeHint CalcDifference(const Layer& aNewLayer) const;



    bool operator==(const Layer& aOther) const;
    bool operator!=(const Layer& aOther) const {
      return !(*this == aOther);
    }
  };



  uint32_t mAttachmentCount,
           mClipCount,
           mOriginCount,
           mRepeatCount,
           mPositionXCount,
           mPositionYCount,
           mImageCount,
           mSizeCount,
           mMaskModeCount,
           mBlendModeCount,
           mCompositeCount;
  nsStyleAutoArray<Layer> mLayers;

  const Layer& BottomLayer() const { return mLayers[mImageCount - 1]; }

  void ResolveImages(nsPresContext* aContext) {
    for (uint32_t i = 0; i < mImageCount; ++i) {
      mLayers[i].ResolveImage(aContext);
    }
  }

  nsChangeHint CalcDifference(const nsStyleImageLayers& aNewLayers,
                              nsStyleImageLayers::LayerType aType) const;

  nsStyleImageLayers& operator=(const nsStyleImageLayers& aOther);
  nsStyleImageLayers& operator=(nsStyleImageLayers&& aOther);
  bool operator==(const nsStyleImageLayers& aOther) const;

  static const nsCSSPropertyID kBackgroundLayerTable[];
  static const nsCSSPropertyID kMaskLayerTable[];







};

struct nsStyleBackground {
  explicit nsStyleBackground(const nsPresContext* aContext);
  nsStyleBackground(const nsStyleBackground& aOther);
  ~nsStyleBackground();




  void FinishStyle(nsPresContext* aPresContext);

  void* operator new(size_t sz, nsStyleBackground* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleBackground, sz);
  }
  void Destroy(nsPresContext* aContext);

  nsChangeHint CalcDifference(const nsStyleBackground& aNewData) const;


  nscolor BackgroundColor(const nsIFrame* aFrame) const;
  nscolor BackgroundColor(nsStyleContext* aContext) const;


  bool IsTransparent(const nsIFrame* aFrame) const;
  bool IsTransparent(nsStyleContext* aContext) const;





  bool HasFixedBackground(nsIFrame* aFrame) const;



  inline bool HasLocalBackground() const;

  const nsStyleImageLayers::Layer& BottomLayer() const { return mImage.BottomLayer(); }

  nsStyleImageLayers mImage;
  mozilla::StyleComplexColor mBackgroundColor;
};






struct nsStyleMargin
{
  explicit nsStyleMargin(const nsPresContext* aContext);
  nsStyleMargin(const nsStyleMargin& aMargin);
  ~nsStyleMargin() {
                                 ;
  }
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStyleMargin* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleMargin, sz);
  }
  void Destroy(nsPresContext* aContext);

  nsChangeHint CalcDifference(const nsStyleMargin& aNewData) const;

  bool GetMargin(nsMargin& aMargin) const
  {
    if (!mMargin.ConvertsToLength()) {
      return false;
    }

    int32_t side916 = mozilla::eSideTop; for (mozilla::Side side; side916 <= mozilla::eSideLeft && ((side = mozilla::Side(side916)), true); ++side916) {
      aMargin.Side(side) = mMargin.ToLength(side);
    }
    return true;
  }



  inline bool HasBlockAxisAuto(mozilla::WritingMode aWM) const;
  inline bool HasInlineAxisAuto(mozilla::WritingMode aWM) const;

  nsStyleSides mMargin;
};

struct nsStylePadding
{
  explicit nsStylePadding(const nsPresContext* aContext);
  nsStylePadding(const nsStylePadding& aPadding);
  ~nsStylePadding() {
                                  ;
  }
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStylePadding* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStylePadding, sz);
  }
  void Destroy(nsPresContext* aContext);

  nsChangeHint CalcDifference(const nsStylePadding& aNewData) const;

  nsStyleSides mPadding;

  bool IsWidthDependent() const {
    return !mPadding.ConvertsToLength();
  }

  bool GetPadding(nsMargin& aPadding) const
  {
    if (!mPadding.ConvertsToLength()) {
      return false;
    }

    int32_t side960 = mozilla::eSideTop; for (mozilla::Side side; side960 <= mozilla::eSideLeft && ((side = mozilla::Side(side960)), true); ++side960) {

      aPadding.Side(side) = std::max(mPadding.ToLength(side), 0);
    }
    return true;
  }
};

struct nsBorderColors
{
  nsBorderColors* mNext;
  nscolor mColor;

  nsBorderColors() : mNext(nullptr), mColor(((nscolor) ((255 << 24) | ((0)<<16) | ((0)<<8) | (0)))) {}
  explicit nsBorderColors(const nscolor& aColor) : mNext(nullptr), mColor(aColor) {}
  ~nsBorderColors();

  nsBorderColors* Clone() const { return Clone(true); }

  static bool Equal(const nsBorderColors* c1,
                      const nsBorderColors* c2) {
    if (c1 == c2) {
      return true;
    }
    while (c1 && c2) {
      if (c1->mColor != c2->mColor) {
        return false;
      }
      c1 = c1->mNext;
      c2 = c2->mNext;
    }


    return !c1 && !c2;
  }

private:
  nsBorderColors* Clone(bool aDeep) const;
};

struct nsCSSShadowItem
{
  nscoord mXOffset;
  nscoord mYOffset;
  nscoord mRadius;
  nscoord mSpread;

  nscolor mColor;
  bool mHasColor;
  bool mInset;

  nsCSSShadowItem() : mHasColor(false) {
                                   ;
  }
  ~nsCSSShadowItem() {
                                   ;
  }

  bool operator==(const nsCSSShadowItem& aOther) const {
    return (mXOffset == aOther.mXOffset &&
            mYOffset == aOther.mYOffset &&
            mRadius == aOther.mRadius &&
            mHasColor == aOther.mHasColor &&
            mSpread == aOther.mSpread &&
            mInset == aOther.mInset &&
            (!mHasColor || mColor == aOther.mColor));
  }
  bool operator!=(const nsCSSShadowItem& aOther) const {
    return !(*this == aOther);
  }
};

class nsCSSShadowArray final
{
public:
  void* operator new(size_t aBaseSize, uint32_t aArrayLen) {





    return ::operator new(aBaseSize +
                          (aArrayLen - 1) * sizeof(nsCSSShadowItem));
  }

  explicit nsCSSShadowArray(uint32_t aArrayLen) :
    mLength(aArrayLen)
  {
    for (uint32_t i = 1; i < mLength; ++i) {


      new (&mArray[i]) nsCSSShadowItem();
    }
  }

private:

  ~nsCSSShadowArray() {
    for (uint32_t i = 1; i < mLength; ++i) {
      mArray[i].~nsCSSShadowItem();
    }
  }

public:
  uint32_t Length() const { return mLength; }
  nsCSSShadowItem* ShadowAt(uint32_t i) {
    do { } while (0);
    return &mArray[i];
  }
  const nsCSSShadowItem* ShadowAt(uint32_t i) const {
    do { } while (0);
    return &mArray[i];
  }

  bool HasShadowWithInset(bool aInset) {
    for (uint32_t i = 0; i < mLength; ++i) {
      if (mArray[i].mInset == aInset) {
        return true;
      }
    }
    return false;
  }

  bool operator==(const nsCSSShadowArray& aOther) const {
    if (mLength != aOther.Length()) {
      return false;
    }

    for (uint32_t i = 0; i < mLength; ++i) {
      if (ShadowAt(i) != aOther.ShadowAt(i)) {
        return false;
      }
    }

    return true;
  }

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsCSSShadowArray>::value, "Reference-counted class " "nsCSSShadowArray" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); nsrefcnt count = ++mRefCnt; ; return (nsrefcnt) count; } MozExternalRefCountType Release(void) { do { } while (0); nsrefcnt count = --mRefCnt; ; if (count == 0) { delete (this); return 0; } return count; } typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:

private:
  uint32_t mLength;
  nsCSSShadowItem mArray[1];
};
static bool IsVisibleBorderStyle(uint8_t aStyle)
{
  return (aStyle != 0 &&
          aStyle != 9);
}

struct nsStyleBorder
{
  explicit nsStyleBorder(const nsPresContext* aContext);
  nsStyleBorder(const nsStyleBorder& aBorder);
  ~nsStyleBorder();




  void FinishStyle(nsPresContext* aPresContext);

  void* operator new(size_t sz, nsStyleBorder* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleBorder, sz);
  }
  void Destroy(nsPresContext* aContext);

  nsChangeHint CalcDifference(const nsStyleBorder& aNewData) const;

  void EnsureBorderColors() {
    if (!mBorderColors) {
      mBorderColors = new nsBorderColors*[4];
      if (mBorderColors) {
        for (int32_t i = 0; i < 4; i++) {
          mBorderColors[i] = nullptr;
        }
      }
    }
  }

  void ClearBorderColors(mozilla::Side aSide) {
    if (mBorderColors && mBorderColors[aSide]) {
      delete mBorderColors[aSide];
      mBorderColors[aSide] = nullptr;
    }
  }






  bool HasVisibleStyle(mozilla::Side aSide) const
  {
    return IsVisibleBorderStyle(mBorderStyle[aSide]);
  }


  void SetBorderWidth(mozilla::Side aSide, nscoord aBorderWidth)
  {
    nscoord roundedWidth =
      ((aBorderWidth) == 0) ? 0 : std::max((mTwipsPerPixel), (aBorderWidth) / (mTwipsPerPixel) * (mTwipsPerPixel));
    mBorder.Side(aSide) = roundedWidth;
    if (HasVisibleStyle(aSide)) {
      mComputedBorder.Side(aSide) = roundedWidth;
    }
  }




  const nsMargin& GetComputedBorder() const
  {
    return mComputedBorder;
  }

  bool HasBorder() const
  {
    return mComputedBorder != nsMargin(0,0,0,0) || !mBorderImageSource.IsEmpty();
  }





  nscoord GetComputedBorderWidth(mozilla::Side aSide) const
  {
    return GetComputedBorder().Side(aSide);
  }

  uint8_t GetBorderStyle(mozilla::Side aSide) const
  {
    do { } while(0);
    return mBorderStyle[aSide];
  }

  void SetBorderStyle(mozilla::Side aSide, uint8_t aStyle)
  {
    do { } while(0);
    mBorderStyle[aSide] = aStyle;
    mComputedBorder.Side(aSide) =
      (HasVisibleStyle(aSide) ? mBorder.Side(aSide) : 0);
  }

  inline bool IsBorderImageLoaded() const
  {
    return mBorderImageSource.IsLoaded();
  }

  void ResolveImage(nsPresContext* aContext)
  {
    if (mBorderImageSource.GetType() == eStyleImageType_Image) {
      mBorderImageSource.ResolveImage(aContext);
    }
  }

  nsMargin GetImageOutset() const;

  void GetCompositeColors(int32_t aIndex, nsBorderColors** aColors) const
  {
    if (!mBorderColors) {
      *aColors = nullptr;
    } else {
      *aColors = mBorderColors[aIndex];
    }
  }

  void AppendBorderColor(int32_t aIndex, nscolor aColor)
  {
    do { } while(0);
    nsBorderColors* colorEntry = new nsBorderColors(aColor);
    if (!mBorderColors[aIndex]) {
      mBorderColors[aIndex] = colorEntry;
    } else {
      nsBorderColors* last = mBorderColors[aIndex];
      while (last->mNext) {
        last = last->mNext;
      }
      last->mNext = colorEntry;
    }
  }

  imgIRequest* GetBorderImageRequest() const
  {
    if (mBorderImageSource.GetType() == eStyleImageType_Image) {
      return mBorderImageSource.GetImageData();
    }
    return nullptr;
  }

public:
  nsBorderColors** mBorderColors;
  nsStyleCorners mBorderRadius;
  nsStyleImage mBorderImageSource;
  nsStyleSides mBorderImageSlice;
  nsStyleSides mBorderImageWidth;
  nsStyleSides mBorderImageOutset;

  uint8_t mBorderImageFill;
  uint8_t mBorderImageRepeatH;
  uint8_t mBorderImageRepeatV;
  mozilla::StyleFloatEdge mFloatEdge;
  mozilla::StyleBoxDecorationBreak mBoxDecorationBreak;

protected:
  uint8_t mBorderStyle[4];

public:


  union {
    struct {
      mozilla::StyleComplexColor mBorderTopColor;
      mozilla::StyleComplexColor mBorderRightColor;
      mozilla::StyleComplexColor mBorderBottomColor;
      mozilla::StyleComplexColor mBorderLeftColor;
    };
    mozilla::StyleComplexColor mBorderColor[4];
  };

  static mozilla::StyleComplexColor nsStyleBorder::*
  BorderColorFieldFor(mozilla::Side aSide) {
    switch (aSide) {
      case mozilla::eSideTop:
        return &nsStyleBorder::mBorderTopColor;
      case mozilla::eSideRight:
        return &nsStyleBorder::mBorderRightColor;
      case mozilla::eSideBottom:
        return &nsStyleBorder::mBorderBottomColor;
      case mozilla::eSideLeft:
        return &nsStyleBorder::mBorderLeftColor;
    }
    do { } while (0);
    return nullptr;
  }

protected:






  nsMargin mComputedBorder;
  nsMargin mBorder;

private:
  nscoord mTwipsPerPixel;

  nsStyleBorder& operator=(const nsStyleBorder& aOther) = delete;
};
static_assert(__builtin_offsetof(nsStyleBorder, mBorderTopColor) == __builtin_offsetof(nsStyleBorder, mBorderColor) + size_t(mozilla::eSideTop) * sizeof(mozilla::StyleComplexColor), "mBorder" "Top" "Color must be at same offset " "as mBorderColor[mozilla::eSide" "Top" "]");
static_assert(__builtin_offsetof(nsStyleBorder, mBorderRightColor) == __builtin_offsetof(nsStyleBorder, mBorderColor) + size_t(mozilla::eSideRight) * sizeof(mozilla::StyleComplexColor), "mBorder" "Right" "Color must be at same offset " "as mBorderColor[mozilla::eSide" "Right" "]");
static_assert(__builtin_offsetof(nsStyleBorder, mBorderBottomColor) == __builtin_offsetof(nsStyleBorder, mBorderColor) + size_t(mozilla::eSideBottom) * sizeof(mozilla::StyleComplexColor), "mBorder" "Bottom" "Color must be at same offset " "as mBorderColor[mozilla::eSide" "Bottom" "]");
static_assert(__builtin_offsetof(nsStyleBorder, mBorderLeftColor) == __builtin_offsetof(nsStyleBorder, mBorderColor) + size_t(mozilla::eSideLeft) * sizeof(mozilla::StyleComplexColor), "mBorder" "Left" "Color must be at same offset " "as mBorderColor[mozilla::eSide" "Left" "]");



struct nsStyleOutline
{
  explicit nsStyleOutline(const nsPresContext* aContext);
  nsStyleOutline(const nsStyleOutline& aOutline);
  ~nsStyleOutline() {
                                  ;
  }
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStyleOutline* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleOutline, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleOutline();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleOutline, this);
  }

  void RecalcData();
  nsChangeHint CalcDifference(const nsStyleOutline& aNewData) const;

  nsStyleCorners mOutlineRadius;






  nscoord mOutlineWidth;
  nscoord mOutlineOffset;
  mozilla::StyleComplexColor mOutlineColor;
  uint8_t mOutlineStyle;

  nscoord GetOutlineWidth() const
  {
    return mActualOutlineWidth;
  }

  bool ShouldPaintOutline() const
  {
    return mOutlineStyle == 10 ||
           (GetOutlineWidth() > 0 &&
            mOutlineStyle != 0);
  }

protected:



  nscoord mActualOutlineWidth;
  nscoord mTwipsPerPixel;
};







class nsStyleQuoteValues
{
public:
  typedef nsTArray<std::pair<nsString, nsString>> QuotePairArray;
  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<nsStyleQuoteValues>::value, "Reference-counted class " "nsStyleQuoteValues" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); nsrefcnt count = ++mRefCnt; ; return (nsrefcnt) count; } MozExternalRefCountType Release(void) { do { } while (0); nsrefcnt count = --mRefCnt; ; if (count == 0) { delete (this); return 0; } return count; } typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:;
  QuotePairArray mQuotePairs;

private:
  ~nsStyleQuoteValues() {}
};

struct nsStyleList
{
  explicit nsStyleList(const nsPresContext* aContext);
  nsStyleList(const nsStyleList& aStyleList);
  ~nsStyleList();

  void FinishStyle(nsPresContext* aPresContext);

  void* operator new(size_t sz, nsStyleList* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleList, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleList();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleList, this);
  }

  nsChangeHint CalcDifference(const nsStyleList& aNewData) const;

  static void Shutdown() {
    sInitialQuotes = nullptr;
    sNoneQuotes = nullptr;
  }

  imgRequestProxy* GetListStyleImage() const
  {
    return mListStyleImage ? mListStyleImage->get() : nullptr;
  }

  already_AddRefed<nsIURI> GetListStyleImageURI() const;

  void GetListStyleType(nsSubstring& aType) const { mCounterStyle->GetStyleName(aType); }
  mozilla::CounterStyle* GetCounterStyle() const
  {
    return mCounterStyle.get();
  }
  void SetCounterStyle(mozilla::CounterStyle* aStyle)
  {


    do { } while (0);
    mCounterStyle = aStyle;
  }
  void SetListStyleType(const nsSubstring& aType,
                        nsPresContext* aPresContext)
  {
    SetCounterStyle(aPresContext->CounterStyleManager()->BuildCounterStyle(aType));
  }

  const nsStyleQuoteValues::QuotePairArray& GetQuotePairs() const;

  void SetQuotesInherit(const nsStyleList* aOther);
  void SetQuotesInitial();
  void SetQuotesNone();
  void SetQuotes(nsStyleQuoteValues::QuotePairArray&& aValues);

  uint8_t mListStylePosition;
  RefPtr<nsStyleImageRequest> mListStyleImage;
private:
  RefPtr<mozilla::CounterStyle> mCounterStyle;
  RefPtr<nsStyleQuoteValues> mQuotes;
  nsStyleList& operator=(const nsStyleList& aOther) = delete;
public:
  nsRect mImageRegion;

private:

  static mozilla::StaticRefPtr<nsStyleQuoteValues> sInitialQuotes;
  static mozilla::StaticRefPtr<nsStyleQuoteValues> sNoneQuotes;
};

struct nsStyleGridLine
{


  bool mHasSpan;
  int32_t mInteger;
  nsString mLineName;




  static const int32_t kMinLine = -10000;
  static const int32_t kMaxLine = 10000;

  nsStyleGridLine()
    : mHasSpan(false)
    , mInteger(0)

  {
  }

  nsStyleGridLine(const nsStyleGridLine& aOther)
  {
    (*this) = aOther;
  }

  void operator=(const nsStyleGridLine& aOther)
  {
    mHasSpan = aOther.mHasSpan;
    mInteger = aOther.mInteger;
    mLineName = aOther.mLineName;
  }

  bool operator!=(const nsStyleGridLine& aOther) const
  {
    return mHasSpan != aOther.mHasSpan ||
           mInteger != aOther.mInteger ||
           mLineName != aOther.mLineName;
  }

  void SetToInteger(uint32_t value)
  {
    mHasSpan = false;
    mInteger = value;
    mLineName.Truncate();
  }

  void SetAuto()
  {
    mHasSpan = false;
    mInteger = 0;
    mLineName.Truncate();
  }

  bool IsAuto() const
  {
    bool haveInitialValues = mInteger == 0 && mLineName.IsEmpty();
    do { } while (0);


    return haveInitialValues;
  }
};
struct nsStyleGridTemplate
{
  nsTArray<nsTArray<nsString>> mLineNameLists;
  nsTArray<nsStyleCoord> mMinTrackSizingFunctions;
  nsTArray<nsStyleCoord> mMaxTrackSizingFunctions;
  nsTArray<nsString> mRepeatAutoLineNameListBefore;
  nsTArray<nsString> mRepeatAutoLineNameListAfter;
  int16_t mRepeatAutoIndex;
  bool mIsAutoFill : 1;
  bool mIsSubgrid : 1;

  nsStyleGridTemplate()
    : mRepeatAutoIndex(-1)
    , mIsAutoFill(false)
    , mIsSubgrid(false)
  {
  }

  inline bool operator!=(const nsStyleGridTemplate& aOther) const {
    return
      mIsSubgrid != aOther.mIsSubgrid ||
      mLineNameLists != aOther.mLineNameLists ||
      mMinTrackSizingFunctions != aOther.mMinTrackSizingFunctions ||
      mMaxTrackSizingFunctions != aOther.mMaxTrackSizingFunctions ||
      mIsAutoFill != aOther.mIsAutoFill ||
      mRepeatAutoIndex != aOther.mRepeatAutoIndex ||
      mRepeatAutoLineNameListBefore != aOther.mRepeatAutoLineNameListBefore ||
      mRepeatAutoLineNameListAfter != aOther.mRepeatAutoLineNameListAfter;
  }

  bool HasRepeatAuto() const {
    return mRepeatAutoIndex != -1;
  }

  bool IsRepeatAutoIndex(uint32_t aIndex) const {
    do { } while (0);
    return int32_t(aIndex) == mRepeatAutoIndex;
  }
};

struct nsStylePosition
{
  explicit nsStylePosition(const nsPresContext* aContext);
  nsStylePosition(const nsStylePosition& aOther);
  ~nsStylePosition();
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStylePosition* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStylePosition, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStylePosition();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStylePosition, this);
  }

  nsChangeHint CalcDifference(const nsStylePosition& aNewData,
                              const nsStyleVisibility* aOldStyleVisibility) const;





  uint8_t UsedAlignSelf(nsStyleContext* aParent) const;





  uint8_t ComputedJustifyItems(nsStyleContext* aParent) const;





  uint8_t UsedJustifySelf(nsStyleContext* aParent) const;

  mozilla::Position mObjectPosition;
  nsStyleSides mOffset;
  nsStyleCoord mWidth;
  nsStyleCoord mMinWidth;
  nsStyleCoord mMaxWidth;
  nsStyleCoord mHeight;
  nsStyleCoord mMinHeight;
  nsStyleCoord mMaxHeight;
  nsStyleCoord mFlexBasis;
  nsStyleCoord mGridAutoColumnsMin;
  nsStyleCoord mGridAutoColumnsMax;
  nsStyleCoord mGridAutoRowsMin;
  nsStyleCoord mGridAutoRowsMax;
  uint8_t mGridAutoFlow;
  mozilla::StyleBoxSizing mBoxSizing;

  uint16_t mAlignContent;
  uint8_t mAlignItems;
  uint8_t mAlignSelf;
  uint16_t mJustifyContent;
private:
  friend class nsRuleNode;




  uint8_t mJustifyItems;
public:
  uint8_t mJustifySelf;
  uint8_t mFlexDirection;
  uint8_t mFlexWrap;
  uint8_t mObjectFit;
  int32_t mOrder;
  float mFlexGrow;
  float mFlexShrink;
  nsStyleCoord mZIndex;
  nsStyleGridTemplate mGridTemplateColumns;
  nsStyleGridTemplate mGridTemplateRows;


  RefPtr<mozilla::css::GridTemplateAreasValue> mGridTemplateAreas;

  nsStyleGridLine mGridColumnStart;
  nsStyleGridLine mGridColumnEnd;
  nsStyleGridLine mGridRowStart;
  nsStyleGridLine mGridRowEnd;
  nsStyleCoord mGridColumnGap;
  nsStyleCoord mGridRowGap;






  bool WidthDependsOnContainer() const
    {
      return mWidth.GetUnit() == eStyleUnit_Auto ||
        WidthCoordDependsOnContainer(mWidth);
    }
  bool MinWidthDependsOnContainer() const
    { return WidthCoordDependsOnContainer(mMinWidth); }
  bool MaxWidthDependsOnContainer() const
    { return WidthCoordDependsOnContainer(mMaxWidth); }
  bool HeightDependsOnContainer() const
    {
      return mHeight.GetUnit() == eStyleUnit_Auto ||
        HeightCoordDependsOnContainer(mHeight);
    }



  bool MinHeightDependsOnContainer() const
    { return HeightCoordDependsOnContainer(mMinHeight); }
  bool MaxHeightDependsOnContainer() const
    { return HeightCoordDependsOnContainer(mMaxHeight); }

  bool OffsetHasPercent(mozilla::Side aSide) const
  {
    return mOffset.Get(aSide).HasPercent();
  }





  inline nsStyleCoord& ISize(mozilla::WritingMode aWM);
  inline nsStyleCoord& MinISize(mozilla::WritingMode aWM);
  inline nsStyleCoord& MaxISize(mozilla::WritingMode aWM);
  inline nsStyleCoord& BSize(mozilla::WritingMode aWM);
  inline nsStyleCoord& MinBSize(mozilla::WritingMode aWM);
  inline nsStyleCoord& MaxBSize(mozilla::WritingMode aWM);
  inline const nsStyleCoord& ISize(mozilla::WritingMode aWM) const;
  inline const nsStyleCoord& MinISize(mozilla::WritingMode aWM) const;
  inline const nsStyleCoord& MaxISize(mozilla::WritingMode aWM) const;
  inline const nsStyleCoord& BSize(mozilla::WritingMode aWM) const;
  inline const nsStyleCoord& MinBSize(mozilla::WritingMode aWM) const;
  inline const nsStyleCoord& MaxBSize(mozilla::WritingMode aWM) const;
  inline bool ISizeDependsOnContainer(mozilla::WritingMode aWM) const;
  inline bool MinISizeDependsOnContainer(mozilla::WritingMode aWM) const;
  inline bool MaxISizeDependsOnContainer(mozilla::WritingMode aWM) const;
  inline bool BSizeDependsOnContainer(mozilla::WritingMode aWM) const;
  inline bool MinBSizeDependsOnContainer(mozilla::WritingMode aWM) const;
  inline bool MaxBSizeDependsOnContainer(mozilla::WritingMode aWM) const;

private:
  static bool WidthCoordDependsOnContainer(const nsStyleCoord &aCoord);
  static bool HeightCoordDependsOnContainer(const nsStyleCoord &aCoord)
    { return aCoord.HasPercent(); }
};

struct nsStyleTextOverflowSide
{
  nsStyleTextOverflowSide() : mType(0) {}

  bool operator==(const nsStyleTextOverflowSide& aOther) const {
    return mType == aOther.mType &&
           (mType != 2 ||
            mString == aOther.mString);
  }
  bool operator!=(const nsStyleTextOverflowSide& aOther) const {
    return !(*this == aOther);
  }

  nsString mString;
  uint8_t mType;
};

struct nsStyleTextOverflow
{
  nsStyleTextOverflow() : mLogicalDirections(true) {}
  bool operator==(const nsStyleTextOverflow& aOther) const {
    return mLeft == aOther.mLeft && mRight == aOther.mRight;
  }
  bool operator!=(const nsStyleTextOverflow& aOther) const {
    return !(*this == aOther);
  }


  const nsStyleTextOverflowSide& GetLeft(uint8_t aDirection) const {
    do { } while(0);

    return !mLogicalDirections || aDirection == 0 ?
             mLeft : mRight;
  }


  const nsStyleTextOverflowSide& GetRight(uint8_t aDirection) const {
    do { } while(0);

    return !mLogicalDirections || aDirection == 0 ?
             mRight : mLeft;
  }


  const nsStyleTextOverflowSide* GetFirstValue() const {
    return mLogicalDirections ? &mRight : &mLeft;
  }


  const nsStyleTextOverflowSide* GetSecondValue() const {
    return mLogicalDirections ? nullptr : &mRight;
  }

  nsStyleTextOverflowSide mLeft;
  nsStyleTextOverflowSide mRight;
  bool mLogicalDirections;
};

struct nsStyleTextReset
{
  explicit nsStyleTextReset(const nsPresContext* aContext);
  nsStyleTextReset(const nsStyleTextReset& aOther);
  ~nsStyleTextReset();
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStyleTextReset* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleTextReset, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleTextReset();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleTextReset, this);
  }



  bool HasTextDecorationLines() const {
    return mTextDecorationLine != 0 &&
           mTextDecorationLine != 0x20;
  }

  nsChangeHint CalcDifference(const nsStyleTextReset& aNewData) const;

  nsStyleTextOverflow mTextOverflow;

  uint8_t mTextDecorationLine;
  uint8_t mTextDecorationStyle;
  uint8_t mUnicodeBidi;
  nscoord mInitialLetterSink;
  float mInitialLetterSize;
  mozilla::StyleComplexColor mTextDecorationColor;
};

struct nsStyleText
{
  explicit nsStyleText(const nsPresContext* aContext);
  nsStyleText(const nsStyleText& aOther);
  ~nsStyleText();
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStyleText* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleText, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleText();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleText, this);
  }

  nsChangeHint CalcDifference(const nsStyleText& aNewData) const;

  uint8_t mTextAlign;
  uint8_t mTextAlignLast;
  bool mTextAlignTrue : 1;
  bool mTextAlignLastTrue : 1;
  mozilla::StyleTextJustify mTextJustify;
  uint8_t mTextTransform;
  uint8_t mWhiteSpace;
  uint8_t mWordBreak;
  uint8_t mOverflowWrap;
  mozilla::StyleHyphens mHyphens;
  uint8_t mRubyAlign;
  uint8_t mRubyPosition;
  uint8_t mTextSizeAdjust;
  uint8_t mTextCombineUpright;
  uint8_t mControlCharacterVisibility;
  uint8_t mTextEmphasisPosition;
  uint8_t mTextEmphasisStyle;
  uint8_t mTextRendering;
  mozilla::StyleComplexColor mTextEmphasisColor;
  mozilla::StyleComplexColor mWebkitTextFillColor;
  mozilla::StyleComplexColor mWebkitTextStrokeColor;

  nsStyleCoord mTabSize;
  nsStyleCoord mWordSpacing;
  nsStyleCoord mLetterSpacing;
  nsStyleCoord mLineHeight;
  nsStyleCoord mTextIndent;
  nscoord mWebkitTextStrokeWidth;

  RefPtr<nsCSSShadowArray> mTextShadow;

  nsString mTextEmphasisStyleString;

  bool WhiteSpaceIsSignificant() const {
    return mWhiteSpace == 1 ||
           mWhiteSpace == 3 ||
           mWhiteSpace == 5;
  }

  bool NewlineIsSignificantStyle() const {
    return mWhiteSpace == 1 ||
           mWhiteSpace == 3 ||
           mWhiteSpace == 4;
  }

  bool WhiteSpaceOrNewlineIsSignificant() const {
    return mWhiteSpace == 1 ||
           mWhiteSpace == 3 ||
           mWhiteSpace == 4 ||
           mWhiteSpace == 5;
  }

  bool TabIsSignificant() const {
    return mWhiteSpace == 1 ||
           mWhiteSpace == 3;
  }

  bool WhiteSpaceCanWrapStyle() const {
    return mWhiteSpace == 0 ||
           mWhiteSpace == 3 ||
           mWhiteSpace == 4;
  }

  bool WordCanWrapStyle() const {
    return WhiteSpaceCanWrapStyle() &&
           mOverflowWrap == 1;
  }

  bool HasTextEmphasis() const {
    return !mTextEmphasisStyleString.IsEmpty();
  }

  bool HasWebkitTextStroke() const {
    return mWebkitTextStrokeWidth > 0;
  }


  inline bool HasTextShadow() const;
  inline nsCSSShadowArray* GetTextShadow() const;





  inline bool NewlineIsSignificant(const nsTextFrame* aContextFrame) const;
  inline bool WhiteSpaceCanWrap(const nsIFrame* aContextFrame) const;
  inline bool WordCanWrap(const nsIFrame* aContextFrame) const;

  mozilla::LogicalSide TextEmphasisSide(mozilla::WritingMode aWM) const;
};

struct nsStyleImageOrientation
{
  static nsStyleImageOrientation CreateAsAngleAndFlip(double aRadians,
                                                      bool aFlip) {
    uint8_t orientation(0);


    double roundedAngle = fmod(aRadians, 2 * 3.14159265358979323846);
    if (roundedAngle < 0.25 * 3.14159265358979323846) { orientation = ANGLE_0; }
    else if (roundedAngle < 0.75 * 3.14159265358979323846) { orientation = ANGLE_90; }
    else if (roundedAngle < 1.25 * 3.14159265358979323846) { orientation = ANGLE_180;}
    else if (roundedAngle < 1.75 * 3.14159265358979323846) { orientation = ANGLE_270;}
    else { orientation = ANGLE_0; }


    if (aFlip) {
      orientation |= FLIP_MASK;
    }

    return nsStyleImageOrientation(orientation);
  }

  static nsStyleImageOrientation CreateAsFlip() {
    return nsStyleImageOrientation(FLIP_MASK);
  }

  static nsStyleImageOrientation CreateAsFromImage() {
    return nsStyleImageOrientation(FROM_IMAGE_MASK);
  }


  nsStyleImageOrientation() : mOrientation(0) { }

  bool IsDefault() const { return mOrientation == 0; }
  bool IsFlipped() const { return mOrientation & FLIP_MASK; }
  bool IsFromImage() const { return mOrientation & FROM_IMAGE_MASK; }
  bool SwapsWidthAndHeight() const {
    uint8_t angle = mOrientation & ORIENTATION_MASK;
    return (angle == ANGLE_90) || (angle == ANGLE_270);
  }

  mozilla::image::Angle Angle() const {
    switch (mOrientation & ORIENTATION_MASK) {
      case ANGLE_0: return mozilla::image::Angle::D0;
      case ANGLE_90: return mozilla::image::Angle::D90;
      case ANGLE_180: return mozilla::image::Angle::D180;
      case ANGLE_270: return mozilla::image::Angle::D270;
      default:
        do { } while(0);
        return mozilla::image::Angle::D0;
    }
  }

  nsStyleCoord AngleAsCoord() const {
    switch (mOrientation & ORIENTATION_MASK) {
      case ANGLE_0: return nsStyleCoord(0.0f, eStyleUnit_Degree);
      case ANGLE_90: return nsStyleCoord(90.0f, eStyleUnit_Degree);
      case ANGLE_180: return nsStyleCoord(180.0f, eStyleUnit_Degree);
      case ANGLE_270: return nsStyleCoord(270.0f, eStyleUnit_Degree);
      default:
        do { } while(0);
        return nsStyleCoord();
    }
  }

  bool operator==(const nsStyleImageOrientation& aOther) const {
    return aOther.mOrientation == mOrientation;
  }

  bool operator!=(const nsStyleImageOrientation& aOther) const {
    return !(*this == aOther);
  }

protected:
  enum Bits {
    ORIENTATION_MASK = 0x1 | 0x2,
    FLIP_MASK = 0x4,
    FROM_IMAGE_MASK = 0x8,
  };

  enum Angles {
    ANGLE_0 = 0,
    ANGLE_90 = 1,
    ANGLE_180 = 2,
    ANGLE_270 = 3,
  };

  explicit nsStyleImageOrientation(uint8_t aOrientation)
    : mOrientation(aOrientation)
  { }

  uint8_t mOrientation;
};

struct nsStyleVisibility
{
  explicit nsStyleVisibility(const nsPresContext* aContext);
  nsStyleVisibility(const nsStyleVisibility& aVisibility);
  ~nsStyleVisibility() {
                                     ;
  }
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStyleVisibility* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleVisibility, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleVisibility();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleVisibility, this);
  }

  nsChangeHint CalcDifference(const nsStyleVisibility& aNewData) const;

  nsStyleImageOrientation mImageOrientation;
  uint8_t mDirection;
  uint8_t mVisible;
  uint8_t mImageRendering;
  uint8_t mWritingMode;
  uint8_t mTextOrientation;
  uint8_t mColorAdjust;

  bool IsVisible() const {
    return (mVisible == 1);
  }

  bool IsVisibleOrCollapsed() const {
    return ((mVisible == 1) ||
            (mVisible == 2));
  }
};

struct nsTimingFunction
{

  enum class Type {
    Ease,
    Linear,
    EaseIn,
    EaseOut,
    EaseInOut,
    StepStart,
    StepEnd,
    CubicBezier,
    Frames,
  };



  static bool IsSplineType(Type aType)
  {
    return aType != Type::StepStart &&
           aType != Type::StepEnd &&
           aType != Type::Frames;
  }

  explicit nsTimingFunction(int32_t aTimingFunctionType
                              = 0)
  {
    AssignFromKeyword(aTimingFunctionType);
  }

  nsTimingFunction(float x1, float y1, float x2, float y2)
    : mType(Type::CubicBezier)
  {
    mFunc.mX1 = x1;
    mFunc.mY1 = y1;
    mFunc.mX2 = x2;
    mFunc.mY2 = y2;
  }

  enum class Keyword { Implicit, Explicit };

  nsTimingFunction(Type aType, uint32_t aStepsOrFrames)
    : mType(aType)
  {
    do { } while (0);



    mStepsOrFrames = aStepsOrFrames;
  }

  nsTimingFunction(const nsTimingFunction& aOther)
  {
    *this = aOther;
  }

  Type mType;
  union {
    struct {
      float mX1;
      float mY1;
      float mX2;
      float mY2;
    } mFunc;
    struct {
      uint32_t mStepsOrFrames;
    };
  };

  nsTimingFunction&
  operator=(const nsTimingFunction& aOther)
  {
    if (&aOther == this) {
      return *this;
    }

    mType = aOther.mType;

    if (HasSpline()) {
      mFunc.mX1 = aOther.mFunc.mX1;
      mFunc.mY1 = aOther.mFunc.mY1;
      mFunc.mX2 = aOther.mFunc.mX2;
      mFunc.mY2 = aOther.mFunc.mY2;
    } else {
      mStepsOrFrames = aOther.mStepsOrFrames;
    }

    return *this;
  }

  bool operator==(const nsTimingFunction& aOther) const
  {
    if (mType != aOther.mType) {
      return false;
    }
    if (HasSpline()) {
      return mFunc.mX1 == aOther.mFunc.mX1 && mFunc.mY1 == aOther.mFunc.mY1 &&
             mFunc.mX2 == aOther.mFunc.mX2 && mFunc.mY2 == aOther.mFunc.mY2;
    }
    return mStepsOrFrames == aOther.mStepsOrFrames;
  }

  bool operator!=(const nsTimingFunction& aOther) const
  {
    return !(*this == aOther);
  }

  bool HasSpline() const { return IsSplineType(mType); }

private:
  void AssignFromKeyword(int32_t aTimingFunctionType);
};

namespace mozilla {

struct StyleTransition
{
  StyleTransition() { }
  explicit StyleTransition(const StyleTransition& aCopy);

  void SetInitialValues();



  const nsTimingFunction& GetTimingFunction() const { return mTimingFunction; }
  float GetDelay() const { return mDelay; }
  float GetDuration() const { return mDuration; }
  nsCSSPropertyID GetProperty() const { return mProperty; }
  nsIAtom* GetUnknownProperty() const { return mUnknownProperty; }

  float GetCombinedDuration() const {

    return std::max(mDuration, 0.0f) + mDelay;
  }

  void SetTimingFunction(const nsTimingFunction& aTimingFunction)
    { mTimingFunction = aTimingFunction; }
  void SetDelay(float aDelay) { mDelay = aDelay; }
  void SetDuration(float aDuration) { mDuration = aDuration; }
  void SetProperty(nsCSSPropertyID aProperty)
    {
      do { } while(0);


      mProperty = aProperty;
    }
  void SetUnknownProperty(nsCSSPropertyID aProperty,
                          const nsAString& aPropertyString);
  void CopyPropertyFrom(const StyleTransition& aOther)
    {
      mProperty = aOther.mProperty;
      mUnknownProperty = aOther.mUnknownProperty;
    }

  nsTimingFunction& TimingFunctionSlot() { return mTimingFunction; }

  bool operator==(const StyleTransition& aOther) const;
  bool operator!=(const StyleTransition& aOther) const
    { return !(*this == aOther); }

private:
  nsTimingFunction mTimingFunction;
  float mDuration;
  float mDelay;
  nsCSSPropertyID mProperty;
  nsCOMPtr<nsIAtom> mUnknownProperty;


};

struct StyleAnimation
{
  StyleAnimation() { }
  explicit StyleAnimation(const StyleAnimation& aCopy);

  void SetInitialValues();



  const nsTimingFunction& GetTimingFunction() const { return mTimingFunction; }
  float GetDelay() const { return mDelay; }
  float GetDuration() const { return mDuration; }
  const nsString& GetName() const { return mName; }
  dom::PlaybackDirection GetDirection() const { return mDirection; }
  dom::FillMode GetFillMode() const { return mFillMode; }
  uint8_t GetPlayState() const { return mPlayState; }
  float GetIterationCount() const { return mIterationCount; }

  void SetTimingFunction(const nsTimingFunction& aTimingFunction)
    { mTimingFunction = aTimingFunction; }
  void SetDelay(float aDelay) { mDelay = aDelay; }
  void SetDuration(float aDuration) { mDuration = aDuration; }
  void SetName(const nsSubstring& aName) { mName = aName; }
  void SetDirection(dom::PlaybackDirection aDirection) { mDirection = aDirection; }
  void SetFillMode(dom::FillMode aFillMode) { mFillMode = aFillMode; }
  void SetPlayState(uint8_t aPlayState) { mPlayState = aPlayState; }
  void SetIterationCount(float aIterationCount)
    { mIterationCount = aIterationCount; }

  nsTimingFunction& TimingFunctionSlot() { return mTimingFunction; }

  bool operator==(const StyleAnimation& aOther) const;
  bool operator!=(const StyleAnimation& aOther) const
    { return !(*this == aOther); }

private:
  nsTimingFunction mTimingFunction;
  float mDuration;
  float mDelay;
  nsString mName;
  dom::PlaybackDirection mDirection;
  dom::FillMode mFillMode;
  uint8_t mPlayState;
  float mIterationCount;
};

class StyleBasicShape final
{
public:
  explicit StyleBasicShape(StyleBasicShapeType type)
    : mType(type),
      mFillRule(StyleFillRule::Nonzero)
  {
    mPosition.SetInitialPercentValues(0.5f);
  }

  StyleBasicShapeType GetShapeType() const { return mType; }
  nsCSSKeyword GetShapeTypeName() const;

  StyleFillRule GetFillRule() const { return mFillRule; }
  void SetFillRule(StyleFillRule aFillRule)
  {
    do { } while (0);
    mFillRule = aFillRule;
  }

  Position& GetPosition() {
    do { } while (0);


    return mPosition;
  }
  const Position& GetPosition() const {
    do { } while (0);


    return mPosition;
  }

  bool HasRadius() const {
    do { } while (0);
    nsStyleCoord zero;
    zero.SetCoordValue(0);
    int32_t corner2401 = mozilla::eCornerTopLeftX; for (mozilla::HalfCorner corner; corner2401 <= mozilla::eCornerBottomLeftY && (corner = mozilla::HalfCorner(corner2401), true); ++corner2401) {
      if (mRadius.Get(corner) != zero) {
        return true;
      }
    }
    return false;
  }
  nsStyleCorners& GetRadius() {
    do { } while (0);
    return mRadius;
  }
  const nsStyleCorners& GetRadius() const {
    do { } while (0);
    return mRadius;
  }



  nsTArray<nsStyleCoord>& Coordinates()
  {
    return mCoordinates;
  }

  const nsTArray<nsStyleCoord>& Coordinates() const
  {
    return mCoordinates;
  }

  bool operator==(const StyleBasicShape& aOther) const
  {
    return mType == aOther.mType &&
           mFillRule == aOther.mFillRule &&
           mCoordinates == aOther.mCoordinates &&
           mPosition == aOther.mPosition &&
           mRadius == aOther.mRadius;
  }
  bool operator!=(const StyleBasicShape& aOther) const {
    return !(*this == aOther);
  }

  public: MozExternalRefCountType AddRef(void) { static_assert(!mozilla::IsDestructible<StyleBasicShape>::value, "Reference-counted class " "StyleBasicShape" " should not have a public destructor. " "Make this class's destructor non-public"); do { } while (0); nsrefcnt count = ++mRefCnt; ; return (nsrefcnt) count; } MozExternalRefCountType Release(void) { do { } while (0); nsrefcnt count = --mRefCnt; ; if (count == 0) { delete (this); return 0; } return count; } typedef mozilla::TrueType HasThreadSafeRefCnt; protected: ::mozilla::ThreadSafeAutoRefCnt mRefCnt; public:;

private:
  ~StyleBasicShape() {}

  StyleBasicShapeType mType;
  StyleFillRule mFillRule;




  nsTArray<nsStyleCoord> mCoordinates;

  Position mPosition;

  nsStyleCorners mRadius;
};

struct StyleShapeSource
{
  StyleShapeSource()
    : mURL(nullptr)
  {}

  StyleShapeSource(const StyleShapeSource& aSource)
    : StyleShapeSource()
  {
    if (aSource.mType == StyleShapeSourceType::URL) {
      SetURL(aSource.mURL);
    } else if (aSource.mType == StyleShapeSourceType::Shape) {
      SetBasicShape(aSource.mBasicShape, aSource.mReferenceBox);
    } else if (aSource.mType == StyleShapeSourceType::Box) {
      SetReferenceBox(aSource.mReferenceBox);
    }
  }

  ~StyleShapeSource()
  {
    ReleaseRef();
  }

  StyleShapeSource& operator=(const StyleShapeSource& aOther)
  {
    if (this == &aOther) {
      return *this;
    }

    if (aOther.mType == StyleShapeSourceType::URL) {
      SetURL(aOther.mURL);
    } else if (aOther.mType == StyleShapeSourceType::Shape) {
      SetBasicShape(aOther.mBasicShape, aOther.mReferenceBox);
    } else if (aOther.mType == StyleShapeSourceType::Box) {
      SetReferenceBox(aOther.mReferenceBox);
    } else {
      ReleaseRef();
      mReferenceBox = StyleGeometryBox::NoBox;
      mType = StyleShapeSourceType::None;
    }
    return *this;
  }

  bool operator==(const StyleShapeSource& aOther) const
  {
    return EqualsInternal<true>(aOther);
  }

  bool DefinitelyEquals(const StyleShapeSource& aOther) const
  {
    return EqualsInternal<false>(aOther);
  }

  template<bool aPrecise>
  bool EqualsInternal(const StyleShapeSource& aOther) const
  {
    if (mType != aOther.mType) {
      return false;
    }

    if (mType == StyleShapeSourceType::URL) {
      return aPrecise ? mURL->Equals(*aOther.mURL)
                      : mURL->DefinitelyEqualURIs(*aOther.mURL);
    } else if (mType == StyleShapeSourceType::Shape) {
      return *mBasicShape == *aOther.mBasicShape &&
             mReferenceBox == aOther.mReferenceBox;
    } else if (mType == StyleShapeSourceType::Box) {
      return mReferenceBox == aOther.mReferenceBox;
    }

    return true;
  }

  bool operator!=(const StyleShapeSource& aOther) const
  {
    return !(*this == aOther);
  }

  StyleShapeSourceType GetType() const
  {
    return mType;
  }

  css::URLValue* GetURL() const
  {
    do { } while (0);
    return mURL;
  }

  bool SetURL(css::URLValue* aValue)
  {
    do { } while (0);
    ReleaseRef();
    mURL = aValue;
    mURL->AddRef();
    mType = StyleShapeSourceType::URL;
    return true;
  }

  StyleBasicShape* GetBasicShape() const
  {
    do { } while (0);
    return mBasicShape;
  }

  void SetBasicShape(StyleBasicShape* aBasicShape,
                     StyleGeometryBox aReferenceBox)
  {
    do { } while(0);
    ReleaseRef();
    mBasicShape = aBasicShape;
    mBasicShape->AddRef();
    mReferenceBox = aReferenceBox;
    mType = StyleShapeSourceType::Shape;
  }

  StyleGeometryBox GetReferenceBox() const
  {
    do { } while (0);


    return mReferenceBox;
  }

  void SetReferenceBox(StyleGeometryBox aReferenceBox)
  {
    ReleaseRef();
    mReferenceBox = aReferenceBox;
    mType = StyleShapeSourceType::Box;
  }

private:
  void ReleaseRef()
  {
    if (mType == StyleShapeSourceType::Shape) {
      do { } while(0);
      mBasicShape->Release();
    } else if (mType == StyleShapeSourceType::URL) {
      do { } while(0);
      mURL->Release();
    }


    mURL = nullptr;
  }

  void* operator new(size_t) = delete;

  union {
    StyleBasicShape* mBasicShape;
    css::URLValue* mURL;
  };
  StyleShapeSourceType mType = StyleShapeSourceType::None;
  StyleGeometryBox mReferenceBox = StyleGeometryBox::NoBox;
};

}






class BindingHolder {
public:
  BindingHolder() {}
  explicit BindingHolder(mozilla::css::URLValue* aPtr) : mPtr(aPtr) {}
  operator mozilla::css::URLValue*() const { return Get(); }
  mozilla::css::URLValue* operator->() const { return Get(); }
  mozilla::css::URLValue* Get() const { return (mPtr && mPtr->GetURI()) ? mPtr.get() : nullptr; }
  mozilla::css::URLValue* ForceGet() const { return mPtr.get(); }
  void Set(mozilla::css::URLValue* aPtr) { mPtr = aPtr; }
private:
  RefPtr<mozilla::css::URLValue> mPtr;
};

struct nsStyleDisplay
{
  typedef mozilla::StyleGeometryBox StyleGeometryBox;

  explicit nsStyleDisplay(const nsPresContext* aContext);
  nsStyleDisplay(const nsStyleDisplay& aOther);
  ~nsStyleDisplay();

  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStyleDisplay* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleDisplay, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleDisplay();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleDisplay, this);
  }

  nsChangeHint CalcDifference(const nsStyleDisplay& aNewData) const;



  BindingHolder mBinding;
  mozilla::StyleDisplay mDisplay;
  mozilla::StyleDisplay mOriginalDisplay;




  uint8_t mContain;
private:
  friend class nsComputedDOMStyle;
  friend class nsRuleNode;
  uint8_t mMozAppearance;
  uint8_t mAppearance;
public:
  __attribute__ ((warn_unused_result)) uint8_t UsedAppearance() const {
    if (mAppearance == 0) {
      return 0;
    }
    do { } while (0);
    return mMozAppearance;
  }

  uint8_t mPosition;


  mozilla::StyleFloat mFloat;

  mozilla::StyleFloat mOriginalFloat;

  mozilla::StyleClear mBreakType;
  uint8_t mBreakInside;
  bool mBreakBefore;
  bool mBreakAfter;
  uint8_t mOverflowX;
  uint8_t mOverflowY;
  uint8_t mOverflowClipBox;
  uint8_t mResize;
  mozilla::StyleOrient mOrient;
  uint8_t mIsolation;
  uint8_t mTopLayer;
  uint8_t mWillChangeBitField;





  nsCOMArray<nsIAtom> mWillChange;

  uint8_t mTouchAction;
  uint8_t mScrollBehavior;
  uint8_t mScrollSnapTypeX;
  uint8_t mScrollSnapTypeY;
  nsStyleCoord mScrollSnapPointsX;
  nsStyleCoord mScrollSnapPointsY;
  mozilla::Position mScrollSnapDestination;
  nsTArray<mozilla::Position> mScrollSnapCoordinate;





  uint8_t mBackfaceVisibility;
  uint8_t mTransformStyle;
  StyleGeometryBox mTransformBox;
  RefPtr<nsCSSValueSharedList> mSpecifiedTransform;
  nsStyleCoord mTransformOrigin[3];
  nsStyleCoord mChildPerspective;
  nsStyleCoord mPerspectiveOrigin[2];

  nsStyleCoord mVerticalAlign;

  nsStyleAutoArray<mozilla::StyleTransition> mTransitions;



  uint32_t mTransitionTimingFunctionCount,
           mTransitionDurationCount,
           mTransitionDelayCount,
           mTransitionPropertyCount;

  nsStyleAutoArray<mozilla::StyleAnimation> mAnimations;



  uint32_t mAnimationTimingFunctionCount,
           mAnimationDurationCount,
           mAnimationDelayCount,
           mAnimationNameCount,
           mAnimationDirectionCount,
           mAnimationFillModeCount,
           mAnimationPlayStateCount,
           mAnimationIterationCountCount;

  mozilla::StyleShapeSource mShapeOutside;

  bool IsBlockInsideStyle() const {
    return mozilla::StyleDisplay::Block == mDisplay ||
           mozilla::StyleDisplay::ListItem == mDisplay ||
           mozilla::StyleDisplay::InlineBlock == mDisplay ||
           mozilla::StyleDisplay::TableCaption == mDisplay ||
           mozilla::StyleDisplay::FlowRoot == mDisplay;



  }

  bool IsBlockOutsideStyle() const {
    return mozilla::StyleDisplay::Block == mDisplay ||
           mozilla::StyleDisplay::Flex == mDisplay ||
           mozilla::StyleDisplay::WebkitBox == mDisplay ||
           mozilla::StyleDisplay::Grid == mDisplay ||
           mozilla::StyleDisplay::ListItem == mDisplay ||
           mozilla::StyleDisplay::Table == mDisplay ||
           mozilla::StyleDisplay::FlowRoot == mDisplay;
  }

  static bool IsDisplayTypeInlineOutside(mozilla::StyleDisplay aDisplay) {
    return mozilla::StyleDisplay::Inline == aDisplay ||
           mozilla::StyleDisplay::InlineBlock == aDisplay ||
           mozilla::StyleDisplay::InlineTable == aDisplay ||
           mozilla::StyleDisplay::MozInlineBox == aDisplay ||
           mozilla::StyleDisplay::InlineFlex == aDisplay ||
           mozilla::StyleDisplay::WebkitInlineBox == aDisplay ||
           mozilla::StyleDisplay::InlineGrid == aDisplay ||
           mozilla::StyleDisplay::MozInlineGrid == aDisplay ||
           mozilla::StyleDisplay::MozInlineStack == aDisplay ||
           mozilla::StyleDisplay::Ruby == aDisplay ||
           mozilla::StyleDisplay::RubyBase == aDisplay ||
           mozilla::StyleDisplay::RubyBaseContainer == aDisplay ||
           mozilla::StyleDisplay::RubyText == aDisplay ||
           mozilla::StyleDisplay::RubyTextContainer == aDisplay ||
           mozilla::StyleDisplay::Contents == aDisplay;
  }

  bool IsInlineOutsideStyle() const {
    return IsDisplayTypeInlineOutside(mDisplay);
  }

  bool IsOriginalDisplayInlineOutsideStyle() const {
    return IsDisplayTypeInlineOutside(mOriginalDisplay);
  }

  bool IsInnerTableStyle() const {
    return mozilla::StyleDisplay::TableCaption == mDisplay ||
           mozilla::StyleDisplay::TableCell == mDisplay ||
           mozilla::StyleDisplay::TableRow == mDisplay ||
           mozilla::StyleDisplay::TableRowGroup == mDisplay ||
           mozilla::StyleDisplay::TableHeaderGroup == mDisplay ||
           mozilla::StyleDisplay::TableFooterGroup == mDisplay ||
           mozilla::StyleDisplay::TableColumn == mDisplay ||
           mozilla::StyleDisplay::TableColumnGroup == mDisplay;
  }

  bool IsFloatingStyle() const {
    return mozilla::StyleFloat::None != mFloat;
  }

  bool IsAbsolutelyPositionedStyle() const {
    return 2 == mPosition ||
           3 == mPosition;
  }

  bool IsRelativelyPositionedStyle() const {
    return 1 == mPosition ||
           4 == mPosition;
  }
  bool IsPositionForcingStackingContext() const {
    return 4 == mPosition ||
           3 == mPosition;
  }

  static bool IsRubyDisplayType(mozilla::StyleDisplay aDisplay) {
    return mozilla::StyleDisplay::Ruby == aDisplay ||
           mozilla::StyleDisplay::RubyBase == aDisplay ||
           mozilla::StyleDisplay::RubyBaseContainer == aDisplay ||
           mozilla::StyleDisplay::RubyText == aDisplay ||
           mozilla::StyleDisplay::RubyTextContainer == aDisplay;
  }

  bool IsRubyDisplayType() const {
    return IsRubyDisplayType(mDisplay);
  }

  bool IsOutOfFlowStyle() const {
    return (IsAbsolutelyPositionedStyle() || IsFloatingStyle());
  }

  bool IsScrollableOverflow() const {


    return mOverflowX != 0 &&
           mOverflowX != 4;
  }

  bool IsContainPaint() const {
    return 0x8 & mContain;
  }



  bool HasTransformStyle() const {
    return mSpecifiedTransform != nullptr ||
           mTransformStyle == 1 ||
           (mWillChangeBitField & (1<<1));
  }

  bool HasPerspectiveStyle() const {
    return mChildPerspective.GetUnit() == eStyleUnit_Coord;
  }

  bool BackfaceIsHidden() const {
    return mBackfaceVisibility == 0;
  }







  inline bool IsBlockInside(const nsIFrame* aContextFrame) const;
  inline bool IsBlockOutside(const nsIFrame* aContextFrame) const;
  inline bool IsInlineOutside(const nsIFrame* aContextFrame) const;
  inline bool IsOriginalDisplayInlineOutside(const nsIFrame* aContextFrame) const;
  inline mozilla::StyleDisplay GetDisplay(const nsIFrame* aContextFrame) const;
  inline bool IsFloating(const nsIFrame* aContextFrame) const;
  inline bool IsRelativelyPositioned(const nsIFrame* aContextFrame) const;
  inline bool IsAbsolutelyPositioned(const nsIFrame* aContextFrame) const;
  inline bool IsAbsPosContainingBlock(const nsIFrame* aContextFrame) const;






  template<class StyleContextLike>
  inline bool IsAbsPosContainingBlockForAppropriateFrame(
                StyleContextLike* aStyleContext) const;






  inline bool HasTransform(const nsIFrame* aContextFrame) const;






  inline bool IsFixedPosContainingBlock(const nsIFrame* aContextFrame) const;






  template<class StyleContextLike>
  inline bool IsFixedPosContainingBlockForAppropriateFrame(
                StyleContextLike* aStyleContext) const;

private:


  template<class StyleContextLike>
  inline bool HasAbsPosContainingBlockStyleInternal(
                StyleContextLike* aStyleContext) const;
  template<class StyleContextLike>
  inline bool HasFixedPosContainingBlockStyleInternal(
                StyleContextLike* aStyleContext) const;

public:



  inline mozilla::StyleFloat PhysicalFloats(mozilla::WritingMode aWM) const;
  inline mozilla::StyleClear PhysicalBreakType(mozilla::WritingMode aWM) const;
};

struct nsStyleTable
{
  explicit nsStyleTable(const nsPresContext* aContext);
  nsStyleTable(const nsStyleTable& aOther);
  ~nsStyleTable();
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStyleTable* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleTable, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleTable();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleTable, this);
  }

  nsChangeHint CalcDifference(const nsStyleTable& aNewData) const;

  uint8_t mLayoutStrategy;
  int32_t mSpan;
};

struct nsStyleTableBorder
{
  explicit nsStyleTableBorder(const nsPresContext* aContext);
  nsStyleTableBorder(const nsStyleTableBorder& aOther);
  ~nsStyleTableBorder();
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStyleTableBorder* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleTableBorder, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleTableBorder();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleTableBorder, this);
  }

  nsChangeHint CalcDifference(const nsStyleTableBorder& aNewData) const;

  nscoord mBorderSpacingCol;
  nscoord mBorderSpacingRow;
  uint8_t mBorderCollapse;
  uint8_t mCaptionSide;
  uint8_t mEmptyCells;
};

enum nsStyleContentType {
  eStyleContentType_String = 1,
  eStyleContentType_Image = 10,
  eStyleContentType_Attr = 20,
  eStyleContentType_Counter = 30,
  eStyleContentType_Counters = 31,
  eStyleContentType_OpenQuote = 40,
  eStyleContentType_CloseQuote = 41,
  eStyleContentType_NoOpenQuote = 42,
  eStyleContentType_NoCloseQuote = 43,
  eStyleContentType_AltContent = 50,
  eStyleContentType_Uninitialized
};

class nsStyleContentData
{
public:
  nsStyleContentData()
    : mType(eStyleContentType_Uninitialized)
  {
                                      ;
    mContent.mString = nullptr;
  }
  nsStyleContentData(const nsStyleContentData&);

  ~nsStyleContentData();
  nsStyleContentData& operator=(const nsStyleContentData& aOther);
  bool operator==(const nsStyleContentData& aOther) const;

  bool operator!=(const nsStyleContentData& aOther) const {
    return !(*this == aOther);
  }

  nsStyleContentType GetType() const { return mType; }

  char16_t* GetString() const
  {
    do { } while (0);

    return mContent.mString;
  }

  nsCSSValue::Array* GetCounters() const
  {
    do { } while (0);

    return mContent.mCounters;
  }

  nsStyleImageRequest* GetImageRequest() const
  {
    do { } while (0);
    return mContent.mImage;
  }

  imgRequestProxy* GetImage() const
  {
    return GetImageRequest()->get();
  }

  void SetKeyword(nsStyleContentType aType)
  {
    do { } while (0);




    do { } while (0);

    mType = aType;
  }

  void SetString(nsStyleContentType aType, const char16_t* aString)
  {
    do { } while (0);

    do { } while (0);
    do { } while (0);

    mType = aType;
    mContent.mString = NS_strdup(aString);
  }

  void SetCounters(nsStyleContentType aType, nsCSSValue::Array* aCounters)
  {
    do { } while (0);

    do { } while (0);
    do { } while (0);
    do { } while (0);

    mType = aType;
    mContent.mCounters = aCounters;
    mContent.mCounters->AddRef();
  }

  void SetImageRequest(already_AddRefed<nsStyleImageRequest> aRequest)
  {
    do { } while (0);

    mType = eStyleContentType_Image;
    mContent.mImage = aRequest.take();
    do { } while (0);
  }

  void Resolve(nsPresContext* aPresContext) {
    if (mType == eStyleContentType_Image && !mContent.mImage->IsResolved()) {
      mContent.mImage->Resolve(aPresContext);
    }
  }

private:
  nsStyleContentType mType;
  union {
    char16_t *mString;
    nsStyleImageRequest* mImage;
    nsCSSValue::Array* mCounters;
  } mContent;
};

struct nsStyleCounterData
{
  nsString mCounter;
  int32_t mValue;

  bool operator==(const nsStyleCounterData& aOther) const {
    return mValue == aOther.mValue && mCounter == aOther.mCounter;
  }

  bool operator!=(const nsStyleCounterData& aOther) const {
    return !(*this == aOther);
  }
};

struct nsStyleContent
{
  explicit nsStyleContent(const nsPresContext* aContext);
  nsStyleContent(const nsStyleContent& aContent);
  ~nsStyleContent();
  void FinishStyle(nsPresContext* aPresContext);

  void* operator new(size_t sz, nsStyleContent* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleContent, sz);
  }
  void Destroy(nsPresContext* aContext);

  nsChangeHint CalcDifference(const nsStyleContent& aNewData) const;

  uint32_t ContentCount() const { return mContents.Length(); }

  const nsStyleContentData& ContentAt(uint32_t aIndex) const {
    return mContents[aIndex];
  }

  nsStyleContentData& ContentAt(uint32_t aIndex) { return mContents[aIndex]; }

  void AllocateContents(uint32_t aCount) {





    mContents.Clear();
    mContents.SetLength(aCount);
  }

  uint32_t CounterIncrementCount() const { return mIncrements.Length(); }
  const nsStyleCounterData& CounterIncrementAt(uint32_t aIndex) const {
    return mIncrements[aIndex];
  }

  void AllocateCounterIncrements(uint32_t aCount) {
    mIncrements.Clear();
    mIncrements.SetLength(aCount);
  }

  void SetCounterIncrementAt(uint32_t aIndex, const nsString& aCounter, int32_t aIncrement) {
    mIncrements[aIndex].mCounter = aCounter;
    mIncrements[aIndex].mValue = aIncrement;
  }

  uint32_t CounterResetCount() const { return mResets.Length(); }
  const nsStyleCounterData& CounterResetAt(uint32_t aIndex) const {
    return mResets[aIndex];
  }

  void AllocateCounterResets(uint32_t aCount) {
    mResets.Clear();
    mResets.SetLength(aCount);
  }

  void SetCounterResetAt(uint32_t aIndex, const nsString& aCounter, int32_t aValue) {
    mResets[aIndex].mCounter = aCounter;
    mResets[aIndex].mValue = aValue;
  }

protected:
  nsTArray<nsStyleContentData> mContents;
  nsTArray<nsStyleCounterData> mIncrements;
  nsTArray<nsStyleCounterData> mResets;
};

struct nsStyleUIReset
{
  explicit nsStyleUIReset(const nsPresContext* aContext);
  nsStyleUIReset(const nsStyleUIReset& aOther);
  ~nsStyleUIReset();
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStyleUIReset* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleUIReset, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleUIReset();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleUIReset, this);
  }

  nsChangeHint CalcDifference(const nsStyleUIReset& aNewData) const;

  mozilla::StyleUserSelect mUserSelect;
  uint8_t mForceBrokenImageIcon;
  uint8_t mIMEMode;
  mozilla::StyleWindowDragging mWindowDragging;
  uint8_t mWindowShadow;
};

struct nsCursorImage
{
  bool mHaveHotspot;
  float mHotspotX, mHotspotY;
  RefPtr<nsStyleImageRequest> mImage;

  nsCursorImage();
  nsCursorImage(const nsCursorImage& aOther);

  nsCursorImage& operator=(const nsCursorImage& aOther);

  bool operator==(const nsCursorImage& aOther) const;
  bool operator!=(const nsCursorImage& aOther) const
  {
    return !(*this == aOther);
  }

  imgRequestProxy* GetImage() const {
    return mImage->get();
  }
};

struct nsStyleUserInterface
{
  explicit nsStyleUserInterface(const nsPresContext* aContext);
  nsStyleUserInterface(const nsStyleUserInterface& aOther);
  ~nsStyleUserInterface();

  void FinishStyle(nsPresContext* aPresContext);

  void* operator new(size_t sz, nsStyleUserInterface* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleUserInterface, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleUserInterface();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleUserInterface, this);
  }

  nsChangeHint CalcDifference(const nsStyleUserInterface& aNewData) const;

  mozilla::StyleUserInput mUserInput;
  mozilla::StyleUserModify mUserModify;
  mozilla::StyleUserFocus mUserFocus;
  uint8_t mPointerEvents;

  uint8_t mCursor;
  nsTArray<nsCursorImage> mCursorImages;
  mozilla::StyleComplexColor mCaretColor;

  inline uint8_t GetEffectivePointerEvents(nsIFrame* aFrame) const;
};

struct nsStyleXUL
{
  explicit nsStyleXUL(const nsPresContext* aContext);
  nsStyleXUL(const nsStyleXUL& aSource);
  ~nsStyleXUL();
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStyleXUL* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleXUL, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleXUL();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleXUL, this);
  }

  nsChangeHint CalcDifference(const nsStyleXUL& aNewData) const;

  float mBoxFlex;
  uint32_t mBoxOrdinal;
  mozilla::StyleBoxAlign mBoxAlign;
  mozilla::StyleBoxDirection mBoxDirection;
  mozilla::StyleBoxOrient mBoxOrient;
  mozilla::StyleBoxPack mBoxPack;
  bool mStretchStack;
};

struct nsStyleColumn
{
  explicit nsStyleColumn(const nsPresContext* aContext);
  nsStyleColumn(const nsStyleColumn& aSource);
  ~nsStyleColumn();
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStyleColumn* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleColumn, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleColumn();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleColumn, this);
  }

  nsChangeHint CalcDifference(const nsStyleColumn& aNewData) const;





  static const uint32_t kMaxColumnCount = 1000;

  uint32_t mColumnCount;
  nsStyleCoord mColumnWidth;
  nsStyleCoord mColumnGap;

  mozilla::StyleComplexColor mColumnRuleColor;
  uint8_t mColumnRuleStyle;
  uint8_t mColumnFill;
  uint8_t mColumnSpan;

  void SetColumnRuleWidth(nscoord aWidth) {
    mColumnRuleWidth = ((aWidth) == 0) ? 0 : std::max((mTwipsPerPixel), (aWidth) / (mTwipsPerPixel) * (mTwipsPerPixel));
  }

  nscoord GetComputedColumnRuleWidth() const {
    return (IsVisibleBorderStyle(mColumnRuleStyle) ? mColumnRuleWidth : 0);
  }

protected:
  nscoord mColumnRuleWidth;
  nscoord mTwipsPerPixel;
};

enum nsStyleSVGPaintType {
  eStyleSVGPaintType_None = 1,
  eStyleSVGPaintType_Color,
  eStyleSVGPaintType_Server,
  eStyleSVGPaintType_ContextFill,
  eStyleSVGPaintType_ContextStroke
};

enum nsStyleSVGOpacitySource : uint8_t {
  eStyleSVGOpacitySource_Normal,
  eStyleSVGOpacitySource_ContextFillOpacity,
  eStyleSVGOpacitySource_ContextStrokeOpacity
};

class nsStyleSVGPaint
{
public:
  explicit nsStyleSVGPaint(nsStyleSVGPaintType aType = nsStyleSVGPaintType(0));
  nsStyleSVGPaint(const nsStyleSVGPaint& aSource);
  ~nsStyleSVGPaint();

  nsStyleSVGPaint& operator=(const nsStyleSVGPaint& aOther);

  nsStyleSVGPaintType Type() const { return mType; }

  void SetNone();
  void SetColor(nscolor aColor);
  void SetPaintServer(mozilla::css::URLValue* aPaintServer,
                      nscolor aFallbackColor);
  void SetContextValue(nsStyleSVGPaintType aType,
                       nscolor aFallbackColor);

  nscolor GetColor() const {
    do { } while (0);
    return mPaint.mColor;
  }

  mozilla::css::URLValue* GetPaintServer() const {
    do { } while (0);
    return mPaint.mPaintServer;
  }

  nscolor GetFallbackColor() const {
    do { } while (0);


    return mFallbackColor;
  }

  bool operator==(const nsStyleSVGPaint& aOther) const;
  bool operator!=(const nsStyleSVGPaint& aOther) const {
    return !(*this == aOther);
  }

private:
  void Reset();
  void Assign(const nsStyleSVGPaint& aOther);

  union {
    nscolor mColor;
    mozilla::css::URLValue* mPaintServer;
  } mPaint;
  nsStyleSVGPaintType mType;
  nscolor mFallbackColor;
};

struct nsStyleSVG
{
  explicit nsStyleSVG(const nsPresContext* aContext);
  nsStyleSVG(const nsStyleSVG& aSource);
  ~nsStyleSVG();
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStyleSVG* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleSVG, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleSVG();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleSVG, this);
  }

  nsChangeHint CalcDifference(const nsStyleSVG& aNewData) const;

  nsStyleSVGPaint mFill;
  nsStyleSVGPaint mStroke;
  RefPtr<mozilla::css::URLValue> mMarkerEnd;
  RefPtr<mozilla::css::URLValue> mMarkerMid;
  RefPtr<mozilla::css::URLValue> mMarkerStart;
  nsTArray<nsStyleCoord> mStrokeDasharray;

  nsStyleCoord mStrokeDashoffset;
  nsStyleCoord mStrokeWidth;

  float mFillOpacity;
  float mStrokeMiterlimit;
  float mStrokeOpacity;

  mozilla::StyleFillRule mClipRule;
  uint8_t mColorInterpolation;
  uint8_t mColorInterpolationFilters;
  mozilla::StyleFillRule mFillRule;
  uint8_t mPaintOrder;
  uint8_t mShapeRendering;
  uint8_t mStrokeLinecap;
  uint8_t mStrokeLinejoin;
  uint8_t mTextAnchor;

  nsStyleSVGOpacitySource FillOpacitySource() const {
    uint8_t value = (mContextFlags & FILL_OPACITY_SOURCE_MASK) >>
                    FILL_OPACITY_SOURCE_SHIFT;
    return nsStyleSVGOpacitySource(value);
  }
  nsStyleSVGOpacitySource StrokeOpacitySource() const {
    uint8_t value = (mContextFlags & STROKE_OPACITY_SOURCE_MASK) >>
                    STROKE_OPACITY_SOURCE_SHIFT;
    return nsStyleSVGOpacitySource(value);
  }
  bool StrokeDasharrayFromObject() const {
    return mContextFlags & STROKE_DASHARRAY_CONTEXT;
  }
  bool StrokeDashoffsetFromObject() const {
    return mContextFlags & STROKE_DASHOFFSET_CONTEXT;
  }
  bool StrokeWidthFromObject() const {
    return mContextFlags & STROKE_WIDTH_CONTEXT;
  }

  void SetFillOpacitySource(nsStyleSVGOpacitySource aValue) {
    mContextFlags = (mContextFlags & ~FILL_OPACITY_SOURCE_MASK) |
                    (aValue << FILL_OPACITY_SOURCE_SHIFT);
  }
  void SetStrokeOpacitySource(nsStyleSVGOpacitySource aValue) {
    mContextFlags = (mContextFlags & ~STROKE_OPACITY_SOURCE_MASK) |
                    (aValue << STROKE_OPACITY_SOURCE_SHIFT);
  }
  void SetStrokeDasharrayFromObject(bool aValue) {
    mContextFlags = (mContextFlags & ~STROKE_DASHARRAY_CONTEXT) |
                    (aValue ? STROKE_DASHARRAY_CONTEXT : 0);
  }
  void SetStrokeDashoffsetFromObject(bool aValue) {
    mContextFlags = (mContextFlags & ~STROKE_DASHOFFSET_CONTEXT) |
                    (aValue ? STROKE_DASHOFFSET_CONTEXT : 0);
  }
  void SetStrokeWidthFromObject(bool aValue) {
    mContextFlags = (mContextFlags & ~STROKE_WIDTH_CONTEXT) |
                    (aValue ? STROKE_WIDTH_CONTEXT : 0);
  }

  bool HasMarker() const {
    return mMarkerStart || mMarkerMid || mMarkerEnd;
  }





  bool HasStroke() const {
    return mStroke.Type() != eStyleSVGPaintType_None && mStrokeOpacity > 0;
  }





  bool HasFill() const {
    return mFill.Type() != eStyleSVGPaintType_None && mFillOpacity > 0;
  }

private:



  enum {
    FILL_OPACITY_SOURCE_MASK = 0x03,
    STROKE_OPACITY_SOURCE_MASK = 0x0C,
    STROKE_DASHARRAY_CONTEXT = 0x10,
    STROKE_DASHOFFSET_CONTEXT = 0x20,
    STROKE_WIDTH_CONTEXT = 0x40,
    FILL_OPACITY_SOURCE_SHIFT = 0,
    STROKE_OPACITY_SOURCE_SHIFT = 2,
  };

  uint8_t mContextFlags;
};

struct nsStyleFilter
{
  nsStyleFilter();
  nsStyleFilter(const nsStyleFilter& aSource);
  ~nsStyleFilter();
  void FinishStyle(nsPresContext* aPresContext) {}

  nsStyleFilter& operator=(const nsStyleFilter& aOther);

  bool operator==(const nsStyleFilter& aOther) const;
  bool operator!=(const nsStyleFilter& aOther) const {
    return !(*this == aOther);
  }

  uint32_t GetType() const {
    return mType;
  }

  const nsStyleCoord& GetFilterParameter() const {
    do { } while(0);


    return mFilterParameter;
  }
  void SetFilterParameter(const nsStyleCoord& aFilterParameter,
                          int32_t aType);

  mozilla::css::URLValue* GetURL() const {
    do { } while (0);
    return mURL;
  }

  bool SetURL(mozilla::css::URLValue* aValue);

  nsCSSShadowArray* GetDropShadow() const {
    do { } while(0);
    return mDropShadow;
  }
  void SetDropShadow(nsCSSShadowArray* aDropShadow);

private:
  void ReleaseRef();

  uint32_t mType;
  nsStyleCoord mFilterParameter;
  union {
    mozilla::css::URLValue* mURL;
    nsCSSShadowArray* mDropShadow;
  };
};

template<>
struct nsTArray_CopyChooser<nsStyleFilter>
{
  typedef nsTArray_CopyWithConstructors<nsStyleFilter> Type;
};

struct nsStyleSVGReset
{
  explicit nsStyleSVGReset(const nsPresContext* aContext);
  nsStyleSVGReset(const nsStyleSVGReset& aSource);
  ~nsStyleSVGReset();




  void FinishStyle(nsPresContext* aPresContext);

  void* operator new(size_t sz, nsStyleSVGReset* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleSVGReset, sz);
  }
  void Destroy(nsPresContext* aContext);

  nsChangeHint CalcDifference(const nsStyleSVGReset& aNewData) const;

  bool HasClipPath() const {
    return mClipPath.GetType() != mozilla::StyleShapeSourceType::None;
  }

  bool HasMask() const;

  bool HasNonScalingStroke() const {
    return mVectorEffect == 1;
  }

  nsStyleImageLayers mMask;
  mozilla::StyleShapeSource mClipPath;
  nscolor mStopColor;
  nscolor mFloodColor;
  nscolor mLightingColor;

  float mStopOpacity;
  float mFloodOpacity;

  uint8_t mDominantBaseline;
  uint8_t mVectorEffect;
  uint8_t mMaskType;
};

struct nsStyleVariables
{
  nsStyleVariables();
  explicit nsStyleVariables(const nsPresContext* aContext);
  nsStyleVariables(const nsStyleVariables& aSource);
  ~nsStyleVariables();
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStyleVariables* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleVariables, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleVariables();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleVariables, this);
  }

  nsChangeHint CalcDifference(const nsStyleVariables& aNewData) const;

  mozilla::CSSVariableValues mVariables;
};

struct nsStyleEffects
{
  explicit nsStyleEffects(const nsPresContext* aContext);
  nsStyleEffects(const nsStyleEffects& aSource);
  ~nsStyleEffects();
  void FinishStyle(nsPresContext* aPresContext) {}

  void* operator new(size_t sz, nsStyleEffects* aSelf) { return aSelf; }
  void* operator new(size_t sz, nsPresContext* aContext) {
    return aContext->PresShell()->
      AllocateByObjectID(mozilla::eArenaObjectID_nsStyleEffects, sz);
  }
  void Destroy(nsPresContext* aContext) {
    this->~nsStyleEffects();
    aContext->PresShell()->
      FreeByObjectID(mozilla::eArenaObjectID_nsStyleEffects, this);
  }

  nsChangeHint CalcDifference(const nsStyleEffects& aNewData) const;

  bool HasFilters() const {
    return !mFilters.IsEmpty();
  }

  nsTArray<nsStyleFilter> mFilters;
  RefPtr<nsCSSShadowArray> mBoxShadow;
  nsRect mClip;
  float mOpacity;
  uint8_t mClipFlags;
  uint8_t mMixBlendMode;
};
struct nsPoint_Simple {
  nscoord x, y;
};

static_assert(sizeof(nsPoint) == sizeof(nsPoint_Simple), "Size mismatch between " "nsPoint" " and " "nsPoint_Simple"); static_assert(alignof(nsPoint) == alignof(nsPoint_Simple), "Align mismatch between " "nsPoint" " and " "nsPoint_Simple");;
static_assert(__builtin_offsetof(nsPoint, x) == __builtin_offsetof(nsPoint_Simple, x), "Field offset mismatch of " "x" " between " "nsPoint" " and " "nsPoint_Simple");;
static_assert(__builtin_offsetof(nsPoint, y) == __builtin_offsetof(nsPoint_Simple, y), "Field offset mismatch of " "y" " between " "nsPoint" " and " "nsPoint_Simple");;




struct nsMargin_Simple {
  nscoord top, right, bottom, left;
};

static_assert(sizeof(nsMargin) == sizeof(nsMargin_Simple), "Size mismatch between " "nsMargin" " and " "nsMargin_Simple"); static_assert(alignof(nsMargin) == alignof(nsMargin_Simple), "Align mismatch between " "nsMargin" " and " "nsMargin_Simple");;
static_assert(__builtin_offsetof(nsMargin, top) == __builtin_offsetof(nsMargin_Simple, top), "Field offset mismatch of " "top" " between " "nsMargin" " and " "nsMargin_Simple");;
static_assert(__builtin_offsetof(nsMargin, right) == __builtin_offsetof(nsMargin_Simple, right), "Field offset mismatch of " "right" " between " "nsMargin" " and " "nsMargin_Simple");;
static_assert(__builtin_offsetof(nsMargin, bottom) == __builtin_offsetof(nsMargin_Simple, bottom), "Field offset mismatch of " "bottom" " between " "nsMargin" " and " "nsMargin_Simple");;
static_assert(__builtin_offsetof(nsMargin, left) == __builtin_offsetof(nsMargin_Simple, left), "Field offset mismatch of " "left" " between " "nsMargin" " and " "nsMargin_Simple");;




struct nsRect_Simple {
  nscoord x, y, width, height;
};

static_assert(sizeof(nsRect) == sizeof(nsRect_Simple), "Size mismatch between " "nsRect" " and " "nsRect_Simple"); static_assert(alignof(nsRect) == alignof(nsRect_Simple), "Align mismatch between " "nsRect" " and " "nsRect_Simple");;
static_assert(__builtin_offsetof(nsRect, x) == __builtin_offsetof(nsRect_Simple, x), "Field offset mismatch of " "x" " between " "nsRect" " and " "nsRect_Simple");;
static_assert(__builtin_offsetof(nsRect, y) == __builtin_offsetof(nsRect_Simple, y), "Field offset mismatch of " "y" " between " "nsRect" " and " "nsRect_Simple");;
static_assert(__builtin_offsetof(nsRect, width) == __builtin_offsetof(nsRect_Simple, width), "Field offset mismatch of " "width" " between " "nsRect" " and " "nsRect_Simple");;
static_assert(__builtin_offsetof(nsRect, height) == __builtin_offsetof(nsRect_Simple, height), "Field offset mismatch of " "height" " between " "nsRect" " and " "nsRect_Simple");;




struct nsSize_Simple {
  nscoord width, height;
};

static_assert(sizeof(nsSize) == sizeof(nsSize_Simple), "Size mismatch between " "nsSize" " and " "nsSize_Simple"); static_assert(alignof(nsSize) == alignof(nsSize_Simple), "Align mismatch between " "nsSize" " and " "nsSize_Simple");;
static_assert(__builtin_offsetof(nsSize, width) == __builtin_offsetof(nsSize_Simple, width), "Field offset mismatch of " "width" " between " "nsSize" " and " "nsSize_Simple");;
static_assert(__builtin_offsetof(nsSize, height) == __builtin_offsetof(nsSize_Simple, height), "Field offset mismatch of " "height" " between " "nsSize" " and " "nsSize_Simple");;







template<typename T, typename Deleter = mozilla::DefaultDelete<T>>
struct UniquePtr_Simple {
  T* mPtr;
};

static_assert(sizeof(mozilla::UniquePtr<int>) == sizeof(UniquePtr_Simple<int>), "Size mismatch between " "mozilla::UniquePtr<int>" " and " "UniquePtr_Simple<int>"); static_assert(alignof(mozilla::UniquePtr<int>) == alignof(UniquePtr_Simple<int>), "Align mismatch between " "mozilla::UniquePtr<int>" " and " "UniquePtr_Simple<int>");;




template<typename T>
class nsTArray_Simple {
  T* mBuffer;
public:


  ~nsTArray_Simple() {};
};

static_assert(sizeof(nsTArray<nsStyleImageLayers::Layer>) == sizeof(nsTArray_Simple<nsStyleImageLayers::Layer>), "Size mismatch between " "nsTArray<nsStyleImageLayers::Layer>" " and " "nsTArray_Simple<nsStyleImageLayers::Layer>"); static_assert(alignof(nsTArray<nsStyleImageLayers::Layer>) == alignof(nsTArray_Simple<nsStyleImageLayers::Layer>), "Align mismatch between " "nsTArray<nsStyleImageLayers::Layer>" " and " "nsTArray_Simple<nsStyleImageLayers::Layer>");;

static_assert(sizeof(nsTArray<mozilla::StyleTransition>) == sizeof(nsTArray_Simple<mozilla::StyleTransition>), "Size mismatch between " "nsTArray<mozilla::StyleTransition>" " and " "nsTArray_Simple<mozilla::StyleTransition>"); static_assert(alignof(nsTArray<mozilla::StyleTransition>) == alignof(nsTArray_Simple<mozilla::StyleTransition>), "Align mismatch between " "nsTArray<mozilla::StyleTransition>" " and " "nsTArray_Simple<mozilla::StyleTransition>");;

static_assert(sizeof(nsTArray<mozilla::StyleAnimation>) == sizeof(nsTArray_Simple<mozilla::StyleAnimation>), "Size mismatch between " "nsTArray<mozilla::StyleAnimation>" " and " "nsTArray_Simple<mozilla::StyleAnimation>"); static_assert(alignof(nsTArray<mozilla::StyleAnimation>) == alignof(nsTArray_Simple<mozilla::StyleAnimation>), "Align mismatch between " "nsTArray<mozilla::StyleAnimation>" " and " "nsTArray_Simple<mozilla::StyleAnimation>");;







template<typename T>
class nsCOMArray_Simple {
  nsTArray<nsISupports*> mBuffer;
};

static_assert(sizeof(nsCOMArray<nsIContent>) == sizeof(nsCOMArray_Simple<nsIContent>), "Size mismatch between " "nsCOMArray<nsIContent>" " and " "nsCOMArray_Simple<nsIContent>"); static_assert(alignof(nsCOMArray<nsIContent>) == alignof(nsCOMArray_Simple<nsIContent>), "Align mismatch between " "nsCOMArray<nsIContent>" " and " "nsCOMArray_Simple<nsIContent>");;

static_assert(sizeof(nsCOMArray<nsINode>) == sizeof(nsCOMArray_Simple<nsINode>), "Size mismatch between " "nsCOMArray<nsINode>" " and " "nsCOMArray_Simple<nsINode>"); static_assert(alignof(nsCOMArray<nsINode>) == alignof(nsCOMArray_Simple<nsINode>), "Align mismatch between " "nsCOMArray<nsINode>" " and " "nsCOMArray_Simple<nsINode>");;

static_assert(sizeof(nsCOMArray<imgIContainer>) == sizeof(nsCOMArray_Simple<imgIContainer>), "Size mismatch between " "nsCOMArray<imgIContainer>" " and " "nsCOMArray_Simple<imgIContainer>"); static_assert(alignof(nsCOMArray<imgIContainer>) == alignof(nsCOMArray_Simple<imgIContainer>), "Align mismatch between " "nsCOMArray<imgIContainer>" " and " "nsCOMArray_Simple<imgIContainer>");;

namespace mozilla {

class ComputedTimingFunction
{
public:
  static ComputedTimingFunction
  CubicBezier(double x1, double y1, double x2, double y2)
  {
    return ComputedTimingFunction(x1, y1, x2, y2);
  }
  static ComputedTimingFunction
  Steps(nsTimingFunction::Type aType, uint32_t aSteps)
  {
    do { } while (0);



    do { } while (0);
    return ComputedTimingFunction(aType, aSteps);
  }
  static ComputedTimingFunction
  Frames(uint32_t aFrames)
  {
    do { } while (0);
    return ComputedTimingFunction(nsTimingFunction::Type::Frames, aFrames);
  }

  ComputedTimingFunction() = default;
  explicit ComputedTimingFunction(const nsTimingFunction& aFunction)
  {
    Init(aFunction);
  }
  void Init(const nsTimingFunction& aFunction);



  enum class BeforeFlag {
    Unset,
    Set
  };
  double GetValue(double aPortion, BeforeFlag aBeforeFlag) const;
  const nsSMILKeySpline* GetFunction() const
  {
    do { } while(0);
    return &mTimingFunction;
  }
  nsTimingFunction::Type GetType() const { return mType; }
  bool HasSpline() const { return nsTimingFunction::IsSplineType(mType); }
  uint32_t GetSteps() const
  {
    do { } while (0);

    return mStepsOrFrames;
  }
  uint32_t GetFrames() const
  {
    do { } while (0);
    return mStepsOrFrames;
  }
  bool operator==(const ComputedTimingFunction& aOther) const
  {
    return mType == aOther.mType &&
           (HasSpline() ?
            mTimingFunction == aOther.mTimingFunction :
            mStepsOrFrames == aOther.mStepsOrFrames);
  }
  bool operator!=(const ComputedTimingFunction& aOther) const
  {
    return !(*this == aOther);
  }
  int32_t Compare(const ComputedTimingFunction& aRhs) const;
  void AppendToString(nsAString& aResult) const;

  static double GetPortion(const Maybe<ComputedTimingFunction>& aFunction,
                           double aPortion,
                           BeforeFlag aBeforeFlag)
  {
    return aFunction ? aFunction->GetValue(aPortion, aBeforeFlag) : aPortion;
  }
  static int32_t Compare(const Maybe<ComputedTimingFunction>& aLhs,
                         const Maybe<ComputedTimingFunction>& aRhs);

private:
  ComputedTimingFunction(double x1, double y1, double x2, double y2)
    : mType(nsTimingFunction::Type::CubicBezier)
    , mTimingFunction(x1, y1, x2, y2) { }
  ComputedTimingFunction(nsTimingFunction::Type aType, uint32_t aStepsOrFrames)
    : mType(aType)
    , mStepsOrFrames(aStepsOrFrames) { }

  nsTimingFunction::Type mType = nsTimingFunction::Type::Linear;
  nsSMILKeySpline mTimingFunction;
  uint32_t mStepsOrFrames;
};

}

class nsIAtom;

namespace mozilla {
namespace dom {
class Element;
}



typedef uint8_t CSSPseudoClassTypeBase;
enum class CSSPseudoClassType : CSSPseudoClassTypeBase
{



empty,
mozOnlyWhitespace,
mozEmptyExceptChildrenWithLocalname,
lang,
root,
any,

firstChild,
firstNode,
lastChild,
lastNode,
onlyChild,
firstOfType,
lastOfType,
onlyOfType,
nthChild,
nthLastChild,
nthOfType,
nthLastOfType,


mozIsHTML,


 unresolved,




mozNativeAnonymous,



mozSystemMetric,



mozLocaleDir,


mozLWTheme,


mozLWThemeBrightText,


mozLWThemeDarkText,


mozWindowInactive,



mozTableBorderNonzero,



mozBrowserFrame,




scope,



negation,



dir,


link,

mozAnyLink,

anyLink,

visited,

active,
checked,
disabled,
enabled,
focus,
focusWithin,
hover,
mozDragOver,
target,
indeterminate,


mozDevtoolsHighlighted,

mozStyleeditorTransitioning,




fullscreen,



mozFullScreen,


mozFocusRing,


mozBroken,
mozLoading,

mozUserDisabled,


mozSuppressed,


mozHandlerClickToPlay,


mozHandlerVulnerableUpdatable,


mozHandlerVulnerableNoUpdate,


mozHandlerDisabled,


mozHandlerBlocked,


mozHandlerCrashed,



mozMathIncrementScriptLevel,





required,
optional,
valid,
invalid,
inRange,
outOfRange,
defaultPseudo,
placeholderShown,

mozReadOnly,

mozReadWrite,

mozSubmitInvalid,

mozUIInvalid,

mozUIValid,

mozMeterOptimum,

mozMeterSubOptimum,

mozMeterSubSubOptimum,



mozPlaceholder,

  Count,
  NotPseudo,
  MAX
};

}

class nsCSSPseudoClasses
{
  typedef mozilla::CSSPseudoClassType Type;
  typedef mozilla::CSSEnabledState EnabledState;

public:
  static void AddRefAtoms();

  static Type GetPseudoType(nsIAtom* aAtom, EnabledState aEnabledState);
  static bool HasStringArg(Type aType);
  static bool HasNthPairArg(Type aType);
  static bool HasSelectorListArg(Type aType) {
    return aType == Type::any;
  }
  static bool IsUserActionPseudoClass(Type aType);


  static void PseudoTypeToString(Type aType, nsAString& aString);

  static bool IsEnabled(Type aType, EnabledState aEnabledState)
  {
    auto index = static_cast<size_t>(aType);
    do { } while (0);
    if (sPseudoClassEnabled[index] ||
        aEnabledState == EnabledState::eIgnoreEnabledState) {
      return true;
    }
    auto flags = kPseudoClassFlags[index];
    if (((aEnabledState & EnabledState::eInChrome) &&
         (flags & (1<<1))) ||
        ((aEnabledState & EnabledState::eInUASheets) &&
         (flags & (1<<0)))) {
      return true;
    }
    return false;
  }




  static mozilla::Maybe<bool>
    MatchesElement(Type aType, const mozilla::dom::Element* aElement);

private:
  static const uint32_t kPseudoClassFlags[size_t(Type::Count)];
  static bool sPseudoClassEnabled[size_t(Type::Count)];
};
class nsIAtom;
class nsIPrincipal;
class nsIURI;
struct nsFont;
namespace mozilla {
  class ServoStyleSheet;
  class FontFamilyList;
  enum FontFamilyType : uint32_t;
  struct Keyframe;
  namespace css {
    struct URLValue;
  };
  enum class UpdateAnimationsTasks : uint8_t;
}
using mozilla::FontFamilyList;
using mozilla::FontFamilyType;
using mozilla::ServoElementSnapshot;
class nsCSSFontFaceRule;
struct nsMediaFeature;
struct nsStyleList;
struct nsStyleImage;
struct nsStyleGradientStop;
class nsStyleGradient;
class nsStyleCoord;
struct nsStyleDisplay;
struct nsTArrayBorrowed_uintptr_t { nsTArray<uintptr_t>* mArray; nsTArrayBorrowed_uintptr_t(nsTArray<uintptr_t>* aArray) : mArray(aArray) {} };


extern "C" {

class ServoBundledURI
{
public:
  already_AddRefed<mozilla::css::URLValue> IntoCssUrl();
  const uint8_t* mURLString;
  uint32_t mURLStringLength;
  mozilla::css::URLExtraData* mExtraData;
};


uint32_t Gecko_ChildrenCount(RawGeckoNodeBorrowed node);
bool Gecko_NodeIsElement(RawGeckoNodeBorrowed node);
bool Gecko_IsInDocument(RawGeckoNodeBorrowed node);
bool Gecko_FlattenedTreeParentIsParent(RawGeckoNodeBorrowed node);
bool Gecko_IsSignificantChild(RawGeckoNodeBorrowed node,
                              bool text_is_significant,
                              bool whitespace_is_significant);
RawGeckoNodeBorrowedOrNull Gecko_GetParentNode(RawGeckoNodeBorrowed node);
RawGeckoNodeBorrowedOrNull Gecko_GetFirstChild(RawGeckoNodeBorrowed node);
RawGeckoNodeBorrowedOrNull Gecko_GetLastChild(RawGeckoNodeBorrowed node);
RawGeckoNodeBorrowedOrNull Gecko_GetPrevSibling(RawGeckoNodeBorrowed node);
RawGeckoNodeBorrowedOrNull Gecko_GetNextSibling(RawGeckoNodeBorrowed node);
RawGeckoElementBorrowedOrNull Gecko_GetFirstChildElement(RawGeckoElementBorrowed element);
RawGeckoElementBorrowedOrNull Gecko_GetLastChildElement(RawGeckoElementBorrowed element);
RawGeckoElementBorrowedOrNull Gecko_GetPrevSiblingElement(RawGeckoElementBorrowed element);
RawGeckoElementBorrowedOrNull Gecko_GetNextSiblingElement(RawGeckoElementBorrowed element);
RawGeckoElementBorrowedOrNull Gecko_GetDocumentElement(RawGeckoDocumentBorrowed document);
void Gecko_LoadStyleSheet(mozilla::css::Loader* loader,
                          mozilla::ServoStyleSheet* parent,
                          RawServoStyleSheetBorrowed child_sheet,
                          RawGeckoURLExtraData* base_url_data,
                          const uint8_t* url_bytes,
                          uint32_t url_length,
                          const uint8_t* media_bytes,
                          uint32_t media_length);



RawGeckoURLExtraData* Gecko_URLExtraData_CreateDummy();







StyleChildrenIteratorOwnedOrNull Gecko_MaybeCreateStyleChildrenIterator(RawGeckoNodeBorrowed node);
void Gecko_DropStyleChildrenIterator(StyleChildrenIteratorOwned it);
RawGeckoNodeBorrowedOrNull Gecko_GetNextStyleChild(StyleChildrenIteratorBorrowedMut it);


uint64_t Gecko_ElementState(RawGeckoElementBorrowed element);
bool Gecko_IsTextNode(RawGeckoNodeBorrowed node);
bool Gecko_IsRootElement(RawGeckoElementBorrowed element);
bool Gecko_MatchesElement(mozilla::CSSPseudoClassType type, RawGeckoElementBorrowed element);
nsIAtom* Gecko_LocalName(RawGeckoElementBorrowed element);
nsIAtom* Gecko_Namespace(RawGeckoElementBorrowed element);
nsIAtom* Gecko_GetElementId(RawGeckoElementBorrowed element);

nsIAtom* Gecko_GetXMLLangValue(RawGeckoElementBorrowed element);
nsIAtom* Gecko_AtomAttrValue(RawGeckoElementBorrowed element, nsIAtom* attribute); bool Gecko_HasAttr(RawGeckoElementBorrowed element, nsIAtom* ns, nsIAtom* name); bool Gecko_AttrEquals(RawGeckoElementBorrowed element, nsIAtom* ns, nsIAtom* name, nsIAtom* str, bool ignoreCase); bool Gecko_AttrDashEquals(RawGeckoElementBorrowed element, nsIAtom* ns, nsIAtom* name, nsIAtom* str); bool Gecko_AttrIncludes(RawGeckoElementBorrowed element, nsIAtom* ns, nsIAtom* name, nsIAtom* str); bool Gecko_AttrHasSubstring(RawGeckoElementBorrowed element, nsIAtom* ns, nsIAtom* name, nsIAtom* str); bool Gecko_AttrHasPrefix(RawGeckoElementBorrowed element, nsIAtom* ns, nsIAtom* name, nsIAtom* str); bool Gecko_AttrHasSuffix(RawGeckoElementBorrowed element, nsIAtom* ns, nsIAtom* name, nsIAtom* str); uint32_t Gecko_ClassOrClassList(RawGeckoElementBorrowed element, nsIAtom** class_, nsIAtom*** classList);
nsIAtom* Gecko_SnapshotAtomAttrValue(const ServoElementSnapshot* element, nsIAtom* attribute); bool Gecko_SnapshotHasAttr(const ServoElementSnapshot* element, nsIAtom* ns, nsIAtom* name); bool Gecko_SnapshotAttrEquals(const ServoElementSnapshot* element, nsIAtom* ns, nsIAtom* name, nsIAtom* str, bool ignoreCase); bool Gecko_SnapshotAttrDashEquals(const ServoElementSnapshot* element, nsIAtom* ns, nsIAtom* name, nsIAtom* str); bool Gecko_SnapshotAttrIncludes(const ServoElementSnapshot* element, nsIAtom* ns, nsIAtom* name, nsIAtom* str); bool Gecko_SnapshotAttrHasSubstring(const ServoElementSnapshot* element, nsIAtom* ns, nsIAtom* name, nsIAtom* str); bool Gecko_SnapshotAttrHasPrefix(const ServoElementSnapshot* element, nsIAtom* ns, nsIAtom* name, nsIAtom* str); bool Gecko_SnapshotAttrHasSuffix(const ServoElementSnapshot* element, nsIAtom* ns, nsIAtom* name, nsIAtom* str); uint32_t Gecko_SnapshotClassOrClassList(const ServoElementSnapshot* element, nsIAtom** class_, nsIAtom*** classList);





RawServoDeclarationBlockStrongBorrowedOrNull
Gecko_GetStyleAttrDeclarationBlock(RawGeckoElementBorrowed element);
RawServoDeclarationBlockStrongBorrowedOrNull
Gecko_GetHTMLPresentationAttrDeclarationBlock(RawGeckoElementBorrowed element);
RawServoDeclarationBlockStrongBorrowedOrNull
Gecko_GetExtraContentStyleDeclarations(RawGeckoElementBorrowed element);


bool
Gecko_GetAnimationRule(RawGeckoElementBorrowed aElement,
                       nsIAtom* aPseudoTag,
                       mozilla::EffectCompositor::CascadeLevel aCascadeLevel,
                       RawServoAnimationValueMapBorrowed aAnimationValues);
bool Gecko_StyleAnimationsEquals(RawGeckoStyleAnimationListBorrowed,
                                 RawGeckoStyleAnimationListBorrowed);
void Gecko_UpdateAnimations(RawGeckoElementBorrowed aElement,
                            nsIAtom* aPseudoTagOrNull,
                            ServoComputedValuesBorrowedOrNull aComputedValues,
                            ServoComputedValuesBorrowedOrNull aParentComputedValues,
                            mozilla::UpdateAnimationsTasks aTaskBits);
bool Gecko_ElementHasAnimations(RawGeckoElementBorrowed aElement,
                                nsIAtom* aPseudoTagOrNull);
bool Gecko_ElementHasCSSAnimations(RawGeckoElementBorrowed aElement,
                                   nsIAtom* aPseudoTagOrNull);
double Gecko_GetProgressFromComputedTiming(RawGeckoComputedTimingBorrowed aComputedTiming);
double Gecko_GetPositionInSegment(
  RawGeckoAnimationPropertySegmentBorrowed aSegment,
  double aProgress,
  mozilla::ComputedTimingFunction::BeforeFlag aBeforeFlag);




RawServoAnimationValueBorrowedOrNull Gecko_AnimationGetBaseStyle(
  void* aBaseStyles,
  nsCSSPropertyID aProperty);


nsIAtom* Gecko_Atomize(const char* aString, uint32_t aLength);
void Gecko_AddRefAtom(nsIAtom* aAtom);
void Gecko_ReleaseAtom(nsIAtom* aAtom);
const uint16_t* Gecko_GetAtomAsUTF16(nsIAtom* aAtom, uint32_t* aLength);
bool Gecko_AtomEqualsUTF8(nsIAtom* aAtom, const char* aString, uint32_t aLength);
bool Gecko_AtomEqualsUTF8IgnoreCase(nsIAtom* aAtom, const char* aString, uint32_t aLength);


void Gecko_FontFamilyList_Clear(FontFamilyList* aList);
void Gecko_FontFamilyList_AppendNamed(FontFamilyList* aList, nsIAtom* aName, bool aQuoted);
void Gecko_FontFamilyList_AppendGeneric(FontFamilyList* list, FontFamilyType familyType);
void Gecko_CopyFontFamilyFrom(nsFont* dst, const nsFont* src);


void Gecko_SetListStyleType(nsStyleList* style_struct, uint32_t type);
void Gecko_CopyListStyleTypeFrom(nsStyleList* dst, const nsStyleList* src);



void Gecko_SetNullImageValue(nsStyleImage* image);
void Gecko_SetGradientImageValue(nsStyleImage* image, nsStyleGradient* gradient);
void Gecko_SetUrlImageValue(nsStyleImage* image,
                            ServoBundledURI uri);
void Gecko_CopyImageValueFrom(nsStyleImage* image, const nsStyleImage* other);
void Gecko_InitializeImageCropRect(nsStyleImage* image);

nsStyleGradient* Gecko_CreateGradient(uint8_t shape,
                                      uint8_t size,
                                      bool repeating,
                                      bool legacy_syntax,
                                      uint32_t stops);


void Gecko_SetListStyleImageNone(nsStyleList* style_struct);
void Gecko_SetListStyleImage(nsStyleList* style_struct,
                             ServoBundledURI uri);
void Gecko_CopyListStyleImageFrom(nsStyleList* dest, const nsStyleList* src);


void Gecko_SetCursorArrayLength(nsStyleUserInterface* ui, size_t len);
void Gecko_SetCursorImage(nsCursorImage* cursor,
                          ServoBundledURI uri);
void Gecko_CopyCursorArrayFrom(nsStyleUserInterface* dest,
                               const nsStyleUserInterface* src);

void Gecko_SetContentDataImage(nsStyleContentData* content_data, ServoBundledURI uri);
void Gecko_SetContentDataArray(nsStyleContentData* content_data, nsStyleContentType type, uint32_t len);


uint32_t Gecko_GetNodeFlags(RawGeckoNodeBorrowed node);
void Gecko_SetNodeFlags(RawGeckoNodeBorrowed node, uint32_t flags);
void Gecko_UnsetNodeFlags(RawGeckoNodeBorrowed node, uint32_t flags);
void Gecko_SetOwnerDocumentNeedsStyleFlush(RawGeckoElementBorrowed element);




nsStyleContext* Gecko_GetStyleContext(RawGeckoNodeBorrowed node,
                                      nsIAtom* aPseudoTagOrNull);
nsChangeHint Gecko_CalcStyleDifference(nsStyleContext* oldstyle,
                                       ServoComputedValuesBorrowed newstyle);
nsChangeHint Gecko_HintsHandledForDescendants(nsChangeHint aHint);


ServoElementSnapshotOwned Gecko_CreateElementSnapshot(RawGeckoElementBorrowed element);
void Gecko_DropElementSnapshot(ServoElementSnapshotOwned snapshot);




void Gecko_EnsureTArrayCapacity(void* array, size_t capacity, size_t elem_size);





void Gecko_ClearPODTArray(void* array, size_t elem_size, size_t elem_align);



void Gecko_ClearAndResizeStyleContents(nsStyleContent* content,
                                       uint32_t how_many);
void Gecko_ClearAndResizeCounterIncrements(nsStyleContent* content,
                                           uint32_t how_many);
void Gecko_ClearAndResizeCounterResets(nsStyleContent* content,
                                       uint32_t how_many);
void Gecko_CopyStyleContentsFrom(nsStyleContent* content, const nsStyleContent* other);
void Gecko_CopyCounterResetsFrom(nsStyleContent* content, const nsStyleContent* other);
void Gecko_CopyCounterIncrementsFrom(nsStyleContent* content, const nsStyleContent* other);

void Gecko_EnsureImageLayersLength(nsStyleImageLayers* layers, size_t len,
                                   nsStyleImageLayers::LayerType layer_type);

void Gecko_EnsureStyleAnimationArrayLength(void* array, size_t len);
void Gecko_EnsureStyleTransitionArrayLength(void* array, size_t len);

void Gecko_ClearWillChange(nsStyleDisplay* display, size_t length);
void Gecko_AppendWillChange(nsStyleDisplay* display, nsIAtom* atom);
void Gecko_CopyWillChangeFrom(nsStyleDisplay* dest, nsStyleDisplay* src);

mozilla::Keyframe* Gecko_AnimationAppendKeyframe(RawGeckoKeyframeListBorrowedMut keyframes,
                                                 float offset,
                                                 const nsTimingFunction* timingFunction);


void Gecko_ResetStyleCoord(nsStyleUnit* unit, nsStyleUnion* value);


void Gecko_SetStyleCoordCalcValue(nsStyleUnit* unit, nsStyleUnion* value, nsStyleCoord::CalcValue calc);

void Gecko_CopyClipPathValueFrom(mozilla::StyleShapeSource* dst, const mozilla::StyleShapeSource* src);

void Gecko_DestroyClipPath(mozilla::StyleShapeSource* clip);
mozilla::StyleBasicShape* Gecko_NewBasicShape(mozilla::StyleBasicShapeType type);
void Gecko_StyleClipPath_SetURLValue(mozilla::StyleShapeSource* clip, ServoBundledURI uri);

void Gecko_ResetFilters(nsStyleEffects* effects, size_t new_len);
void Gecko_CopyFiltersFrom(nsStyleEffects* aSrc, nsStyleEffects* aDest);
void Gecko_nsStyleFilter_SetURLValue(nsStyleFilter* effects, ServoBundledURI uri);

void Gecko_nsStyleSVGPaint_CopyFrom(nsStyleSVGPaint* dest, const nsStyleSVGPaint* src);
void Gecko_nsStyleSVGPaint_SetURLValue(nsStyleSVGPaint* paint, ServoBundledURI uri);
void Gecko_nsStyleSVGPaint_Reset(nsStyleSVGPaint* paint);

void Gecko_nsStyleSVG_SetDashArrayLength(nsStyleSVG* svg, uint32_t len);
void Gecko_nsStyleSVG_CopyDashArray(nsStyleSVG* dst, const nsStyleSVG* src);

mozilla::css::URLValue* Gecko_NewURLValue(ServoBundledURI uri);
void Gecko_AddRefCSSURLValueArbitraryThread(mozilla::css::URLValue* aPtr); void Gecko_ReleaseCSSURLValueArbitraryThread(mozilla::css::URLValue* aPtr);;
void Gecko_AddRefURLExtraDataArbitraryThread(RawGeckoURLExtraData* aPtr); void Gecko_ReleaseURLExtraDataArbitraryThread(RawGeckoURLExtraData* aPtr);;

void Gecko_FillAllBackgroundLists(nsStyleImageLayers* layers, uint32_t max_len);
void Gecko_FillAllMaskLists(nsStyleImageLayers* layers, uint32_t max_len);
void Gecko_AddRefCalcArbitraryThread(nsStyleCoord::Calc* aPtr); void Gecko_ReleaseCalcArbitraryThread(nsStyleCoord::Calc* aPtr);;

nsCSSShadowArray* Gecko_NewCSSShadowArray(uint32_t len);
void Gecko_AddRefCSSShadowArrayArbitraryThread(nsCSSShadowArray* aPtr); void Gecko_ReleaseCSSShadowArrayArbitraryThread(nsCSSShadowArray* aPtr);;

nsStyleQuoteValues* Gecko_NewStyleQuoteValues(uint32_t len);
void Gecko_AddRefQuoteValuesArbitraryThread(nsStyleQuoteValues* aPtr); void Gecko_ReleaseQuoteValuesArbitraryThread(nsStyleQuoteValues* aPtr);;

nsCSSValueSharedList* Gecko_NewCSSValueSharedList(uint32_t len);


nsCSSValueBorrowedMut Gecko_CSSValue_GetArrayItem(nsCSSValueBorrowedMut css_value, int32_t index);

nsCSSValueBorrowed Gecko_CSSValue_GetArrayItemConst(nsCSSValueBorrowed css_value, int32_t index);
nscoord Gecko_CSSValue_GetAbsoluteLength(nsCSSValueBorrowed css_value);
float Gecko_CSSValue_GetAngle(nsCSSValueBorrowed css_value);
nsCSSKeyword Gecko_CSSValue_GetKeyword(nsCSSValueBorrowed aCSSValue);
float Gecko_CSSValue_GetNumber(nsCSSValueBorrowed css_value);
float Gecko_CSSValue_GetPercentage(nsCSSValueBorrowed css_value);
nsStyleCoord::CalcValue Gecko_CSSValue_GetCalc(nsCSSValueBorrowed aCSSValue);

void Gecko_CSSValue_SetAbsoluteLength(nsCSSValueBorrowedMut css_value, nscoord len);
void Gecko_CSSValue_SetNormal(nsCSSValueBorrowedMut css_value);
void Gecko_CSSValue_SetNumber(nsCSSValueBorrowedMut css_value, float number);
void Gecko_CSSValue_SetKeyword(nsCSSValueBorrowedMut css_value, nsCSSKeyword keyword);
void Gecko_CSSValue_SetPercentage(nsCSSValueBorrowedMut css_value, float percent);
void Gecko_CSSValue_SetAngle(nsCSSValueBorrowedMut css_value, float radians);
void Gecko_CSSValue_SetCalc(nsCSSValueBorrowedMut css_value, nsStyleCoord::CalcValue calc);
void Gecko_CSSValue_SetFunction(nsCSSValueBorrowedMut css_value, int32_t len);
void Gecko_CSSValue_SetString(nsCSSValueBorrowedMut css_value,
                              const uint8_t* string, uint32_t len, nsCSSUnit unit);
void Gecko_CSSValue_SetStringFromAtom(nsCSSValueBorrowedMut css_value,
                                      nsIAtom* atom, nsCSSUnit unit);
void Gecko_CSSValue_SetArray(nsCSSValueBorrowedMut css_value, int32_t len);
void Gecko_CSSValue_SetURL(nsCSSValueBorrowedMut css_value, ServoBundledURI uri);
void Gecko_CSSValue_SetInt(nsCSSValueBorrowedMut css_value, int32_t integer, nsCSSUnit unit);
void Gecko_CSSValue_Drop(nsCSSValueBorrowedMut css_value);
void Gecko_AddRefCSSValueSharedListArbitraryThread(nsCSSValueSharedList* aPtr); void Gecko_ReleaseCSSValueSharedListArbitraryThread(nsCSSValueSharedList* aPtr);;
bool Gecko_PropertyId_IsPrefEnabled(nsCSSPropertyID id);

void Gecko_nsStyleFont_SetLang(nsStyleFont* font, nsIAtom* atom);
void Gecko_nsStyleFont_CopyLangFrom(nsStyleFont* aFont, const nsStyleFont* aSource);
nscoord Gecko_nsStyleFont_GetBaseSize(const nsStyleFont* font, RawGeckoPresContextBorrowed pres_context);

const nsMediaFeature* Gecko_GetMediaFeatures();



nsCSSFontFaceRule* Gecko_CSSFontFaceRule_Create();
void Gecko_CSSFontFaceRule_GetCssText(const nsCSSFontFaceRule* rule, nsAString* result);
void Gecko_CSSFontFaceRule_AddRef(nsCSSFontFaceRule* aPtr); void Gecko_CSSFontFaceRule_Release(nsCSSFontFaceRule* aPtr);;

RawGeckoElementBorrowedOrNull Gecko_GetBody(RawGeckoPresContextBorrowed pres_context);



nscolor Gecko_GetLookAndFeelSystemColor(int32_t color_id,
                                        RawGeckoPresContextBorrowed pres_context);

bool Gecko_MatchStringArgPseudo(RawGeckoElementBorrowed element,
                                mozilla::CSSPseudoClassType type,
                                const char16_t* ident,
                                bool* set_slow_selector);
void Gecko_Construct_Default_nsStyleFont( nsStyleFont* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleFont(nsStyleFont* ptr, const nsStyleFont* other); void Gecko_Destroy_nsStyleFont(nsStyleFont* ptr);



void Gecko_Construct_Default_nsStyleColor( nsStyleColor* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleColor(nsStyleColor* ptr, const nsStyleColor* other); void Gecko_Destroy_nsStyleColor(nsStyleColor* ptr);


void Gecko_Construct_Default_nsStyleList( nsStyleList* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleList(nsStyleList* ptr, const nsStyleList* other); void Gecko_Destroy_nsStyleList(nsStyleList* ptr);




void Gecko_Construct_Default_nsStyleText( nsStyleText* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleText(nsStyleText* ptr, const nsStyleText* other); void Gecko_Destroy_nsStyleText(nsStyleText* ptr);





void Gecko_Construct_Default_nsStyleVisibility( nsStyleVisibility* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleVisibility(nsStyleVisibility* ptr, const nsStyleVisibility* other); void Gecko_Destroy_nsStyleVisibility(nsStyleVisibility* ptr);


void Gecko_Construct_Default_nsStyleUserInterface( nsStyleUserInterface* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleUserInterface(nsStyleUserInterface* ptr, const nsStyleUserInterface* other); void Gecko_Destroy_nsStyleUserInterface(nsStyleUserInterface* ptr);


void Gecko_Construct_Default_nsStyleTableBorder( nsStyleTableBorder* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleTableBorder(nsStyleTableBorder* ptr, const nsStyleTableBorder* other); void Gecko_Destroy_nsStyleTableBorder(nsStyleTableBorder* ptr);




void Gecko_Construct_Default_nsStyleSVG( nsStyleSVG* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleSVG(nsStyleSVG* ptr, const nsStyleSVG* other); void Gecko_Destroy_nsStyleSVG(nsStyleSVG* ptr);





void Gecko_Construct_Default_nsStyleVariables( nsStyleVariables* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleVariables(nsStyleVariables* ptr, const nsStyleVariables* other); void Gecko_Destroy_nsStyleVariables(nsStyleVariables* ptr);

void Gecko_Construct_Default_nsStyleBackground( nsStyleBackground* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleBackground(nsStyleBackground* ptr, const nsStyleBackground* other); void Gecko_Destroy_nsStyleBackground(nsStyleBackground* ptr);





void Gecko_Construct_Default_nsStylePosition( nsStylePosition* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStylePosition(nsStylePosition* ptr, const nsStylePosition* other); void Gecko_Destroy_nsStylePosition(nsStylePosition* ptr);




void Gecko_Construct_Default_nsStyleTextReset( nsStyleTextReset* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleTextReset(nsStyleTextReset* ptr, const nsStyleTextReset* other); void Gecko_Destroy_nsStyleTextReset(nsStyleTextReset* ptr);





void Gecko_Construct_Default_nsStyleDisplay( nsStyleDisplay* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleDisplay(nsStyleDisplay* ptr, const nsStyleDisplay* other); void Gecko_Destroy_nsStyleDisplay(nsStyleDisplay* ptr);




void Gecko_Construct_Default_nsStyleContent( nsStyleContent* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleContent(nsStyleContent* ptr, const nsStyleContent* other); void Gecko_Destroy_nsStyleContent(nsStyleContent* ptr);




void Gecko_Construct_Default_nsStyleUIReset( nsStyleUIReset* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleUIReset(nsStyleUIReset* ptr, const nsStyleUIReset* other); void Gecko_Destroy_nsStyleUIReset(nsStyleUIReset* ptr);


void Gecko_Construct_Default_nsStyleTable( nsStyleTable* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleTable(nsStyleTable* ptr, const nsStyleTable* other); void Gecko_Destroy_nsStyleTable(nsStyleTable* ptr);


void Gecko_Construct_Default_nsStyleMargin( nsStyleMargin* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleMargin(nsStyleMargin* ptr, const nsStyleMargin* other); void Gecko_Destroy_nsStyleMargin(nsStyleMargin* ptr);




void Gecko_Construct_Default_nsStylePadding( nsStylePadding* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStylePadding(nsStylePadding* ptr, const nsStylePadding* other); void Gecko_Destroy_nsStylePadding(nsStylePadding* ptr);




void Gecko_Construct_Default_nsStyleBorder( nsStyleBorder* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleBorder(nsStyleBorder* ptr, const nsStyleBorder* other); void Gecko_Destroy_nsStyleBorder(nsStyleBorder* ptr);





void Gecko_Construct_Default_nsStyleOutline( nsStyleOutline* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleOutline(nsStyleOutline* ptr, const nsStyleOutline* other); void Gecko_Destroy_nsStyleOutline(nsStyleOutline* ptr);





void Gecko_Construct_Default_nsStyleXUL( nsStyleXUL* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleXUL(nsStyleXUL* ptr, const nsStyleXUL* other); void Gecko_Destroy_nsStyleXUL(nsStyleXUL* ptr);


void Gecko_Construct_Default_nsStyleSVGReset( nsStyleSVGReset* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleSVGReset(nsStyleSVGReset* ptr, const nsStyleSVGReset* other); void Gecko_Destroy_nsStyleSVGReset(nsStyleSVGReset* ptr);





void Gecko_Construct_Default_nsStyleColumn( nsStyleColumn* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleColumn(nsStyleColumn* ptr, const nsStyleColumn* other); void Gecko_Destroy_nsStyleColumn(nsStyleColumn* ptr);





void Gecko_Construct_Default_nsStyleEffects( nsStyleEffects* ptr, RawGeckoPresContextBorrowed pres_context); void Gecko_CopyConstruct_nsStyleEffects(nsStyleEffects* ptr, const nsStyleEffects* other); void Gecko_Destroy_nsStyleEffects(nsStyleEffects* ptr);


void Gecko_Construct_nsStyleVariables(nsStyleVariables* ptr);



void Servo_Element_ClearData(RawGeckoElementBorrowed node);


RawServoStyleSheetStrong Servo_StyleSheet_Empty(mozilla::css::SheetParsingMode parsing_mode);

RawServoStyleSheetStrong Servo_StyleSheet_FromUTF8Bytes(mozilla::css::Loader* loader, mozilla::ServoStyleSheet* gecko_stylesheet, const nsACString* data, mozilla::css::SheetParsingMode parsing_mode, RawGeckoURLExtraData* extra_data);





RawServoStyleSheetStrong Servo_ImportRule_GetSheet(const RawServoImportRuleBorrowed import_rule);


void Servo_StyleSheet_ClearAndUpdate(RawServoStyleSheetBorrowed stylesheet, mozilla::css::Loader* loader, mozilla::ServoStyleSheet* gecko_stylesheet, const nsACString* data, RawGeckoURLExtraData* extra_data);






bool Servo_StyleSheet_HasRules(RawServoStyleSheetBorrowed sheet);

ServoCssRulesStrong Servo_StyleSheet_GetRules(RawServoStyleSheetBorrowed sheet);

RawServoStyleSetOwned Servo_StyleSet_Init(RawGeckoPresContextOwned pres_context);
void Servo_StyleSet_RebuildData(RawServoStyleSetBorrowed set);

void Servo_StyleSet_Drop(RawServoStyleSetOwned set);
void Servo_StyleSet_AppendStyleSheet(RawServoStyleSetBorrowed set, RawServoStyleSheetBorrowed sheet, bool flush);

void Servo_StyleSet_PrependStyleSheet(RawServoStyleSetBorrowed set, RawServoStyleSheetBorrowed sheet, bool flush);

void Servo_StyleSet_RemoveStyleSheet(RawServoStyleSetBorrowed set, RawServoStyleSheetBorrowed sheet, bool flush);

void Servo_StyleSet_InsertStyleSheetBefore(RawServoStyleSetBorrowed set, RawServoStyleSheetBorrowed sheet, RawServoStyleSheetBorrowed reference, bool flush);


void Servo_StyleSet_FlushStyleSheets(RawServoStyleSetBorrowed set);
void Servo_StyleSet_NoteStyleSheetsChanged(RawServoStyleSetBorrowed set);

bool Servo_StyleSet_FillKeyframesForName(RawServoStyleSetBorrowed set, const nsACString* property, nsTimingFunctionBorrowed timing_function, ServoComputedValuesBorrowed computed_values, RawGeckoKeyframeListBorrowedMut keyframe_list);





void Servo_StyleSet_GetFontFaceRules(RawServoStyleSetBorrowed set, RawGeckoFontFaceRuleListBorrowedMut list);




void Servo_CssRules_ListTypes(ServoCssRulesBorrowed rules, nsTArrayBorrowed_uintptr_t result);


nsresult Servo_CssRules_InsertRule(ServoCssRulesBorrowed rules, RawServoStyleSheetBorrowed sheet, const nsACString* rule, uint32_t index, bool nested, mozilla::css::Loader* loader, mozilla::ServoStyleSheet* gecko_stylesheet, uint16_t* rule_type);





nsresult Servo_CssRules_DeleteRule(ServoCssRulesBorrowed rules, uint32_t index);
RawServoStyleRuleStrong Servo_CssRules_GetStyleRuleAt(ServoCssRulesBorrowed rules, uint32_t index); void Servo_StyleRule_Debug(RawServoStyleRuleBorrowed rule, nsACString* result); void Servo_StyleRule_GetCssText(RawServoStyleRuleBorrowed rule, nsAString* result);
RawServoMediaRuleStrong Servo_CssRules_GetMediaRuleAt(ServoCssRulesBorrowed rules, uint32_t index); void Servo_MediaRule_Debug(RawServoMediaRuleBorrowed rule, nsACString* result); void Servo_MediaRule_GetCssText(RawServoMediaRuleBorrowed rule, nsAString* result);
RawServoNamespaceRuleStrong Servo_CssRules_GetNamespaceRuleAt(ServoCssRulesBorrowed rules, uint32_t index); void Servo_NamespaceRule_Debug(RawServoNamespaceRuleBorrowed rule, nsACString* result); void Servo_NamespaceRule_GetCssText(RawServoNamespaceRuleBorrowed rule, nsAString* result);

nsCSSFontFaceRule* Servo_CssRules_GetFontFaceRuleAt(ServoCssRulesBorrowed rules, uint32_t index);

RawServoDeclarationBlockStrong Servo_StyleRule_GetStyle(RawServoStyleRuleBorrowed rule);

void Servo_StyleRule_SetStyle(RawServoStyleRuleBorrowed rule, RawServoDeclarationBlockBorrowed declarations);


void Servo_StyleRule_GetSelectorText(RawServoStyleRuleBorrowed rule, nsAString* result);

RawServoMediaListStrong Servo_MediaRule_GetMedia(RawServoMediaRuleBorrowed rule);

ServoCssRulesStrong Servo_MediaRule_GetRules(RawServoMediaRuleBorrowed rule);

nsIAtom* Servo_NamespaceRule_GetPrefix(RawServoNamespaceRuleBorrowed rule);

nsIAtom* Servo_NamespaceRule_GetURI(RawServoNamespaceRuleBorrowed rule);



RawServoDeclarationBlockStrong Servo_ParseProperty(const nsACString* property, const nsACString* value, RawGeckoURLExtraData* data);



bool Servo_ParseEasing(const nsAString* easing, RawGeckoURLExtraData* data, nsTimingFunctionBorrowedMut output);



void Servo_GetComputedKeyframeValues(RawGeckoKeyframeListBorrowed keyframes, ServoComputedValuesBorrowed style, ServoComputedValuesBorrowedOrNull parent_style, RawServoStyleSetBorrowed set, RawGeckoComputedKeyframeValuesListBorrowedMut result);





void Servo_AnimationValueMap_Push(RawServoAnimationValueMapBorrowed, nsCSSPropertyID property, RawServoAnimationValueBorrowed value);



RawServoAnimationValueStrong Servo_ComputedValues_ExtractAnimationValue(ServoComputedValuesBorrowed computed_values, nsCSSPropertyID property);





RawServoAnimationValueStrong Servo_AnimationValues_Interpolate(RawServoAnimationValueBorrowed from, RawServoAnimationValueBorrowed to, double progress);




void Servo_AnimationValue_Serialize(RawServoAnimationValueBorrowed value, nsCSSPropertyID property, nsAString* buffer);



float Servo_AnimationValue_GetOpacity(RawServoAnimationValueBorrowed value);

void Servo_AnimationValue_GetTransform(RawServoAnimationValueBorrowed value, RefPtr<nsCSSValueSharedList>* list);


bool Servo_AnimationValue_DeepEqual(RawServoAnimationValueBorrowed, RawServoAnimationValueBorrowed);




RawServoDeclarationBlockStrong Servo_ParseStyleAttribute(const nsACString* data, RawGeckoURLExtraData* extra_data);


RawServoDeclarationBlockStrong Servo_DeclarationBlock_CreateEmpty();

RawServoDeclarationBlockStrong Servo_DeclarationBlock_Clone(RawServoDeclarationBlockBorrowed declarations);

bool Servo_DeclarationBlock_Equals(RawServoDeclarationBlockBorrowed a, RawServoDeclarationBlockBorrowed b);


void Servo_DeclarationBlock_GetCssText(RawServoDeclarationBlockBorrowed declarations, nsAString* result);


void Servo_DeclarationBlock_SerializeOneValue(RawServoDeclarationBlockBorrowed declarations, nsCSSPropertyID property, nsAString* buffer);


uint32_t Servo_DeclarationBlock_Count(RawServoDeclarationBlockBorrowed declarations);

bool Servo_DeclarationBlock_GetNthProperty(RawServoDeclarationBlockBorrowed declarations, uint32_t index, nsAString* result);


void Servo_DeclarationBlock_GetPropertyValue(RawServoDeclarationBlockBorrowed declarations, const nsACString* property, nsAString* value);


void Servo_DeclarationBlock_GetPropertyValueById(RawServoDeclarationBlockBorrowed declarations, nsCSSPropertyID property, nsAString* value);


bool Servo_DeclarationBlock_GetPropertyIsImportant(RawServoDeclarationBlockBorrowed declarations, const nsACString* property);


bool Servo_DeclarationBlock_SetProperty(RawServoDeclarationBlockBorrowed declarations, const nsACString* property, const nsACString* value, bool is_important, RawGeckoURLExtraData* data);




bool Servo_DeclarationBlock_SetPropertyById(RawServoDeclarationBlockBorrowed declarations, nsCSSPropertyID property, const nsACString* value, bool is_important, RawGeckoURLExtraData* data);




void Servo_DeclarationBlock_RemoveProperty(RawServoDeclarationBlockBorrowed declarations, const nsACString* property);


void Servo_DeclarationBlock_RemovePropertyById(RawServoDeclarationBlockBorrowed declarations, nsCSSPropertyID property);





void Servo_AnimationCompose(RawServoAnimationValueMapBorrowed animation_values, void* base_values, nsCSSPropertyID property, RawGeckoAnimationPropertySegmentBorrowed animation_segment, RawGeckoComputedTimingBorrowed computed_timing);







bool Servo_DeclarationBlock_PropertyIsSet(RawServoDeclarationBlockBorrowed declarations, nsCSSPropertyID property);


void Servo_DeclarationBlock_SetIdentStringValue(RawServoDeclarationBlockBorrowed declarations, nsCSSPropertyID property, nsIAtom* value);



void Servo_DeclarationBlock_SetKeywordValue(RawServoDeclarationBlockBorrowed declarations, nsCSSPropertyID property, int32_t value);



void Servo_DeclarationBlock_SetIntValue(RawServoDeclarationBlockBorrowed declarations, nsCSSPropertyID property, int32_t value);



void Servo_DeclarationBlock_SetPixelValue(RawServoDeclarationBlockBorrowed declarations, nsCSSPropertyID property, float value);



void Servo_DeclarationBlock_SetPercentValue(RawServoDeclarationBlockBorrowed declarations, nsCSSPropertyID property, float value);



void Servo_DeclarationBlock_SetAutoValue(RawServoDeclarationBlockBorrowed declarations, nsCSSPropertyID property);


void Servo_DeclarationBlock_SetCurrentColor(RawServoDeclarationBlockBorrowed declarations, nsCSSPropertyID property);


void Servo_DeclarationBlock_SetColorValue(RawServoDeclarationBlockBorrowed declarations, nsCSSPropertyID property, nscolor value);



void Servo_DeclarationBlock_SetFontFamily(RawServoDeclarationBlockBorrowed declarations, const nsAString& value);


void Servo_DeclarationBlock_SetTextDecorationColorOverride(RawServoDeclarationBlockBorrowed declarations);



void Servo_MediaList_GetText(RawServoMediaListBorrowed list, nsAString* result);

void Servo_MediaList_SetText(RawServoMediaListBorrowed list, const nsACString* text);

uint32_t Servo_MediaList_GetLength(RawServoMediaListBorrowed list);

bool Servo_MediaList_GetMediumAt(RawServoMediaListBorrowed list, uint32_t index, nsAString* result);


void Servo_MediaList_AppendMedium(RawServoMediaListBorrowed list, const nsACString* new_medium);

bool Servo_MediaList_DeleteMedium(RawServoMediaListBorrowed list, const nsACString* old_medium);



bool Servo_CSSSupports2(const nsACString* name, const nsACString* value);

bool Servo_CSSSupports(const nsACString* cond);



ServoComputedValuesStrong Servo_ComputedValues_GetForAnonymousBox(ServoComputedValuesBorrowedOrNull parent_style_or_null, nsIAtom* pseudoTag, bool skip_display_fixup, RawServoStyleSetBorrowed set);




ServoComputedValuesStrong Servo_ComputedValues_Inherit(RawServoStyleSetBorrowed set, ServoComputedValuesBorrowedOrNull parent_style);




void Servo_Initialize();

void Servo_Shutdown();



ServoElementSnapshot* Servo_Element_GetSnapshot(RawGeckoElementBorrowed element);



void Servo_NoteExplicitHints(RawGeckoElementBorrowed element, nsRestyleHint restyle_hint, nsChangeHint change_hint);

nsChangeHint Servo_TakeChangeHint(RawGeckoElementBorrowed element);
ServoComputedValuesStrong Servo_ResolveStyle(RawGeckoElementBorrowed element, RawServoStyleSetBorrowed set, bool allow_stale);



ServoComputedValuesStrong Servo_ResolvePseudoStyle(RawGeckoElementBorrowed element, nsIAtom* pseudo_tag, bool is_probe, RawServoStyleSetBorrowed set);
ServoComputedValuesStrong Servo_ResolveStyleLazily(RawGeckoElementBorrowed element, nsIAtom* pseudo_tag, RawServoStyleSetBorrowed set);





bool Servo_TraverseSubtree(RawGeckoElementBorrowed root, RawServoStyleSetBorrowed set, mozilla::TraversalRootBehavior root_behavior);




void Servo_AssertTreeIsClean(RawGeckoElementBorrowed root);


ServoComputedValuesStrong Servo_StyleSet_GetBaseComputedValuesForElement(RawServoStyleSetBorrowed set, RawGeckoElementBorrowed element, nsIAtom* pseudo_tag);
struct nsStyleFont; const nsStyleFont* Servo_GetStyleFont(ServoComputedValuesBorrowedOrNull computed_values);



struct nsStyleColor; const nsStyleColor* Servo_GetStyleColor(ServoComputedValuesBorrowedOrNull computed_values);


struct nsStyleList; const nsStyleList* Servo_GetStyleList(ServoComputedValuesBorrowedOrNull computed_values);




struct nsStyleText; const nsStyleText* Servo_GetStyleText(ServoComputedValuesBorrowedOrNull computed_values);





struct nsStyleVisibility; const nsStyleVisibility* Servo_GetStyleVisibility(ServoComputedValuesBorrowedOrNull computed_values);


struct nsStyleUserInterface; const nsStyleUserInterface* Servo_GetStyleUserInterface(ServoComputedValuesBorrowedOrNull computed_values);


struct nsStyleTableBorder; const nsStyleTableBorder* Servo_GetStyleTableBorder(ServoComputedValuesBorrowedOrNull computed_values);




struct nsStyleSVG; const nsStyleSVG* Servo_GetStyleSVG(ServoComputedValuesBorrowedOrNull computed_values);





struct nsStyleVariables; const nsStyleVariables* Servo_GetStyleVariables(ServoComputedValuesBorrowedOrNull computed_values);

struct nsStyleBackground; const nsStyleBackground* Servo_GetStyleBackground(ServoComputedValuesBorrowedOrNull computed_values);





struct nsStylePosition; const nsStylePosition* Servo_GetStylePosition(ServoComputedValuesBorrowedOrNull computed_values);




struct nsStyleTextReset; const nsStyleTextReset* Servo_GetStyleTextReset(ServoComputedValuesBorrowedOrNull computed_values);





struct nsStyleDisplay; const nsStyleDisplay* Servo_GetStyleDisplay(ServoComputedValuesBorrowedOrNull computed_values);




struct nsStyleContent; const nsStyleContent* Servo_GetStyleContent(ServoComputedValuesBorrowedOrNull computed_values);




struct nsStyleUIReset; const nsStyleUIReset* Servo_GetStyleUIReset(ServoComputedValuesBorrowedOrNull computed_values);


struct nsStyleTable; const nsStyleTable* Servo_GetStyleTable(ServoComputedValuesBorrowedOrNull computed_values);


struct nsStyleMargin; const nsStyleMargin* Servo_GetStyleMargin(ServoComputedValuesBorrowedOrNull computed_values);




struct nsStylePadding; const nsStylePadding* Servo_GetStylePadding(ServoComputedValuesBorrowedOrNull computed_values);




struct nsStyleBorder; const nsStyleBorder* Servo_GetStyleBorder(ServoComputedValuesBorrowedOrNull computed_values);





struct nsStyleOutline; const nsStyleOutline* Servo_GetStyleOutline(ServoComputedValuesBorrowedOrNull computed_values);





struct nsStyleXUL; const nsStyleXUL* Servo_GetStyleXUL(ServoComputedValuesBorrowedOrNull computed_values);


struct nsStyleSVGReset; const nsStyleSVGReset* Servo_GetStyleSVGReset(ServoComputedValuesBorrowedOrNull computed_values);





struct nsStyleColumn; const nsStyleColumn* Servo_GetStyleColumn(ServoComputedValuesBorrowedOrNull computed_values);





struct nsStyleEffects; const nsStyleEffects* Servo_GetStyleEffects(ServoComputedValuesBorrowedOrNull computed_values);














void Servo_CssRules_AddRef(ServoCssRulesBorrowed); void Servo_CssRules_Release(ServoCssRulesBorrowed);
void Servo_StyleSheet_AddRef(RawServoStyleSheetBorrowed); void Servo_StyleSheet_Release(RawServoStyleSheetBorrowed);
void Servo_ComputedValues_AddRef(ServoComputedValuesBorrowed); void Servo_ComputedValues_Release(ServoComputedValuesBorrowed);
void Servo_DeclarationBlock_AddRef(RawServoDeclarationBlockBorrowed); void Servo_DeclarationBlock_Release(RawServoDeclarationBlockBorrowed);
void Servo_StyleRule_AddRef(RawServoStyleRuleBorrowed); void Servo_StyleRule_Release(RawServoStyleRuleBorrowed);
void Servo_ImportRule_AddRef(RawServoImportRuleBorrowed); void Servo_ImportRule_Release(RawServoImportRuleBorrowed);
void Servo_AnimationValue_AddRef(RawServoAnimationValueBorrowed); void Servo_AnimationValue_Release(RawServoAnimationValueBorrowed);
void Servo_AnimationValueMap_AddRef(RawServoAnimationValueMapBorrowed); void Servo_AnimationValueMap_Release(RawServoAnimationValueMapBorrowed);
void Servo_MediaList_AddRef(RawServoMediaListBorrowed); void Servo_MediaList_Release(RawServoMediaListBorrowed);
void Servo_MediaRule_AddRef(RawServoMediaRuleBorrowed); void Servo_MediaRule_Release(RawServoMediaRuleBorrowed);
void Servo_NamespaceRule_AddRef(RawServoNamespaceRuleBorrowed); void Servo_NamespaceRule_Release(RawServoNamespaceRuleBorrowed);


}

